{"version":3,"file":"BalanceDetailsDialog-Q2iBlQpm.js","sources":["../node_modules/memoize-one/dist/memoize-one.esm.js","../node_modules/react-window/dist/index.esm.js","../src/Generic/components/VirtualList.tsx","../src/Generic/lib/popularAssets.ts","../src/Assets/components/BalanceDetailsListItem.tsx","../src/Assets/components/CustomTrustline.tsx","../src/Assets/components/AddAssetDialog.tsx","../src/Assets/components/BalanceDetailsDialog.tsx"],"sourcesContent":["function areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsOverscanRowsColumnsCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _style;\n\n          itemStyleCache[key] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = getColumnOffset(_this.props, columnIndex, _this._instanceProps), _style.top = getRowOffset(_this.props, rowIndex, _this._instanceProps), _style.height = getRowHeight(_this.props, rowIndex, _this._instanceProps), _style.width = getColumnWidth(_this.props, columnIndex, _this._instanceProps), _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName$1 =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _style;\n\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          itemStyleCache[index] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = isHorizontal ? _offset : 0, _style.top = !isHorizontal ? _offset : 0, _style.height = !isHorizontal ? size : '100%', _style.width = isHorizontal ? size : '100%', _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n","import React from \"react\"\nimport * as Window from \"react-window\"\n\ninterface FixedSizeListProps {\n  children: React.FunctionComponent<Window.ListChildComponentProps>\n  container: HTMLElement | null\n  itemCount: number\n  itemSize: number\n}\n\nexport function FixedSizeList(props: FixedSizeListProps) {\n  if (!props.container) {\n    return null\n  }\n\n  const height = props.container.clientHeight\n  const width = props.container.clientWidth\n\n  return (\n    <Window.FixedSizeList height={height} itemCount={props.itemCount} itemSize={props.itemSize} width={width}>\n      {props.children}\n    </Window.FixedSizeList>\n  )\n}\n","import { Asset } from \"stellar-sdk\"\n\nexport const mainnet = [\n  new Asset(\"EURMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"MTLAP\", \"GCNVDZIHGX473FEI7IXCUAEXUJ4BGCKEMHF36VYP5EMS7PX2QBLAMTLA\"),\n  new Asset(\"MTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"MTLRECT\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"BTCMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"SATSMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"USDM\", \"GDHDC4GBNPMENZAOBB4NCQ25TGZPDRK6ZGWUGSI22TVFATOLRPSUUSDM\"),\n  new Asset(\"USDC\", \"GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN\")\n]\n\nexport const testnet = [\n  new Asset(\"USD\", \"GCKFBEIYV2U22IO2BJ4KVJOIP7XPWQGQFKKWXR6DOSJBV7STMAQSMTGG\"),\n  new Asset(\"SRT\", \"GCDNJUBQSX7AJWLJACMJ7I4BC3Z47BQUTMHEICZLE6MU4KQBRYG5JY6B\")\n]\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport Badge from \"@material-ui/core/Badge\"\nimport ListItem from \"@material-ui/core/ListItem\"\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\"\nimport ListItemText from \"@material-ui/core/ListItemText\"\nimport { makeStyles } from \"@material-ui/core/styles\"\nimport { useAssetMetadata } from \"~Generic/hooks/stellar\"\nimport { balancelineToAsset } from \"~Generic/lib/stellar\"\nimport { breakpoints } from \"~App/theme\"\nimport { SingleBalance } from \"~Account/components/AccountBalances\"\nimport { BalanceLine } from \"~Generic/lib/account\"\nimport { AccountName } from \"~Generic/components/Fetchers\"\nimport AssetLogo from \"./AssetLogo\"\n\nexport const actionsSize = 36\n\nconst useBalanceItemStyles = makeStyles({\n  clickable: {},\n  icon: {\n    [breakpoints.down(350)]: {\n      minWidth: 48\n    }\n  },\n  logo: {\n    [breakpoints.down(350)]: {\n      width: 36,\n      height: 36\n    }\n  },\n  logoHidden: {\n    visibility: \"hidden\"\n  },\n  badge: {\n    top: 4,\n    right: 4,\n    boxShadow: \"0 0 3px 1px black\"\n  },\n  mainListItemText: {\n    flex: \"1 1 auto\",\n    whiteSpace: \"nowrap\"\n  },\n  mainListItemTextPrimaryTypography: {\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\",\n\n    [breakpoints.down(400)]: {\n      fontSize: 15\n    },\n    [breakpoints.down(350)]: {\n      fontSize: 13\n    }\n  },\n  mainListItemTextSecondaryTypography: {\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\",\n\n    [breakpoints.down(400)]: {\n      fontSize: 14\n    },\n    [breakpoints.down(350)]: {\n      fontSize: 12\n    }\n  },\n  balanceListItemText: {\n    flex: \"1 0 auto\",\n    marginLeft: 8,\n    textAlign: \"right\"\n  },\n  balanceText: {\n    fontSize: \"140%\",\n\n    [breakpoints.down(350)]: {\n      fontSize: \"120%\"\n    }\n  },\n  actions: {\n    flex: \"0 0 auto\",\n    marginLeft: 4,\n    marginRight: -16,\n    width: 48\n  }\n})\n\ninterface BalanceListItemProps {\n  badgeCount?: number | string\n  balance: BalanceLine\n  className?: string\n  hideBalance?: boolean\n  hideLogo?: boolean\n  onClick?: () => void\n  spendableBalance?: boolean\n  style?: React.CSSProperties\n  testnet: boolean\n}\n\nfunction BalanceListItem(props: BalanceListItemProps) {\n  const classes = useBalanceItemStyles()\n  const className = `${props.className || \"\"} ${props.onClick ? classes.clickable : \"\"}`\n\n  const asset = React.useMemo(() => balancelineToAsset(props.balance), [props.balance])\n  const assetMetadata = useAssetMetadata(asset, props.testnet)\n  const { t } = useTranslation()\n\n  const balance = React.useMemo(\n    () => (props.hideBalance ? null : <SingleBalance assetCode={\"\"} balance={props.balance.balance} />),\n    [props.balance.balance, props.hideBalance]\n  )\n\n  if (props.balance.asset_type === \"native\") {\n    return (\n      <ListItem\n        button={Boolean(props.onClick) as any}\n        className={className}\n        onClick={props.onClick}\n        style={props.style}\n      >\n        <ListItemIcon className={classes.icon}>\n          <AssetLogo\n            asset={asset}\n            className={`${classes.logo} ${props.hideLogo ? classes.logoHidden : \"\"}`}\n            testnet={props.testnet}\n          />\n        </ListItemIcon>\n        <ListItemText\n          classes={{\n            root: classes.mainListItemText,\n            primary: classes.mainListItemTextPrimaryTypography,\n            secondary: classes.mainListItemTextSecondaryTypography\n          }}\n          primary={\n            props.spendableBalance\n              ? t(\"account.balance-details.item.spendable-balance.primary\")\n              : \"Stellar Lumens (XLM)\"\n          }\n          secondary={props.spendableBalance ? undefined : \"stellar.org\"}\n        />\n        <ListItemText\n          classes={{\n            root: classes.balanceListItemText,\n            primary: classes.balanceText\n          }}\n          primary={balance}\n        />\n      </ListItem>\n    )\n  }\n\n  const assetName = (assetMetadata && assetMetadata.name) || props.balance.asset_code\n  const title =\n    assetName !== props.balance.asset_code ? `${assetName} (${props.balance.asset_code})` : props.balance.asset_code\n\n  return (\n    <ListItem button={Boolean(props.onClick) as any} className={className} onClick={props.onClick} style={props.style}>\n      <ListItemIcon className={classes.icon}>\n        <Badge badgeContent={props.badgeCount} classes={{ badge: classes.badge }} color=\"primary\">\n          <AssetLogo\n            asset={asset}\n            className={`${classes.logo} ${props.hideLogo ? classes.logoHidden : \"\"}`}\n            dark\n            testnet={props.testnet}\n          />\n        </Badge>\n      </ListItemIcon>\n      <ListItemText\n        className={classes.mainListItemText}\n        classes={{\n          primary: classes.mainListItemTextPrimaryTypography,\n          secondary: classes.mainListItemTextSecondaryTypography\n        }}\n        primary={title}\n        secondary={<AccountName publicKey={props.balance.asset_issuer} testnet={props.testnet} />}\n      />\n      <ListItemText\n        className={classes.balanceListItemText}\n        primary={balance}\n        primaryTypographyProps={{ className: classes.balanceText }}\n      />\n    </ListItem>\n  )\n}\n\nexport default React.memo(BalanceListItem)\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, Server, Transaction } from \"stellar-sdk\"\nimport useMediaQuery from \"@material-ui/core/useMediaQuery\"\nimport TextField from \"@material-ui/core/TextField\"\nimport VerifiedUserIcon from \"@material-ui/icons/VerifiedUser\"\nimport { Account } from \"~App/contexts/accounts\"\nimport { AccountData } from \"~Generic/lib/account\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport { ActionButton, DialogActionsBox } from \"~Generic/components/DialogActions\"\nimport MainTitle from \"~Generic/components/MainTitle\"\n\ninterface Props {\n  account: Account\n  accountData: AccountData\n  createAddAssetTransaction: (asset: Asset, options: { limit?: string }) => any\n  horizon: Server\n  onClose: () => void\n  sendTransaction: (createTransactionToSend: () => Promise<Transaction>) => any\n  txCreationPending: boolean\n}\n\nfunction CustomTrustlineDialog(props: Props) {\n  const [code, setCode] = React.useState(\"\")\n  const [issuerPublicKey, setIssuerPublicKey] = React.useState(\"\")\n  const [limit, setLimit] = React.useState(\"\")\n  const isWidthMax450 = useMediaQuery(\"(max-width:450px)\")\n  const { t } = useTranslation()\n\n  const createTransaction = () =>\n    props.createAddAssetTransaction(new Asset(code, issuerPublicKey), { limit: limit || undefined })\n  const addCustomAsset = () => props.sendTransaction(createTransaction)\n\n  return (\n    <DialogBody\n      top={<MainTitle hideBackButton onBack={props.onClose} title={t(\"account-settings.custom-trustline.title\")} />}\n    >\n      <form noValidate style={{ display: \"block\", width: \"100%\" }}>\n        <TextField\n          label={t(\"account-settings.custom-trustline.textfield.code.label\")}\n          placeholder=\"EURT, USDT, BTC, ...\"\n          autoFocus={import.meta.env.VITE_PLATFORM !== \"ios\"}\n          margin=\"dense\"\n          name=\"asset-code\"\n          value={code}\n          onChange={event => setCode(event.target.value)}\n        />\n        <TextField\n          fullWidth\n          label={t(\"account-settings.custom-trustline.textfield.issuer.label\")}\n          placeholder={t(\"account-settings.custom-trustline.textfield.issuer.placeholder\")}\n          margin=\"dense\"\n          name=\"asset-issuer\"\n          value={issuerPublicKey}\n          onChange={event => setIssuerPublicKey(event.target.value)}\n        />\n        <TextField\n          inputProps={{\n            pattern: \"^[0-9]*(.[0-9]+)?$\",\n            inputMode: \"decimal\"\n          }}\n          fullWidth\n          label={t(\"account-settings.custom-trustline.textfield.limit.label\")}\n          placeholder={t(\"account-settings.custom-trustline.textfield.limit.placeholder\")}\n          margin=\"dense\"\n          name=\"trust-limit\"\n          value={limit}\n          type=\"number\"\n          onChange={event => setLimit(event.target.value)}\n        />\n        {/* Not in the DialogBody's `actions` prop as it's not a fullscreen dialog */}\n        <DialogActionsBox preventMobileActionsBox>\n          <ActionButton onClick={props.onClose}>{t(\"account-settings.custom-trustline.action.cancel\")}</ActionButton>\n          <ActionButton\n            icon={<VerifiedUserIcon />}\n            loading={props.txCreationPending}\n            onClick={addCustomAsset}\n            type=\"primary\"\n          >\n            {isWidthMax450\n              ? t(\"account-settings.custom-trustline.action.trust.short\")\n              : t(\"account-settings.custom-trustline.action.trust.long\")}\n          </ActionButton>\n        </DialogActionsBox>\n      </form>\n    </DialogBody>\n  )\n}\n\nexport default React.memo(CustomTrustlineDialog)\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, AssetType, Horizon, Operation, Server, Transaction } from \"stellar-sdk\"\nimport Dialog from \"@material-ui/core/Dialog\"\nimport List from \"@material-ui/core/List\"\nimport ListItem from \"@material-ui/core/ListItem\"\nimport ListItemText from \"@material-ui/core/ListItemText\"\nimport { makeStyles } from \"@material-ui/core/styles\"\nimport AddIcon from \"@material-ui/icons/Add\"\nimport { Account } from \"~App/contexts/accounts\"\nimport { trackError } from \"~App/contexts/notifications\"\nimport * as routes from \"~App/routes\"\nimport { CompactDialogTransition } from \"~App/theme\"\nimport ButtonListItem from \"~Generic/components/ButtonListItem\"\nimport { AccountName } from \"~Generic/components/Fetchers\"\nimport { SearchField } from \"~Generic/components/FormFields\"\nimport MainTitle from \"~Generic/components/MainTitle\"\nimport ViewLoading from \"~Generic/components/ViewLoading\"\nimport { FixedSizeList } from \"~Generic/components/VirtualList\"\nimport { useTickerAssets, useWellKnownAccounts } from \"~Generic/hooks/stellar-ecosystem\"\nimport { useRouter } from \"~Generic/hooks/userinterface\"\nimport { AccountData } from \"~Generic/lib/account\"\nimport * as popularAssets from \"~Generic/lib/popularAssets\"\nimport { assetRecordToAsset, stringifyAsset } from \"~Generic/lib/stellar\"\nimport { createTransaction } from \"~Generic/lib/transaction\"\nimport { VerticalLayout } from \"~Layout/components/Box\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport TransactionSender from \"~Transaction/components/TransactionSender\"\nimport BalanceDetailsListItem from \"./BalanceDetailsListItem\"\nimport CustomTrustlineDialog from \"./CustomTrustline\"\nimport { AssetRecord } from \"~Generic/lib/stellar-ticker\"\n\nfunction assetRecordMatches(assetRecord: AssetRecord, search: string) {\n  search = search.toLowerCase()\n  return assetRecord.code.toLowerCase().startsWith(search) || assetRecord.name.toLowerCase().startsWith(search)\n}\n\nfunction issuerMatches(issuerDetails: AssetRecord[\"issuer_detail\"], search: string) {\n  search = search.toLowerCase()\n  return issuerDetails.name.toLowerCase().startsWith(search)\n}\n\nfunction assetToBalance(asset: Asset): Horizon.BalanceLineAsset {\n  return {\n    asset_code: asset.getCode(),\n    asset_issuer: asset.getIssuer(),\n    asset_type: asset.getAssetType() as AssetType.credit4 | AssetType.credit12,\n    balance: \"0\",\n    is_authorized: true,\n    is_authorized_to_maintain_liabilities: true,\n    last_modified_ledger: 0,\n    limit: \"0\",\n    buying_liabilities: \"0\",\n    selling_liabilities: \"0\",\n    is_clawback_enabled: false\n  }\n}\n\nfunction groupAssets(values: AssetRecord[], createKey: (arg: AssetRecord) => string) {\n  const map: { [issuer: string]: AssetRecord[] } = {}\n\n  for (const value of values) {\n    const key = createKey(value)\n    const existingValues = map[key]\n    existingValues ? existingValues.push(value) : (map[key] = [value])\n  }\n\n  return map\n}\n\ninterface PopularAssetsProps {\n  assets: Asset[]\n  onOpenAssetDetails: (asset: Asset) => void\n  testnet: boolean\n}\n\nconst PopularAssets = React.memo(function PopularAssets(props: PopularAssetsProps) {\n  return (\n    <>\n      {props.assets.map(asset => (\n        <BalanceDetailsListItem\n          key={stringifyAsset(asset)}\n          balance={assetToBalance(asset)}\n          hideBalance\n          onClick={() => props.onOpenAssetDetails(asset)}\n          testnet={props.testnet}\n        />\n      ))}\n    </>\n  )\n})\n\nconst searchResultRowHeight = 73\n\nconst useSearchResultStyles = makeStyles({\n  assetItem: {\n    borderRadius: \"0 !important\",\n    height: searchResultRowHeight\n  },\n  issuerItem: {\n    background: \"white\",\n    borderRadius: 8,\n    height: searchResultRowHeight\n  },\n  noResultItem: {\n    background: \"white\",\n    borderRadius: 8,\n    height: searchResultRowHeight\n  }\n})\n\nfunction createSearchResultRow(\n  account: Account,\n  assetsByIssuer: Record<string, AssetRecord[]>,\n  openAssetDetails: (asset: Asset) => void\n) {\n  // tslint:disable-next-line interface-over-type-literal\n  type AssetItemRecord = { type: \"asset\"; issuer: string; record: AssetRecord }\n  // tslint:disable-next-line interface-over-type-literal\n  type IssuerItemRecord = { type: \"issuer\"; issuer: string }\n\n  const itemRenderMap: (AssetItemRecord | IssuerItemRecord)[] = []\n\n  for (const issuer of Object.keys(assetsByIssuer)) {\n    itemRenderMap.push({\n      type: \"issuer\",\n      issuer\n    })\n    itemRenderMap.push(\n      ...assetsByIssuer[issuer].map(\n        (assetRecord: AssetRecord): AssetItemRecord => ({\n          type: \"asset\",\n          issuer,\n          record: assetRecord\n        })\n      )\n    )\n  }\n\n  function SearchResultRow(props: { index: number; style: React.CSSProperties }) {\n    const classes = useSearchResultStyles()\n    const item = itemRenderMap[props.index]\n    const { t } = useTranslation()\n\n    return (\n      <div style={props.style}>\n        <React.Suspense fallback={<ViewLoading />}>\n          {item.type === \"issuer\" ? (\n            <ListItem key={item.issuer} className={classes.issuerItem}>\n              <ListItemText\n                primary={\n                  item.issuer === \"native\" ? (\n                    \"stellar.org\"\n                  ) : (\n                    <AccountName publicKey={item.issuer} testnet={account.testnet} />\n                  )\n                }\n                secondary={\n                  assetsByIssuer[item.issuer].length === 1\n                    ? t(\"account.add-asset.item.issuer.secondary.one-asset\")\n                    : t(\"account.add-asset.item.issuer.secondary.more-than-one-asset\", {\n                        amount: assetsByIssuer[item.issuer].length\n                      })\n                }\n                secondaryTypographyProps={{\n                  style: { overflow: \"hidden\", textOverflow: \"ellipsis\" }\n                }}\n              />\n            </ListItem>\n          ) : null}\n          {item.type === \"asset\" ? (\n            <BalanceDetailsListItem\n              balance={assetToBalance(assetRecordToAsset(item.record))}\n              className={classes.assetItem}\n              hideBalance\n              onClick={() => openAssetDetails(assetRecordToAsset(item.record))}\n              style={{ paddingLeft: 32 }}\n              testnet={account.testnet}\n            />\n          ) : null}\n        </React.Suspense>\n      </div>\n    )\n  }\n\n  function NoResultRow() {\n    const classes = useSearchResultStyles()\n    const { t } = useTranslation()\n\n    return (\n      <ListItem key={0} className={classes.noResultItem}>\n        <ListItemText\n          primary={t(\"account.add-asset.item.no-result.primary\")}\n          secondary={t(\"account.add-asset.item.no-result.secondary\")}\n        />\n      </ListItem>\n    )\n  }\n\n  if (itemRenderMap.length > 0) {\n    SearchResultRow.count = itemRenderMap.length\n    return SearchResultRow\n  } else {\n    NoResultRow.count = 1\n    return NoResultRow\n  }\n}\n\nconst useAddAssetStyles = makeStyles({\n  grow: {\n    flexGrow: 1\n  },\n  list: {\n    marginTop: 16,\n    padding: 0\n  },\n  searchField: {\n    background: \"white\",\n    flexShrink: 0,\n    flexGrow: 0,\n    marginBottom: 16\n  },\n  searchFieldInput: {\n    fontSize: 16,\n    paddingTop: 14,\n    paddingBottom: 14\n  }\n})\n\ninterface AddAssetDialogProps {\n  account: Account\n  accountData: AccountData\n  horizon: Server\n  hpadding: number\n  itemHPadding: number\n  onClose: () => void\n  sendTransaction: (transaction: Transaction, signatureRequest?: null) => void\n}\n\nconst AddAssetDialog = React.memo(function AddAssetDialog(props: AddAssetDialogProps) {\n  const assets = props.account.testnet ? popularAssets.testnet : popularAssets.mainnet\n  const classes = useAddAssetStyles()\n  const containerRef = React.useRef<HTMLUListElement | null>(null)\n  const allAssets = useTickerAssets(props.account.testnet)\n  const router = useRouter()\n  const { t } = useTranslation()\n  const wellKnownAccounts = useWellKnownAccounts(props.account.testnet)\n  const [customTrustlineDialogOpen, setCustomTrustlineDialogOpen] = React.useState(false)\n  const [searchFieldValue, setSearchFieldValue] = React.useState(\"\")\n  const [txCreationPending, setTxCreationPending] = React.useState(false)\n\n  const openAssetDetails = React.useCallback(\n    (asset: Asset) => router.history.push(routes.assetDetails(props.account.id, stringifyAsset(asset))),\n    [router.history, props.account.id]\n  )\n\n  const openCustomTrustlineDialog = () => setCustomTrustlineDialogOpen(true)\n  const closeCustomTrustlineDialog = () => setCustomTrustlineDialogOpen(false)\n\n  const createAddAssetTransaction = async (asset: Asset, options: { limit?: string } = {}) => {\n    const operations = [Operation.changeTrust({ asset, limit: options.limit, withMuxing: true })]\n    return createTransaction(operations, {\n      accountData: props.accountData,\n      horizon: props.horizon,\n      walletAccount: props.account\n    })\n  }\n\n  const sendTransaction = async (createTransactionToSend: () => Promise<Transaction>) => {\n    try {\n      setTxCreationPending(true)\n      const transaction = await createTransactionToSend()\n      setTxCreationPending(false)\n      await props.sendTransaction(transaction)\n    } catch (error) {\n      setTxCreationPending(false)\n      trackError(error)\n    }\n  }\n\n  const isAssetAlreadyAdded = (asset: Asset) => {\n    return props.accountData.balances.some(\n      (balance: any) => balance.asset_code === asset.code && balance.asset_issuer === asset.issuer\n    )\n  }\n\n  const wellknownAccountMatches = React.useCallback(\n    (accountID: string, search: string) => {\n      const lowerCasedSearch = search.toLowerCase()\n      const record = wellKnownAccounts.lookup(accountID)\n\n      if (!record) {\n        return false\n      }\n      return (\n        record.domain.toLowerCase().includes(lowerCasedSearch) || record.name.toLowerCase().includes(lowerCasedSearch)\n      )\n    },\n    [wellKnownAccounts]\n  )\n\n  const notYetAddedAssets = assets.filter(asset => !isAssetAlreadyAdded(asset))\n\n  const onSearchFieldChange = React.useCallback((event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    setSearchFieldValue(event.target.value)\n  }, [])\n\n  const assetsByIssuer = React.useMemo(() => {\n    const filteredAssets = allAssets.filter(\n      assetRecord =>\n        assetRecordMatches(assetRecord, searchFieldValue) ||\n        issuerMatches(assetRecord.issuer_detail, searchFieldValue) ||\n        wellknownAccountMatches(assetRecord.issuer, searchFieldValue)\n    )\n\n    return groupAssets(filteredAssets, assetRecord => assetRecord.issuer)\n  }, [allAssets, searchFieldValue, wellknownAccountMatches])\n\n  const SearchResultRow = React.useMemo(() => createSearchResultRow(props.account, assetsByIssuer, openAssetDetails), [\n    props.account,\n    assetsByIssuer,\n    openAssetDetails\n  ])\n\n  return (\n    <DialogBody excessWidth={24} top={<MainTitle onBack={props.onClose} title={t(\"account.add-asset.title\")} />}>\n      <VerticalLayout grow margin=\"16px 0 0\">\n        <SearchField\n          autoFocus\n          className={classes.searchField}\n          inputProps={{\n            className: classes.searchFieldInput\n          }}\n          onChange={onSearchFieldChange}\n          value={searchFieldValue}\n          placeholder={t(\"account.add-asset.search-field.placeholder\")}\n        />\n        <List className={classes.list}>\n          <ButtonListItem onClick={openCustomTrustlineDialog}>\n            <AddIcon />\n            &nbsp;&nbsp;{t(\"account.add-asset.button.add-custom-asset.label\")}\n          </ButtonListItem>\n        </List>\n        <React.Suspense fallback={<ViewLoading />}>\n          {searchFieldValue ? (\n            <ul className={`${classes.list} ${classes.grow}`} ref={containerRef}>\n              <FixedSizeList\n                container={containerRef.current}\n                itemCount={SearchResultRow.count}\n                itemSize={searchResultRowHeight}\n              >\n                {SearchResultRow}\n              </FixedSizeList>\n            </ul>\n          ) : (\n            <List className={`${classes.list} ${classes.grow}`}>\n              <PopularAssets\n                assets={notYetAddedAssets}\n                onOpenAssetDetails={openAssetDetails}\n                testnet={props.account.testnet}\n              />\n            </List>\n          )}\n        </React.Suspense>\n      </VerticalLayout>\n      <Dialog\n        open={customTrustlineDialogOpen}\n        onClose={closeCustomTrustlineDialog}\n        TransitionComponent={CompactDialogTransition}\n      >\n        <React.Suspense fallback={<ViewLoading />}>\n          <CustomTrustlineDialog\n            account={props.account}\n            accountData={props.accountData}\n            createAddAssetTransaction={createAddAssetTransaction}\n            horizon={props.horizon}\n            onClose={closeCustomTrustlineDialog}\n            sendTransaction={sendTransaction}\n            txCreationPending={txCreationPending}\n          />\n        </React.Suspense>\n      </Dialog>\n    </DialogBody>\n  )\n})\n\nfunction ConnectedAddAssetDialog(props: Omit<AddAssetDialogProps, \"horizon\" | \"sendTransaction\">) {\n  return (\n    <TransactionSender account={props.account} onSubmissionCompleted={props.onClose}>\n      {({ horizon, sendTransaction }) => (\n        <AddAssetDialog {...props} horizon={horizon} sendTransaction={sendTransaction} />\n      )}\n    </TransactionSender>\n  )\n}\n\nexport default React.memo(ConnectedAddAssetDialog)\n","import BigNumber from \"big.js\"\nimport React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, Horizon, ServerApi } from \"stellar-sdk\"\nimport Dialog from \"@material-ui/core/Dialog\"\nimport Divider from \"@material-ui/core/Divider\"\nimport List from \"@material-ui/core/List\"\nimport AddIcon from \"@material-ui/icons/Add\"\nimport { Account } from \"~App/contexts/accounts\"\nimport * as routes from \"~App/routes\"\nimport { FullscreenDialogTransition } from \"~App/theme\"\nimport ButtonListItem from \"~Generic/components/ButtonListItem\"\nimport MainTitle from \"~Generic/components/MainTitle\"\nimport ViewLoading from \"~Generic/components/ViewLoading\"\nimport { useLiveAccountData, useLiveAccountOffers } from \"~Generic/hooks/stellar-subscriptions\"\nimport { useIsMobile, useRouter } from \"~Generic/hooks/userinterface\"\nimport { AccountData, BalanceLine } from \"~Generic/lib/account\"\nimport { sortBalances } from \"~Generic/lib/balances\"\nimport { matchesRoute } from \"~Generic/lib/routes\"\nimport { getAccountMinimumBalance, getSpendableBalance, stringifyAsset } from \"~Generic/lib/stellar\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport AddAssetDialog from \"./AddAssetDialog\"\nimport BalanceDetailsListItem from \"./BalanceDetailsListItem\"\n\nfunction isAssetMatchingBalance(asset: Asset, balance: BalanceLine): boolean {\n  return balance.asset_type === \"native\"\n    ? asset.isNative()\n    : balance.asset_code === asset.getCode() && balance.asset_issuer === asset.getIssuer()\n}\n\ninterface TrustedAssetsProps {\n  account: Account\n  accountData: AccountData\n  assets: Asset[]\n  hmargin: string | number\n  hpadding: string | number\n  onOpenAssetDetails: (asset: Asset) => void\n  openOffers: ServerApi.OfferRecord[]\n  olderOffersAvailable?: boolean\n}\n\nconst TrustedAssets = React.memo(function TrustedAssets(props: TrustedAssetsProps) {\n  return (\n    <>\n      {props.assets.map(asset => {\n        const balance = props.accountData.balances.find(bal => isAssetMatchingBalance(asset, bal))\n        const openOffers = props.openOffers.filter(\n          offer =>\n            (offer.buying.asset_code === asset.code && offer.buying.asset_issuer === asset.issuer) ||\n            (offer.selling.asset_code === asset.code && offer.selling.asset_issuer === asset.issuer)\n        )\n        const badgeCount = props.olderOffersAvailable && openOffers.length >= 10 ? \"10+\" : openOffers.length\n        return (\n          <BalanceDetailsListItem\n            key={stringifyAsset(asset)}\n            badgeCount={badgeCount}\n            balance={balance!}\n            onClick={() => props.onOpenAssetDetails(asset)}\n            style={{\n              paddingLeft: props.hpadding,\n              paddingRight: props.hpadding,\n              marginLeft: props.hmargin,\n              marginRight: props.hmargin\n            }}\n            testnet={props.account.testnet}\n          />\n        )\n      })}\n    </>\n  )\n})\n\ninterface NativeBalanceItemsProps {\n  account: Account\n  accountData: AccountData\n  balance: Horizon.BalanceLineNative\n  hmargin: string | number\n  hpadding: string | number\n  onOpenAssetDetails: (asset: Asset) => void\n}\n\nconst NativeBalanceItems = React.memo(function NativeBalanceItems(props: NativeBalanceItemsProps) {\n  return (\n    <>\n      <BalanceDetailsListItem\n        key=\"XLM\"\n        balance={props.balance}\n        onClick={() => props.onOpenAssetDetails(Asset.native())}\n        style={{\n          paddingLeft: props.hpadding,\n          paddingRight: props.hpadding,\n          marginLeft: props.hmargin,\n          marginRight: props.hmargin\n        }}\n        testnet={props.account.testnet}\n      />\n      <BalanceDetailsListItem\n        key=\"XLM:spendable\"\n        balance={{\n          ...props.balance,\n          balance: BigNumber(props.balance.balance).eq(0)\n            ? \"0\"\n            : getSpendableBalance(getAccountMinimumBalance(props.accountData), props.balance).toString()\n        }}\n        hideLogo\n        onClick={() => props.onOpenAssetDetails(Asset.native())}\n        spendableBalance\n        style={{\n          marginTop: -8,\n          paddingLeft: props.hpadding,\n          paddingRight: props.hpadding,\n          marginLeft: props.hmargin,\n          marginRight: props.hmargin\n        }}\n        testnet={props.account.testnet}\n      />\n    </>\n  )\n})\n\ninterface BalanceDetailsProps {\n  account: Account\n  onClose: () => void\n}\n\nfunction BalanceDetailsDialog(props: BalanceDetailsProps) {\n  const accountData = useLiveAccountData(props.account.accountID, props.account.testnet)\n  const { offers: openOrders, olderOffersAvailable } = useLiveAccountOffers(\n    props.account.accountID,\n    props.account.testnet\n  )\n  const isSmallScreen = useIsMobile()\n  const router = useRouter()\n  const { t } = useTranslation()\n\n  const openAddAssetDialog = React.useCallback(\n    () => router.history.push(routes.manageAccountAssets(props.account.id)),\n    [props.account.id, router.history]\n  )\n  const closeAddAssetDialog = React.useCallback(() => router.history.push(routes.balanceDetails(props.account.id)), [\n    props.account.id,\n    router.history\n  ])\n\n  const addAssetDialogOpen = matchesRoute(router.location.pathname, routes.manageAccountAssets(props.account.id))\n  const assetDetailsDialogOpen =\n    matchesRoute(router.location.pathname, routes.assetDetails(\"*\", \"*\")) &&\n    !matchesRoute(router.location.pathname, routes.assetDetails(\"*\", \"manage\"))\n\n  const openAssetDetails = (asset: Asset) =>\n    router.history.push(routes.assetDetails(props.account.id, stringifyAsset(asset)))\n\n  const trustedAssets = sortBalances(accountData.balances)\n    .filter((balance): balance is Horizon.BalanceLineAsset => balance.asset_type !== \"native\")\n    .map(balance => new Asset(balance.asset_code, balance.asset_issuer))\n\n  const nativeBalance = accountData.balances.find(\n    (balance): balance is Horizon.BalanceLineNative => balance.asset_type === \"native\"\n  )\n\n  const hpadding = isSmallScreen ? 0 : 8\n  const itemHPadding = 16\n  const itemHMargin = 0\n\n  return (\n    <DialogBody excessWidth={12} top={<MainTitle onBack={props.onClose} title={props.account.name} />}>\n      <List style={{ paddingLeft: hpadding, paddingRight: hpadding, margin: \"0 -8px\" }}>\n        <ButtonListItem\n          gutterBottom\n          onClick={openAddAssetDialog}\n          style={{\n            padding: `0 ${itemHPadding}px`,\n            marginLeft: itemHMargin,\n            marginRight: itemHMargin\n          }}\n        >\n          <AddIcon />\n          &nbsp;&nbsp;{t(\"account.balance-details.button.add-asset.label\")}\n        </ButtonListItem>\n        <TrustedAssets\n          account={props.account}\n          accountData={accountData}\n          assets={trustedAssets}\n          hmargin={itemHMargin}\n          hpadding={itemHPadding}\n          onOpenAssetDetails={openAssetDetails}\n          openOffers={openOrders}\n          olderOffersAvailable={olderOffersAvailable}\n        />\n      </List>\n      <Divider style={{ margin: \"16px 0\" }} />\n      <List style={{ paddingLeft: hpadding, paddingRight: hpadding, margin: \"0 -8px 8px\" }}>\n        {nativeBalance ? (\n          <NativeBalanceItems\n            account={props.account}\n            accountData={accountData}\n            balance={nativeBalance}\n            hmargin={itemHMargin}\n            hpadding={itemHPadding}\n            onOpenAssetDetails={openAssetDetails}\n          />\n        ) : null}\n      </List>\n      <Dialog\n        fullScreen\n        open={addAssetDialogOpen || assetDetailsDialogOpen}\n        onClose={closeAddAssetDialog}\n        TransitionComponent={FullscreenDialogTransition}\n      >\n        <React.Suspense fallback={<ViewLoading />}>\n          <AddAssetDialog\n            account={props.account}\n            accountData={accountData}\n            hpadding={hpadding}\n            itemHPadding={itemHPadding}\n            onClose={closeAddAssetDialog}\n          />\n        </React.Suspense>\n      </Dialog>\n    </DialogBody>\n  )\n}\n\nexport default React.memo(BalanceDetailsDialog)\n"],"names":["areInputsEqual","newInputs","lastInputs","i","memoizeOne","resultFn","isEqual","lastThis","lastArgs","lastResult","calledOnce","memoized","newArgs","_i","hasNativePerformanceNow","now","cancelTimeout","timeoutID","requestTimeout","callback","delay","start","tick","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","outerStyle","innerDiv","innerStyle","IS_SCROLLING_DEBOUNCE_INTERVAL$1","defaultItemKey$1","index","data","createListComponent","_ref","_class","_temp","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","_inheritsLoose","List","props","_this","_assertThisInitialized","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","scrollDirection","scrollOffset","scrollUpdateWasRequested","_this$props","direction","itemSize","layout","itemStyleCache","style","_style","_offset","size","isHorizontal","_","__","___","event","_event$currentTarget","clientWidth","scrollLeft","scrollWidth","prevState","_event$currentTarget2","clientHeight","scrollHeight","scrollTop","ref","outerRef","nextProps","validateSharedProps$1","_proto","align","itemCount","_this$props2","initialScrollOffset","_this$props3","_this$state","_this$props4","children","className","height","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","width","isScrolling","onScroll","_this$_getRangeToRend","startIndex","stopIndex","items","_index","createElement","estimatedTotalSize","_extends","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_this$state2","_scrollDirection","_scrollOffset","_scrollUpdateWasRequested","_this$props5","overscanCount","_this$state3","overscanBackward","overscanForward","PureComponent","_ref2","_ref3","FixedSizeList","_ref4","lastItemOffset","maxOffset","minOffset","middleOffset","_ref5","offset","_ref6","numVisibleItems","_ref7","React","Window.FixedSizeList","mainnet","Asset","testnet","useBalanceItemStyles","makeStyles","breakpoints","BalanceListItem","classes","asset","balancelineToAsset","assetMetadata","useAssetMetadata","t","useTranslation","balance","SingleBalance","ListItem","ListItemIcon","AssetLogo","ListItemText","assetName","title","Badge","AccountName","BalanceDetailsListItem","CustomTrustlineDialog","code","setCode","issuerPublicKey","setIssuerPublicKey","limit","setLimit","isWidthMax450","useMediaQuery","createTransaction","addCustomAsset","DialogBody","MainTitle","TextField","DialogActionsBox","ActionButton","VerifiedUserIcon","CustomTrustlineDialog$1","assetRecordMatches","assetRecord","search","issuerMatches","issuerDetails","assetToBalance","groupAssets","values","createKey","map","value","key","existingValues","PopularAssets","stringifyAsset","searchResultRowHeight","useSearchResultStyles","createSearchResultRow","account","assetsByIssuer","openAssetDetails","itemRenderMap","issuer","SearchResultRow","item","ViewLoading","assetRecordToAsset","NoResultRow","useAddAssetStyles","AddAssetDialog","assets","popularAssets.testnet","popularAssets.mainnet","containerRef","allAssets","useTickerAssets","router","useRouter","wellKnownAccounts","useWellKnownAccounts","customTrustlineDialogOpen","setCustomTrustlineDialogOpen","searchFieldValue","setSearchFieldValue","txCreationPending","setTxCreationPending","routes.assetDetails","openCustomTrustlineDialog","closeCustomTrustlineDialog","createAddAssetTransaction","options","operations","Operation","sendTransaction","createTransactionToSend","transaction","error","trackError","isAssetAlreadyAdded","wellknownAccountMatches","accountID","lowerCasedSearch","record","notYetAddedAssets","onSearchFieldChange","filteredAssets","VerticalLayout","SearchField","ButtonListItem","AddIcon","Dialog","CompactDialogTransition","ConnectedAddAssetDialog","TransactionSender","horizon","AddAssetDialog$1","isAssetMatchingBalance","TrustedAssets","bal","openOffers","offer","badgeCount","NativeBalanceItems","BigNumber","getSpendableBalance","getAccountMinimumBalance","BalanceDetailsDialog","accountData","useLiveAccountData","openOrders","olderOffersAvailable","useLiveAccountOffers","isSmallScreen","useIsMobile","openAddAssetDialog","routes.manageAccountAssets","closeAddAssetDialog","routes.balanceDetails","addAssetDialogOpen","matchesRoute","assetDetailsDialogOpen","trustedAssets","sortBalances","nativeBalance","hpadding","itemHPadding","itemHMargin","Divider","FullscreenDialogTransition","BalanceDetailsDialog$1"],"mappings":"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","x_google_ignoreList":[0,1]}