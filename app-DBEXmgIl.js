const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["app-stage2-CwdMAbKU.js","app-stage2-v69G8-5r.css"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
function _mergeNamespaces(n, m) {
  for (var i2 = 0; i2 < m.length; i2++) {
    const e = m[i2];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var smoothscroll = { exports: {} };
var hasRequiredSmoothscroll;
function requireSmoothscroll() {
  if (hasRequiredSmoothscroll) return smoothscroll.exports;
  hasRequiredSmoothscroll = 1;
  (function(module, exports2) {
    (function() {
      function polyfill2() {
        var w = window;
        var d = document;
        if ("scrollBehavior" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {
          return;
        }
        var Element = w.HTMLElement || w.Element;
        var SCROLL_TIME = 468;
        var original2 = {
          scroll: w.scroll || w.scrollTo,
          scrollBy: w.scrollBy,
          elementScroll: Element.prototype.scroll || scrollElement,
          scrollIntoView: Element.prototype.scrollIntoView
        };
        var now2 = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;
        function isMicrosoftBrowser(userAgent) {
          var userAgentPatterns = ["MSIE ", "Trident/", "Edge/"];
          return new RegExp(userAgentPatterns.join("|")).test(userAgent);
        }
        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;
        function scrollElement(x, y) {
          this.scrollLeft = x;
          this.scrollTop = y;
        }
        function ease(k) {
          return 0.5 * (1 - Math.cos(Math.PI * k));
        }
        function shouldBailOut(firstArg) {
          if (firstArg === null || typeof firstArg !== "object" || firstArg.behavior === void 0 || firstArg.behavior === "auto" || firstArg.behavior === "instant") {
            return true;
          }
          if (typeof firstArg === "object" && firstArg.behavior === "smooth") {
            return false;
          }
          throw new TypeError(
            "behavior member of ScrollOptions " + firstArg.behavior + " is not a valid value for enumeration ScrollBehavior."
          );
        }
        function hasScrollableSpace(el2, axis) {
          if (axis === "Y") {
            return el2.clientHeight + ROUNDING_TOLERANCE < el2.scrollHeight;
          }
          if (axis === "X") {
            return el2.clientWidth + ROUNDING_TOLERANCE < el2.scrollWidth;
          }
        }
        function canOverflow(el2, axis) {
          var overflowValue = w.getComputedStyle(el2, null)["overflow" + axis];
          return overflowValue === "auto" || overflowValue === "scroll";
        }
        function isScrollable(el2) {
          var isScrollableY = hasScrollableSpace(el2, "Y") && canOverflow(el2, "Y");
          var isScrollableX = hasScrollableSpace(el2, "X") && canOverflow(el2, "X");
          return isScrollableY || isScrollableX;
        }
        function findScrollableParent(el2) {
          while (el2 !== d.body && isScrollable(el2) === false) {
            el2 = el2.parentNode || el2.host;
          }
          return el2;
        }
        function step(context2) {
          var time = now2();
          var value;
          var currentX;
          var currentY;
          var elapsed = (time - context2.startTime) / SCROLL_TIME;
          elapsed = elapsed > 1 ? 1 : elapsed;
          value = ease(elapsed);
          currentX = context2.startX + (context2.x - context2.startX) * value;
          currentY = context2.startY + (context2.y - context2.startY) * value;
          context2.method.call(context2.scrollable, currentX, currentY);
          if (currentX !== context2.x || currentY !== context2.y) {
            w.requestAnimationFrame(step.bind(w, context2));
          }
        }
        function smoothScroll(el2, x, y) {
          var scrollable;
          var startX;
          var startY;
          var method;
          var startTime = now2();
          if (el2 === d.body) {
            scrollable = w;
            startX = w.scrollX || w.pageXOffset;
            startY = w.scrollY || w.pageYOffset;
            method = original2.scroll;
          } else {
            scrollable = el2;
            startX = el2.scrollLeft;
            startY = el2.scrollTop;
            method = scrollElement;
          }
          step({
            scrollable,
            method,
            startTime,
            startX,
            startY,
            x,
            y
          });
        }
        w.scroll = w.scrollTo = function() {
          if (arguments[0] === void 0) {
            return;
          }
          if (shouldBailOut(arguments[0]) === true) {
            original2.scroll.call(
              w,
              arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : w.scrollX || w.pageXOffset,
              // use top prop, second argument if present or fallback to scrollY
              arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : w.scrollY || w.pageYOffset
            );
            return;
          }
          smoothScroll.call(
            w,
            d.body,
            arguments[0].left !== void 0 ? ~~arguments[0].left : w.scrollX || w.pageXOffset,
            arguments[0].top !== void 0 ? ~~arguments[0].top : w.scrollY || w.pageYOffset
          );
        };
        w.scrollBy = function() {
          if (arguments[0] === void 0) {
            return;
          }
          if (shouldBailOut(arguments[0])) {
            original2.scrollBy.call(
              w,
              arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : 0,
              arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : 0
            );
            return;
          }
          smoothScroll.call(
            w,
            d.body,
            ~~arguments[0].left + (w.scrollX || w.pageXOffset),
            ~~arguments[0].top + (w.scrollY || w.pageYOffset)
          );
        };
        Element.prototype.scroll = Element.prototype.scrollTo = function() {
          if (arguments[0] === void 0) {
            return;
          }
          if (shouldBailOut(arguments[0]) === true) {
            if (typeof arguments[0] === "number" && arguments[1] === void 0) {
              throw new SyntaxError("Value could not be converted");
            }
            original2.elementScroll.call(
              this,
              // use left prop, first number argument or fallback to scrollLeft
              arguments[0].left !== void 0 ? ~~arguments[0].left : typeof arguments[0] !== "object" ? ~~arguments[0] : this.scrollLeft,
              // use top prop, second argument or fallback to scrollTop
              arguments[0].top !== void 0 ? ~~arguments[0].top : arguments[1] !== void 0 ? ~~arguments[1] : this.scrollTop
            );
            return;
          }
          var left = arguments[0].left;
          var top = arguments[0].top;
          smoothScroll.call(
            this,
            this,
            typeof left === "undefined" ? this.scrollLeft : ~~left,
            typeof top === "undefined" ? this.scrollTop : ~~top
          );
        };
        Element.prototype.scrollBy = function() {
          if (arguments[0] === void 0) {
            return;
          }
          if (shouldBailOut(arguments[0]) === true) {
            original2.elementScroll.call(
              this,
              arguments[0].left !== void 0 ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft,
              arguments[0].top !== void 0 ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop
            );
            return;
          }
          this.scroll({
            left: ~~arguments[0].left + this.scrollLeft,
            top: ~~arguments[0].top + this.scrollTop,
            behavior: arguments[0].behavior
          });
        };
        Element.prototype.scrollIntoView = function() {
          if (shouldBailOut(arguments[0]) === true) {
            original2.scrollIntoView.call(
              this,
              arguments[0] === void 0 ? true : arguments[0]
            );
            return;
          }
          var scrollableParent = findScrollableParent(this);
          var parentRects = scrollableParent.getBoundingClientRect();
          var clientRects = this.getBoundingClientRect();
          if (scrollableParent !== d.body) {
            smoothScroll.call(
              this,
              scrollableParent,
              scrollableParent.scrollLeft + clientRects.left - parentRects.left,
              scrollableParent.scrollTop + clientRects.top - parentRects.top
            );
            if (w.getComputedStyle(scrollableParent).position !== "fixed") {
              w.scrollBy({
                left: parentRects.left,
                top: parentRects.top,
                behavior: "smooth"
              });
            }
          } else {
            w.scrollBy({
              left: clientRects.left,
              top: clientRects.top,
              behavior: "smooth"
            });
          }
        };
      }
      {
        module.exports = { polyfill: polyfill2 };
      }
    })();
  })(smoothscroll);
  return smoothscroll.exports;
}
var smoothscrollExports = requireSmoothscroll();
const SmoothScroll = /* @__PURE__ */ getDefaultExportFromCjs$1(smoothscrollExports);
const Messages = {
  CopyToClipboard: "CopyToClipboard",
  BioAuthAvailable: "BioAuthAvailable",
  TestBioAuth: "TestBioAuth",
  NotificationPermission: "NotificationPermission",
  RequestNotificationPermission: "RequestNotificationPermission",
  ShowNotification: "ShowNotification",
  OpenLink: "OpenLink",
  DeepLinkURL: "DeepLinkURL",
  IsDefaultProtocolClient: "IsDefaultProtocolClient",
  IsDifferentHandlerInstalled: "IsDifferentHandlerInstalled",
  SetAsDefaultProtocolClient: "SetAsDefaultProtocolClient",
  CheckUpdateAvailability: "CheckUpdateAvailability",
  StartUpdate: "StartUpdate",
  ReadSettings: "ReadSettings",
  StoreSettings: "StoreSettings",
  ReadIgnoredSignatureRequestHashes: "ReadIgnoredSignatureRequestHashes",
  StoreIgnoredSignatureRequestHashes: "StoreIgnoredSignatureRequestHashes",
  GetKeyIDs: "GetKeyIDs",
  GetPublicKeyData: "GetPublicKeyData",
  GetPrivateKeyData: "GetPrivateKeyData",
  SaveKey: "SaveKey",
  SavePublicKeyData: "SavePublicKeyData",
  SignTransaction: "SignTransaction",
  RemoveKey: "RemoveKey"
};
var register = {};
var master$1 = {};
var implementation_browser$1 = {};
var getBundleUrl_browser = {};
var hasRequiredGetBundleUrl_browser;
function requireGetBundleUrl_browser() {
  if (hasRequiredGetBundleUrl_browser) return getBundleUrl_browser;
  hasRequiredGetBundleUrl_browser = 1;
  Object.defineProperty(getBundleUrl_browser, "__esModule", { value: true });
  getBundleUrl_browser.getBundleURL = getBundleUrl_browser.getBaseURL = void 0;
  let bundleURL;
  function getBundleURLCached() {
    if (!bundleURL) {
      bundleURL = getBundleURL();
    }
    return bundleURL;
  }
  getBundleUrl_browser.getBundleURL = getBundleURLCached;
  function getBundleURL() {
    try {
      throw new Error();
    } catch (err) {
      const matches = ("" + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
      if (matches) {
        return getBaseURL(matches[0]);
      }
    }
    return "/";
  }
  function getBaseURL(url2) {
    return ("" + url2).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, "$1") + "/";
  }
  getBundleUrl_browser.getBaseURL = getBaseURL;
  return getBundleUrl_browser;
}
var hasRequiredImplementation_browser$1;
function requireImplementation_browser$1() {
  if (hasRequiredImplementation_browser$1) return implementation_browser$1;
  hasRequiredImplementation_browser$1 = 1;
  Object.defineProperty(implementation_browser$1, "__esModule", { value: true });
  implementation_browser$1.isWorkerRuntime = implementation_browser$1.getWorkerImplementation = implementation_browser$1.defaultPoolSize = void 0;
  const get_bundle_url_browser_1 = /* @__PURE__ */ requireGetBundleUrl_browser();
  implementation_browser$1.defaultPoolSize = typeof navigator !== "undefined" && navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 4;
  const isAbsoluteURL2 = (value) => /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(value);
  function createSourceBlobURL(code2) {
    const blob = new Blob([code2], { type: "application/javascript" });
    return URL.createObjectURL(blob);
  }
  function selectWorkerImplementation() {
    if (typeof Worker === "undefined") {
      return class NoWebWorker {
        constructor() {
          throw Error("No web worker implementation available. You might have tried to spawn a worker within a worker in a browser that doesn't support workers in workers.");
        }
      };
    }
    class WebWorker extends Worker {
      constructor(url2, options2) {
        var _a, _b;
        if (typeof url2 === "string" && options2 && options2._baseURL) {
          url2 = new URL(url2, options2._baseURL);
        } else if (typeof url2 === "string" && !isAbsoluteURL2(url2) && get_bundle_url_browser_1.getBundleURL().match(/^file:\/\//i)) {
          url2 = new URL(url2, get_bundle_url_browser_1.getBundleURL().replace(/\/[^\/]+$/, "/"));
          if ((_a = options2 === null || options2 === void 0 ? void 0 : options2.CORSWorkaround) !== null && _a !== void 0 ? _a : true) {
            url2 = createSourceBlobURL(`importScripts(${JSON.stringify(url2)});`);
          }
        }
        if (typeof url2 === "string" && isAbsoluteURL2(url2)) {
          if ((_b = options2 === null || options2 === void 0 ? void 0 : options2.CORSWorkaround) !== null && _b !== void 0 ? _b : true) {
            url2 = createSourceBlobURL(`importScripts(${JSON.stringify(url2)});`);
          }
        }
        super(url2, options2);
      }
    }
    class BlobWorker extends WebWorker {
      constructor(blob, options2) {
        const url2 = window.URL.createObjectURL(blob);
        super(url2, options2);
      }
      static fromText(source, options2) {
        const blob = new window.Blob([source], { type: "text/javascript" });
        return new BlobWorker(blob, options2);
      }
    }
    return {
      blob: BlobWorker,
      default: WebWorker
    };
  }
  let implementation2;
  function getWorkerImplementation() {
    if (!implementation2) {
      implementation2 = selectWorkerImplementation();
    }
    return implementation2;
  }
  implementation_browser$1.getWorkerImplementation = getWorkerImplementation;
  function isWorkerRuntime() {
    const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
    return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
  }
  implementation_browser$1.isWorkerRuntime = isWorkerRuntime;
  return implementation_browser$1;
}
var pool = {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser$f = { exports: {} };
var process = browser$f.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len2 = queue.length;
  while (len2) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len2) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len2 = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array2) {
  this.fun = fun;
  this.array = array2;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$3() {
}
process.on = noop$3;
process.addListener = noop$3;
process.once = noop$3;
process.off = noop$3;
process.removeListener = noop$3;
process.removeAllListeners = noop$3;
process.emit = noop$3;
process.prependListener = noop$3;
process.prependOnceListener = noop$3;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$f.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var browser$e = { exports: {} };
var ms$1;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms$1;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options2) {
    options2 = options2 || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common$5;
var hasRequiredCommon$4;
function requireCommon$4() {
  if (hasRequiredCommon$4) return common$5;
  hasRequiredCommon$4 = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key2) => {
      createDebug[key2] = env[key2];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i2 = 0; i2 < namespace.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns2 of split) {
        if (ns2[0] === "-") {
          createDebug.skips.push(ns2.slice(1));
        } else {
          createDebug.names.push(ns2);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns2 of createDebug.names) {
        if (matchesTemplate(name, ns2)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$5 = setup;
  return common$5;
}
var hasRequiredBrowser$e;
function requireBrowser$e() {
  if (hasRequiredBrowser$e) return browser$e.exports;
  hasRequiredBrowser$e = 1;
  (function(module, exports2) {
    var define_process_env_default = {};
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r && typeof process$1 !== "undefined" && "env" in process$1) {
        r = define_process_env_default.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module.exports = requireCommon$4()(exports2);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  })(browser$e, browser$e.exports);
  return browser$e.exports;
}
var __awaiter$5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class AsyncSerialScheduler {
  constructor(observer) {
    this._baseObserver = observer;
    this._pendingPromises = /* @__PURE__ */ new Set();
  }
  complete() {
    Promise.all(this._pendingPromises).then(() => this._baseObserver.complete()).catch((error3) => this._baseObserver.error(error3));
  }
  error(error3) {
    this._baseObserver.error(error3);
  }
  schedule(task) {
    const prevPromisesCompletion = Promise.all(this._pendingPromises);
    const values2 = [];
    const next = (value) => values2.push(value);
    const promise2 = Promise.resolve().then(() => __awaiter$5(this, void 0, void 0, function* () {
      yield prevPromisesCompletion;
      yield task(next);
      this._pendingPromises.delete(promise2);
      for (const value of values2) {
        this._baseObserver.next(value);
      }
    })).catch((error3) => {
      this._pendingPromises.delete(promise2);
      this._baseObserver.error(error3);
    });
    this._pendingPromises.add(promise2);
  }
}
const hasSymbols$2 = () => typeof Symbol === "function";
const hasSymbol$2 = (name) => hasSymbols$2() && Boolean(Symbol[name]);
const getSymbol$1 = (name) => hasSymbol$2(name) ? Symbol[name] : "@@" + name;
if (!hasSymbol$2("asyncIterator")) {
  Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");
}
const SymbolIterator$1 = getSymbol$1("iterator");
const SymbolObservable$1 = getSymbol$1("observable");
const SymbolSpecies$1 = getSymbol$1("species");
function getMethod$1(obj, key2) {
  const value = obj[key2];
  if (value == null) {
    return void 0;
  }
  if (typeof value !== "function") {
    throw new TypeError(value + " is not a function");
  }
  return value;
}
function getSpecies$1(obj) {
  let ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies$1];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable$1;
}
function isObservable$2(x) {
  return x instanceof Observable$1;
}
function hostReportError$1(error3) {
  if (hostReportError$1.log) {
    hostReportError$1.log(error3);
  } else {
    setTimeout(() => {
      throw error3;
    }, 0);
  }
}
function enqueue$1(fn) {
  Promise.resolve().then(() => {
    try {
      fn();
    } catch (e) {
      hostReportError$1(e);
    }
  });
}
function cleanupSubscription$1(subscription) {
  const cleanup = subscription._cleanup;
  if (cleanup === void 0) {
    return;
  }
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      const unsubscribe2 = getMethod$1(cleanup, "unsubscribe");
      if (unsubscribe2) {
        unsubscribe2.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError$1(e);
  }
}
function closeSubscription$1(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription$1(subscription) {
  const queue2 = subscription._queue;
  if (!queue2) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (const item of queue2) {
    notifySubscription$1(subscription, item.type, item.value);
    if (subscription._state === "closed") {
      break;
    }
  }
}
function notifySubscription$1(subscription, type2, value) {
  subscription._state = "running";
  const observer = subscription._observer;
  try {
    const m = observer ? getMethod$1(observer, type2) : void 0;
    switch (type2) {
      case "next":
        if (m)
          m.call(observer, value);
        break;
      case "error":
        closeSubscription$1(subscription);
        if (m)
          m.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription$1(subscription);
        if (m)
          m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError$1(e);
  }
  if (subscription._state === "closed") {
    cleanupSubscription$1(subscription);
  } else if (subscription._state === "running") {
    subscription._state = "ready";
  }
}
function onNotify$1(subscription, type2, value) {
  if (subscription._state === "closed") {
    return;
  }
  if (subscription._state === "buffering") {
    subscription._queue = subscription._queue || [];
    subscription._queue.push({ type: type2, value });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{ type: type2, value }];
    enqueue$1(() => flushSubscription$1(subscription));
    return;
  }
  notifySubscription$1(subscription, type2, value);
}
let Subscription$1 = class Subscription2 {
  constructor(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    const subscriptionObserver = new SubscriptionObserver$1(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }
    if (this._state === "initializing") {
      this._state = "ready";
    }
  }
  get closed() {
    return this._state === "closed";
  }
  unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription$1(this);
      cleanupSubscription$1(this);
    }
  }
};
let SubscriptionObserver$1 = class SubscriptionObserver2 {
  constructor(subscription) {
    this._subscription = subscription;
  }
  get closed() {
    return this._subscription._state === "closed";
  }
  next(value) {
    onNotify$1(this._subscription, "next", value);
  }
  error(value) {
    onNotify$1(this._subscription, "error", value);
  }
  complete() {
    onNotify$1(this._subscription, "complete");
  }
};
let Observable$1 = class Observable2 {
  constructor(subscriber) {
    if (!(this instanceof Observable2)) {
      throw new TypeError("Observable cannot be called as a function");
    }
    if (typeof subscriber !== "function") {
      throw new TypeError("Observable initializer must be a function");
    }
    this._subscriber = subscriber;
  }
  subscribe(nextOrObserver, onError, onComplete) {
    if (typeof nextOrObserver !== "object" || nextOrObserver === null) {
      nextOrObserver = {
        next: nextOrObserver,
        error: onError,
        complete: onComplete
      };
    }
    return new Subscription$1(nextOrObserver, this._subscriber);
  }
  pipe(first, ...mappers) {
    let intermediate = this;
    for (const mapper of [first, ...mappers]) {
      intermediate = mapper(intermediate);
    }
    return intermediate;
  }
  tap(nextOrObserver, onError, onComplete) {
    const tapObserver = typeof nextOrObserver !== "object" || nextOrObserver === null ? {
      next: nextOrObserver,
      error: onError,
      complete: onComplete
    } : nextOrObserver;
    return new Observable2((observer) => {
      return this.subscribe({
        next(value) {
          tapObserver.next && tapObserver.next(value);
          observer.next(value);
        },
        error(error3) {
          tapObserver.error && tapObserver.error(error3);
          observer.error(error3);
        },
        complete() {
          tapObserver.complete && tapObserver.complete();
          observer.complete();
        },
        start(subscription) {
          tapObserver.start && tapObserver.start(subscription);
        }
      });
    });
  }
  forEach(fn) {
    return new Promise((resolve2, reject) => {
      if (typeof fn !== "function") {
        reject(new TypeError(fn + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve2(void 0);
      }
      const subscription = this.subscribe({
        next(value) {
          try {
            fn(value, done);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error(error3) {
          reject(error3);
        },
        complete() {
          resolve2(void 0);
        }
      });
    });
  }
  map(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies$1(this);
    return new C((observer) => this.subscribe({
      next(value) {
        let propagatedValue = value;
        try {
          propagatedValue = fn(value);
        } catch (e) {
          return observer.error(e);
        }
        observer.next(propagatedValue);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    }));
  }
  filter(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies$1(this);
    return new C((observer) => this.subscribe({
      next(value) {
        try {
          if (!fn(value))
            return;
        } catch (e) {
          return observer.error(e);
        }
        observer.next(value);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    }));
  }
  reduce(fn, seed) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies$1(this);
    const hasSeed = arguments.length > 1;
    let hasValue2 = false;
    let acc = seed;
    return new C((observer) => this.subscribe({
      next(value) {
        const first = !hasValue2;
        hasValue2 = true;
        if (!first || hasSeed) {
          try {
            acc = fn(acc, value);
          } catch (e) {
            return observer.error(e);
          }
        } else {
          acc = value;
        }
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        if (!hasValue2 && !hasSeed) {
          return observer.error(new TypeError("Cannot reduce an empty sequence"));
        }
        observer.next(acc);
        observer.complete();
      }
    }));
  }
  concat(...sources) {
    const C = getSpecies$1(this);
    return new C((observer) => {
      let subscription;
      let index2 = 0;
      function startNext(next) {
        subscription = next.subscribe({
          next(v) {
            observer.next(v);
          },
          error(e) {
            observer.error(e);
          },
          complete() {
            if (index2 === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C.from(sources[index2++]));
            }
          }
        });
      }
      startNext(this);
      return () => {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  }
  flatMap(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies$1(this);
    return new C((observer) => {
      const subscriptions = [];
      const outer = this.subscribe({
        next(value) {
          let normalizedValue;
          if (fn) {
            try {
              normalizedValue = fn(value);
            } catch (e) {
              return observer.error(e);
            }
          } else {
            normalizedValue = value;
          }
          const inner = C.from(normalizedValue).subscribe({
            next(innerValue) {
              observer.next(innerValue);
            },
            error(e) {
              observer.error(e);
            },
            complete() {
              const i2 = subscriptions.indexOf(inner);
              if (i2 >= 0)
                subscriptions.splice(i2, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error(e) {
          observer.error(e);
        },
        complete() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0) {
          observer.complete();
        }
      }
      return () => {
        subscriptions.forEach((s) => s.unsubscribe());
        outer.unsubscribe();
      };
    });
  }
  [SymbolObservable$1]() {
    return this;
  }
  static from(x) {
    const C = typeof this === "function" ? this : Observable2;
    if (x == null) {
      throw new TypeError(x + " is not an object");
    }
    const observableMethod = getMethod$1(x, SymbolObservable$1);
    if (observableMethod) {
      const observable = observableMethod.call(x);
      if (Object(observable) !== observable) {
        throw new TypeError(observable + " is not an object");
      }
      if (isObservable$2(observable) && observable.constructor === C) {
        return observable;
      }
      return new C((observer) => observable.subscribe(observer));
    }
    if (hasSymbol$2("iterator")) {
      const iteratorMethod = getMethod$1(x, SymbolIterator$1);
      if (iteratorMethod) {
        return new C((observer) => {
          enqueue$1(() => {
            if (observer.closed)
              return;
            for (const item of iteratorMethod.call(x)) {
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x)) {
      return new C((observer) => {
        enqueue$1(() => {
          if (observer.closed)
            return;
          for (const item of x) {
            observer.next(item);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x + " is not observable");
  }
  static of(...items) {
    const C = typeof this === "function" ? this : Observable2;
    return new C((observer) => {
      enqueue$1(() => {
        if (observer.closed)
          return;
        for (const item of items) {
          observer.next(item);
          if (observer.closed)
            return;
        }
        observer.complete();
      });
    });
  }
  static get [SymbolSpecies$1]() {
    return this;
  }
};
if (hasSymbols$2()) {
  Object.defineProperty(Observable$1, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable$1,
      hostReportError: hostReportError$1
    },
    configurable: true
  });
}
function unsubscribe$1(subscription) {
  if (typeof subscription === "function") {
    subscription();
  } else if (subscription && typeof subscription.unsubscribe === "function") {
    subscription.unsubscribe();
  }
}
var __awaiter$4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function filter$1(test) {
  return (observable) => {
    return new Observable$1((observer) => {
      const scheduler2 = new AsyncSerialScheduler(observer);
      const subscription = observable.subscribe({
        complete() {
          scheduler2.complete();
        },
        error(error3) {
          scheduler2.error(error3);
        },
        next(input) {
          scheduler2.schedule((next) => __awaiter$4(this, void 0, void 0, function* () {
            if (yield test(input)) {
              next(input);
            }
          }));
        }
      });
      return () => unsubscribe$1(subscription);
    });
  };
}
function isAsyncIterator(thing) {
  return thing && hasSymbol$2("asyncIterator") && thing[Symbol.asyncIterator];
}
function isIterator(thing) {
  return thing && hasSymbol$2("iterator") && thing[Symbol.iterator];
}
var __awaiter$3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues$1 = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n) {
    i2[n] = o[n] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n](v), settle2(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle2(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
};
function flatMap(mapper) {
  return (observable) => {
    return new Observable$1((observer) => {
      const scheduler2 = new AsyncSerialScheduler(observer);
      const subscription = observable.subscribe({
        complete() {
          scheduler2.complete();
        },
        error(error3) {
          scheduler2.error(error3);
        },
        next(input) {
          scheduler2.schedule((next) => __awaiter$3(this, void 0, void 0, function* () {
            var e_1, _a;
            const mapped = yield mapper(input);
            if (isIterator(mapped) || isAsyncIterator(mapped)) {
              try {
                for (var mapped_1 = __asyncValues$1(mapped), mapped_1_1; mapped_1_1 = yield mapped_1.next(), !mapped_1_1.done; ) {
                  const element = mapped_1_1.value;
                  next(element);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (mapped_1_1 && !mapped_1_1.done && (_a = mapped_1.return)) yield _a.call(mapped_1);
                } finally {
                  if (e_1) throw e_1.error;
                }
              }
            } else {
              mapped.map((output2) => next(output2));
            }
          }));
        }
      });
      return () => unsubscribe$1(subscription);
    });
  };
}
function interval(period) {
  return new Observable$1((observer) => {
    let counter = 0;
    const handle2 = setInterval(() => {
      observer.next(counter++);
    }, period);
    return () => clearInterval(handle2);
  });
}
var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function map(mapper) {
  return (observable) => {
    return new Observable$1((observer) => {
      const scheduler2 = new AsyncSerialScheduler(observer);
      const subscription = observable.subscribe({
        complete() {
          scheduler2.complete();
        },
        error(error3) {
          scheduler2.error(error3);
        },
        next(input) {
          scheduler2.schedule((next) => __awaiter$2(this, void 0, void 0, function* () {
            const mapped = yield mapper(input);
            next(mapped);
          }));
        }
      });
      return () => unsubscribe$1(subscription);
    });
  };
}
function merge(...observables) {
  if (observables.length === 0) {
    return Observable$1.from([]);
  }
  return new Observable$1((observer) => {
    let completed = 0;
    const subscriptions = observables.map((input) => {
      return input.subscribe({
        error(error3) {
          observer.error(error3);
          unsubscribeAll();
        },
        next(value) {
          observer.next(value);
        },
        complete() {
          if (++completed === observables.length) {
            observer.complete();
            unsubscribeAll();
          }
        }
      });
    });
    const unsubscribeAll = () => {
      subscriptions.forEach((subscription) => unsubscribe$1(subscription));
    };
    return unsubscribeAll;
  });
}
let MulticastSubject$1 = class MulticastSubject2 extends Observable$1 {
  constructor() {
    super((observer) => {
      this._observers.add(observer);
      return () => this._observers.delete(observer);
    });
    this._observers = /* @__PURE__ */ new Set();
  }
  next(value) {
    for (const observer of this._observers) {
      observer.next(value);
    }
  }
  error(error3) {
    for (const observer of this._observers) {
      observer.error(error3);
    }
  }
  complete() {
    for (const observer of this._observers) {
      observer.complete();
    }
  }
};
function multicast$1(coldObservable) {
  const subject = new MulticastSubject$1();
  let sourceSubscription;
  let subscriberCount = 0;
  return new Observable$1((observer) => {
    if (!sourceSubscription) {
      sourceSubscription = coldObservable.subscribe(subject);
    }
    const subscription = subject.subscribe(observer);
    subscriberCount++;
    return () => {
      subscriberCount--;
      subscription.unsubscribe();
      if (subscriberCount === 0) {
        unsubscribe$1(sourceSubscription);
        sourceSubscription = void 0;
      }
    };
  });
}
var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function scan(accumulator, seed) {
  return (observable) => {
    return new Observable$1((observer) => {
      let accumulated;
      let index2 = 0;
      const scheduler2 = new AsyncSerialScheduler(observer);
      const subscription = observable.subscribe({
        complete() {
          scheduler2.complete();
        },
        error(error3) {
          scheduler2.error(error3);
        },
        next(value) {
          scheduler2.schedule((next) => __awaiter$1(this, void 0, void 0, function* () {
            const prevAcc = index2 === 0 ? typeof seed === "undefined" ? value : seed : accumulated;
            accumulated = yield accumulator(prevAcc, value, index2++);
            next(accumulated);
          }));
        }
      });
      return () => unsubscribe$1(subscription);
    });
  };
}
const dist_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Observable: Observable$1,
  Subject: MulticastSubject$1,
  filter: filter$1,
  flatMap,
  interval,
  map,
  merge,
  multicast: multicast$1,
  scan,
  unsubscribe: unsubscribe$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$4 = /* @__PURE__ */ getAugmentedNamespace(dist_esm);
var ponyfills = {};
var hasRequiredPonyfills;
function requirePonyfills() {
  if (hasRequiredPonyfills) return ponyfills;
  hasRequiredPonyfills = 1;
  Object.defineProperty(ponyfills, "__esModule", { value: true });
  ponyfills.allSettled = void 0;
  function allSettled(values2) {
    return Promise.all(values2.map((item) => {
      const onFulfill = (value) => {
        return { status: "fulfilled", value };
      };
      const onReject = (reason) => {
        return { status: "rejected", reason };
      };
      const itemPromise = Promise.resolve(item);
      try {
        return itemPromise.then(onFulfill, onReject);
      } catch (error3) {
        return Promise.reject(error3);
      }
    }));
  }
  ponyfills.allSettled = allSettled;
  return ponyfills;
}
var poolTypes = {};
var hasRequiredPoolTypes;
function requirePoolTypes() {
  if (hasRequiredPoolTypes) return poolTypes;
  hasRequiredPoolTypes = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PoolEventType = void 0;
    (function(PoolEventType) {
      PoolEventType["initialized"] = "initialized";
      PoolEventType["taskCanceled"] = "taskCanceled";
      PoolEventType["taskCompleted"] = "taskCompleted";
      PoolEventType["taskFailed"] = "taskFailed";
      PoolEventType["taskQueued"] = "taskQueued";
      PoolEventType["taskQueueDrained"] = "taskQueueDrained";
      PoolEventType["taskStart"] = "taskStart";
      PoolEventType["terminated"] = "terminated";
    })(exports2.PoolEventType || (exports2.PoolEventType = {}));
  })(poolTypes);
  return poolTypes;
}
var thread = {};
var symbols = {};
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  Object.defineProperty(symbols, "__esModule", { value: true });
  symbols.$worker = symbols.$transferable = symbols.$terminate = symbols.$events = symbols.$errors = void 0;
  symbols.$errors = Symbol("thread.errors");
  symbols.$events = Symbol("thread.events");
  symbols.$terminate = Symbol("thread.terminate");
  symbols.$transferable = Symbol("thread.transferable");
  symbols.$worker = Symbol("thread.worker");
  return symbols;
}
var hasRequiredThread;
function requireThread() {
  if (hasRequiredThread) return thread;
  hasRequiredThread = 1;
  Object.defineProperty(thread, "__esModule", { value: true });
  thread.Thread = void 0;
  const symbols_1 = /* @__PURE__ */ requireSymbols();
  function fail(message) {
    throw Error(message);
  }
  thread.Thread = {
    /** Return an observable that can be used to subscribe to all errors happening in the thread. */
    errors(thread2) {
      return thread2[symbols_1.$errors] || fail("Error observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
    },
    /** Return an observable that can be used to subscribe to internal events happening in the thread. Useful for debugging. */
    events(thread2) {
      return thread2[symbols_1.$events] || fail("Events observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
    },
    /** Terminate a thread. Remember to terminate every thread when you are done using it. */
    terminate(thread2) {
      return thread2[symbols_1.$terminate]();
    }
  };
  return thread;
}
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool;
  hasRequiredPool = 1;
  (function(exports2) {
    var __awaiter2 = pool && pool.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = pool && pool.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pool = exports2.Thread = exports2.PoolEventType = void 0;
    const debug_1 = __importDefault2(requireBrowser$e());
    const observable_fns_1 = require$$1$4;
    const ponyfills_1 = /* @__PURE__ */ requirePonyfills();
    const implementation_1 = /* @__PURE__ */ requireImplementation_browser$1();
    const pool_types_1 = /* @__PURE__ */ requirePoolTypes();
    Object.defineProperty(exports2, "PoolEventType", { enumerable: true, get: function() {
      return pool_types_1.PoolEventType;
    } });
    const thread_1 = /* @__PURE__ */ requireThread();
    Object.defineProperty(exports2, "Thread", { enumerable: true, get: function() {
      return thread_1.Thread;
    } });
    let nextPoolID = 1;
    function createArray(size) {
      const array2 = [];
      for (let index2 = 0; index2 < size; index2++) {
        array2.push(index2);
      }
      return array2;
    }
    function delay(ms2) {
      return new Promise((resolve2) => setTimeout(resolve2, ms2));
    }
    function flatMap2(array2, mapper) {
      return array2.reduce((flattened, element) => [...flattened, ...mapper(element)], []);
    }
    function slugify(text) {
      return text.replace(/\W/g, " ").trim().replace(/\s+/g, "-");
    }
    function spawnWorkers2(spawnWorker, count) {
      return createArray(count).map(() => ({
        init: spawnWorker(),
        runningTasks: []
      }));
    }
    class WorkerPool {
      constructor(spawnWorker, optionsOrSize) {
        this.eventSubject = new observable_fns_1.Subject();
        this.initErrors = [];
        this.isClosing = false;
        this.nextTaskID = 1;
        this.taskQueue = [];
        const options2 = typeof optionsOrSize === "number" ? { size: optionsOrSize } : optionsOrSize || {};
        const { size = implementation_1.defaultPoolSize } = options2;
        this.debug = debug_1.default(`threads:pool:${slugify(options2.name || String(nextPoolID++))}`);
        this.options = options2;
        this.workers = spawnWorkers2(spawnWorker, size);
        this.eventObservable = observable_fns_1.multicast(observable_fns_1.Observable.from(this.eventSubject));
        Promise.all(this.workers.map((worker2) => worker2.init)).then(() => this.eventSubject.next({
          type: pool_types_1.PoolEventType.initialized,
          size: this.workers.length
        }), (error3) => {
          this.debug("Error while initializing pool worker:", error3);
          this.eventSubject.error(error3);
          this.initErrors.push(error3);
        });
      }
      findIdlingWorker() {
        const { concurrency = 1 } = this.options;
        return this.workers.find((worker2) => worker2.runningTasks.length < concurrency);
      }
      runPoolTask(worker2, task) {
        return __awaiter2(this, void 0, void 0, function* () {
          const workerID = this.workers.indexOf(worker2) + 1;
          this.debug(`Running task #${task.id} on worker #${workerID}...`);
          this.eventSubject.next({
            type: pool_types_1.PoolEventType.taskStart,
            taskID: task.id,
            workerID
          });
          try {
            const returnValue = yield task.run(yield worker2.init);
            this.debug(`Task #${task.id} completed successfully`);
            this.eventSubject.next({
              type: pool_types_1.PoolEventType.taskCompleted,
              returnValue,
              taskID: task.id,
              workerID
            });
          } catch (error3) {
            this.debug(`Task #${task.id} failed`);
            this.eventSubject.next({
              type: pool_types_1.PoolEventType.taskFailed,
              taskID: task.id,
              error: error3,
              workerID
            });
          }
        });
      }
      run(worker2, task) {
        return __awaiter2(this, void 0, void 0, function* () {
          const runPromise = (() => __awaiter2(this, void 0, void 0, function* () {
            const removeTaskFromWorkersRunningTasks = () => {
              worker2.runningTasks = worker2.runningTasks.filter((someRunPromise) => someRunPromise !== runPromise);
            };
            yield delay(0);
            try {
              yield this.runPoolTask(worker2, task);
            } finally {
              removeTaskFromWorkersRunningTasks();
              if (!this.isClosing) {
                this.scheduleWork();
              }
            }
          }))();
          worker2.runningTasks.push(runPromise);
        });
      }
      scheduleWork() {
        this.debug(`Attempt de-queueing a task in order to run it...`);
        const availableWorker = this.findIdlingWorker();
        if (!availableWorker)
          return;
        const nextTask = this.taskQueue.shift();
        if (!nextTask) {
          this.debug(`Task queue is empty`);
          this.eventSubject.next({ type: pool_types_1.PoolEventType.taskQueueDrained });
          return;
        }
        this.run(availableWorker, nextTask);
      }
      taskCompletion(taskID) {
        return new Promise((resolve2, reject) => {
          const eventSubscription = this.events().subscribe((event) => {
            if (event.type === pool_types_1.PoolEventType.taskCompleted && event.taskID === taskID) {
              eventSubscription.unsubscribe();
              resolve2(event.returnValue);
            } else if (event.type === pool_types_1.PoolEventType.taskFailed && event.taskID === taskID) {
              eventSubscription.unsubscribe();
              reject(event.error);
            } else if (event.type === pool_types_1.PoolEventType.terminated) {
              eventSubscription.unsubscribe();
              reject(Error("Pool has been terminated before task was run."));
            }
          });
        });
      }
      settled(allowResolvingImmediately = false) {
        return __awaiter2(this, void 0, void 0, function* () {
          const getCurrentlyRunningTasks = () => flatMap2(this.workers, (worker2) => worker2.runningTasks);
          const taskFailures = [];
          const failureSubscription = this.eventObservable.subscribe((event) => {
            if (event.type === pool_types_1.PoolEventType.taskFailed) {
              taskFailures.push(event.error);
            }
          });
          if (this.initErrors.length > 0) {
            return Promise.reject(this.initErrors[0]);
          }
          if (allowResolvingImmediately && this.taskQueue.length === 0) {
            yield ponyfills_1.allSettled(getCurrentlyRunningTasks());
            return taskFailures;
          }
          yield new Promise((resolve2, reject) => {
            const subscription = this.eventObservable.subscribe({
              next(event) {
                if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {
                  subscription.unsubscribe();
                  resolve2(void 0);
                }
              },
              error: reject
              // make a pool-wide error reject the completed() result promise
            });
          });
          yield ponyfills_1.allSettled(getCurrentlyRunningTasks());
          failureSubscription.unsubscribe();
          return taskFailures;
        });
      }
      completed(allowResolvingImmediately = false) {
        return __awaiter2(this, void 0, void 0, function* () {
          const settlementPromise = this.settled(allowResolvingImmediately);
          const earlyExitPromise = new Promise((resolve2, reject) => {
            const subscription = this.eventObservable.subscribe({
              next(event) {
                if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {
                  subscription.unsubscribe();
                  resolve2(settlementPromise);
                } else if (event.type === pool_types_1.PoolEventType.taskFailed) {
                  subscription.unsubscribe();
                  reject(event.error);
                }
              },
              error: reject
              // make a pool-wide error reject the completed() result promise
            });
          });
          const errors2 = yield Promise.race([
            settlementPromise,
            earlyExitPromise
          ]);
          if (errors2.length > 0) {
            throw errors2[0];
          }
        });
      }
      events() {
        return this.eventObservable;
      }
      queue(taskFunction) {
        const { maxQueuedJobs = Infinity } = this.options;
        if (this.isClosing) {
          throw Error(`Cannot schedule pool tasks after terminate() has been called.`);
        }
        if (this.initErrors.length > 0) {
          throw this.initErrors[0];
        }
        const taskID = this.nextTaskID++;
        const taskCompletion = this.taskCompletion(taskID);
        taskCompletion.catch((error3) => {
          this.debug(`Task #${taskID} errored:`, error3);
        });
        const task = {
          id: taskID,
          run: taskFunction,
          cancel: () => {
            if (this.taskQueue.indexOf(task) === -1)
              return;
            this.taskQueue = this.taskQueue.filter((someTask) => someTask !== task);
            this.eventSubject.next({
              type: pool_types_1.PoolEventType.taskCanceled,
              taskID: task.id
            });
          },
          then: taskCompletion.then.bind(taskCompletion)
        };
        if (this.taskQueue.length >= maxQueuedJobs) {
          throw Error("Maximum number of pool tasks queued. Refusing to queue another one.\nThis usually happens for one of two reasons: We are either at peak workload right now or some tasks just won't finish, thus blocking the pool.");
        }
        this.debug(`Queueing task #${task.id}...`);
        this.taskQueue.push(task);
        this.eventSubject.next({
          type: pool_types_1.PoolEventType.taskQueued,
          taskID: task.id
        });
        this.scheduleWork();
        return task;
      }
      terminate(force) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.isClosing = true;
          if (!force) {
            yield this.completed(true);
          }
          this.eventSubject.next({
            type: pool_types_1.PoolEventType.terminated,
            remainingQueue: [...this.taskQueue]
          });
          this.eventSubject.complete();
          yield Promise.all(this.workers.map((worker2) => __awaiter2(this, void 0, void 0, function* () {
            return thread_1.Thread.terminate(yield worker2.init);
          })));
        });
      }
    }
    WorkerPool.EventType = pool_types_1.PoolEventType;
    function PoolConstructor(spawnWorker, optionsOrSize) {
      return new WorkerPool(spawnWorker, optionsOrSize);
    }
    PoolConstructor.EventType = pool_types_1.PoolEventType;
    exports2.Pool = PoolConstructor;
  })(pool);
  return pool;
}
var spawn$1 = {};
var common$4 = {};
var serializers = {};
var hasRequiredSerializers;
function requireSerializers() {
  if (hasRequiredSerializers) return serializers;
  hasRequiredSerializers = 1;
  Object.defineProperty(serializers, "__esModule", { value: true });
  serializers.DefaultSerializer = serializers.extendSerializer = void 0;
  function extendSerializer(extend2, implementation2) {
    const fallbackDeserializer = extend2.deserialize.bind(extend2);
    const fallbackSerializer = extend2.serialize.bind(extend2);
    return {
      deserialize(message) {
        return implementation2.deserialize(message, fallbackDeserializer);
      },
      serialize(input) {
        return implementation2.serialize(input, fallbackSerializer);
      }
    };
  }
  serializers.extendSerializer = extendSerializer;
  const DefaultErrorSerializer = {
    deserialize(message) {
      return Object.assign(Error(message.message), {
        name: message.name,
        stack: message.stack
      });
    },
    serialize(error3) {
      return {
        __error_marker: "$$error",
        message: error3.message,
        name: error3.name,
        stack: error3.stack
      };
    }
  };
  const isSerializedError = (thing) => thing && typeof thing === "object" && "__error_marker" in thing && thing.__error_marker === "$$error";
  serializers.DefaultSerializer = {
    deserialize(message) {
      if (isSerializedError(message)) {
        return DefaultErrorSerializer.deserialize(message);
      } else {
        return message;
      }
    },
    serialize(input) {
      if (input instanceof Error) {
        return DefaultErrorSerializer.serialize(input);
      } else {
        return input;
      }
    }
  };
  return serializers;
}
var hasRequiredCommon$3;
function requireCommon$3() {
  if (hasRequiredCommon$3) return common$4;
  hasRequiredCommon$3 = 1;
  Object.defineProperty(common$4, "__esModule", { value: true });
  common$4.serialize = common$4.deserialize = common$4.registerSerializer = void 0;
  const serializers_1 = /* @__PURE__ */ requireSerializers();
  let registeredSerializer = serializers_1.DefaultSerializer;
  function registerSerializer2(serializer) {
    registeredSerializer = serializers_1.extendSerializer(registeredSerializer, serializer);
  }
  common$4.registerSerializer = registerSerializer2;
  function deserialize(message) {
    return registeredSerializer.deserialize(message);
  }
  common$4.deserialize = deserialize;
  function serialize(input) {
    return registeredSerializer.serialize(input);
  }
  common$4.serialize = serialize;
  return common$4;
}
var promise = {};
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  Object.defineProperty(promise, "__esModule", { value: true });
  promise.createPromiseWithResolver = void 0;
  const doNothing = () => void 0;
  function createPromiseWithResolver() {
    let alreadyResolved = false;
    let resolvedTo;
    let resolver = doNothing;
    const promise2 = new Promise((resolve2) => {
      if (alreadyResolved) {
        resolve2(resolvedTo);
      } else {
        resolver = resolve2;
      }
    });
    const exposedResolver = (value) => {
      alreadyResolved = true;
      resolvedTo = value;
      resolver(resolvedTo);
    };
    return [promise2, exposedResolver];
  }
  promise.createPromiseWithResolver = createPromiseWithResolver;
  return promise;
}
var master = {};
var hasRequiredMaster$1;
function requireMaster$1() {
  if (hasRequiredMaster$1) return master;
  hasRequiredMaster$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkerEventType = void 0;
    (function(WorkerEventType) {
      WorkerEventType["internalError"] = "internalError";
      WorkerEventType["message"] = "message";
      WorkerEventType["termination"] = "termination";
    })(exports2.WorkerEventType || (exports2.WorkerEventType = {}));
  })(master);
  return master;
}
var invocationProxy = {};
var observablePromise = {};
var hasRequiredObservablePromise;
function requireObservablePromise() {
  if (hasRequiredObservablePromise) return observablePromise;
  hasRequiredObservablePromise = 1;
  Object.defineProperty(observablePromise, "__esModule", { value: true });
  observablePromise.ObservablePromise = void 0;
  const observable_fns_1 = require$$1$4;
  const doNothing = () => void 0;
  const returnInput = (input) => input;
  const runDeferred = (fn) => Promise.resolve().then(fn);
  function fail(error3) {
    throw error3;
  }
  function isThenable(thing) {
    return thing && typeof thing.then === "function";
  }
  class ObservablePromise extends observable_fns_1.Observable {
    constructor(init2) {
      super((originalObserver) => {
        const self2 = this;
        const observer = Object.assign(Object.assign({}, originalObserver), {
          complete() {
            originalObserver.complete();
            self2.onCompletion();
          },
          error(error3) {
            originalObserver.error(error3);
            self2.onError(error3);
          },
          next(value) {
            originalObserver.next(value);
            self2.onNext(value);
          }
        });
        try {
          this.initHasRun = true;
          return init2(observer);
        } catch (error3) {
          observer.error(error3);
        }
      });
      this.initHasRun = false;
      this.fulfillmentCallbacks = [];
      this.rejectionCallbacks = [];
      this.firstValueSet = false;
      this.state = "pending";
    }
    onNext(value) {
      if (!this.firstValueSet) {
        this.firstValue = value;
        this.firstValueSet = true;
      }
    }
    onError(error3) {
      this.state = "rejected";
      this.rejection = error3;
      for (const onRejected of this.rejectionCallbacks) {
        runDeferred(() => onRejected(error3));
      }
    }
    onCompletion() {
      this.state = "fulfilled";
      for (const onFulfilled of this.fulfillmentCallbacks) {
        runDeferred(() => onFulfilled(this.firstValue));
      }
    }
    then(onFulfilledRaw, onRejectedRaw) {
      const onFulfilled = onFulfilledRaw || returnInput;
      const onRejected = onRejectedRaw || fail;
      let onRejectedCalled = false;
      return new Promise((resolve2, reject) => {
        const rejectionCallback = (error3) => {
          if (onRejectedCalled)
            return;
          onRejectedCalled = true;
          try {
            resolve2(onRejected(error3));
          } catch (anotherError) {
            reject(anotherError);
          }
        };
        const fulfillmentCallback = (value) => {
          try {
            resolve2(onFulfilled(value));
          } catch (error3) {
            rejectionCallback(error3);
          }
        };
        if (!this.initHasRun) {
          this.subscribe({ error: rejectionCallback });
        }
        if (this.state === "fulfilled") {
          return resolve2(onFulfilled(this.firstValue));
        }
        if (this.state === "rejected") {
          onRejectedCalled = true;
          return resolve2(onRejected(this.rejection));
        }
        this.fulfillmentCallbacks.push(fulfillmentCallback);
        this.rejectionCallbacks.push(rejectionCallback);
      });
    }
    catch(onRejected) {
      return this.then(void 0, onRejected);
    }
    finally(onCompleted) {
      const handler = onCompleted || doNothing;
      return this.then((value) => {
        handler();
        return value;
      }, () => handler());
    }
    static from(thing) {
      if (isThenable(thing)) {
        return new ObservablePromise((observer) => {
          const onFulfilled = (value) => {
            observer.next(value);
            observer.complete();
          };
          const onRejected = (error3) => {
            observer.error(error3);
          };
          thing.then(onFulfilled, onRejected);
        });
      } else {
        return super.from(thing);
      }
    }
  }
  observablePromise.ObservablePromise = ObservablePromise;
  return observablePromise;
}
var transferable = {};
var hasRequiredTransferable;
function requireTransferable() {
  if (hasRequiredTransferable) return transferable;
  hasRequiredTransferable = 1;
  Object.defineProperty(transferable, "__esModule", { value: true });
  transferable.Transfer = transferable.isTransferDescriptor = void 0;
  const symbols_1 = /* @__PURE__ */ requireSymbols();
  function isTransferable(thing) {
    if (!thing || typeof thing !== "object")
      return false;
    return true;
  }
  function isTransferDescriptor(thing) {
    return thing && typeof thing === "object" && thing[symbols_1.$transferable];
  }
  transferable.isTransferDescriptor = isTransferDescriptor;
  function Transfer(payload, transferables) {
    if (!transferables) {
      if (!isTransferable(payload))
        throw Error();
      transferables = [payload];
    }
    return {
      [symbols_1.$transferable]: true,
      send: payload,
      transferables
    };
  }
  transferable.Transfer = Transfer;
  return transferable;
}
var messages = {};
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkerMessageType = exports2.MasterMessageType = void 0;
    (function(MasterMessageType) {
      MasterMessageType["cancel"] = "cancel";
      MasterMessageType["run"] = "run";
    })(exports2.MasterMessageType || (exports2.MasterMessageType = {}));
    (function(WorkerMessageType) {
      WorkerMessageType["error"] = "error";
      WorkerMessageType["init"] = "init";
      WorkerMessageType["result"] = "result";
      WorkerMessageType["running"] = "running";
      WorkerMessageType["uncaughtError"] = "uncaughtError";
    })(exports2.WorkerMessageType || (exports2.WorkerMessageType = {}));
  })(messages);
  return messages;
}
var hasRequiredInvocationProxy;
function requireInvocationProxy() {
  if (hasRequiredInvocationProxy) return invocationProxy;
  hasRequiredInvocationProxy = 1;
  var __importDefault2 = invocationProxy && invocationProxy.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(invocationProxy, "__esModule", { value: true });
  invocationProxy.createProxyModule = invocationProxy.createProxyFunction = void 0;
  const debug_1 = __importDefault2(requireBrowser$e());
  const observable_fns_1 = require$$1$4;
  const common_1 = /* @__PURE__ */ requireCommon$3();
  const observable_promise_1 = /* @__PURE__ */ requireObservablePromise();
  const transferable_1 = /* @__PURE__ */ requireTransferable();
  const messages_1 = /* @__PURE__ */ requireMessages();
  const debugMessages = debug_1.default("threads:master:messages");
  let nextJobUID = 1;
  const dedupe2 = (array2) => Array.from(new Set(array2));
  const isJobErrorMessage = (data) => data && data.type === messages_1.WorkerMessageType.error;
  const isJobResultMessage = (data) => data && data.type === messages_1.WorkerMessageType.result;
  const isJobStartMessage = (data) => data && data.type === messages_1.WorkerMessageType.running;
  function createObservableForJob(worker2, jobUID) {
    return new observable_fns_1.Observable((observer) => {
      let asyncType;
      const messageHandler = (event) => {
        debugMessages("Message from worker:", event.data);
        if (!event.data || event.data.uid !== jobUID)
          return;
        if (isJobStartMessage(event.data)) {
          asyncType = event.data.resultType;
        } else if (isJobResultMessage(event.data)) {
          if (asyncType === "promise") {
            if (typeof event.data.payload !== "undefined") {
              observer.next(common_1.deserialize(event.data.payload));
            }
            observer.complete();
            worker2.removeEventListener("message", messageHandler);
          } else {
            if (event.data.payload) {
              observer.next(common_1.deserialize(event.data.payload));
            }
            if (event.data.complete) {
              observer.complete();
              worker2.removeEventListener("message", messageHandler);
            }
          }
        } else if (isJobErrorMessage(event.data)) {
          const error3 = common_1.deserialize(event.data.error);
          if (asyncType === "promise" || !asyncType) {
            observer.error(error3);
          } else {
            observer.error(error3);
          }
          worker2.removeEventListener("message", messageHandler);
        }
      };
      worker2.addEventListener("message", messageHandler);
      return () => {
        if (asyncType === "observable" || !asyncType) {
          const cancelMessage = {
            type: messages_1.MasterMessageType.cancel,
            uid: jobUID
          };
          worker2.postMessage(cancelMessage);
        }
        worker2.removeEventListener("message", messageHandler);
      };
    });
  }
  function prepareArguments(rawArgs) {
    if (rawArgs.length === 0) {
      return {
        args: [],
        transferables: []
      };
    }
    const args = [];
    const transferables = [];
    for (const arg of rawArgs) {
      if (transferable_1.isTransferDescriptor(arg)) {
        args.push(common_1.serialize(arg.send));
        transferables.push(...arg.transferables);
      } else {
        args.push(common_1.serialize(arg));
      }
    }
    return {
      args,
      transferables: transferables.length === 0 ? transferables : dedupe2(transferables)
    };
  }
  function createProxyFunction(worker2, method) {
    return (...rawArgs) => {
      const uid = nextJobUID++;
      const { args, transferables } = prepareArguments(rawArgs);
      const runMessage = {
        type: messages_1.MasterMessageType.run,
        uid,
        method,
        args
      };
      debugMessages("Sending command to run function to worker:", runMessage);
      try {
        worker2.postMessage(runMessage, transferables);
      } catch (error3) {
        return observable_promise_1.ObservablePromise.from(Promise.reject(error3));
      }
      return observable_promise_1.ObservablePromise.from(observable_fns_1.multicast(createObservableForJob(worker2, uid)));
    };
  }
  invocationProxy.createProxyFunction = createProxyFunction;
  function createProxyModule(worker2, methodNames) {
    const proxy = {};
    for (const methodName of methodNames) {
      proxy[methodName] = createProxyFunction(worker2, methodName);
    }
    return proxy;
  }
  invocationProxy.createProxyModule = createProxyModule;
  return invocationProxy;
}
var hasRequiredSpawn;
function requireSpawn() {
  if (hasRequiredSpawn) return spawn$1;
  hasRequiredSpawn = 1;
  var define_process_env_default = {};
  var __awaiter2 = spawn$1 && spawn$1.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = spawn$1 && spawn$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(spawn$1, "__esModule", { value: true });
  spawn$1.spawn = void 0;
  const debug_1 = __importDefault2(requireBrowser$e());
  const observable_fns_1 = require$$1$4;
  const common_1 = /* @__PURE__ */ requireCommon$3();
  const promise_1 = /* @__PURE__ */ requirePromise();
  const symbols_1 = /* @__PURE__ */ requireSymbols();
  const master_1 = /* @__PURE__ */ requireMaster$1();
  const invocation_proxy_1 = /* @__PURE__ */ requireInvocationProxy();
  const debugMessages = debug_1.default("threads:master:messages");
  const debugSpawn = debug_1.default("threads:master:spawn");
  const debugThreadUtils = debug_1.default("threads:master:thread-utils");
  const isInitMessage = (data) => data && data.type === "init";
  const isUncaughtErrorMessage = (data) => data && data.type === "uncaughtError";
  const initMessageTimeout = typeof process$1 !== "undefined" && define_process_env_default.THREADS_WORKER_INIT_TIMEOUT ? Number.parseInt(define_process_env_default.THREADS_WORKER_INIT_TIMEOUT, 10) : 1e4;
  function withTimeout(promise2, timeoutInMs, errorMessage) {
    return __awaiter2(this, void 0, void 0, function* () {
      let timeoutHandle;
      const timeout = new Promise((resolve2, reject) => {
        timeoutHandle = setTimeout(() => reject(Error(errorMessage)), timeoutInMs);
      });
      const result = yield Promise.race([
        promise2,
        timeout
      ]);
      clearTimeout(timeoutHandle);
      return result;
    });
  }
  function receiveInitMessage(worker2) {
    return new Promise((resolve2, reject) => {
      const messageHandler = (event) => {
        debugMessages("Message from worker before finishing initialization:", event.data);
        if (isInitMessage(event.data)) {
          worker2.removeEventListener("message", messageHandler);
          resolve2(event.data);
        } else if (isUncaughtErrorMessage(event.data)) {
          worker2.removeEventListener("message", messageHandler);
          reject(common_1.deserialize(event.data.error));
        }
      };
      worker2.addEventListener("message", messageHandler);
    });
  }
  function createEventObservable(worker2, workerTermination) {
    return new observable_fns_1.Observable((observer) => {
      const messageHandler = (messageEvent) => {
        const workerEvent = {
          type: master_1.WorkerEventType.message,
          data: messageEvent.data
        };
        observer.next(workerEvent);
      };
      const rejectionHandler = (errorEvent) => {
        debugThreadUtils("Unhandled promise rejection event in thread:", errorEvent);
        const workerEvent = {
          type: master_1.WorkerEventType.internalError,
          error: Error(errorEvent.reason)
        };
        observer.next(workerEvent);
      };
      worker2.addEventListener("message", messageHandler);
      worker2.addEventListener("unhandledrejection", rejectionHandler);
      workerTermination.then(() => {
        const terminationEvent = {
          type: master_1.WorkerEventType.termination
        };
        worker2.removeEventListener("message", messageHandler);
        worker2.removeEventListener("unhandledrejection", rejectionHandler);
        observer.next(terminationEvent);
        observer.complete();
      });
    });
  }
  function createTerminator(worker2) {
    const [termination, resolver] = promise_1.createPromiseWithResolver();
    const terminate = () => __awaiter2(this, void 0, void 0, function* () {
      debugThreadUtils("Terminating worker");
      yield worker2.terminate();
      resolver();
    });
    return { terminate, termination };
  }
  function setPrivateThreadProps(raw, worker2, workerEvents, terminate) {
    const workerErrors = workerEvents.filter((event) => event.type === master_1.WorkerEventType.internalError).map((errorEvent) => errorEvent.error);
    return Object.assign(raw, {
      [symbols_1.$errors]: workerErrors,
      [symbols_1.$events]: workerEvents,
      [symbols_1.$terminate]: terminate,
      [symbols_1.$worker]: worker2
    });
  }
  function spawn2(worker2, options2) {
    return __awaiter2(this, void 0, void 0, function* () {
      debugSpawn("Initializing new thread");
      const timeout = options2 && options2.timeout ? options2.timeout : initMessageTimeout;
      const initMessage = yield withTimeout(receiveInitMessage(worker2), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);
      const exposed = initMessage.exposed;
      const { termination, terminate } = createTerminator(worker2);
      const events2 = createEventObservable(worker2, termination);
      if (exposed.type === "function") {
        const proxy = invocation_proxy_1.createProxyFunction(worker2);
        return setPrivateThreadProps(proxy, worker2, events2, terminate);
      } else if (exposed.type === "module") {
        const proxy = invocation_proxy_1.createProxyModule(worker2, exposed.methods);
        return setPrivateThreadProps(proxy, worker2, events2, terminate);
      } else {
        const type2 = exposed.type;
        throw Error(`Worker init message states unexpected type of expose(): ${type2}`);
      }
    });
  }
  spawn$1.spawn = spawn2;
  return spawn$1;
}
var hasRequiredMaster;
function requireMaster() {
  if (hasRequiredMaster) return master$1;
  hasRequiredMaster = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Worker = exports2.BlobWorker = exports2.isWorkerRuntime = exports2.Thread = exports2.spawn = exports2.Pool = void 0;
    const implementation_1 = /* @__PURE__ */ requireImplementation_browser$1();
    Object.defineProperty(exports2, "isWorkerRuntime", { enumerable: true, get: function() {
      return implementation_1.isWorkerRuntime;
    } });
    var pool_1 = /* @__PURE__ */ requirePool();
    Object.defineProperty(exports2, "Pool", { enumerable: true, get: function() {
      return pool_1.Pool;
    } });
    var spawn_1 = /* @__PURE__ */ requireSpawn();
    Object.defineProperty(exports2, "spawn", { enumerable: true, get: function() {
      return spawn_1.spawn;
    } });
    var thread_1 = /* @__PURE__ */ requireThread();
    Object.defineProperty(exports2, "Thread", { enumerable: true, get: function() {
      return thread_1.Thread;
    } });
    exports2.BlobWorker = implementation_1.getWorkerImplementation().blob;
    exports2.Worker = implementation_1.getWorkerImplementation().default;
  })(master$1);
  return master$1;
}
var hasRequiredRegister;
function requireRegister() {
  if (hasRequiredRegister) return register;
  hasRequiredRegister = 1;
  Object.defineProperty(register, "__esModule", { value: true });
  const index_1 = /* @__PURE__ */ requireMaster();
  if (typeof commonjsGlobal !== "undefined") {
    commonjsGlobal.Worker = index_1.Worker;
  } else if (typeof window !== "undefined") {
    window.Worker = index_1.Worker;
  }
  return register;
}
requireRegister();
var dist$1 = {};
var worker = {};
var isObservable$1;
var hasRequiredIsObservable;
function requireIsObservable() {
  if (hasRequiredIsObservable) return isObservable$1;
  hasRequiredIsObservable = 1;
  isObservable$1 = (value) => {
    if (!value) {
      return false;
    }
    if (typeof Symbol.observable === "symbol" && typeof value[Symbol.observable] === "function") {
      return value === value[Symbol.observable]();
    }
    if (typeof value["@@observable"] === "function") {
      return value === value["@@observable"]();
    }
    return false;
  };
  return isObservable$1;
}
var implementation_browser = {};
var hasRequiredImplementation_browser;
function requireImplementation_browser() {
  if (hasRequiredImplementation_browser) return implementation_browser;
  hasRequiredImplementation_browser = 1;
  Object.defineProperty(implementation_browser, "__esModule", { value: true });
  const isWorkerRuntime = function isWorkerRuntime2() {
    const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
    return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
  };
  const postMessageToMaster = function postMessageToMaster2(data, transferList) {
    self.postMessage(data, transferList);
  };
  const subscribeToMasterMessages = function subscribeToMasterMessages2(onMessage) {
    const messageHandler = (messageEvent) => {
      onMessage(messageEvent.data);
    };
    const unsubscribe2 = () => {
      self.removeEventListener("message", messageHandler);
    };
    self.addEventListener("message", messageHandler);
    return unsubscribe2;
  };
  implementation_browser.default = {
    isWorkerRuntime,
    postMessageToMaster,
    subscribeToMasterMessages
  };
  return implementation_browser;
}
var hasRequiredWorker;
function requireWorker() {
  if (hasRequiredWorker) return worker;
  hasRequiredWorker = 1;
  (function(exports2) {
    var __awaiter2 = worker && worker.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = worker && worker.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expose = exports2.isWorkerRuntime = exports2.Transfer = exports2.registerSerializer = void 0;
    const is_observable_1 = __importDefault2(requireIsObservable());
    const common_1 = /* @__PURE__ */ requireCommon$3();
    const transferable_1 = /* @__PURE__ */ requireTransferable();
    const messages_1 = /* @__PURE__ */ requireMessages();
    const implementation_1 = __importDefault2(/* @__PURE__ */ requireImplementation_browser());
    var common_2 = /* @__PURE__ */ requireCommon$3();
    Object.defineProperty(exports2, "registerSerializer", { enumerable: true, get: function() {
      return common_2.registerSerializer;
    } });
    var transferable_2 = /* @__PURE__ */ requireTransferable();
    Object.defineProperty(exports2, "Transfer", { enumerable: true, get: function() {
      return transferable_2.Transfer;
    } });
    exports2.isWorkerRuntime = implementation_1.default.isWorkerRuntime;
    let exposeCalled = false;
    const activeSubscriptions = /* @__PURE__ */ new Map();
    const isMasterJobCancelMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.cancel;
    const isMasterJobRunMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.run;
    const isObservable2 = (thing) => is_observable_1.default(thing) || isZenObservable(thing);
    function isZenObservable(thing) {
      return thing && typeof thing === "object" && typeof thing.subscribe === "function";
    }
    function deconstructTransfer(thing) {
      return transferable_1.isTransferDescriptor(thing) ? { payload: thing.send, transferables: thing.transferables } : { payload: thing, transferables: void 0 };
    }
    function postFunctionInitMessage() {
      const initMessage = {
        type: messages_1.WorkerMessageType.init,
        exposed: {
          type: "function"
        }
      };
      implementation_1.default.postMessageToMaster(initMessage);
    }
    function postModuleInitMessage(methodNames) {
      const initMessage = {
        type: messages_1.WorkerMessageType.init,
        exposed: {
          type: "module",
          methods: methodNames
        }
      };
      implementation_1.default.postMessageToMaster(initMessage);
    }
    function postJobErrorMessage(uid, rawError) {
      const { payload: error3, transferables } = deconstructTransfer(rawError);
      const errorMessage = {
        type: messages_1.WorkerMessageType.error,
        uid,
        error: common_1.serialize(error3)
      };
      implementation_1.default.postMessageToMaster(errorMessage, transferables);
    }
    function postJobResultMessage(uid, completed, resultValue) {
      const { payload, transferables } = deconstructTransfer(resultValue);
      const resultMessage = {
        type: messages_1.WorkerMessageType.result,
        uid,
        complete: completed ? true : void 0,
        payload
      };
      implementation_1.default.postMessageToMaster(resultMessage, transferables);
    }
    function postJobStartMessage(uid, resultType) {
      const startMessage = {
        type: messages_1.WorkerMessageType.running,
        uid,
        resultType
      };
      implementation_1.default.postMessageToMaster(startMessage);
    }
    function postUncaughtErrorMessage(error3) {
      try {
        const errorMessage = {
          type: messages_1.WorkerMessageType.uncaughtError,
          error: common_1.serialize(error3)
        };
        implementation_1.default.postMessageToMaster(errorMessage);
      } catch (subError) {
        console.error("Not reporting uncaught error back to master thread as it occured while reporting an uncaught error already.\nLatest error:", subError, "\nOriginal error:", error3);
      }
    }
    function runFunction(jobUID, fn, args) {
      return __awaiter2(this, void 0, void 0, function* () {
        let syncResult;
        try {
          syncResult = fn(...args);
        } catch (error3) {
          return postJobErrorMessage(jobUID, error3);
        }
        const resultType = isObservable2(syncResult) ? "observable" : "promise";
        postJobStartMessage(jobUID, resultType);
        if (isObservable2(syncResult)) {
          const subscription = syncResult.subscribe((value) => postJobResultMessage(jobUID, false, common_1.serialize(value)), (error3) => {
            postJobErrorMessage(jobUID, common_1.serialize(error3));
            activeSubscriptions.delete(jobUID);
          }, () => {
            postJobResultMessage(jobUID, true);
            activeSubscriptions.delete(jobUID);
          });
          activeSubscriptions.set(jobUID, subscription);
        } else {
          try {
            const result = yield syncResult;
            postJobResultMessage(jobUID, true, common_1.serialize(result));
          } catch (error3) {
            postJobErrorMessage(jobUID, common_1.serialize(error3));
          }
        }
      });
    }
    function expose(exposed) {
      if (!implementation_1.default.isWorkerRuntime()) {
        throw Error("expose() called in the master thread.");
      }
      if (exposeCalled) {
        throw Error("expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.");
      }
      exposeCalled = true;
      if (typeof exposed === "function") {
        implementation_1.default.subscribeToMasterMessages((messageData) => {
          if (isMasterJobRunMessage(messageData) && !messageData.method) {
            runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));
          }
        });
        postFunctionInitMessage();
      } else if (typeof exposed === "object" && exposed) {
        implementation_1.default.subscribeToMasterMessages((messageData) => {
          if (isMasterJobRunMessage(messageData) && messageData.method) {
            runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));
          }
        });
        const methodNames = Object.keys(exposed).filter((key2) => typeof exposed[key2] === "function");
        postModuleInitMessage(methodNames);
      } else {
        throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);
      }
      implementation_1.default.subscribeToMasterMessages((messageData) => {
        if (isMasterJobCancelMessage(messageData)) {
          const jobUID = messageData.uid;
          const subscription = activeSubscriptions.get(jobUID);
          if (subscription) {
            subscription.unsubscribe();
            activeSubscriptions.delete(jobUID);
          }
        }
      });
    }
    exports2.expose = expose;
    if (typeof self !== "undefined" && typeof self.addEventListener === "function" && implementation_1.default.isWorkerRuntime()) {
      self.addEventListener("error", (event) => {
        setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);
      });
      self.addEventListener("unhandledrejection", (event) => {
        const error3 = event.reason;
        if (error3 && typeof error3.message === "string") {
          setTimeout(() => postUncaughtErrorMessage(error3), 250);
        }
      });
    }
    if (typeof process$1 !== "undefined" && typeof process$1.on === "function" && implementation_1.default.isWorkerRuntime()) {
      process$1.on("uncaughtException", (error3) => {
        setTimeout(() => postUncaughtErrorMessage(error3), 250);
      });
      process$1.on("unhandledRejection", (error3) => {
        if (error3 && typeof error3.message === "string") {
          setTimeout(() => postUncaughtErrorMessage(error3), 250);
        }
      });
    }
  })(worker);
  return worker;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$1;
  hasRequiredDist$1 = 1;
  (function(exports2) {
    var __createBinding2 = dist$1 && dist$1.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = dist$1 && dist$1.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transfer = exports2.DefaultSerializer = exports2.expose = exports2.registerSerializer = void 0;
    var common_1 = /* @__PURE__ */ requireCommon$3();
    Object.defineProperty(exports2, "registerSerializer", { enumerable: true, get: function() {
      return common_1.registerSerializer;
    } });
    __exportStar2(/* @__PURE__ */ requireMaster(), exports2);
    var index_1 = requireWorker();
    Object.defineProperty(exports2, "expose", { enumerable: true, get: function() {
      return index_1.expose;
    } });
    var serializers_1 = /* @__PURE__ */ requireSerializers();
    Object.defineProperty(exports2, "DefaultSerializer", { enumerable: true, get: function() {
      return serializers_1.DefaultSerializer;
    } });
    var transferable_1 = /* @__PURE__ */ requireTransferable();
    Object.defineProperty(exports2, "Transfer", { enumerable: true, get: function() {
      return transferable_1.Transfer;
    } });
  })(dist$1);
  return dist$1;
}
var distExports = /* @__PURE__ */ requireDist$1();
const Threads = /* @__PURE__ */ getDefaultExportFromCjs$1(distExports);
const registerSerializer = Threads.registerSerializer;
const spawn = Threads.spawn;
Threads.BlobWorker;
Threads.DefaultSerializer;
Threads.Pool;
Threads.Thread;
Threads.Transfer;
Threads.Worker;
var lodash_isarguments;
var hasRequiredLodash_isarguments;
function requireLodash_isarguments() {
  if (hasRequiredLodash_isarguments) return lodash_isarguments;
  hasRequiredLodash_isarguments = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  function isArguments2(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  lodash_isarguments = isArguments2;
  return lodash_isarguments;
}
var lodash_isarray;
var hasRequiredLodash_isarray;
function requireLodash_isarray() {
  if (hasRequiredLodash_isarray) return lodash_isarray;
  hasRequiredLodash_isarray = 1;
  var arrayTag = "[object Array]", funcTag = "[object Function]";
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  var objectProto = Object.prototype;
  var fnToString = Function.prototype.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var nativeIsArray = getNative(Array, "isArray");
  var MAX_SAFE_INTEGER = 9007199254740991;
  function getNative(object, key2) {
    var value = object == null ? void 0 : object[key2];
    return isNative(value) ? value : void 0;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  var isArray2 = nativeIsArray || function(value) {
    return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
  };
  function isFunction2(value) {
    return isObject2(value) && objToString.call(value) == funcTag;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function isNative(value) {
    if (value == null) {
      return false;
    }
    if (isFunction2(value)) {
      return reIsNative.test(fnToString.call(value));
    }
    return isObjectLike(value) && reIsHostCtor.test(value);
  }
  lodash_isarray = isArray2;
  return lodash_isarray;
}
var lodash__baseflatten;
var hasRequiredLodash__baseflatten;
function requireLodash__baseflatten() {
  if (hasRequiredLodash__baseflatten) return lodash__baseflatten;
  hasRequiredLodash__baseflatten = 1;
  var isArguments2 = requireLodash_isarguments(), isArray2 = requireLodash_isarray();
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function arrayPush(array2, values2) {
    var index2 = -1, length = values2.length, offset = array2.length;
    while (++index2 < length) {
      array2[offset + index2] = values2[index2];
    }
    return array2;
  }
  function baseFlatten(array2, isDeep, isStrict, result) {
    result || (result = []);
    var index2 = -1, length = array2.length;
    while (++index2 < length) {
      var value = array2[index2];
      if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray2(value) || isArguments2(value))) {
        if (isDeep) {
          baseFlatten(value, isDeep, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function baseProperty(key2) {
    return function(object) {
      return object == null ? void 0 : object[key2];
    };
  }
  var getLength = baseProperty("length");
  function isArrayLike(value) {
    return value != null && isLength(getLength(value));
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  lodash__baseflatten = baseFlatten;
  return lodash__baseflatten;
}
var lodash__bindcallback;
var hasRequiredLodash__bindcallback;
function requireLodash__bindcallback() {
  if (hasRequiredLodash__bindcallback) return lodash__bindcallback;
  hasRequiredLodash__bindcallback = 1;
  function bindCallback(func, thisArg, argCount) {
    if (typeof func != "function") {
      return identity;
    }
    if (thisArg === void 0) {
      return func;
    }
    switch (argCount) {
      case 1:
        return function(value) {
          return func.call(thisArg, value);
        };
      case 3:
        return function(value, index2, collection) {
          return func.call(thisArg, value, index2, collection);
        };
      case 4:
        return function(accumulator, value, index2, collection) {
          return func.call(thisArg, accumulator, value, index2, collection);
        };
      case 5:
        return function(value, other, key2, object, source) {
          return func.call(thisArg, value, other, key2, object, source);
        };
    }
    return function() {
      return func.apply(thisArg, arguments);
    };
  }
  function identity(value) {
    return value;
  }
  lodash__bindcallback = bindCallback;
  return lodash__bindcallback;
}
var lodash__pickbyarray;
var hasRequiredLodash__pickbyarray;
function requireLodash__pickbyarray() {
  if (hasRequiredLodash__pickbyarray) return lodash__pickbyarray;
  hasRequiredLodash__pickbyarray = 1;
  function pickByArray(object, props) {
    object = toObject(object);
    var index2 = -1, length = props.length, result = {};
    while (++index2 < length) {
      var key2 = props[index2];
      if (key2 in object) {
        result[key2] = object[key2];
      }
    }
    return result;
  }
  function toObject(value) {
    return isObject2(value) ? value : Object(value);
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  lodash__pickbyarray = pickByArray;
  return lodash__pickbyarray;
}
var lodash__basefor;
var hasRequiredLodash__basefor;
function requireLodash__basefor() {
  if (hasRequiredLodash__basefor) return lodash__basefor;
  hasRequiredLodash__basefor = 1;
  var baseFor = createBaseFor();
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key2 = props[++index2];
        if (iteratee(iterable[key2], key2, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  lodash__basefor = baseFor;
  return lodash__basefor;
}
var lodash_keysin;
var hasRequiredLodash_keysin;
function requireLodash_keysin() {
  if (hasRequiredLodash_keysin) return lodash_keysin;
  hasRequiredLodash_keysin = 1;
  var isArguments2 = requireLodash_isarguments(), isArray2 = requireLodash_isarray();
  var reIsUint = /^\d+$/;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isIndex(value, length) {
    value = typeof value == "number" || reIsUint.test(value) ? +value : -1;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return value > -1 && value % 1 == 0 && value < length;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function keysIn(object) {
    if (object == null) {
      return [];
    }
    if (!isObject2(object)) {
      object = Object(object);
    }
    var length = object.length;
    length = length && isLength(length) && (isArray2(object) || isArguments2(object)) && length || 0;
    var Ctor = object.constructor, index2 = -1, isProto = typeof Ctor == "function" && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0;
    while (++index2 < length) {
      result[index2] = index2 + "";
    }
    for (var key2 in object) {
      if (!(skipIndexes && isIndex(key2, length)) && !(key2 == "constructor" && (isProto || !hasOwnProperty.call(object, key2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  lodash_keysin = keysIn;
  return lodash_keysin;
}
var lodash__pickbycallback;
var hasRequiredLodash__pickbycallback;
function requireLodash__pickbycallback() {
  if (hasRequiredLodash__pickbycallback) return lodash__pickbycallback;
  hasRequiredLodash__pickbycallback = 1;
  var baseFor = requireLodash__basefor(), keysIn = requireLodash_keysin();
  function baseForIn(object, iteratee) {
    return baseFor(object, iteratee, keysIn);
  }
  function pickByCallback(object, predicate) {
    var result = {};
    baseForIn(object, function(value, key2, object2) {
      if (predicate(value, key2, object2)) {
        result[key2] = value;
      }
    });
    return result;
  }
  lodash__pickbycallback = pickByCallback;
  return lodash__pickbycallback;
}
var lodash_restparam;
var hasRequiredLodash_restparam;
function requireLodash_restparam() {
  if (hasRequiredLodash_restparam) return lodash_restparam;
  hasRequiredLodash_restparam = 1;
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max;
  function restParam(func, start) {
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    start = nativeMax(start === void 0 ? func.length - 1 : +start || 0, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), rest = Array(length);
      while (++index2 < length) {
        rest[index2] = args[start + index2];
      }
      switch (start) {
        case 0:
          return func.call(this, rest);
        case 1:
          return func.call(this, args[0], rest);
        case 2:
          return func.call(this, args[0], args[1], rest);
      }
      var otherArgs = Array(start + 1);
      index2 = -1;
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = rest;
      return func.apply(this, otherArgs);
    };
  }
  lodash_restparam = restParam;
  return lodash_restparam;
}
var lodash_pick;
var hasRequiredLodash_pick;
function requireLodash_pick() {
  if (hasRequiredLodash_pick) return lodash_pick;
  hasRequiredLodash_pick = 1;
  var baseFlatten = requireLodash__baseflatten(), bindCallback = requireLodash__bindcallback(), pickByArray = requireLodash__pickbyarray(), pickByCallback = requireLodash__pickbycallback(), restParam = requireLodash_restparam();
  var pick2 = restParam(function(object, props) {
    if (object == null) {
      return {};
    }
    return typeof props[0] == "function" ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
  });
  lodash_pick = pick2;
  return lodash_pick;
}
var lodash_pickExports = requireLodash_pick();
const pick = /* @__PURE__ */ getDefaultExportFromCjs$1(lodash_pickExports);
function CustomError(name, message, extras) {
  const error3 = Object.assign(Error(message), {
    ...extras,
    __extraProps: Object.keys(extras || {}),
    name
  });
  return error3;
}
CustomError.deserialize = function deserializeCustomError(error3) {
  return Object.assign(CustomError(error3.name, error3.message, pick(error3, error3.__extraProps || [])), {
    stack: error3.stack
  });
};
CustomError.serialize = function serializeCustomError(error3) {
  return {
    ...pick(error3, error3.__extraProps),
    __extraProps: error3.__extraProps,
    __type: "$$CustomError",
    message: error3.message,
    name: error3.name,
    stack: error3.stack
  };
};
CustomError.isCustomError = function isCustomError(thing) {
  return thing && thing instanceof Error && "__extraProps" in thing;
};
function isSerializedCustomError(thing) {
  return thing && typeof thing === "object" && "__type" in thing && thing.__type === "$$CustomError";
}
const CustomErrorSerializer = {
  deserialize(message, defaultHandler) {
    return isSerializedCustomError(message) ? CustomError.deserialize(message) : defaultHandler(message);
  },
  serialize(thing, defaultHandler) {
    return CustomError.isCustomError(thing) ? CustomError.serialize(thing) : defaultHandler(thing);
  }
};
function WrongPasswordError(message = "Wrong password.") {
  return Object.assign(new Error(message), { name: "WrongPasswordError" });
}
function isWrongPasswordError(error3) {
  return error3 && error3.name === "WrongPasswordError";
}
function toKebabCase(value) {
  return value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
}
function getErrorTranslation(error3, t2) {
  var _a;
  const key2 = `generic.error.${toKebabCase(error3.name)}`;
  const params = CustomError.isCustomError(error3) ? pick(error3, error3.__extraProps || []) : void 0;
  let prefix2 = "";
  if (params && params["status"] && String(params["status"]).startsWith("5")) {
    prefix2 = t2("generic.error.submission-error.prefix.server-error");
    prefix2 += ": ";
  }
  const fallback = ((_a = error3.message) == null ? void 0 : _a.message) || error3.message;
  try {
    return prefix2 + t2([key2, fallback], params);
  } catch (e) {
    return prefix2 + fallback;
  }
}
function renderFormFieldError(error3, t2) {
  if (error3) {
    return error3 instanceof Error ? getErrorTranslation(error3, t2) : error3.message;
  } else {
    return error3;
  }
}
const netWorker$1 = new Worker(new URL(
  /* @vite-ignore */
  "/net-worker-h-vBGrTB.js",
  import.meta.url
), { type: "module" });
registerSerializer(CustomErrorSerializer);
async function spawnNetWorker() {
  window.addEventListener("message", (event) => {
    if (event.data && ["app:pause", "app:resume"].indexOf(event.data) > -1) {
      netWorker$1.postMessage(event.data);
    }
  });
  const worker2 = await spawn(netWorker$1);
  await worker2.enableLogging(localStorage.getItem("debug") || "");
  return worker2;
}
async function spawnWorkers() {
  return {
    netWorker: await spawnNetWorker()
  };
}
const workers = spawnWorkers();
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
function toPrimitive$1(t2, r) {
  if ("object" != _typeof$2(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
function toPropertyKey$1(t2) {
  var i2 = toPrimitive$1(t2, "string");
  return "symbol" == _typeof$2(i2) ? i2 : i2 + "";
}
function _defineProperty$1(e, r, t2) {
  return (r = toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t2, e;
}
function _objectSpread$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? Object(arguments[r]) : {}, o = Object.keys(t2);
    "function" == typeof Object.getOwnPropertySymbols && o.push.apply(o, Object.getOwnPropertySymbols(t2).filter(function(e2) {
      return Object.getOwnPropertyDescriptor(t2, e2).enumerable;
    })), o.forEach(function(r2) {
      _defineProperty$1(e, r2, t2[r2]);
    });
  }
  return e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t2 = 0; t2 < r.length; t2++) {
    var o = r[t2];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey$1(o.key), o);
  }
}
function _createClass(e, r, t2) {
  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _possibleConstructorReturn(t2, e) {
  if (e && ("object" == _typeof$2(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t2);
}
function _getPrototypeOf(t2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, _getPrototypeOf(t2);
}
function _setPrototypeOf(t2, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
    return t3.__proto__ = e2, t3;
  }, _setPrototypeOf(t2, e);
}
function _inherits(t2, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t2,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t2, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t2, e);
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _iterableToArrayLimit(r, l) {
  var t2 = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t2) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t2 = t2.call(r)).next, 0 === l) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e = i2.call(t2)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t2["return"] && (u = t2["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error2(args) {
    this.output("error", args);
  },
  output: function output(type2, args) {
    var _console;
    if (console && console[type2]) (_console = console)[type2].apply(_console, _toConsumableArray(args));
  }
};
var Logger = /* @__PURE__ */ function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options2);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init2(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options2;
      this.debug = options2.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool2) {
      this.debug = bool2;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error3() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix2, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === "string") args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create4(moduleName) {
      return new Logger2(this.logger, _objectSpread$2({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }, this.options));
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = /* @__PURE__ */ function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on(events2, listener) {
      var _this = this;
      events2.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event]) return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise2 = new Promise(function(resolve2, reject) {
    res = resolve2;
    rej = reject;
  });
  promise2.resolve = res;
  promise2.reject = rej;
  return promise2;
}
function makeString(object) {
  if (object == null) return "";
  return "" + object;
}
function copy(a, s, t2) {
  a.forEach(function(m) {
    if (s[m]) t2[m] = s[m];
  });
}
function getLastOfPath(object, path2, Empty) {
  function cleanKey(key3) {
    return key3 && key3.indexOf("###") > -1 ? key3.replace(/###/g, ".") : key3;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key2 = cleanKey(stack.shift());
    if (!object[key2] && Empty) object[key2] = new Empty();
    object = object[key2];
  }
  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path2, newValue) {
  var _getLastOfPath = getLastOfPath(object, path2, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath(object, path2, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path2, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
}
function getPath$3(object, path2) {
  var _getLastOfPath3 = getLastOfPath(object, path2), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj) return void 0;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key2) {
  var value = getPath$3(data, key2);
  if (value !== void 0) {
    return value;
  }
  return getPath$3(defaultData, key2);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop in target) {
      if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
        if (overwrite) target[prop] = source[prop];
      } else {
        deepExtend(target[prop], source[prop], overwrite);
      }
    } else {
      target[prop] = source[prop];
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape$2(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data;
}
var ResourceStore = /* @__PURE__ */ function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  function ResourceStore2(data) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore2).call(this));
    EventEmitter.call(_assertThisInitialized(_this));
    _this.data = data || {};
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns2) {
      if (this.options.ns.indexOf(ns2) < 0) {
        this.options.ns.push(ns2);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns2) {
      var index2 = this.options.ns.indexOf(ns2);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns2, key2) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var path2 = [lng, ns2];
      if (key2 && typeof key2 !== "string") path2 = path2.concat(key2);
      if (key2 && typeof key2 === "string") path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
      }
      return getPath$3(this.data, path2);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns2, key2, value) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0) keySeparator = ".";
      var path2 = [lng, ns2];
      if (key2) path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        value = ns2;
        ns2 = path2[1];
      }
      this.addNamespaces(ns2);
      setPath(this.data, path2, value);
      if (!options2.silent) this.emit("added", lng, ns2, key2, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns2, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m in resources) {
        if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]") this.addResource(lng, ns2, m, resources[m], {
          silent: true
        });
      }
      if (!options2.silent) this.emit("added", lng, ns2, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns2, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path2 = [lng, ns2];
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        deep = resources;
        resources = ns2;
        ns2 = path2[1];
      }
      this.addNamespaces(ns2);
      var pack = getPath$3(this.data, path2) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$2({}, pack, resources);
      }
      setPath(this.data, path2, pack);
      if (!options2.silent) this.emit("added", lng, ns2, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns2) {
      if (this.hasResourceBundle(lng, ns2)) {
        delete this.data[lng][ns2];
      }
      this.removeNamespaces(ns2);
      this.emit("removed", lng, ns2);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns2) {
      return this.getResource(lng, ns2) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns2) {
      if (!ns2) ns2 = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1") return _objectSpread$2({}, {}, this.getResource(lng, ns2));
      return this.getResource(lng, ns2);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key2, options2, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key2, options2, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = /* @__PURE__ */ function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  function Translator2(services) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator2).call(this));
    EventEmitter.call(_assertThisInitialized(_this));
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key2) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var resolved = this.resolve(key2, options2);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key2, options2) {
      var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
      if (nsSeparator === void 0) nsSeparator = ":";
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var namespaces = options2.ns || this.options.defaultNS;
      if (nsSeparator && key2.indexOf(nsSeparator) > -1) {
        var parts = key2.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key2 = parts.join(keySeparator);
      }
      if (typeof namespaces === "string") namespaces = [namespaces];
      return {
        key: key2,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys2, options2) {
      var _this2 = this;
      if (_typeof$2(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
        options2 = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options2) options2 = {};
      if (keys2 === void 0 || keys2 === null) return "";
      if (!Array.isArray(keys2)) keys2 = [String(keys2)];
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys2[keys2.length - 1], options2), key2 = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options2.lng || this.language;
      var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key2;
        }
        return key2;
      }
      var resolved = this.resolve(keys2, options2);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key2;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key2;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options2) : "key '".concat(key2, " (").concat(this.language, ")' returned an object instead of string.");
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy$$1 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy$$1[m] = this.translate(deepKey, _objectSpread$2({}, options2, {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy$$1[m] === deepKey) copy$$1[m] = res[m];
            }
          }
          res = copy$$1;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys2, options2);
      } else {
        var usedDefault = false;
        var usedKey = false;
        if (!this.isValidLookup(res) && options2.defaultValue !== void 0) {
          usedDefault = true;
          if (options2.count !== void 0) {
            var suffix = this.pluralResolver.getSuffix(lng, options2.count);
            res = options2["defaultValue".concat(suffix)];
          }
          if (!res) res = options2.defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key2;
        }
        var updateMissing = options2.defaultValue && options2.defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key2, updateMissing ? options2.defaultValue : res);
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
          } else {
            lngs.push(options2.lng || this.language);
          }
          var send = function send2(l, k) {
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options2.defaultValue : res, updateMissing, options2);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options2.defaultValue : res, updateMissing, options2);
            }
            _this2.emit("missingKey", l, namespace, k, res);
          };
          if (this.options.saveMissing) {
            var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(l) {
                var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key2);
                plurals.forEach(function(p) {
                  return send([l], p);
                });
              });
            } else {
              send(lngs, key2);
            }
          }
        }
        res = this.extendTranslation(res, keys2, options2, resolved);
        if (usedKey && res === key2 && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key2);
        if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key2, options2, resolved) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, options2, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options2.skipInterpolation) {
        if (options2.interpolation) this.interpolator.init(_objectSpread$2({}, options2, {
          interpolation: _objectSpread$2({}, this.options.interpolation, options2.interpolation)
        }));
        var data = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables) data = _objectSpread$2({}, this.options.interpolation.defaultVariables, data);
        res = this.interpolator.interpolate(res, data, options2.lng || this.language, options2);
        if (options2.nest !== false) res = this.interpolator.nest(res, function() {
          return _this3.translate.apply(_this3, arguments);
        }, options2);
        if (options2.interpolation) this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key2, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options2) : options2, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve2(keys2) {
      var _this4 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys2 === "string") keys2 = [keys2];
      keys2.forEach(function(k) {
        if (_this4.isValidLookup(found)) return;
        var extracted = _this4.extractFromKey(k, options2);
        var key2 = extracted.key;
        usedKey = key2;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var needsContextHandling = options2.context !== void 0 && typeof options2.context === "string" && options2.context !== "";
        var codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
        namespaces.forEach(function(ns2) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns2;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for namespace "').concat(usedNS, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace was not yet loaded`), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code2) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code2;
            var finalKey = key2;
            var finalKeys = [finalKey];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key2, code2, ns2, options2);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code2, options2.count);
              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);
              if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options2.context));
              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code2, ns2, possibleKey, options2);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code2, ns2, key2) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code2, ns2, key2, options2);
      return this.resourceStore.getResource(code2, ns2, key2, options2);
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize$1(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var LanguageUtil = /* @__PURE__ */ function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options2;
    this.whitelist = this.options.whitelist || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0) return null;
      var p = code2.split("-");
      if (p.length === 2) return null;
      p.pop();
      return this.formatLanguageCode(p.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0) return code2;
      var p = code2.split("-");
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code2) {
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p = code2.split("-");
        if (this.options.lowerCaseLng) {
          p = p.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize$1(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase();
          if (p[1].length === 2) p[1] = p[1].toUpperCase();
          if (p[0] !== "sgn" && p[2].length === 2) p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize$1(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize$1(p[2].toLowerCase());
        }
        return p.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
    }
  }, {
    key: "isWhitelisted",
    value: function isWhitelisted(code2) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitWhitelist) {
        code2 = this.getLanguagePartFromCode(code2);
      }
      return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code2) > -1;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code2) {
      if (!fallbacks) return [];
      if (typeof fallbacks === "string") fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]") return fallbacks;
      if (!code2) return fallbacks["default"] || [];
      var found = fallbacks[code2];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code2)];
      if (!found) found = fallbacks[this.formatLanguageCode(code2)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code2, fallbackCode) {
      var _this = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
      var codes = [];
      var addCode = function addCode2(c) {
        if (!c) return;
        if (_this.isWhitelisted(c)) {
          codes.push(c);
        } else {
          _this.logger.warn("rejecting non-whitelisted language code: ".concat(c));
        }
      };
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code2));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code2));
        if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code2));
      } else if (typeof code2 === "string") {
        addCode(this.formatLanguageCode(code2));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _2(n) {
    return Number(n != 1);
  },
  3: function _3(n) {
    return 0;
  },
  4: function _4(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n) {
    return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _7(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _9(n) {
    return Number(n >= 2);
  },
  10: function _10(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _11(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _12(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _13(n) {
    return Number(n !== 0);
  },
  14: function _14(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _15(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _17(n) {
    return Number(n == 1 || n % 10 == 1 ? 0 : 1);
  },
  18: function _18(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _19(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _20(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _21(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _22(n) {
    return Number(n === 1 ? 0 : n === 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
function createRules() {
  var rules = {};
  sets.forEach(function(set3) {
    set3.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set3.nr,
        plurals: _rulesPluralsTypes[set3.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = /* @__PURE__ */ function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code2) {
      return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code2) {
      var rule = this.getRule(code2);
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code2, key2) {
      var _this = this;
      var ret = [];
      var rule = this.getRule(code2);
      if (!rule) return ret;
      rule.numbers.forEach(function(n) {
        var suffix = _this.getSuffix(code2, n);
        ret.push("".concat(key2).concat(suffix));
      });
      return ret;
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code2, count) {
      var _this2 = this;
      var rule = this.getRule(code2);
      if (rule) {
        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = "plural";
          } else if (suffix === 1) {
            suffix = "";
          }
        }
        var returnSuffix = function returnSuffix2() {
          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
        };
        if (this.options.compatibilityJSON === "v1") {
          if (suffix === 1) return "";
          if (typeof suffix === "number") return "_plural_".concat(suffix.toString());
          return returnSuffix();
        } else if (
          /* v2 */
          this.options.compatibilityJSON === "v2"
        ) {
          return returnSuffix();
        } else if (
          /* v3 - gettext index */
          this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1
        ) {
          return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }
      this.logger.warn("no plural rule found for: ".concat(code2));
      return "";
    }
  }]);
  return PluralResolver2;
}();
var Interpolator = /* @__PURE__ */ function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    };
    this.init(options2);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init2() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options2.interpolation) options2.interpolation = {
        escapeValue: true
      };
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape$2;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options2) {
      var _this = this;
      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key2) {
        if (key2.indexOf(_this.formatSeparator) < 0) {
          var path2 = getPathWithDefaults(data, defaultData, key2);
          return _this.alwaysFormat ? _this.format(path2, void 0, lng) : path2;
        }
        var p = key2.split(_this.formatSeparator);
        var k = p.shift().trim();
        var f = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, options2);
      };
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
      replaces = 0;
      while (match = this.regexpUnescape.exec(str)) {
        value = handleFormat(match[1].trim());
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            var temp = missingInterpolationHandler(str, match, options2);
            value = typeof temp === "string" ? temp : "";
          } else {
            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
            value = "";
          }
        } else if (typeof value !== "string" && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        str = str.replace(match[0], regexSafe(value));
        this.regexpUnescape.lastIndex = 0;
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
      replaces = 0;
      while (match = this.regexp.exec(str)) {
        value = handleFormat(match[1].trim());
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            var _temp = missingInterpolationHandler(str, match, options2);
            value = typeof _temp === "string" ? _temp : "";
          } else {
            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
            value = "";
          }
        } else if (typeof value !== "string" && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match;
      var value;
      var clonedOptions = _objectSpread$2({}, options2);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key2, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key2.indexOf(sep) < 0) return key2;
        var c = key2.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key2 = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread$2({}, inheritedOptions, clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key2), e);
          return "".concat(key2).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key2;
      }
      while (match = this.nestingRegexp.exec(str)) {
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string") return value;
        if (typeof value !== "string") value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = "";
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function remove(arr2, what) {
  var found = arr2.indexOf(what);
  while (found !== -1) {
    arr2.splice(found, 1);
    found = arr2.indexOf(what);
  }
}
var Connector = /* @__PURE__ */ function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  function Connector2(backend, store, services) {
    var _this;
    var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector2).call(this));
    EventEmitter.call(_assertThisInitialized(_this));
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options2;
    _this.logger = baseLogger.create("backendConnector");
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options2.backend, options2);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options2, callback) {
      var _this2 = this;
      var toLoad = [];
      var pending = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns2) {
          var name = "".concat(lng, "|").concat(ns2);
          if (!options2.reload && _this2.store.hasResourceBundle(lng, ns2)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0) ;
          else if (_this2.state[name] === 1) {
            if (pending.indexOf(name) < 0) pending.push(name);
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending.indexOf(name) < 0) pending.push(name);
            if (toLoad.indexOf(name) < 0) toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns2) < 0) toLoadNamespaces.push(ns2);
          }
        });
        if (!hasAllNamespaces) toLoadLanguages.push(lng);
      });
      if (toLoad.length || pending.length) {
        this.queue.push({
          pending,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad,
        pending,
        toLoadLanguages,
        toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var _name$split = name.split("|"), _name$split2 = _slicedToArray(_name$split, 2), lng = _name$split2[0], ns2 = _name$split2[1];
      if (err) this.emit("failedLoading", lng, ns2, err);
      if (data) {
        this.store.addResourceBundle(lng, ns2, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q) {
        pushPath(q.loaded, [lng], ns2);
        remove(q.pending, name);
        if (err) q.errors.push(err);
        if (q.pending.length === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function(l) {
            if (!loaded2[l]) loaded2[l] = [];
            if (q.loaded[l].length) {
              q.loaded[l].forEach(function(ns3) {
                if (loaded2[l].indexOf(ns3) < 0) loaded2[l].push(ns3);
              });
            }
          });
          q.done = true;
          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns2, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 250;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length) return callback(null, {});
      return this.backend[fcName](lng, ns2, function(err, data) {
        if (err && data && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns2, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      });
    }
    /* eslint consistent-return: 0 */
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string") languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string") namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options2, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var _name$split3 = name.split("|"), _name$split4 = _slicedToArray(_name$split3, 2), lng = _name$split4[0], ns2 = _name$split4[1];
      this.read(lng, ns2, "read", void 0, void 0, function(err, data) {
        if (err) _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns2, " for language ").concat(lng, " failed"), err);
        if (!err && data) _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns2, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key2, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key2, '" for namespace "').concat(namespace, '" as the namespace was not yet loaded'), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key2 === void 0 || key2 === null || key2 === "") return;
      if (this.backend && this.backend.create) {
        this.backend.create(
          languages,
          namespace,
          key2,
          fallbackValue,
          null,
          _objectSpread$2({}, options2, {
            isUpdate
          })
        );
      }
      if (!languages || !languages[0]) return;
      this.store.addResource(languages[0], namespace, key2, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get$2() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    // string or array of namespaces
    whitelist: false,
    // array with whitelisted languages
    nonExplicitWhitelist: false,
    load: "all",
    // | currentOnly | languageOnly
    preload: false,
    // array with preload languages
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    // allow bundling certain languages that are not remotely fetched
    saveMissing: false,
    // enable to send missing values
    updateMissing: false,
    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
    saveMissingTo: "fallback",
    // 'current' || 'all'
    saveMissingPlurals: true,
    // will save all forms not only singular key
    missingKeyHandler: false,
    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
    missingInterpolationHandler: false,
    // function(str, match)
    postProcess: false,
    // string or array of postProcessor names
    postProcessPassResolved: false,
    // pass resolved object into 'options.i18nResolved' for postprocessor
    returnNull: true,
    // allows null value as valid translation
    returnEmptyString: true,
    // allows empty string value as valid translation
    returnObjects: false,
    joinArrays: false,
    // or string to join array
    returnedObjectHandler: false,
    // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: false,
    // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof$2(args[1]) === "object") ret = args[1];
      if (typeof args[1] === "string") ret.defaultValue = args[1];
      if (typeof args[2] === "string") ret.tDescription = args[2];
      if (_typeof$2(args[2]) === "object" || _typeof$2(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key2) {
          ret[key2] = options2[key2];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options2) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
      maxReplaces: 1e3
      // max replaces to prevent endless loop
    }
  };
}
function transformOptions(options2) {
  if (typeof options2.ns === "string") options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string") options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string") options2.fallbackNS = [options2.fallbackNS];
  if (options2.whitelist && options2.whitelist.indexOf("cimode") < 0) {
    options2.whitelist = options2.whitelist.concat(["cimode"]);
  }
  return options2;
}
function noop$2() {
}
var I18n = /* @__PURE__ */ function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  function I18n2() {
    var _this;
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n2).call(this));
    EventEmitter.call(_assertThisInitialized(_this));
    _this.options = transformOptions(options2);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    if (callback && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options2, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options2, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init2() {
      var _this2 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      this.options = _objectSpread$2({}, get$2(), this.options, transformOptions(options2));
      this.format = this.options.interpolation.format;
      if (!callback) callback = noop$2;
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === "function") return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m) {
          if (m.init) m.init(_this2);
        });
      }
      if (!this.modules.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "addResource", "addResources", "addResourceBundle", "removeResourceBundle", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var deferred = defer();
      var load = function load2() {
        _this2.changeLanguage(_this2.options.lng, function(err, t2) {
          _this2.isInitialized = true;
          _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t2);
          callback(err, t2);
        });
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
    /* eslint consistent-return: 0 */
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$2;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function") usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode") return usedCallback();
        var toLoad = [];
        var append = function append2(lng) {
          if (!lng) return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l) {
            return append(l);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns2, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns2) ns2 = this.options.ns;
      if (!callback) callback = noop$2;
      this.services.backendConnector.reload(lngs, ns2, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var done = function done2(err, l) {
        if (l) {
          _this4.language = l;
          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          _this4.translator.changeLanguage(l);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l);
          _this4.logger.log("languageChanged", l);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err, function() {
          return _this4.t.apply(_this4, arguments);
        });
      };
      var setLng = function setLng2(l) {
        if (l) {
          if (!_this4.language) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          }
          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
        }
        _this4.loadResources(l, function(err) {
          done(err, l);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns2) {
      var _this5 = this;
      var fixedT = function fixedT2(key2, opts) {
        var options2;
        if (_typeof$2(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options2 = _this5.options.overloadTranslationOptionHandler([key2, opts].concat(rest));
        } else {
          options2 = _objectSpread$2({}, opts);
        }
        options2.lng = options2.lng || fixedT2.lng;
        options2.lngs = options2.lngs || fixedT2.lngs;
        options2.ns = options2.ns || fixedT2.ns;
        return _this5.t(key2, options2);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns2;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t2() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns2) {
      this.options.defaultNS = ns2;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns2) {
      var _this6 = this;
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode") return true;
      var loadNotPending = function loadNotPending2(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
        return loadState === -1 || loadState === 2;
      };
      if (this.hasResourceBundle(lng, ns2)) return true;
      if (!this.services.backendConnector.backend) return true;
      if (loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns2, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns2 === "string") ns2 = [ns2];
      ns2.forEach(function(n) {
        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string") lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
      if (!lng) return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
    }
    /* eslint class-methods-use-this: 0 */
  }, {
    key: "createInstance",
    value: function createInstance() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      return new I18n2(options2, callback);
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$2;
      var mergedOptions = _objectSpread$2({}, this.options, options2, {
        isClone: true
      });
      var clone = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m) {
        clone[m] = _this8[m];
      });
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options;
      return clone;
    }
  }]);
  return I18n2;
}(EventEmitter);
var i18next = new I18n();
var arr = [];
var each$1 = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each$1.call(slice.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var cookie = {
  create: function create2(name, value, minutes, domain) {
    var expires;
    if (minutes) {
      var date = /* @__PURE__ */ new Date();
      date.setTime(date.getTime() + minutes * 60 * 1e3);
      expires = "; expires=" + date.toGMTString();
    } else expires = "";
    domain = domain ? "domain=" + domain + ";" : "";
    document.cookie = name + "=" + value + expires + ";" + domain + "path=/";
  },
  read: function read(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(";");
    for (var i2 = 0; i2 < ca.length; i2++) {
      var c = ca[i2];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove: function remove2(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup2(options2) {
    var found;
    if (options2.lookupCookie && typeof document !== "undefined") {
      var c = cookie.read(options2.lookupCookie);
      if (c) found = c;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options2) {
    if (options2.lookupCookie && typeof document !== "undefined") {
      cookie.create(options2.lookupCookie, lng, options2.cookieMinutes, options2.cookieDomain);
    }
  }
};
var querystring$1 = {
  name: "querystring",
  lookup: function lookup3(options2) {
    var found;
    if (typeof window !== "undefined") {
      var query = window.location.search.substring(1);
      var params = query.split("&");
      for (var i2 = 0; i2 < params.length; i2++) {
        var pos = params[i2].indexOf("=");
        if (pos > 0) {
          var key2 = params[i2].substring(0, pos);
          if (key2 === options2.lookupQuerystring) {
            found = params[i2].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport;
try {
  hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
  var testKey = "i18next.translate.boo";
  window.localStorage.setItem(testKey, "foo");
  window.localStorage.removeItem(testKey);
} catch (e) {
  hasLocalStorageSupport = false;
}
var localStorage$1 = {
  name: "localStorage",
  lookup: function lookup4(options2) {
    var found;
    if (options2.lookupLocalStorage && hasLocalStorageSupport) {
      var lng = window.localStorage.getItem(options2.lookupLocalStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options2) {
    if (options2.lookupLocalStorage && hasLocalStorageSupport) {
      window.localStorage.setItem(options2.lookupLocalStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup5(options2) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i2 = 0; i2 < navigator.languages.length; i2++) {
          found.push(navigator.languages[i2]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup6(options2) {
    var found;
    var htmlTag2 = options2.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  lookup: function lookup7(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options2.lookupFromPathIndex === "number") {
          if (typeof language[options2.lookupFromPathIndex] !== "string") {
            return void 0;
          }
          found = language[options2.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup8(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
      if (language instanceof Array) {
        if (typeof options2.lookupFromSubdomainIndex === "number") {
          found = language[options2.lookupFromSubdomainIndex].replace("http://", "").replace("https://", "").replace(".", "");
        } else {
          found = language[0].replace("http://", "").replace("https://", "").replace(".", "");
        }
      }
    }
    return found;
  }
};
function getDefaults$1() {
  return {
    order: ["querystring", "cookie", "localStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    //cookieMinutes: 10,
    //cookieDomain: 'myDomain'
    checkWhitelist: true
  };
}
var Browser = /* @__PURE__ */ function() {
  function Browser2(services) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options2);
  }
  _createClass(Browser2, [{
    key: "init",
    value: function init2(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options2, this.options || {}, getDefaults$1());
      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring$1);
      this.addDetector(localStorage$1);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder) detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup9 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup9 && typeof lookup9 === "string") lookup9 = [lookup9];
          if (lookup9) detected = detected.concat(lookup9);
        }
      });
      var found;
      detected.forEach(function(lng) {
        if (found) return;
        var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
        if (!_this.options.checkWhitelist || _this.services.languageUtils.isWhitelisted(cleanedLng)) found = cleanedLng;
      });
      if (!found) {
        var fallbacks = this.i18nOptions.fallbackLng;
        if (typeof fallbacks === "string") fallbacks = [fallbacks];
        if (!fallbacks) fallbacks = [];
        if (Object.prototype.toString.apply(fallbacks) === "[object Array]") {
          found = fallbacks[0];
        } else {
          found = fallbacks[0] || fallbacks["default"] && fallbacks["default"][0];
        }
      }
      return found;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage3(lng, caches) {
      var _this2 = this;
      if (!caches) caches = this.options.caches;
      if (!caches) return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
      caches.forEach(function(cacheName) {
        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);
  return Browser2;
}();
Browser.type = "languageDetector";
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t2 = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t2[n] = r[n];
  }
  return t2;
}
function _objectWithoutProperties(e, t2) {
  if (null == e) return {};
  var o, r, i2 = _objectWithoutPropertiesLoose(e, t2);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i2[o] = e[o]);
  }
  return i2;
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z && a[z] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D = {};
  function E(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
  };
  E.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a, b, e) {
    var d, c = {}, k = null, h = null;
    if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c.children = e;
    else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
      c.children = f;
    }
    if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
    return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
  }
  function N(a, b) {
    return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l;
  }
  function escape2(a) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b[a2];
    });
  }
  var P2 = /\/+/g;
  function Q(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
  }
  function R(a, b, e, d, c) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h = false;
    if (null === a) h = true;
    else switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l:
          case n:
            h = true;
        }
    }
    if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P2, "$&/") + "/"), R(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P2, "$&/") + "/") + a)), b.push(c)), 1;
    h = 0;
    d = "" === d ? "." : d + ":";
    if (I(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = d + Q(k, g);
      h += R(k, b, e, f, c);
    }
    else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
    else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h;
  }
  function S(a, b, e) {
    if (null == a) return a;
    var d = [], c = 0;
    R(a, d, "", "", function(a2) {
      return b.call(e, a2, c++);
    });
    return d;
  }
  function T(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      b.then(function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
      }, function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
      });
      -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a, b, e) {
    S(a, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a) {
    var b = 0;
    S(a, function() {
      b++;
    });
    return b;
  }, toArray: function(a) {
    return S(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p;
  react_production_min.Profiler = r;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a, b, e) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h = K.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;
    else if (1 < f) {
      g = Array(f);
      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
      d.children = g;
    }
    return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t2, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a) {
    var b = M.bind(null, a);
    b.type = a;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v, render: a };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a) {
    return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
  };
  react_production_min.memo = function(a, b) {
    return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a) {
    var b = V.transition;
    V.transition = {};
    try {
      a();
    } finally {
      V.transition = b;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a, b) {
    return U.current.useCallback(a, b);
  };
  react_production_min.useContext = function(a) {
    return U.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b) {
    return U.current.useEffect(a, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b, e) {
    return U.current.useImperativeHandle(a, b, e);
  };
  react_production_min.useInsertionEffect = function(a, b) {
    return U.current.useInsertionEffect(a, b);
  };
  react_production_min.useLayoutEffect = function(a, b) {
    return U.current.useLayoutEffect(a, b);
  };
  react_production_min.useMemo = function(a, b) {
    return U.current.useMemo(a, b);
  };
  react_production_min.useReducer = function(a, b, e) {
    return U.current.useReducer(a, b, e);
  };
  react_production_min.useRef = function(a) {
    return U.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b, e) {
    return U.current.useSyncExternalStore(a, b, e);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs$1(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key2) {
        _defineProperty$1(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
var defaultOptions$1 = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true
};
var i18nInstance;
var I18nContext = React.createContext();
function setDefaults() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions$1 = _objectSpread$1(_objectSpread$1({}, defaultOptions$1), options2);
}
function getDefaults() {
  return defaultOptions$1;
}
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    _classCallCheck(this, ReportNamespaces2);
    this.usedNamespaces = {};
  }
  _createClass(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns2) {
        if (!_this.usedNamespaces[ns2]) _this.usedNamespaces[ns2] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);
  return ReportNamespaces2;
}();
function setI18n(instance) {
  i18nInstance = instance;
}
function getI18n() {
  return i18nInstance;
}
var initReactI18next = {
  type: "3rdParty",
  init: function init(instance) {
    setDefaults(instance.options.react);
    setI18n(instance);
  }
};
function warn() {
  if (console && console.warn) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string") args[0] = "react-i18next:: ".concat(args[0]);
    (_console = console).warn.apply(_console, args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]]) return;
  if (typeof args[0] === "string") alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn.apply(void 0, args);
}
function loadNamespaces(i18n, ns2, cb) {
  i18n.loadNamespaces(ns2, function() {
    if (i18n.isInitialized) {
      cb();
    } else {
      var initialized = function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0);
        cb();
      };
      i18n.on("initialized", initialized);
    }
  });
}
function hasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  var lng = i18n.languages[0];
  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  var lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode") return true;
  var loadNotPending = function loadNotPending2(l, n) {
    var loadState = i18n.services.backendConnector.state["".concat(l, "|").concat(n)];
    return loadState === -1 || loadState === 2;
  };
  if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns2)) return false;
  if (i18n.hasResourceBundle(lng, ns2)) return true;
  if (!i18n.services.backendConnector.backend) return true;
  if (loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2))) return true;
  return false;
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty$1(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
function useTranslation(ns2) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var i18nFromProps = props.i18n;
  var _ref3 = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref3.i18n, defaultNSFromContext = _ref3.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = function notReadyT2(k) {
      return Array.isArray(k) ? k[k.length - 1] : k;
    };
    var retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0) warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread(_objectSpread(_objectSpread({}, getDefaults()), i18n.options.react), props);
  var useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix;
  var namespaces = ns2 || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces) i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n) {
    return hasLoadedNamespace(n, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  var _useState = reactExports.useState(getT), _useState2 = _slicedToArray(_useState, 2), t2 = _useState2[0], setT = _useState2[1];
  var isMounted = reactExports.useRef(true);
  reactExports.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      loadNamespaces(i18n, namespaces, function() {
        if (isMounted.current) setT(getT);
      });
    }
    function boundReset() {
      if (isMounted.current) setT(getT);
    }
    if (bindI18n && i18n) i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n) i18n.store.on(bindI18nStore, boundReset);
    return function() {
      isMounted.current = false;
      if (bindI18n && i18n) bindI18n.split(" ").forEach(function(e) {
        return i18n.off(e, boundReset);
      });
      if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach(function(e) {
        return i18n.store.off(e, boundReset);
      });
    };
  }, [i18n, namespaces.join()]);
  var isInitial = reactExports.useRef(true);
  reactExports.useEffect(function() {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n]);
  var ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready) return ret;
  if (!ready && !useSuspense) return ret;
  throw new Promise(function(resolve2) {
    loadNamespaces(i18n, namespaces, function() {
      resolve2();
    });
  });
}
var _excluded = ["ns", "children"];
function Translation(props) {
  var ns2 = props.ns, children = props.children, options2 = _objectWithoutProperties(props, _excluded);
  var _useTranslation = useTranslation(ns2, options2), _useTranslation2 = _slicedToArray(_useTranslation, 3), t2 = _useTranslation2[0], i18n = _useTranslation2[1], ready = _useTranslation2[2];
  return children(t2, {
    i18n,
    lng: i18n.language
  }, ready);
}
const settings$7 = { "delete-account": { "text": { "primary": "Merge or Remove Account" } }, "export-secret-key": { "text": { "primary": "Export Secret Key", "secondary": "Decrypt and show secret key" } }, "multi-sig": { "text": { "primary": "Multi-Signature", "secondary": { "cosigner-of": "This account is cosigner of", "short": "Manage co-signers", "long": "Make account multi-signature and manage co-signers" } } }, "set-password": { "text": { "primary": { "account-protected": "Change Password", "account-not-protected": "Set Password" }, "secondary": { "account-protected": "Your account is secure, protected by a password", "account-not-protected": "Your account is not protected" } } } };
const AccountSettings$3 = {
  "account-deletion": { "action": { "cancel": "Cancel", "confirm": "Confirm", "delete": "Remove", "merge": { "long": "Merge into", "short": "Merge" } }, "confirm": { "title": "Confirm deletion", "text": { "confirm": "Are you sure?", "delete": "The account will be deleted", "merge": "and the remaining funds transferred" } }, "remaining-funds": { "text": "Send remaining funds to" }, "text": { "1": 'Are you sure you want to remove the account "{{accountName}}" from Sunce? You can still use it elsewhere if you save the secret key.', "2": " Make sure to backup your secret key or merge the funds into another account of yours, since there are still funds left!" }, "title": "Confirm Account Removal", "warning-dialog": { "close": { "label": "OK" } }, "warnings": { "cannot-merge": { "text": "Cannot merge account yet. First you need to cancel all open trading orders and remove all assets.", "title": "Manual action required" } } },
  "custom-trustline": { "action": { "cancel": "Cancel", "trust": { "long": "Trust Asset", "short": "Trust" } }, "textfield": { "code": { "label": "Code" }, "issuer": { "label": "Issuer", "placeholder": "Issuing account public key" }, "limit": { "label": "Limit (optional)", "placeholder": "Limit trust in this asset / maximum balance to hold" } }, "title": "Add Custom Asset" },
  "export-key": { "action": { "confirm": "Done", "reveal": { "long": "Reveal key", "short": "Click to reveal secret key" } }, "info": { "backup": { "title": "Back up your secret key now", "paragraph-1": "The secret key backup is the only way to recover your funds if you forget your password or cannot access your device anymore.", "paragraph-2": "Write down the key or print it. Keep it in a safe place and do not share it with anyone." }, "export": { "paragraph-1": "The secret key backup is the only way to recover your funds if you forget your password or cannot access your device anymore.", "paragraph-2": "Write down the key or print it. Keep it in a safe place and do not share it with anyone." }, "secret-key": "Write down the key on paper and store it in a safe place.", "tap-to-copy": "Tap to copy" }, "textfield": { "password": { "label": "Password" } }, "title": { "default": "Export Secret Key", "initial-backup": "Secret Key Backup" } },
  "manage-signers": { "action": { "add-signer": "Add Signer", "apply": { "long": "Apply changes", "short": "Apply" }, "cancel": "Cancel", "proceed": "Proceed" }, "preset-description": { "m-out-of-n": "Add or remove signers from the account. Any single signature will authorize transactions.", "m-out-of-n_plural": "Add or remove signers from the account. {{ count }} signatures will authorize transactions.", "one-out-of-n": "Add or remove signers from the account. Any single signer can authorize transactions.", "single-signature": "Choose the key that should be the account's single signer." }, "preset-description-extra": { "m-out-of-n": "Go to 'Add Account' > 'Join Account' in the co-signing Sunce Wallet to create a new co-signer's key.", "one-out-of-n": "Go to 'Add Account' > 'Join Account' in the co-signing Sunce Wallet to create a new co-signer's key." }, "preset-selector": { "options": { "m-out-of-n": { "primary": "Collective signing", "secondary": "Multiple signers have to sign a transaction." }, "one-out-of-n": { "primary": "Backup keys", "secondary": "Every signer can sign transactions by themself." }, "single-signature": { "primary": "Single signature", "secondary": "No co-signers. Just one key pair." } }, "title": "Choose how your account should work" }, "signers-editor": { "list": { "item": { "weight": "Weight", "local-key": "Local key" } }, "new-signer": { "label": "Public Key or Stellar Address", "placeholder": { "long": "GABC… or address", "short": "GABCDEFGHIJK… or alice*example.org" } }, "threshold": { "primary": "Required signatures", "secondary": "No. of signatures to authorize transactions" }, "validation": { "existing-signer": "Cannot add existing signer.", "integer-required": "Must be an integer.", "invalid-stellar-address": "Expected a public key or stellar address." } }, "title": { "long": "Manage Signers", "short": "Manage Account Signers" }, "validation": { "no-signers": "No signers left. Don't lock yourself out!", "invalid-weight-type": "Weight must be an integer", "threshold-higher-than-weights": "Threshold higher than combined key weights", "no-threshold": "Please set a threshold" } },
  "set-password": { "action": { "change-password": { "long": "Change password", "short": "Change" }, "remove-password": { "long": "Remove password", "short": "Remove" } }, "notification": { "password-changed": "Password changed.", "password-set": "Password set.", "password-removed": "Password removed." }, "textfield": { "prev-password": { "label": "Current password" }, "next-password": { "label": "New password" }, "next-password-repeat": { "label": "Repeat new password" } }, "title": { "change-password": "Change Password", "set-password": "Set Password" }, "validation": { "next-password-missing": 'Enter a password or set "remove password".', "next-password-repeat-missing": "Please repeat the password.", "passwords-no-match": "Password does not match", "previous-password-missing": "Current password is missing." } },
  settings: settings$7
};
const action$b = { "receive": "Receive", "send": "Send" };
const cosigner$1 = { "not-cosigner-yet": { "label": "Your public key:", "note": "Your key is not yet a signer of the account. Please ask the account owner to add you." } };
const transactions$3 = { "action": { "friendbot": { "description": "Get some free testnet lumens", "label": "Ask the friendbot" }, "navigate-to-deposit": { "description": "Via credit card, bank transfer, etc.", "label": "Deposit funds" } }, "offer-list": { "text": { "buy": "Buy <1 /> for <3 />", "sell": "Sell <1 /> for <3 />", "for": "for" }, "title": "Open orders" }, "transaction-list": { "offer-description": { "prefix": { "default": "Order", "cancel": "Cancel order", "update": "Update order" }, "buy": "Buy {{buyingAmount}} {{buyingCode}} for {{sellingAmount}} {{sellingCode}} ", "sell": "Sell {{sellingAmount}} {{sellingCode}} for {{buyingAmount}} {{buyingCode}}" }, "item": { "from": "From", "to": "To", "memo": "Memo", "remote-public-keys": { "more": "more" }, "trust": { "add-trust": "Trust asset {{asset}}", "remove-trust": "Remove trust in asset {{asset}}" } }, "load-more": { "label": "Load more" }, "title": "Recent transactions" }, "signature-request-list": { "title": { "requests-to-cosign": "Transactions to co-sign", "requests-waiting-for-others": "Awaiting additional signatures" } } };
const title$f = { "password-status": { "protected": "Password protected", "unprotected": "No password" }, "tooltip": { "multi-sig-account": "Multi-Signature Account", "security-service": "{{service}} Protection" }, "placeholder": "Account name…", "testnet": "Testnet" };
const Account$3 = {
  action: action$b,
  "add-asset": { "action": { "add-asset": "Add asset to account", "remove": "Remove", "trade": "Trade" }, "button": { "add-custom-asset": { "label": "Add Custom Asset" } }, "item": { "issuer": { "secondary": { "one-asset": "One matching asset", "more-than-one-asset": "{{amount}} matching assets" } }, "no-result": { "primary": "No matching asset", "secondary": "No asset or issuer matches your search" } }, "search-field": { "placeholder": "Search assets by code or name…" }, "title": "Add Asset" },
  "asset-details": { "lumen": { "description": { "label": "Description", "text": "The native token of the Stellar network.\n\n Every account on the network has a lumens balance. Lumens are used to pay transaction fees." } }, "general": { "account-flags": { "auth-required": "Authorization by issuer required", "auth-not-required": "No authorization required", "auth-revocable": "Authorization revocable", "auth-not-revocable": "Authorization not revocable", "auth-immutable": "These flags are immutable", "auth-mutable": "Issuer can change these flags", "label": "Account flags" }, "anchor-asset": { "label": "Anchored to" }, "conditions": { "label": "Conditions" }, "description": { "label": "Description" }, "issuing-account": { "label": "Issuing account" }, "organisation": { "address": { "label": "Address" }, "dba": { "label": "Doing business as" }, "description": { "label": "Description" }, "email": { "label": "Email address" }, "name": { "label": "Organization name" }, "phone-number": { "label": "Phone number" }, "website": { "label": "Website" } }, "redemption-instructions": { "label": "Redemption instructions" } } },
  "balance-details": { "button": { "add-asset": { "label": "Add Asset To Your Account" } }, "item": { "spendable-balance": { "primary": "Spendable balance" } }, "spendable-balances": { "base-reserve": { "primary": "Base reserve", "secondary": "Fixed base reserve" }, "data-reserve": { "primary": "Data fields reserve", "secondary": "Account data fields" }, "headline": "Amounts in XLM", "open-orders-reserve": { "primary": "Open orders reserve", "secondary": "Reserve per order" }, "selling-liabilities": { "primary": "Amount to be sold", "secondary": "Committed to open orders" }, "signers-reserve": { "primary": "Account signers reserve", "secondary": { "single-key": "Single key reserve", "multiple-keys": "Master key + co-signers" } }, "spendable-balance": { "primary": "Spendable balance", "secondary": "Freely usable amount" }, "total-balance": { "primary": "Total balance", "secondary": "Your balance, incl. unspendable" }, "trustline-reserve": { "primary": "Trustlines reserve", "secondary": "For each non-XLM balance" } } },
  "saved-addresses": { "title": "Saved Addresses", "search-field": { "placeholder": "Search name or address…" }, "item": { "no-result": { "primary": "No matching record", "secondary": "No name or address matches your search" } }, "button": { "add": { "label": "Add Address" } } },
  "saved-address-details": { "address": { "label": "Address", "placeholder": "Address" }, "label": { "label": "Label", "placeholder": "Label" }, "validation": { "no-address": "Address is missing", "no-label": "Label is missing", "label-too-long": "Label is too long. Consider {{max}} characters max", "invalid-address": "Address is invalid" }, "button": { "add": { "label": "Save" }, "remove": { "label": "Remove" } } },
  "context-menu": { "account-settings": { "label": "Account Settings" }, "assets-and-balances": { "label": "Assets & Balances" }, "deposit": { "label": "Add funds" }, "trade": { "label": "Trade" }, "transactions": { "label": "Transactions" }, "withdraw": { "label": "Withdraw" }, "saved-addresses": { "label": "Saved Addresses" } },
  cosigner: cosigner$1,
  "purchase-lumens": { "legal-confirmation": { "action": { "confirm": "I understand" } }, "moonpay": { "text": { "primary": "MoonPay", "secondary": "Buy Stellar Lumens instantly using your debit/credit card or Apple Pay" }, "legal-confirmation": " You will be redirected to moonpay.io, a third-party service. The depositing process is operated by Moon Pay Ltd, not by Sunce or Montelibero. <1 /> <2 /> Please contact the moonpay.io support for inquiries related to your deposit." }, "title": "Buy Stellar lumens" },
  "remove-trustline": { "action": { "cancel": "Cancel", "remove": "Remove" }, "text": { "warning": "You cannot remove this asset unless the asset's balance is zero.", "info": 'You are about to remove <1>{{asset}}</1> from account "{{accountName}}".' }, "title": "Confirm Removing Asset" },
  transactions: transactions$3,
  "transaction-review": { "action": { "confirm": "Confirm", "cancel-order": "Cancel order", "dismiss": "Dismiss", "inspect": "Inspect", "show-more": "Show more details" }, "account-creation-warning": { "primary": "Funding a new account", "secondary": "Funding an empty account. Make sure that the destination is correct." }, "add-signer-warning": { "primary": "Adding another signer", "secondary": "Make sure you are adding the right co-signer. Adding an unknown key might lock your account forever." }, "dangerous-transaction-warning": { "primary": "Transaction initiated by unrecognized account", "secondary": "Please review carefully. In case of doubt, prefer dismissing." }, "dismissal": { "action": { "cancel": "Cancel", "confirm": "Confirm" }, "header": "Dismiss pending multi-signature transaction?", "title": "Confirm" }, "signers": { "heading-details": { "single-signature": "Single signature", "default-signatures": "{{threshold}} of {{length}} multi-signature", "custom-consensus": "Custom consensus multi-signature" }, "label": "Signers {{details}}" }, "signer-status": { "tooltip": { "has-signed": "Has signed the transaction", "has-not-signed": "Awaiting their signature" } }, "summary": { "item": { "account": { "label": "Account" }, "authenticating-account": { "label": "Authenticating Account" }, "expiry": { "label": "Expiry" }, "max-fee": { "label": "Maximum fee" }, "service": { "label": "Service" }, "submission": { "label": "Submission" }, "tx-hash": { "label": "Transaction Hash" } } }, "textfield": { "password": { "label": "Password" } }, "title": { "transaction": "Transaction", "payment": "Payment", "delete-orders-operation": "Delete Trading Orders", "web-auth": "Web Authentication" }, "transaction-memo": { "label": "{{type}} Memo" }, "validation": { "no-account-data": "Invariant violation: Cannot find the transaction source account's account data in set of account data subscriptions.", "no-manage-data-operation": "Invariant violation: Stellar web auth transaction must contain a manage_data operation.", "password-required": "Password required" } },
  title: title$f
};
const notification$3 = { "desktop": { "new-signature-request": { "title": "New transaction to co-sign", "body": "From {{signersHavingSigned}}" }, "received-payment": { "title": "Received payment | {{account}}", "body": "Received {{amount}} {{assetCode}}" }, "trade-completed": { "title": "Trade completed | {{account}}" } }, "details": { "action": { "dismiss": "Dismiss" }, "support": "Having an issue with the app? <1/> Contact us via", "title": "Error", "offline": "Offline" }, "permission": { "app-notification": { "error": "Enable in operating system settings", "granted": { "title": "Notifications enabled", "text": "Sunce Wallet will now show notifications" }, "message": "Enable app notifications" }, "protocol-handler": { "error": "Could not register Sunce as default handler.", "message": "Do you want Sunce to handle interactive Stellar links on this computer (recommended)?", "success": "Successfully registered Sunce as default handler.", "tooltip": { "dismiss": "Dismiss", "install": "Install" } } } };
const App$4 = {
  "account-list": { "add-account-card": { "label": "Add account" }, "badges": { "tooltip": { "multi-sig": "Multi-Signature Account", "security-service": "{{service}} Protection" } } },
  "all-accounts": { "switch": { "label": "Testnet" }, "update": { "notification": { "start": "Starting download of update...", "success": "Download is ready and will be installed on next restart!" }, "tooltip": "Update available" }, "title": { "testnet": "Testnet Accounts", "mainnet": "My Accounts" } },
  notification: notification$3,
  "terms-and-conditions": { "action": { "confirm": "Confirm" }, "header": "Welcome to Sunce Wallet", "checkbox": { "1": { "label": "I understand that I am responsible for the safety of my funds and that Sunce Wallet is not able to recover my funds in case of data loss or if I lose my credentials." }, "2": { "label": "I have read, understood and agree to the <1>Terms and Conditions</1> <2>&amp;</2> <3>Privacy policy</3> of Sunce Wallet." } } }
};
const settings$6 = { "biometric-lock": { "text": { "primary": { "default": "Fingerprint lock", "ios": "Face ID / Touch ID" }, "secondary": { "disabled": "Biometric authentication is disabled", "enabled": "Biometric authentication is enabled", "not-enrolled": "Configure biometric authentication in your operating system settings" } }, "prompt": { "enable": "Unlock your device once to enable the feature.", "disable": "Unlock your device to disable the auto-lock." } }, "language": { "auto-detect": { "label": "auto" }, "text": { "primary": "Language", "secondary": "Change the user interface language here" } }, "memo": { "text": { "primary": "Show Memos", "secondary": { "hidden": "Memos are hidden in the transaction overview", "shown": "Memos are shown in the transaction overview" } } }, "multi-sig": { "text": { "primary": "Enable Multi-Signature", "secondary": { "enabled": "Multi-Signature features are enabled", "disabled": "Multi-Signature features are disabled" } } }, "protocol-handler": { "text": { "primary": "Handle Stellar protocol requests", "secondary": { "default": "Sunce is handling all Stellar links", "non-default": "Make Sunce handle all Stellar URIs" } } }, "testnet": { "text": { "primary": "Show Testnet Accounts", "secondary": { "cannot-disable": "Cannot be disabled because you already added testnet accounts", "hidden": "Testnet accounts are hidden", "shown": "Testnet accounts are shown" } } }, "title": "Settings", "trusted-services": { "text": { "primary": "Manage Trusted Services", "secondary": "Remove Trusted Services" } }, "saved-addresses-export": { "text": { "primary": "Import/Export Saved Addresses", "secondary": "Quick access to all the saved addresses in JSON-format" } }, "dust": { "text": { "primary": "Show dust transactions", "secondary": { "hidden": "Transactions smaller than 0.01 XLM are hidden in transaction list", "shown": "Transactions smaller than 0.01 XLM are shown in transaction list" } } }, "create-claimable-balance": { "text": { "primary": "Show Create Claimable Balance transactions", "secondary": { "hidden": "Create Claimable Balance transactions are hidden in transaction list", "shown": "Create Claimable Balance transactions are shown in transaction list" } } } };
const AppSettings$3 = {
  settings: settings$6,
  "trusted-services": { "info": "Trusted Services are web services that are allowed to interact with Sunce wallet by requesting account data or proposing transactions. You can add a new service once it tries to interact with Sunce.", "service-selection": { "action": { "cancel": "Cancel", "confirm": "Confirm" }, "confirm": { "title": "Confirm removal", "text": "The service will be removed from your trust list. Are you sure?" }, "no-services": "No trusted services" } }
};
const action$a = { "cancel": "Cancel", "confirm": "Confirm", "create": "Create Account", "import": "Import Account", "join-shared": "Add Account" };
const confirm$3 = { "text": "You are about to create an account without password protection. Anyone that has access to your device will have access to your account funds. <1 /> <3 /> Are you sure you want to continue without setting up a password?", "title": "Continue without password" };
const header$3 = { "placeholder": { "mainnet": "New Account", "testnet": "New Testnet Account" } };
const inputs$b = { "import": { "helper-text": "A Stellar secret key is 56 alphanumeric characters long and starts with an S", "placeholder": "SABCDEFGH…", "label": "Secret key", "title": "Import Existing" }, "multisig-account": { "explanation-long": "Make sure the account to join has at least 2 XLM on it, so they can add you as a co-signer.", "explanation-short": "Make sure the account to join has been funded.", "helper-text": "The multi-signature account's address (public key)", "placeholder": "GABCDEFGH…", "label": "Multi-signature account" }, "password": { "label": "Password", "placeholder": "Enter a password" }, "password-repeat": { "label": "Repeat password", "placeholder": "Repeat your password" } };
const options$3 = { "cosigner": { "label": "Join shared account", "description": "Co-sign a multi-signature account" }, "cosigner-import": { "label": "Co-signs shared account", "description": "Key is signer of another account" }, "import": { "label": "Import secret key", "description": "Restore account from backup" }, "password": { "label": "Password protection", "protected": "Your secret key will be encrypted", "unprotected": "Your secret key will be unprotected" } };
const validation$b = { "invalid-key": "Invalid Stellar secret key.", "no-account-name": "No account name has been entered.", "no-password": "No password has been entered.", "password-no-match": "Password does not match.", "same-account": "Already added this account." };
const CreateAccount$3 = {
  action: action$a,
  "action-selection": { "create": { "description": "Create a new empty account", "label": "Create Account" }, "import": { "description": "Restore account from backup", "label": "Import Account" }, "join-shared": { "description": "Co-sign a shared account", "label": "Join Account" } },
  "base-name": { "mainnet": "My Account", "testnet": "My Testnet Account" },
  confirm: confirm$3,
  header: header$3,
  inputs: inputs$b,
  options: options$3,
  validation: validation$b
};
const error$3 = { "asset-not-depositable-error": "Asset {{asset}} seems to not be depositable via {{domain}}", "asset-not-withdrawable-error": "Asset {{asset}} seems to not be withdrawable via {{domain}}", "boundary": { "header": "Oops, something went wrong...", "contact-us": "Contact us via" }, "bad-response-error": "Bad response ({{status}}) from {{server}} server", "bad-transaction-error": "Bad transaction given. Expected a Transaction or TransactionRecord, but got: {{transaction}}", "bio-auth-test-canceled": "Biometric authentication canceled", "cosigner-lacking-key": "Cannot add key pair as co-signer of an account, since no public key for the account to co-sign has been provided", "expected-json-response-error": "Expected {{url}} to return a JSON response. Content type was {{contentType}} instead.", "existing-account-error": "An account with that name does already exist.", "fetch-account-data-error": "Cannot fetch account data of {{account}} from {{horizon}}", "fetch-signature-requests-error": "Fetching signature requests failed: {{response}} \nService: {{service}}", "fetch-web-auth-challenge-error": "Cannot fetch web auth challenge", "http-request-error": "HTTP fetch failed: {{response}} \nService: {{service}}", "invariant-violation-error": "Invariant violation: {{message}}", "low-reserve-order-error": "Cannot place order because spendable XLM balance is too low.", "memo-already-specified-error": "Cannot set a custom memo. Federation record of {{destination}} already specifies memo.", "missing-info-error": "Cannot create transaction, because {{transferServer}} did not send all required information.", "multi-sig-config-threshold-lock": "Signature threshold too high. You would lock your account.", "multi-sig-config-threshold-too-low": "Signature threshold too low.", "multi-sig-event-stream-double-errored-error": "Multi-signature update event stream double-errored: {{url}}", "multi-sig-service-not-locatable": "Multi-signature service cannot be located: {{domain}}", "no-callback-url-error": "Cannot submit back to multi-signature service. Signature request has no callback URL set.", "non-existent-destination-error": "Cannot pay in {{assetCode}}, since the destination account does not exist yet. Account creations always need to be done via XLM.", "only-interactive-kyc-supported-error": "Only interactive KYCs are supported.", "password-required-error": "Account {{accountName}} is password-protected, but no password was passed.", "promise-timeout-error": "Promise timed out after {{timeout}}ms", "request-failed-error": "Request to {{target}} failed with status {{status}}: {{message}}", "stellar-address-not-found-error": "Stellar address not found: {{address}}", "stellar-address-request-failed-error": "Stellar address resolution of {{address}} failed.", "stellar-uri-verification-error": "Stellar URI's signature could not be verified.", "stellar-uri-callback-format-error": "Stellar URI's callback is not valid: {{reason}}", "submission-failed-error": "Submitting transaction to {{endpoint}} failed with status {{status}}: {{message}}", "testnet-endpoint-not-available-error": "{{service}} does not provide a testnet endpoint.", "timeout-error": "Request timed out", "unexpected-action-error": "Unexpected action: {{action}}", "unexpected-state-error": "Encountered unexpected state: {{state}}", "unexpected-response-type-error": "Unexpected response type: {{type}} / ${dataType}", "unexpected-stellar-uri-type-error": "Incoming uri {{incomingURI}} does not match any expected type.", "unknown-error": "An unknown error occured.", "update-already-running-error": "Update is already running!", "wrong-password-error": "Wrong password.", "wrong-request-start-error": "Expected request to start with 'web+stellar:'", "submission-error": { "default": "Transaction rejected by the network. Error code(s): {{codes}}", "internal-server-error": "The server had trouble processing this request. Please try again.", "op-result-code": { "op_cross_self": "The order would counter an open order of yours.", "op_has_sub_entries": "Account still has trustlines (assets) or open trading orders.", "op_immutable_set": "Account is immutable (AUTH_IMMUTABLE flag set).", "op_line_full": "The destination account's balance would exceed the destination's trust in the asset.", "op_low_reserve": "Transaction rejected by the network. Source or destination account balance would be below minimum balance.", "op_no_account": "Destination account does not exist.", "op_no_issuer": "Asset is invalid. Incorrect asset issuer.", "op_no_trust": "Destination account does not trust the asset you are attempting to send.", "op_offer_not_found": "Offer does not exist.", "op_self_not_allowed": "Account cannot trust assets issued by itself.", "op_underfunded": "Not enough funds to perform this operation." }, "prefix": { "server-error": "Server Error" }, "tx-result-code": { "insufficient_fee": "Network demands higher fees than set in the transaction.", "internal_error": "An unknown error occured on the Stellar server.", "no_account": "Source account not found.", "tx_bad_auth": "Too few valid signatures or wrong network.", "tx_bad_auth_extra": "Unused signatures attached to transaction.", "tx_bad_seq": "Sequence number mismatch. Please re-create the transaction.", "tx_insufficient_balance": "Insufficient balance. Balance would fall below the minimum reserve.", "tx_too_late": "Transaction draft has expired. Try again." }, "timeout": "The server did not respond. Please try again." } };
const Generic$3 = {
  "dialog-actions": { "close": { "label": "Close" }, "retry": { "label": "Retry" } },
  error: error$3,
  "qr-reader": { "action": { "cancel": "Cancel" } },
  "submission-progress": { "pending": "Submitting to network ...", "success": { "default": "Successful", "multisig": "Waiting for missing signatures", "third-party": "Waiting for authorization of third-party service" } },
  "testnet-badge": { "label": "Testnet" },
  "user-interface": { "copied-to-clipboard": "Copied to clipboard." }
};
const payment$8 = { "summary": { "amount": "Amount", "destination": "Destination", "source": "Source" }, "title": "Payment" };
const Operations$3 = {
  "account-merge": { "summary": { "account": "Account", "merge-into": "Merge into" }, "title": "Merge Account" },
  "change-trust": { "summary": { "asset": "Asset", "issued-by": "Issued by", "limit": { "label": "Limit", "value": { "unlimited": "Unlimited", "limited-to": "Limited to {{limit}} {{code}}" } } }, "title": { "add-asset": "Add asset", "remove-asset": "Remove asset" } },
  "create-account": { "summary": { "account": "Account to create", "funding-account": "Funding account", "funding-amount": "Funding amount" }, "title": "Create account" },
  "manage-buy-offer": { "title": { "create": "Create buy order", "delete": "Buy order", "update": "Update buy order" } },
  "manage-data": { "title": "Set account data" },
  "manage-offer": { "summary": { "buy": "Buy", "sell": "Sell" } },
  "manage-sell-offer": { "title": { "create": "Create sell order", "delete": "Sell order", "update": "Update sell order" } },
  "offer-details": { "string": "Buy {{price}} {{buyingCode}} for {{amount}} {{sellingCode}}" },
  payment: payment$8,
  "set-options": { "add-signer": { "summary": { "account": "Account to add signer to", "key-weight": "Key weight", "new-signer": "New signer" }, "title": "Add signer" }, "change-signature-setup": { "summary": { "key-thresholds": { "label": "New key thresholds", "value": { "low": "Low threshold:    {{threshold}}", "medium": "Medium threshold: {{threshold}}", "high": "High threshold:   {{threshold}}" } }, "required-signatures": "New key weight threshold" }, "title": "Change signature setup" }, "remove-signer": { "summary": { "account": "Account to remove signer from", "signer": "Signer" }, "title": "Remove signer" }, "set-account-options": { "title": "Set account options" }, "set-home-domain": { "title": "Set home domain" }, "set-inflation-destination": { "summary": { "new-destination": "New destination" }, "title": "Set inflation destination" }, "set-master-key-weight": { "title": "Set master key weight" } }
};
const actions$3 = { "dismiss": "Dismiss", "submit": "Send now" };
const inputs$a = { "destination": { "label": "Destination address", "placeholder": "GABCD..., MABCD... or alice*example.org" }, "price": { "label": "Amount", "placeholder": "Max. {{amount}}" } };
const note$1 = { "multisig-pubkey": "Address of the multi-signature account, not your local co-signature key." };
const title$e = { "send": "Send funds", "receive": "Receive Funds" };
const validation$a = { "memo-required": "Set a memo when sending funds to {{destination}}", "memo-too-long": "Memo too long.", "no-destination": "No destination specified.", "no-price": "No amount specified.", "not-enough-funds": "Not enough funds.", "invalid-destination": "Expected a public key or stellar address.", "invalid-price": "Invalid amount.", "integer-memo-required": "Memo must be an integer.", "asset-missing": "No asset selected." };
const Payment$3 = {
  actions: actions$3,
  "memo-metadata": { "label": { "default": "Memo", "id": "Memo (ID)", "text": "Memo (Text)" }, "placeholder": { "optional": "Description (optional)", "mandatory": "Description (mandatory)" } },
  inputs: inputs$a,
  note: note$1,
  title: title$e,
  validation: validation$a
};
const action$9 = { "add-asset": "Add asset", "submit": "Place order" };
const advanced$3 = { "header": "Advanced" };
const inputs$9 = { "estimated-costs": { "label": { "buy": "Estimated costs", "sell": "Estimated return" } }, "primary-amount": { "label": { "buy": "Amount to buy", "sell": "Amount to sell" }, "max-button": { "label": "Max" }, "placeholder": "Max. {{amount}}" }, "primary-asset-selector": { "label": { "buy": "You buy", "sell": "You sell" } }, "secondary-asset-selector": { "label": { "buy": "Spend", "sell": "Receive" } } };
const title$d = "Trade";
const validation$9 = { "primary-amount-missing": "No amount specified.", "primary-asset-missing": "No asset selected.", "invalid-amount": "Invalid amount specified.", "invalid-price": "Invalid price", "not-enough-balance": "Exceeds your spendable balance", "secondary-asset-missing": "No asset selected." };
const warning$3 = { "title": "Warning", "message": "The spread between buying and selling price is about {{spread}}%." };
const Trading$3 = {
  action: action$9,
  "action-selection": { "buy": { "description": "Buy some amount of an asset on the distributed exchange", "label": "Buy asset" }, "sell": { "description": "Trade some amount of an asset for another one", "label": "Sell asset" } },
  advanced: advanced$3,
  inputs: inputs$9,
  "no-assets-info": "This account does not use any assets other than Stellar Lumens yet.",
  title: title$d,
  "trading-price": { "default-label": "Price (limit)", "label": "Price per {{unit}} (limit)" },
  validation: validation$9,
  warning: warning$3
};
const payment$7 = { "account-selector": "Select the account to use", "action": { "dismiss": "Dismiss", "select": "Select" }, "error": { "no-activated-accounts": "No activated accounts found.", "no-accounts-with-trustline": "No accounts with matching trustline found." }, "uri-content": { "message": "Message" } };
const transaction$4 = { "account-selector": { "source-account": "Select the source account", "signing-account": "Select the account that will sign the transaction" }, "action": { "dismiss": "Dismiss", "select": "Select" }, "error": { "signer-not-imported": "The transaction request specified '{{signer}}' as the target signer but this account is not imported.", "no-eligible-accounts": "No eligible account found." }, "hint": "Hint", "uri-content": { "message": "Message" }, "warning": "The origin of this request cannot be verified! Decline when in doubt." };
const TransactionRequest$3 = {
  "no-accounts": { "action": { "dismiss": "Dismiss" }, "info": { "1": "No accounts found for the specified network.", "2": "You must import an account before you can sign transaction requests." }, "title": "Transaction proposed" },
  payment: payment$7,
  transaction: transaction$4,
  "stellar-uri": { "header": { "origin-domain": "The following transaction has been proposed by <1>{{originDomain}}<3>", "warning": "The origin of this request cannot be verified! Decline when in doubt." }, "title": "Transaction proposed" },
  "verify-trusted-service": { "action": { "trust": "Trust", "cancel": "Cancel" }, "info": { "1": "You opened a Stellar URI originating from an unknown origin", "2": "If you trust this domain you can add this service to your list of trusted services.", "3": "You can view and edit your list of trusted services anytime in the application settings." }, "title": "Verify Trusted Service" }
};
const authentication$3 = { "sidebar": { "headline": "Authentication", "info": { "1": "The asset issuer requires you to log in to their service using your account.", "2": "An authentication transaction will be signed to prove ownership of that account." } } };
const initial$3 = { "action": { "proceed": "Proceed" }, "body": { "asset-selector": { "label": { "deposit": "Asset", "short": "Asset", "withdrawal": "Asset to withdraw" }, "no-assets": "No withdrawable assets" }, "method-selector": { "info-item": { "asset": "Please select a type", "no-asset": "Select an asset first" }, "label": { "deposit": "Type of deposit", "withdrawal": "Type of withdrawal" } } }, "sidebar": { "deposit": { "headline": "Fund your account", "info": { "1": "Purchase Stellar lumens (XLM) or deposit assets to fund your account. Send USD from your bank account, ETH from your Ethereum wallet, etc.", "2": "Sunce acts as a client to the service offered by the asset issuer only." } }, "withdrawal": { "headline": "What to withdraw", "info": { "1": "Withdraw assets in your account, like USD to your bank account or ETH to your Ethereum wallet.", "2": "Sunce acts as a client to the service offered by the asset issuer only." } } } };
const title$c = { "deposit": "Add funds", "withdrawal": "Withdraw funds" };
const TransferService$3 = {
  authentication: authentication$3,
  "deposit-success": { "action": { "close": "Close" }, "body": { "deposit-pending": "Deposit pending", "info": { "1": "{{domain}} is waiting for your deposit.", "2": "The funds will be credited to your Stellar account when the deposit is credited to the asset issuer." } }, "sidebar": { "headline": "Done", "info": "Your deposit has been accepted and will be processed by the asset issuer when your payment arrives." } },
  "form-builder": { "placeholder": { "optional": "(Optional) {{name}}" } },
  initial: initial$3,
  "kyc-denied": { "sidebar": { "headline": "Know Your Customer", "info": "You have been rejected – the service is disabled for you. Please contact the asset issuer." } },
  "kyc-pending": { "action": { "continue": "Continue", "open-again": "Open again" }, "body": { "additional-info-needed": "Additional information needed" }, "sidebar": { "headline": "Know Your Customer", "info": { "1": "The service will only work if you provide personal information about you.", "2": "This usually happens for legal reasons." } } },
  "no-withdrawable-assets": { "action": { "add-asset": "Add asset" }, "body": { "no-withdrawable-assets": "This account holds no withdrawable assets." } },
  "purchase-lumens": { "sidebar": { "headline": "Buy Stellar lumens", "info": { "1": "We offer options to buy lumens that do not involve a Stellar asset issuer.", "2": " Stellar lumens (XLM) are the native tokens on the Stellar network. They are used to pay transaction fees, among other things." } } },
  title: title$c,
  "transaction-details": { "action": { "done": "Done", "withdraw": "Withdraw" }, "body": { "amount": { "error": { "amount-greater-than-balance": "Specified amount greater than balance" }, "label": { "deposit": "Amount to deposit", "withdrawal": "Amount to withdraw" } }, "amount-to-receive": { "label": "Amount to receive" }, "deposit-instructions": { "label": "Deposit instructions" }, "eta": { "label": "ETA", "not-available": "N/A" }, "fees": { "label": "Fees", "value": { "unknown": "unknown" } }, "information": { "label": "Information" } }, "sidebar": { "deposit": { "headline": "Deposit summary", "info": { "1": "Make sure that you send the funds to the right destination.", "2": "The asset issuer will credit the tokens once your deposit is credited." } }, "withdrawal": { "headline": "Almost done", "info": { "1": "Check the form and provide an amount to withdraw if necessary.", "2": "The withdrawal is almost ready." } } } },
  "transaction-status": { "error": { "rejected": { "deposit": "Deposit rejected", "withdrawal": "Withdrawal rejected" }, "contact": "Please contact {{domain}}." }, "incomplete": { "already-redirected": { "info": { "1": "{{domain}} is checking your personal information. Please try again later.", "2": "Estimated time to completion: {{eta}}" } }, "not-redirected": { "info": "{{domain}} requires you to provide additional information." } }, "more-info-url": { "info": "For more information, visit" }, "pending-user-transfer-start": { "info": "{{domain}} requires further information from you." } },
  "withdrawal-success": { "action": { "close": "Close" }, "body": { "withdrawal-in-progress": "Withdrawal in progress", "info": { "1": "{{domain}} is conducting the withdrawal.", "2": "The funds have been deducted from your Stellar account and should be credited to the withdrawal destination shortly." } }, "sidebar": { "headline": "Done", "info": "Your withdrawal has been accepted and will be processed by the asset issuer." } },
  "transfer-details": { "action": { "proceed": "Proceed" }, "body": { "destination": { "name": "Destination account" }, "dest_extra": { "name": "Extra destination data (no description)" }, "min-max-amount": { "label": "Amount", "max-amount": "Max. {{amount}} {{assetCode}}", "min-amount": "Min. {{amount}} {{assetCode}}", "not-enough-funds": "You do not have enough funds." }, "fee": { "helper-text": "As charged by {{domain}}", "label": { "deposit": "Deposit fee", "withdrawal": "Withdrawal fee" } } }, "sidebar": { "deposit": { "headline": "Deposit details", "info": { "1": "Further details about your intended deposit.", "2": "Depending on what the asset issuer requests you may have to enter additional information here." } }, "withdrawal": { "headline": "Withdrawal details", "info": { "1": "Further details about your intended deposit.", "2": "Depending on what the asset issuer requests you may have to enter additional information here." } } } }
};
const translations$3 = {
  "account-settings": AccountSettings$3,
  account: Account$3,
  app: App$4,
  "app-settings": AppSettings$3,
  "create-account": CreateAccount$3,
  generic: Generic$3,
  operations: Operations$3,
  payment: Payment$3,
  trading: Trading$3,
  "transaction-request": TransactionRequest$3,
  "transfer-service": TransferService$3
};
const settings$5 = { "delete-account": { "text": { "primary": "Unir o borrar cuenta" } }, "export-secret-key": { "text": { "primary": "Exporta clave secreta", "secondary": "Desencripta y muestra la clave privada" } }, "multi-sig": { "text": { "primary": "Multi-firma", "secondary": { "short": "Administrar cofirmantes", "long": "Crea cuenta con multi-firma y administra co-firmantes" } } }, "set-password": { "text": { "primary": { "account-protected": "Cambiar contraseña", "account-not-protected": "Establecer contraseña" }, "secondary": { "account-protected": "Tu cuenta es segura, protegida por una contraseña", "account-not-protected": "Tu cuenta no está protegida" } } } };
const AccountSettings$2 = {
  "account-deletion": { "action": { "cancel": "Cancelar", "confirm": "Confirmar", "delete": "Eliminar", "merge": { "long": "Unir dentro de", "short": "Unir" } }, "confirm": { "title": "Confirmar para eliminar", "text": { "confirm": "¿Está seguro?", "delete": "La cuenta será eliminada", "merge": "y los fondos restantes transferidos" } }, "remaining-funds": { "text": "Enviar fondos restantes a" }, "text": { "1": '¿Está seguro de querer borrar la cuenta "{{accountName}}"?', "2": "Asegúrese de tener copia de la clave privada o de unirla a otra cuenta, ¡Aún quedan fondos en esta cuenta!" }, "title": "Confirmar para borrar la cuenta", "warning-dialog": { "close": { "label": "OK" } }, "warnings": { "cannot-merge": { "text": "Aún no es posible unir a otra cuenta. Primero debe cancelar todas las órdenes de intercambio abiertas y remover todos los activos.", "title": "Acción manual requerida" } } },
  "custom-trustline": { "action": { "cancel": "Anular", "trust": { "long": "Confiar en el Token", "short": "Confiar" } }, "textfield": { "code": { "label": "Código" }, "issuer": { "label": "Emisor", "placeholder": "Clave pública del emisor" }, "limit": { "label": "Límite (opcional)", "placeholder": "Limita la confianza en este activo / saldo máximo a mantener" } }, "title": "Agregar activo personalizado" },
  "export-key": { "action": { "confirm": "Hecho", "reveal": { "long": "Revela la clave", "short": "Presionar para revelar clave privada" } }, "info": { "backup": { "title": "Resguarde la clave secreta ahora", "paragraph-1": "La clave secreta es el único modo de recuperar sus fondos si olvida la contraseña o pierde el acceso a su dispositivo.", "paragraph-2": "Escriba o imprima la clave secreta, guárdela en un lugar seguro y no la comparta con nadie." }, "export": { "paragraph-1": "La clave secreta es el único modo de recuperar sus fondos si olvida la contraseña o pierde el acceso a su dispositivo.", "paragraph-2": "Escriba o imprima la clave secreta, guárdela en un lugar seguro y no la comparta con nadie." }, "secret-key": "Escriba la clave en papel y guárdela en un lugar seguro", "tap-to-copy": "Presionar para copiar" }, "textfield": { "password": { "label": "Contraseña" } }, "title": { "default": "Exportar la clave secreta", "initial-backup": "Respaldar la clave secreta" } },
  "manage-signers": { "action": { "add-signer": "Añadir firmante", "apply": { "long": "Aplicar el cambio", "short": "Aplicar" }, "cancel": "Cancelar", "proceed": "Continuar" }, "preset-description": { "m-out-of-n": "Agregar o quitar firmantes de la cuenta. Cualquier firma autorizará las transacciones. ", "m-out-of-n_plural": "Agregar o quitar firmantes de la cuenta. {{ count }} firmas autorizarán las transacciones", "one-out-of-n": "Agregar o quitar firmantes de la cuenta. Cualquier firmante puede autorizar transacciones.", "single-signature": "Escoge la clave que será la firma única de la cuenta." }, "preset-description-extra": { "m-out-of-n": "Ve a 'Agregar cuenta' > 'Unirse a la cuenta' en Sunce para crear una nueva clave de co-firmante.", "one-out-of-n": "Ve a 'Agregar cuenta' > 'Unirse a la cuenta' en Sunce para crear una nueva clave de co-firmante." }, "preset-selector": { "options": { "m-out-of-n": { "primary": "Firma colectiva", "secondary": "Múltiples firmantes tienen que firmar una transacción." }, "one-out-of-n": { "primary": "Claves de respaldo", "secondary": "Cada firmante puede firmar transacciones por él mismo." }, "single-signature": { "primary": "Firma única", "secondary": "No hay co-firmantes. Solo un par de claves." } }, "title": "Elige como quieres que funcione tu cuenta" }, "signers-editor": { "list": { "item": { "weight": "Peso", "local-key": "Clave local" } }, "new-signer": { "label": "Clave pública o dirección Stellar", "placeholder": { "long": "GABC… o dirección", "short": "GABCDEFGHIJK… o alice*example.org" } }, "threshold": { "primary": "Firmas requeridas", "secondary": "Número de firmas requeridas para autorizar transacciones" }, "validation": { "existing-signer": "No puede agregar firmante existente.", "integer-required": "Debe ser un número entero.", "invalid-stellar-address": "Se espera un clave pública o dirección Stellar" } }, "title": { "long": "Administrar Firmantes", "short": "Administrar firmantes de cuenta" }, "validation": { "no-signers": "No queda ningún firmante. No te quedes encerrado!", "threshold-higher-than-weights": "El umbral es más alto que los pesos de las claves combinados", "invalid-weight-type": "El peso debe ser un número entero", "no-threshold": "Por favor establezca un umbral" } },
  "set-password": { "action": { "change-password": { "long": "Cambiar contraseña", "short": "Modificar" }, "remove-password": { "long": "Remover contraseña", "short": "Remover" } }, "notification": { "password-changed": "Contraseña cambiada.", "password-set": "Contraseña establecida.", "password-removed": "Contraseña removida." }, "textfield": { "prev-password": { "label": "Contraseña actual" }, "next-password": { "label": "Nueva contraseña" }, "next-password-repeat": { "label": "Repetir nueva contraseña" } }, "title": { "change-password": "Cambiar contraseña", "set-password": "Establecer contraseña" }, "validation": { "next-password-missing": 'Entrar una contraseña o establecer "Remover contraseña".', "next-password-repeat-missing": "Por favor repetir la contraseña.", "passwords-no-match": "La contraseña no coincide", "previous-password-missing": "Falta la contraseña actual." } },
  settings: settings$5
};
const action$8 = { "receive": "Recibir", "send": "Enviar" };
const transactions$2 = { "action": { "friendbot": { "description": "Obtener algunos lúmenes gratuitos test", "label": "Pedir a friendbot" }, "navigate-to-deposit": { "description": "Con tarjeta de crédito, transferencia bancaria, etc.", "label": "Depositar fondos" } }, "offer-list": { "text": { "buy": "Comprar <1 /> por <3 />", "sell": "Vender <1 /> por <3 />", "for": "por" }, "title": "Órdenes abiertas" }, "transaction-list": { "offer-description": { "prefix": { "default": "Ordenar", "cancel": "Anular orden", "update": "Actualizar orden" }, "buy": "Comprar {{buyingAmount}} {{buyingCode}} por {{sellingAmount}} {{sellingCode}}", "sell": "Vender {{sellingAmount}} {{sellingCode}} por {{buyingAmount}} {{buyingCode}}" }, "item": { "from": "Desde", "to": "Hasta", "memo": "Memo", "remote-public-keys": { "more": "más" }, "trust": { "add-trust": "Confiar en el activo {{asset}}", "remove-trust": "Remover confianza en el activo {{asset}}" } }, "load-more": { "label": "Cargar más" }, "title": "Transacciones recientes" }, "signature-request-list": { "title": { "requests-to-cosign": "Transacciones para co-firmar", "requests-waiting-for-others": "Esperando por firmas adicionales" } } };
const title$b = { "password-status": { "protected": "Protegido con contraseña", "unprotected": "Sin contraseña" }, "tooltip": { "multi-sig-account": "Cuenta multifirma", "security-service": "{{service}} Protección" }, "placeholder": "Nombre de cuenta", "testnet": "Testnet" };
const Account$2 = {
  action: action$8,
  "add-asset": { "action": { "add-asset": "Agregar activo a la cuenta", "remove": "Remover", "trade": "Negociar" }, "button": { "add-custom-asset": { "label": "Agregar activo personalizado" } }, "item": { "issuer": { "secondary": { "one-asset": "Un activo coincide", "more-than-one-asset": "{{amount}} activos coinciden" } }, "no-result": { "primary": "Ningún activo coincide", "secondary": "Ningún activo o emisor coincide con la búsqueda" } }, "search-field": { "placeholder": "Busca activo por código o nombre" }, "title": "Agregar activo" },
  "asset-details": { "lumen": { "description": { "label": "Descripción", "text": "El token nativo de la red Stellar.\n\n Toda cuenta de la red tiene un balance de lúmenes. Estos son usados para pagar el costo de transacción." } }, "general": { "account-flags": { "auth-required": "Necesita autorización del emisor", "auth-not-required": "No necesita autorización", "auth-revocable": "Autorización revocable", "auth-not-revocable": "Autorización no revocable", "auth-immutable": "Estas marcas son inmutables", "auth-mutable": "El emisor puede cambiar estas marcas.", "label": "Marcas de la cuenta" }, "anchor-asset": { "label": "Anclado a" }, "conditions": { "label": "Condiciones" }, "description": { "label": "Descripción" }, "issuing-account": { "label": "Cuenta emisora" }, "organisation": { "address": { "label": "Dirección" }, "dba": { "label": "Negociando como" }, "description": { "label": "Descripción" }, "email": { "label": "Correo electrónico" }, "name": { "label": "Organización" }, "phone-number": { "label": "Teléfono" }, "website": { "label": "Sito web" } }, "redemption-instructions": { "label": "Instrucciones para reembolso" } } },
  "balance-details": { "button": { "add-asset": { "label": "Agregar activo a tu cuenta" } }, "item": { "spendable-balance": { "primary": "Saldo disponible" } }, "spendable-balances": { "base-reserve": { "primary": "Reserva base", "secondary": "Reserva base fija" }, "data-reserve": { "primary": "Reserva campo de datos", "secondary": "Campos de datos de la cuenta" }, "headline": "Valor en XLM", "open-orders-reserve": { "primary": "Reserva órdenes abiertas", "secondary": "Reserva por orden" }, "selling-liabilities": { "primary": "Monto a vender", "secondary": "Comprometido a abrir órdenes" }, "signers-reserve": { "primary": "Reserva de firmantes", "secondary": { "single-key": "Reserva de clave única", "multiple-keys": "Clave principal + co-firmantes" } }, "spendable-balance": { "primary": "Saldo disponible", "secondary": "Monto libremente utilizable" }, "total-balance": { "primary": "Saldo total", "secondary": "Tu saldo, incluido el no utilizable" }, "trustline-reserve": { "primary": "Reserva de líneas de confianza", "secondary": "Por cada saldo (no XLM)" } } },
  "saved-addresses": { "title": "Direcciónes Favoritos", "search-field": { "placeholder": "Busca activo por nombre o dirección…" }, "item": { "no-result": { "primary": "Ningún registro coincidente", "secondary": "Ningún nombre o dirección coincide con su búsqueda" } }, "button": { "add": { "label": "Add destino" } } },
  "saved-address-details": { "address": { "label": "Dirección", "placeholder": "Dirección" }, "label": { "label": "Etiqueta", "placeholder": "Etiqueta" }, "validation": { "no-address": "Falta la dirección", "no-label": "Falta etiqueta", "label-too-long": "La etiqueta es demasiado larga. Considere {{max}} caracteres como máximo", "invalid-address": "La dirección no es válida" }, "button": { "add": { "label": "Guardar" }, "remove": { "label": "Remover" } } },
  "context-menu": { "account-settings": { "label": "Ajustes de la cuenta" }, "assets-and-balances": { "label": "Activos & Saldos" }, "deposit": { "label": "Agregar fondos" }, "trade": { "label": "Comerciar" }, "transactions": { "label": "Transacciones" }, "withdraw": { "label": "Retirar" }, "saved-addresses": { "label": "Direcciónes Favoritos" } },
  "purchase-lumens": { "legal-confirmation": { "action": { "confirm": "Yo comprendo" } }, "moonpay": { "text": { "primary": "MoonPay", "secondary": "Comprar inmediatamente Lúmenes Stellar usando tu tarjeta de débito / crédito o Apple Pay" }, "legal-confirmation": " Serás redirigido a moonpay.io, un servicio externo. El proceso de depósito es operado por Moon Pay Ltd, no por Sunce o Montelibero. <1 /> <2 /> Por favor contacte a moonpay.io para consultas sobre tu depósito." }, "title": "Compra lúmenes Stellar" },
  "remove-trustline": { "action": { "cancel": "Cancelar", "remove": "Remover" }, "text": { "Advertencia": "No puedes remover este activo a menos que el saldo del balance sea cero.", "info": 'Estás por remover <1> {{asset}} </1> de la cuenta "{{accountName}}".' }, "title": "Confirma remover el activo" },
  transactions: transactions$2,
  "transaction-review": { "action": { "confirm": "Confirmar", "cancel-order": "Anular orden", "dismiss": "Ignorar", "inspect": "Inspeccionar", "show-more": "Mostrar más detalles" }, "account-creation-warning": { "primary": "Agregando fondos a una cuenta nueva", "secondary": "Agregando fondos a una cuenta sin fondos. Asegúrate de que el destino sea correcto." }, "dangerous-transaction-warning": { "primary": "Transacción iniciada por una cuenta desconocida", "secondary": "Por favor revisa cuidadosamente. En caso de duda, es mejor ignorarla." }, "dismissal": { "action": { "cancel": "Anular", "confirm": "Confirmar" }, "header": "Ignorar la transacción multifirma pendiente?", "title": "Confirmar" }, "signers": { "heading-details": { "single-signature": "Firma única", "default-signatures": "{{threshold}} de {{length}} multi-firma", "custom-consensus": "Multifirma de consenso personalizada" }, "label": "Firmantes {{details}}" }, "signer-status": { "tooltip": { "has-signed": "Has firmado la transacción", "has-not-signed": "Esperando otras firmas" } }, "summary": { "item": { "account": { "label": "Cuenta" }, "authenticating-account": { "label": "Autenticando cuenta" }, "expiry": { "label": "Vencimiento" }, "max-fee": { "label": "Costo máximo" }, "service": { "label": "Servicio" }, "submission": { "label": "Envío" }, "tx-hash": { "label": "Hash de transacción" } } }, "textfield": { "password": { "label": "Contraseña" } }, "title": { "transaction": "Transacción", "payment": "Pago", "delete-orders-operation": "Eliminar órdenes de intercambio", "web-auth": "Autenticación Web" }, "transaction-memo": { "label": "{{type}} Memo" }, "validation": { "no-account-data": "Violación invariante: Imposible encontrar los datos de la cuenta de origen en el conjunto de suscripciones de datos de cuenta.", "no-manage-data-operation": "Violación invariante: La transacción de autenticación web de Stellar debe contener una operación manage_data.", "password-required": "Contraseña requerida" } },
  title: title$b
};
const notification$2 = { "desktop": { "new-signature-request": { "title": "Nueva transacción para co-firmar", "body": "De {{signersHavingSigned}}" }, "received-payment": { "title": "Pago recibido | {{account}}", "body": "Recibido {{amount}} {{assetCode}}" }, "Intercambio-completado": { "title": "Intercambio completado | {{account}}" } }, "details": { "action": { "dismiss": "Desechar" }, "support": "Tiene problemas con la aplicación? <1 /> Contáctenos por", "title": "Error", "offline": "Desconectado" }, "permission": { "app-notification": { "error": "Habilitar en ajustes del dispositivo", "granted": { "title": "Notificaciones habilitadas", "text": "A partir de ahora Sunce mostrará notificaciones" }, "message": "Habilitar notificaciones" } } };
const App$3 = {
  "account-list": { "add-account-card": { "label": "Agregar cuenta" }, "badges": { "tooltip": { "multi-sig": "Cuenta multi-firma", "security-service": "{{service}} seguridad" } } },
  "all-accounts": { "switch": { "label": "Testnet" }, "update": { "notification": { "start": "Iniciando descarga de actualización...", "success": "La descarga está completa y se instalará en el próximo reinicio!" }, "tooltip": "Actualización disponible" }, "title": { "testnet": "Cuenta Testnet", "mainnet": "Mis Cuentas" } },
  notification: notification$2,
  "terms-and-conditions": { "action": { "confirm": "Confirmar" }, "header": "Bienvenido a Sunce", "checkbox": { "1": { "label": "Comprendo que soy responsable por la seguridad de mis fondos y que Sunce no puede recuperar mis fondos en caso de pérdida de datos o si pierdo mis credenciales." }, "2": { "label": "He leído, comprendo y estoy de acuerdo con los <1>Términos y Condiciones</1> <2>y la</2> <3>Política de Privacidad</3> de Sunce." } } }
};
const settings$4 = { "biometric-lock": { "text": { "primary": { "default": "Bloqueo con huella digital", "ios": "Face ID / Touch ID" }, "secondary": { "disabled": "La autenticación biométrica está deshabilitada", "enabled": "La autenticación biométrica está habilitada", "not-enrolled": "Configurar la autenticación biométrica en los ajustes del dispositivo." } }, "prompt": { "enable": "Desbloquear el dispositivo para habilitar la función.", "disable": "Desbloquear el dispositivo para deshabilitar la función." } }, "language": { "auto-detect": { "label": "auto" }, "text": { "primary": "Idioma", "secondary": "Cambiar el idioma de interfaz" } }, "memo": { "text": { "primary": "Mostrar memo", "secondary": { "hidden": "Los Memos no se muestran en la vista transacciones", "shown": "Los Memos se muestran en la vista de transacciones" } } }, "multi-sig": { "text": { "primary": "Habilitar firmas múltiples", "secondary": { "enabled": "Las funciones multi-firma están habilitadas", "disabled": "Las funcionales multi-firma están deshabilitadas" } } }, "testnet": { "text": { "primary": "Mostrar cuentas de Testnet", "secondary": { "cannot-disable": "No puede ser deshabilitado porque ya agregaste cuentas de testnet", "hidden": "Las cuentas de Testnet están ocultas", "shown": "Las cuentas de Testnet están visibles" } } }, "title": "Ajustes", "trusted-services": { "text": { "primary": "Administrar Trusted Services", "secondary": "Remover Trusted Services" } }, "saved-addresses-export": { "text": { "primary": "Importar/exportar direcciones guardadas", "secondary": "Acceso rápido a todas las direcciones guardadas en formato JSON" } }, "dust": { "text": { "primary": "Mostrar transacciones de polvo", "secondary": { "hidden": "Las transacciones inferiores a 0,001 XLM no se muestran en la vista de transacciones", "shows": "Las transacciones inferiores a 0,001 XLM se muestran en la vista de transacciones" } } }, "create-claimable-balance": { "text": { "primary": "Mostrar transacciones de Crear Saldo Reclamable", "secondary": { "hidden": "Las transacciones de Crear Saldo Reclamable no se muestran en la vista de transacciones", "shown": "Las transacciones de Crear Saldo Reclamable se muestran en la vista de transacciones" } } } };
const AppSettings$2 = {
  settings: settings$4,
  "trusted-services": { "info": "Trusted Services o servicios de confianza, son servicios en la web a los que se permite interactuar con Sunce solicitando datos de cuenta o proponiendo transacciones. Puedes agregar un nuevo servicio una vez que el mismo trata de interactuar con Sunce.", "service-selection": { "action": { "cancel": "Cancelar", "confirm": "Confirmar" }, "confirm": { "title": "Confirmar remover", "text": "El servicio será eliminado de tu lista de confianza. Estás seguro?" }, "no-services": "No hay servicios de confianza." } }
};
const action$7 = { "cancel": "Cancelar", "confirm": "Confirmar", "create": "Crear una cuenta", "import": "Importar cuenta", "join-shared": "Agregar cuenta compartida" };
const confirm$2 = { "text": "Está a punto de crear una cuenta sin protección de contraseña. Cualquiera con acceso a este dispositivo tendrá acceso a los fondos. <1 /> <3 /> ¿Estás seguro de querer continuar sin establecer una contraseña?", "title": "Continuar sin contraseña" };
const header$2 = { "placeholder": { "mainnet": "Nueva cuenta", "testnet": "Nueva cuenta Testnet" } };
const inputs$8 = { "import": { "helper-text": "La clave secreta Stellar tiene 56 caracteres alfanuméricos y empieza con una S.", "placeholder": "SABCDEFGH ...", "label": "Clave secreta", "title": "Importar existente" }, "multisig-account": { "explanation-long": "Asegúrate de que la cuenta a agregar tenga al menos 2 XLM, así puedes ser agregado como co-firmante.", "explanation-short": "Asegúrate de que la cuenta tiene fondos.", "helper-text": "La dirección de la cuenta Multisig (clave pública)", "placeholder": "GABCDEFGH…", "label": "Cuenta Multisig (firmas múltiples)" }, "password": { "label": "Contraseña", "placeholder": "Ingresa una contraseña" }, "password-repeat": { "label": "Repetir contraseña", "placeholder": "Repita su contraseña" } };
const options$2 = { "cosigner": { "label": "Unirse a cuenta compartida", "description": "Co-firmar una cuenta Multisig (de múltiples firmas)" }, "cosigner-import": { "label": "Co-firma una cuenta compartida", "description": "La clave es firmante de otra cuenta" }, "import": { "label": "Importar clave secreta", "description": "Restaurar cuenta desde copia de seguridad" }, "password": { "label": "Protección con contraseña", "protected": "Tu clave privada será encriptada", "unprotected": "Tu clave secreta no será protegida" } };
const validation$8 = { "invalid-key": "Clave privada Stellar no es válida.", "no-account-name": "No se ha introducido nombre de cuenta.", "no-password": "No se ha introducido contraseña.", "password-no-match": "Las contraseñas no coinciden.", "same-account": "Ya se había agregado esta cuenta." };
const CreateAccount$2 = {
  action: action$7,
  "action-selection": { "create": { "description": "Crear una cuenta nueva", "label": "Crea una cuenta" }, "import": { "description": "Restaurar cuenta desde copia de seguridad", "label": "Importar cuenta" }, "join-shared": { "description": "Co-firmar una cuenta compartida", "label": "Unirse a la cuenta" } },
  "base-name": { "mainnet": "Mi cuenta", "testnet": "Mi cuenta Testnet" },
  confirm: confirm$2,
  header: header$2,
  inputs: inputs$8,
  options: options$2,
  validation: validation$8
};
const error$2 = { "asset-not-depositable-error": "El activo {{asset}} parece no ser depositable en {{domain}}", "asset-not-withdrawable-error": "El activo {{asset}} parece no se puede cobrar en {{domain}}", "boundary": { "header": "¡Ups! Algo salió mal...", "contact-us": "Contáctenos por" }, "bad-response-error": "Respuesta inválida ({{status}}) del servidor {{server}}", "bad-transaction-error": "Transacción inválida. Se esperaba Transaction o TransactionRecord, pero se obtuvo: {{transaction}}", "bio-auth-test-canceled": "Autenticación biométrica anulada", "expected-json-response-error": "Se esperaba que {{url}} responda en formato JSON. El tipo de contenido fue {{contentType}}.", "existing-account-error": "Ya existe otra cuenta con el mismo nombre.", "fetch-account-data-error": "Imposible recuperar los datos de la cuenta de {{account}} desde {{horizon}}", "fetch-web-auth-challenge-error": "Error al obtener el desafío de autenticación", "fetch-signature-requests-error": "Fallaron las solicitudes de recuperar firmas: {{response}} \nServicio: {{service}}", "invariant-violation-error": "Violación invariante: {{message}}", "low-reserve-order-error": "No se pueden agregar órdenes porque el saldo de XLM utilizable es muy bajo.", "memo-already-specified-error": "No se puede establecer un MEMO personalizado. El registro de la Federación de {{destination}} ya especificó el MEMO.", "missing-info-error": "Imposible crear la transacción, porque {{transferServer}} no ha enviado la información solicitada.", "multi-sig-event-stream-double-errored-error": "Doble Error en la actualización Multi-firma: {{url}}", "no-callback-url-error": "No se pudo responder al servicio multi-firma. La solicitud de firma no especifica ninguna URL de respuesta.", "non-existent-destination-error": "No se puede pagar en {{assetCode}}, porque la cuenta de destino ya no existe. Las creaciones de cuentas siempre deben hacerse con XLM.", "only-interactive-kyc-supported-error": "Se soportan solo KYC interactivos.", "password-required-error": "Cuenta {{accountName}} está protegida por contraseña, pero no se pasó contraseña.", "promise-timeout-error": "Promesa caduca después de {{timeout}} ms", "request-failed-error": "Solicitud a {{target}} ha fallado con estado {{status}}: {{message}}", "stellar-address-not-found-error": "Dirección Stellar no encontrada: {{address}}", "stellar-address-request-failed-error": "Falló la resolución de la dirección Stellar {{address}}", "stellar-uri-verification-error": "No se ha podido verificar la firma de Stellar URI", "stellar-uri-callback-format-error": "Stellar URI's callback is not valid: {{reason}}", "submission-failed-error": "Envío de transacción a {{endpoint}} falló con estado {{status}}: {{message}}", "testnet-endpoint-not-available-error": "{{service}} no provee un punto de conexión Testnet.", "timeout-error": "Solicitud ha caducado", "unexpected-action-error": "Acción imprevista: {{action}}", "unexpected-state-error": "Se encontró un estado inesperado: {{state}}", "unexpected-response-type-error": "Tipo de respuesta imprevista: {{type}} / ${dataType}", "unexpected-stellar-uri-type-error": "La uri entrante {{incomingURI}} no coincide con ningún tipo esperado.", "unknown-error": "Ocurrió un error desconocido.", "update-already-running-error": "¡La actualización ya se está ejecutando!", "wrong-password-error": "Contraseña equivocada.", "wrong-request-start-error": "Se esperaba solicitud para iniciar 'web+stellar:'", "submission-error": { "default": "Transacción rechazada por la red. Código(s) de Error: {{codes}}", "internal-server-error": "El servidor tuvo problemas procesando su solicitud. Por favor reintentar.", "op-result-code": { "op_cross_self": "La orden va a cerrar ejecutar una de tus órdenes anteriores.", "op_has_sub_entries": "La cuenta aún tiene líneas de confianza (activos) órdenes de intercambio abiertas.", "op_immutable_set": "La cuenta no es modificable (se estableció la señal AUTH_IMMUTABLE).", "op_line_full": "El saldo de la cuenta destino excedería la confianza del destino en el activo.", "op_low_reserve": "Transacción rechazada por la red. El saldo de la cuenta de origen o de destino quedaría por debajo del saldo mínimo.", "op_no_account": "La cuenta de destino no existe.", "op_no_issuer": "Activo inválido. Emisor de activo incorrecto.", "op_no_trust": "La cuenta destino confía en el activo que estás tratando de enviar.", "op_offer_not_found": "La oferta no existe.", "op_self_not_allowed": "La cuenta no puede confiar en activos emitidos por ella misma.", "op_underfunded": "Fondos insuficientes para desarrollar esta operación." }, "prefix": { "server-error": "Error de servidor" }, "tx-result-code": { "insufficient_fee": "la red demanda pago mayor que el establecido para esta transacción.", "internal_error": "Un error desconocido ha ocurrido en el servidor Stellar.", "no_account": "Cuenta de origen no encontrada.", "tx_bad_auth": "Muy pocas firmas válidas o red equivocada.", "tx_bad_auth_extra": "Firmas no usadas se anexaron a la transacción.", "tx_bad_seq": "Numero de secuencia equivocado, Por favor vuelva a crear la transacción.", "tx_insufficient_balance": "Saldo insuficiente. El saldo quedaría por debajo del a reserva mínima.", "tx_too_late": "El borrador de la transacción ha expirado, por favor intente de nuevo." }, "timeout": "El servidor respondió. Por favor reintentar." } };
const Generic$2 = {
  "dialog-actions": { "close": { "label": "Cerrar" }, "retry": { "label": "Reintentar" } },
  error: error$2,
  "qr-reader": { "action": { "cancel": "Anular" } },
  "submission-progress": { "pending": "Enviando a la red...", "success": { "default": "Exito", "multisig": "Esperando por firmas faltantes", "third-party": "Esperando por autorización de un servicio de terceros" } },
  "testnet-badge": { "label": "Testnet" },
  "user-interface": { "copied-to-clipboard": "Copiado a Portapapeles." }
};
const payment$6 = { "summary": { "amount": "Cantidad", "destination": "Destino", "source": "Origen" }, "title": "Pago" };
const Operations$2 = {
  "account-merge": { "summary": { "account": "Cuenta", "merge-into": "Unir con" }, "title": "Unir cuenta" },
  "change-trust": { "summary": { "asset": "Activo", "issued-by": "Emitido por", "limit": { "label": "Límite", "value": { "unlimited": "Ilimitado", "limited-to": "Limitado a {{limit}} {{code}}" } } }, "title": { "add-asset": "Añadir activo", "remove-asset": "Remover activo" } },
  "create-account": { "summary": { "account": "Cuenta a crear", "funding-account": "Cuenta fundadora", "funding-amount": "Monto para fundar" }, "title": "Crear una cuenta" },
  "manage-buy-offer": { "title": { "create": "Crear orden de compra", "delete": "Cancelar orden", "update": "Actualizar orden de compra" } },
  "manage-data": { "title": "Establecer datos de la cuenta" },
  "manage-offer": { "summary": { "buy": "Comprar", "sell": "Vender" } },
  "manage-sell-offer": { "title": { "create": "Crea orden de venta", "delete": "Cancela orden de venta", "update": "Actualizar orden de venta" } },
  "offer-details": { "string": "Comprar {{price}} {{buyingCode}} por {{amount}} {{sellingCode}}" },
  payment: payment$6,
  "set-options": { "add-signer": { "summary": { "account": "Cuenta para añadir firmante", "key-weight": "Peso de clave", "new-signer": "Nuevo firmante" }, "title": "Añadir firmante" }, "change-signature-setup": { "summary": { "key-thresholds": { "label": "Nuevos umbrales de clave", "value": { "low": "Umbral bajo: {{threshold}}", "medium": "Umbral medio: {{threshold}}", "high": "Umbral alto: {{threshold}}" } }, "required-signatures": "Firmas requeridas" }, "title": "Cambiar ajustes de firma" }, "remove-signer": { "summary": { "account": "Cuenta de la cual retirar firmante", "signer": "Firmante" }, "title": "Remover firmante" }, "set-account-options": { "title": "Establecer opciones de cuenta" }, "set-home-domain": { "title": "Establecer dominio" }, "set-inflation-destination": { "summary": { "new-destination": "Nuevo destino" }, "title": "Establecer destino de la inflación" }, "set-master-key-weight": { "title": "Establecer el peso de la llave master" } }
};
const actions$2 = { "dismiss": "Desechar", "submit": "Enviar ahora" };
const inputs$7 = { "destination": { "label": "Dirección de destino", "placeholder": "GABCD..., MABCD... o alice*example.org" }, "price": { "label": "Monto", "placeholder": "Max. {{amount}}" } };
const title$a = { "send": "Envía fondos", "receive": "Recibe fondos" };
const validation$7 = { "memo-required": "Establecer un Memo cuando envía fondos a {{destination}}", "memo-too-long": "Memo muy largo.", "no-destination": "Ninguna dirección especificada.", "no-price": "Ningún monto especificado.", "not-enough-funds": "Fondos insuficientes.", "invalid-destination": "Se esperaba una llave pública o una dirección Stellar.", "invalid-price": "Monto no válido.", "integer-memo-required": "El Memo debe ser un número entero", "asset-missing": "Ningún activo seleccionado." };
const Payment$2 = {
  actions: actions$2,
  "memo-metadata": { "label": { "default": "Memo", "id": "Memo (ID)", "text": "Memo (Texto)" }, "placeholder": { "optional": "Descripción (opcional)", "mandatory": "Descripción (obligatoria)" } },
  inputs: inputs$7,
  title: title$a,
  validation: validation$7
};
const action$6 = { "add-asset": "Añadir activo", "submit": "Enviar orden" };
const advanced$2 = { "header": "Avanzado" };
const inputs$6 = { "estimated-costs": { "label": { "buy": "Costos estimados", "sell": "Retorno estimado" } }, "primary-amount": { "label": { "buy": "Monto a comprar", "sell": "Monto a vender" }, "max-button": { "label": "Max" }, "placeholder": "Max. {{amount}}" }, "primary-asset-selector": { "label": { "buy": "Compras", "sell": "Vendes" } }, "secondary-asset-selector": { "label": { "buy": "Gastas", "sell": "Recibes" } } };
const title$9 = "Negociar";
const validation$6 = { "primary-amount-missing": "Ningún valor especificado.", "primary-asset-missing": "Ningún activo seleccionado.", "secondary-asset-missing": "Ningún activo seleccionado.", "invalid-amount": "Valor especificado no válido.", "invalid-price": "Precio no válido" };
const warning$2 = { "title": "Advertencia", "message": "La diferencia entre precio de compra y precio de venta es cercana a {{spread}}%." };
const Trading$2 = {
  action: action$6,
  "action-selection": { "buy": { "description": "Adquirir alguna cantidad de un activo en el intercambio distribuido", "label": "Adquirir activo" }, "sell": { "description": "Negociar algún monto de un activo a cambio de otro", "label": "Vender activo" } },
  advanced: advanced$2,
  inputs: inputs$6,
  "no-assets-info": "Esta cuenta aún no usa activos diferentes a Lumens Stellar.",
  title: title$9,
  "trading-price": { "default-label": "Precio (límite)", "label": "Precio por {{unit}} (límite)" },
  validation: validation$6,
  warning: warning$2
};
const payment$5 = { "account-selector": "Select the account to use", "action": { "dismiss": "Dismiss", "select": "Select" }, "error": { "no-activated-accounts": "No activated accounts found.", "no-accounts-with-trustline": "No accounts with matching trustline found." }, "uri-content": { "message": "Message" } };
const transaction$3 = { "account-selector": { "source-account": "Select the source account", "signing-account": "Select the account that will sign the transaction" }, "action": { "dismiss": "Dismiss", "select": "Select" }, "error": { "signer-not-imported": "The transaction request specified '{{signer}}' as the target signer but this account is not imported.", "no-eligible-accounts": "No eligible account found." }, "hint": "Hint", "uri-content": { "message": "Message" }, "warning": "The origin of this request cannot be verified! Decline when in doubt." };
const TransactionRequest$2 = {
  "no-accounts": { "action": { "dismiss": "Dismiss" }, "info": { "1": "No accounts found for the specified network.", "2": "You must import an account before you can sign transaction requests." }, "title": "Transaction proposed" },
  payment: payment$5,
  transaction: transaction$3,
  "stellar-uri": { "header": { "origin-domain": "The following transaction has been proposed by <1>{{originDomain}}<3>", "warning": "The origin of this request cannot be verified! Decline when in doubt." }, "title": "Transaction proposed" },
  "verify-trusted-service": { "action": { "trust": "Trust", "cancel": "Cancel" }, "info": { "1": "You opened a Stellar URI originating from an unknown origin", "2": "If you trust this domain you can add this service to your list of trusted services.", "3": "You can view and edit your list of trusted services anytime in the application settings." }, "title": "Verify Trusted Service" }
};
const authentication$2 = { "sidebar": { "headline": "Autenticación", "info": { "1": "El emisor del activo requiere que te conectes a su servicio usando tu cuenta.", "2": "Una transacción de verificación se firmará para probar la propiedad de la cuenta." } } };
const initial$2 = { "action": { "proceed": "Proceder" }, "body": { "asset-selector": { "label": { "deposit": "Activo", "short": "Activo", "withdrawal": "Activo para retiro" }, "no-assets": "Ningún activo a retirar" }, "method-selector": { "info-item": { "asset": "Favor seleccionar un tipo", "no-asset": "Seleccionar un activo primero" }, "label": { "deposit": "Tipo de depósito", "withdrawal": "Tipo de retiro" } } }, "sidebar": { "deposit": { "headline": "Agregar fondos a tu cuenta", "info": { "1": "Compra Lúmenes Stellar (XLM) o deposita recursos en tu cuenta. Envía dinero desde tu cuenta bancaria, ETH de tu monedero Ethereum, etc.", "2": "Sunce actúa como un cliente para el servicio ofrecido exclusivamente por el emisor del activo." } }, "withdrawal": { "headline": "Qué retirar?", "info": { "1": "Retirar activos de tu cuenta, como USD a tu banco o ETH a tu monedero Ethereum.", "2": "Sunce actúa como un cliente para el servicio ofrecido exclusivamente por el emisor del activo." } } } };
const title$8 = { "deposit": "Agregar fondos", "withdrawal": "Retirar fondos" };
const TransferService$2 = {
  authentication: authentication$2,
  "deposit-success": { "action": { "close": "Cerrar" }, "body": { "deposit-pending": "Depósito pendiente", "info": { "1": "{{domain}} está esperando por tu depósito.", "2": "Los fondos serán acreditados a tu cuenta Stellar cuando el depósito sea acreditado al emisor del activo." } }, "sidebar": { "headline": "Hecho", "info": "El depósito fue aceptado y será procesado por el emisor del activo cuando reciba el pago." } },
  "form-builder": { "placeholder": { "optional": "(Opcional) {{name}}" } },
  initial: initial$2,
  "kyc-denied": { "sidebar": { "headline": "Conoce tu cliente", "info": "Haz sido rechazado: El servicio fue deshabilitado para ti. Por favor contacta al emisor del activo." } },
  "kyc-pending": { "action": { "continue": "Continua", "open-again": "Abrir de nuevo" }, "body": { "additional-info-needed": "Se necesita información adicional." }, "sidebar": { "headline": "Conoce tu Cliente", "info": { "1": "El servicio solo funcionará si proporcionas información personal sobre ti.", "2": "Esto usualmente pasa por motivos legales." } } },
  "no-withdrawable-assets": { "action": { "add-asset": "Agregar activo" }, "body": { "no-withdrawable-assets": "Esta cuenta no contiene activos para retirar." } },
  "purchase-lumens": { "sidebar": { "headline": "Comprar Lúmenes Stellar", "info": { "1": "Ofrecemos opciones para comrpar Lumenes Stellar que no involucran a un emisor de activos Stellar.", "2": "Los Lúmenes Stellar (XLM) son las moneda nativa de la red Stellar. Se usan para pagar los costos de transacción, entre otras cosas." } } },
  title: title$8,
  "transaction-details": { "action": { "done": "Hecho", "withdraw": "Retirar" }, "body": { "amount": { "error": { "amount-greater-than-balance": "Monto especificado es mayor que el saldo" }, "label": { "deposit": "Monto a depositar", "withdrawal": "Monto a retirar" } }, "amount-to-receive": { "label": "Monto a recibir" }, "deposit-instructions": { "label": "Instrucciones de depósito" }, "eta": { "label": "ETA", "not-available": "N / A" }, "fees": { "label": "Gastos", "value": { "unknown": "Desconocido" } }, "information": { "label": "Información" } }, "sidebar": { "deposit": { "headline": "Sumario del depósito", "info": { "1": "Asegúrate de enviar los fondos a la dirección correcta.", "2": "El emisor del activo acreditará los tokens una vez que tu depósito sea acreditado." } }, "withdrawal": { "headline": "Casi hecho", "info": { "1": "Verifica el formulario y provee un monto para retirar si es necesario.", "2": "El retiro está casi listo." } } } },
  "transaction-status": { "error": { "rejected": { "deposit": "Depósito rechazado", "withdrawal": "Retiro rechazado" }, "contact": "Contacta a {{domain}}." }, "incomplete": { "already-redirected": { "info": { "1": "{{domain}} está verificando tu información personal. Por favor intenta más tarde.", "2": "Tiempo estimado para terminar: {{eta}}" } }, "not-redirected": { "info": "{{domain}} solicita que proveas información adicional." } }, "more-info-url": { "info": "Para más información visita" }, "pending-user-transfer-start": { "info": "{{domain}} te solicita más información." } },
  "withdrawal-success": { "action": { "close": "Cerrar" }, "body": { "withdrawal-in-progress": "Retiro en proceso", "info": { "1": "{{domain}} esta procesando el retiro.", "2": "Los fondos serán deducidos de la tu cuenta Stellar y deberían ser acreditados a tu cuenta de retiro prontamente." } }, "sidebar": { "headline": "Hecho", "info": "Tu retiro ha sido aceptado y será procesado por el emisor del activo." } },
  "transfer-details": { "action": { "proceed": "Proceder" }, "body": { "destination": { "name": "Cuenta de destino" }, "dest_extra": { "name": "Datos adicionales de destino (ninguna descripción)" }, "min-max-amount": { "label": "Monto", "max-amount": "Max. {{amount}} {{assetCode}}", "min-amount": "Min. {{amount}} {{assetCode}}" }, "fee": { "helper-text": "Como debitado por {{domain}}", "label": { "deposit": "Comisión de depósito", "withdrawal": "Comisión de retiro" } } }, "sidebar": { "deposit": { "headline": "Detalles del depósito", "info": { "1": "Detalles adicionales sobre tu depósito.", "2": "Dependiendo de lo que el emisor del activo requiera, podrías tener que entrar información adicional aquí." } }, "withdrawal": { "headline": "Detalles del retiro", "info": { "1": "Detalles adicionales sobre tu depósito.", "2": "Dependiendo de lo que el emisor del activo requiera, podrías tener que entrar información adicional aquí." } } } }
};
const translations$2 = {
  "account-settings": AccountSettings$2,
  account: Account$2,
  app: App$3,
  "app-settings": AppSettings$2,
  "create-account": CreateAccount$2,
  generic: Generic$2,
  operations: Operations$2,
  payment: Payment$2,
  trading: Trading$2,
  "transaction-request": TransactionRequest$2,
  "transfer-service": TransferService$2
};
const settings$3 = { "delete-account": { "text": { "primary": "Unisci o elimina account" } }, "export-secret-key": { "text": { "primary": "Esporta chiave segreta", "secondary": "Decifra e mostra la chiave privata" } }, "multi-sig": { "text": { "primary": "Multi-firma", "secondary": { "short": "Gestisci i cofirmatari", "long": "Crea account con firma multipla e gestisci i co-firmatari" } } }, "set-password": { "text": { "primary": { "account-protected": "Cambia la password", "account-not-protected": "Impostar la password" }, "secondary": { "account-protected": "Il tuo account è sicuro, protetto da una password", "account-not-protected": "Il tuo account non è protetto" } } } };
const AccountSettings$1 = {
  "account-deletion": { "action": { "cancel": "Annulla", "confirm": "Conferma", "delete": "Elimina", "merge": { "long": "Unisciti a", "short": "Unisci" } }, "confirm": { "title": "Conferma la cancellazione", "text": { "confirm": "Sei sicuro?", "delete": "L'account verrà eliminato", "merge": "e i fondi rimanenti trasferiti" } }, "remaining-funds": { "text": "Invia i fondi rimanenti a" }, "text": { "1": `Sei sicuro di voler eliminare l'account "{{accountName}}"?`, "2": "Assicurati di eseguire il backup della tua chiave privata o di unire i fondi in un altro tuo account, poiché ci sono ancora fondi rimasti!" }, "title": "Conferma l'eliminazione dell'account", "warning-dialog": { "close": { "label": "ok" } }, "warnings": { "cannot-merge": { "text": "Non è ancora possibile unire l'account. Per prima cosa devi annullare tutti gli ordini di trading aperti e rimuovere tutte le risorse.", "title": "Azione manuale richiesta" } } },
  "custom-trustline": { "action": { "cancel": "Annulla", "trust": { "long": "Fidati della moneta", "short": "Fiducia" } }, "textfield": { "code": { "label": "Codice" }, "issuer": { "label": "Emittente", "placeholder": "Rilascio della chiave pubblica dell'account" }, "limit": { "label": "Limite (opzionale)", "placeholder": "Limita la fiducia in questa risorsa / saldo massimo da mantenere" } }, "title": "Aggiungi risorsa personalizzata" },
  "export-key": { "action": { "confirm": "Fatto", "reveal": { "long": "Rivela la chiave", "short": "Fai clic per rivelare la chiave segreta" } }, "info": { "backup": { "title": "Esegui il backup della tua chiave segreta ora", "paragraph-1": "Il backup della chiave segreta è l'unico modo per recuperare i tuoi fondi se dimentichi la password o non riesci più ad accedere al tuo dispositivo.", "paragraph-2": "Annota la chiave o stampala. Conservala in un luogo sicuro e non condividerla con nessuno." }, "export": { "paragraph-1": "Il backup della chiave segreta è l'unico modo per recuperare i tuoi fondi se dimentichi la password o non riesci più ad accedere al tuo dispositivo.", "paragraph-2": "Annota la chiave o stampala. Conservala in un luogo sicuro e non condividerla con nessuno." }, "secret-key": "Annota la chiave su carta e conservala in un luogo sicuro.", "tap-to-copy": "Tocca per copiare" }, "textfield": { "password": { "label": "Password" } }, "title": { "default": "Esporta la chiave segreta", "initial-backup": "Backup della chiave segreta" } },
  "manage-signers": { "action": { "add-co-signer": { "long": "Aggiungi co-firmatario", "short": "Firmatario" }, "cancel": "Annulla", "apply": { "long": "Applica i cambiamenti", "short": "Applica" } }, "signers-editor": { "list": { "item": { "weight": "Peso", "local-key": "Chiave locale" } }, "new-signer": { "label": "Chiave Pubblica o indirizzo Stellar", "placeholder": { "long": "GABCDEFGHIJK… o alice*example.org", "short": "GABC… o indirizzo" } }, "validation": { "existing-signer": "Impossibile aggiungere un firmatario esistente.", "integer-required": "Deve essere un numero intero.", "invalid-stellar-address": "Attesa una chiave pubblica o un indirizzo stellare." } }, "textfield": { "weight-threshold": { "explanation": { "required-signatures": "Ogni transazione deve essere firmata da {{amount}} firmatari", "required-weight": "Ogni transazione deve essere firmata dai firmatari con un peso chiave combinato di {{amount}}" }, "label": { "required-signatures": "Firme richieste", "required-weight": "Peso chiave richiesto" } } }, "title": { "long": "Gestisci firmatari", "short": "Gestisci i firmatari dell'account" }, "validation": { "no-signers": "Nessun firmatario rimasto. Non chiuderti fuori!", "invalid-weight-type": "Il peso deve essere un numero intero", "threshold-higher-than-weights": "Soglia superiore ai pesi chiave combinati", "no-threshold": "Si prega di impostare una soglia" } },
  "set-password": { "action": { "change-password": { "long": "Cambia la password", "short": "Modifica" }, "remove-password": { "long": "Rimuovi la password", "short": "Rimuovi" } }, "notification": { "password-changed": "Password cambiata.", "password-set": "Password impostata.", "password-removed": "Password rimossa." }, "textfield": { "prev-password": { "label": "Password attuale" }, "next-password": { "label": "Nuova password" }, "next-password-repeat": { "label": "Ripetere la nuova password" } }, "title": { "change-password": "Cambia la password", "set-password": "Impostare la password" }, "validation": { "next-password-missing": 'Immettere una password o impostare "Rimuovi password".', "next-password-repeat-missing": "Ripeti la password.", "passwords-no-match": "La password non corrisponde", "previous-password-missing": "Manca la password attuale." } },
  settings: settings$3
};
const action$5 = { "receive": "Ricevi", "send": "Invia" };
const transactions$1 = { "action": { "friendbot": { "description": "Ottieni alcuni lumen di testnet gratuiti", "label": "Chiedi all'amicobot" }, "navigate-to-deposit": { "description": "Con carta di credito, bonifico, etc.", "label": "Fondi di deposito" } }, "offer-list": { "text": { "buy": "Acquista <1 /> per <3 />", "sell": "Vendi <1 /> per <3 />", "for": "per" }, "title": "Ordini aperti" }, "transaction-list": { "offer-description": { "prefix": { "default": "Ordine", "cancel": "Annulla Ordine", "update": "Aggiorna l'ordine" }, "buy": "Acquista {{buyingAmount}} {{buyingCode}} per {{sellingAmount}} {{sellingCode}}", "sell": "Vendi {{sellingAmount}} {{sellingCode}} per {{buyingAmount}} {{buyingCode}}" }, "item": { "from": "A partire dal", "to": "Per", "memo": "Memo", "remote-public-keys": { "more": "Di Più" }, "trust": { "add-trust": "Fidati della risorsa {{asset}}", "remove-trust": "Rimuovi la fiducia nella risorsa {{asset}}" } }, "load-more": { "label": "Carica di più" }, "title": "Le transazioni recenti" }, "signature-request-list": { "title": { "requests-to-cosign": "Transazioni da co-firmare", "requests-waiting-for-others": "In attesa di firme aggiuntive" } } };
const title$7 = { "password-status": { "protected": "Protetto da password", "unprotected": "No Password" }, "tooltip": { "multi-sig-account": "Account multi-firma", "security-service": "{{service}} Protezione" }, "placeholder": "Nome utente…", "testnet": "Testnet" };
const Account$1 = {
  action: action$5,
  "add-asset": { "action": { "add-asset": "Aggiungi risorsa all' account", "remove": "Rimuovi", "trade": "Negozia" }, "button": { "add-custom-asset": { "label": "Aggiungi risorsa personalizzata" } }, "item": { "issuer": { "secondary": { "one-asset": "1 risorsa trovata", "more-than-one-asset": "{{amount}} risorse trovati" } }, "no-result": { "primary": "Nessuna risorsa trovato", "secondary": "Nessuna risorsa o emittente corrispondente alla tua ricerca" } }, "search-field": { "placeholder": "Cerca risorse tramite codice o nome…" }, "title": "Aggiungi risorsa" },
  "asset-details": { "lumen": { "description": { "label": "Descrizione", "text": "Il token nativo della rete Stellar.\n\n Ogni account della rete ha un saldo di lumens. I Lumens sono usati per pagare le commissioni sulle transazioni." } }, "general": { "account-flags": { "auth-required": "Autorizzazione tramite emittente richiesta", "auth-not-required": "Nessuna autorizzazione richiesta", "auth-revocable": "Autorizzazione revocabile", "auth-not-revocable": "Autorizzazione non revocabile", "auth-immutable": "Queste impostazioni sono immutabili", "auth-mutable": "L'emittente può cambiare queste impostazioni", "label": "Impostazioni del conto" }, "anchor-asset": { "label": "Relativo a" }, "conditions": { "label": "Condizioni" }, "description": { "label": "Descrizione" }, "issuing-account": { "label": "Conto di emizzione" }, "organisation": { "address": { "label": "Indirizzio" }, "dba": { "label": "Fare affari come" }, "description": { "label": "Descrizione" }, "email": { "label": "indirizzo di posta elettronica" }, "name": { "label": "Nome dell'organizzazione" }, "phone-number": { "label": "Numero di telefono" }, "website": { "label": "Sito web" } }, "redemption-instructions": { "label": "Istruzioni sul rimborso" } } },
  "balance-details": { "button": { "add-asset": { "label": "Aggiungi risorsa al tuo Conto" } }, "item": { "spendable-balance": { "primary": "Saldo spendibile" } }, "spendable-balances": { "base-reserve": { "primary": "Riserva di base", "secondary": "Riserva di base fissa" }, "data-reserve": { "primary": "Riserva di campi dati", "secondary": "Campi dati dell'account" }, "headline": "Importi in XLM", "open-orders-reserve": { "primary": "Riserva ordini aperti", "secondary": "Riserva per ordine" }, "selling-liabilities": { "primary": "Importo da vendere", "secondary": "Impegnato ad aprire gli ordini" }, "signers-reserve": { "primary": "Riserva dei firmatari dell'account", "secondary": { "single-key": "Riserva chiave singola", "multiple-keys": "Co-firmatari della chiave principale" } }, "spendable-balance": { "primary": "Saldo spendibile", "secondary": "Importo liberamente utilizzabile" }, "total-balance": { "primary": "Saldo totale", "secondary": "Il tuo saldo, incl. inutile" }, "trustline-reserve": { "primary": "Riserva di fiducia", "secondary": "Per ogni saldo non XLM" } } },
  "saved-addresses": { "title": "Destinazioni Preferite", "search-field": { "placeholder": "Cerca risorse tramite nome o indirizzo…" }, "item": { "no-result": { "primary": "Nessun record corrispondente", "secondary": "Nessun nome o indirizzo corrisponde alla ricerca" } }, "button": { "add": { "label": "Aggiungi Indirizzo" } } },
  "saved-address-details": { "address": { "label": "Indirizzo", "placeholder": "Indirizzo" }, "label": { "label": "Etichetta", "placeholder": "Etichetta" }, "validation": { "no-address": "Manca l'indirizzo", "no-label": "Manca l'etichetta", "label-too-long": "L'etichetta è troppo lunga. Considerate un massimo di {{max}} caratteri", "invalid-address": "L'indirizzo non è valido" }, "button": { "add": { "label": "Salvare" }, "remove": { "label": "Rimuovere" } } },
  "context-menu": { "account-settings": { "label": "Impostazioni dell 'account" }, "assets-and-balances": { "label": "Risorse & Saldi" }, "deposit": { "label": "Aggiungi fondi" }, "trade": { "label": "Negozia" }, "transactions": { "label": "Transazioni" }, "withdraw": { "label": "Ritira" }, "saved-addresses": { "label": "Destinazioni Preferite" } },
  "purchase-lumens": { "legal-confirmation": { "action": { "confirm": "Capisco" } }, "moonpay": { "text": { "primary": "MoonPay", "secondary": "Acquista Stellar Lumens immediatamente utilizzando la tua carta di debito / credito o Apple Pay" }, "legal-confirmation": "Verrai reindirizzato a moonpay.io, un servizio di terze parti. Il processo di deposito è gestito da Moon Pay Ltd, non da Sunce o Montelibero. <1 /> <2 /> Contatta l'assistenza di moonpay.io per domande relative al tuo deposito." }, "title": "Acquista Stellar lumen" },
  "remove-trustline": { "action": { "cancel": "Annulla", "remove": "Rimuovi" }, "text": { "warning": "Non è possibile rimuovere questa risorsa a meno che il saldo della risorsa non sia zero.", "info": `Stai per rimuovere <1> {{asset}} </1> dall'account "{{accountName}}".` }, "title": "Conferma la rimozione della risorsa" },
  transactions: transactions$1,
  "transaction-review": { "action": { "confirm": "Conferma", "cancel-order": "Annulla Ordine", "dismiss": "Respingi", "inspect": "Ispeziona", "show-more": "Mostra più dettagli" }, "account-creation-warning": { "primary": "Finanziamento di un nuovo account", "secondary": "Finanziamento di un conto vuoto. Assicurati che la destinazione sia corretta." }, "dangerous-transaction-warning": { "primary": "Transazione avviata da un account non riconosciuto", "secondary": "Si prega di rivedere attentamente. In caso di dubbio, annullare." }, "dismissal": { "action": { "cancel": "Annulla", "confirm": "Conferma" }, "header": "Ignorare la transazione multi-firma in sospeso?", "title": "Conferma" }, "signers": { "heading-details": { "single-signature": "Firma singola", "default-signatures": "{{threshold}} di {{length}} multi-firma", "custom-consensus": "Multi-firma di consenso personalizzato" }, "label": "Firmatari {{details}}" }, "signer-status": { "tooltip": { "has-signed": "Ha firmato la transazione", "has-not-signed": "In attesa della loro firma" } }, "summary": { "item": { "account": { "label": "Account" }, "authenticating-account": { "label": "Account di autenticazione" }, "expiry": { "label": "Scadenza" }, "max-fee": { "label": "Canone massimo" }, "service": { "label": "Servizio" }, "submission": { "label": "Sottomissione" }, "tx-hash": { "label": "Hash di transazione" } } }, "textfield": { "password": { "label": "Parola d'ordine" } }, "title": { "transaction": "Transazione", "payment": "Pagamento", "delete-orders-operation": "Elimina ordini di trading", "web-auth": "Autenticazione Web" }, "transaction-memo": { "label": "{{type}} Promemoria" }, "validation": { "no-account-data": "Violazione invariante: impossibile trovare i dati dell'account di origine della transazione nel set di sottoscrizioni dei dati dell'account.", "no-manage-data-operation": "Violazione invariante: la transazione di autenticazione web stellare deve contenere un'operazione di manage_data.", "password-required": "Password richiesta" } },
  title: title$7
};
const notification$1 = { "desktop": { "new-signature-request": { "title": "Nuova transazione da co-firmare", "body": "Da {{signersHavingSigned}}" }, "received-payment": { "title": "Pagamento ricevuto | {{account}}", "body": "Ricevuto {{amount}} {{assetCode}}" }, "trade-completed": { "title": "Scambio completato | {{account}}" } }, "details": { "action": { "dismiss": "Respingi" }, "support": "Hai un problema con l'app? <1 /> Contattaci tramite", "title": "Errore", "offline": "Disconnesso" }, "permission": { "app-notification": { "error": "Abilita nelle impostazioni del sistema operativo", "granted": { "title": "Notifiche abilitate", "text": "Sunce ora mostrerà le notifiche" }, "message": "Abilita le notifiche dell'app" } } };
const App$2 = {
  "account-list": { "add-account-card": { "label": "Aggiungi account" }, "badges": { "tooltip": { "multi-sig": "Account multi-firma", "security-service": "{{service}} Protezione" } } },
  "all-accounts": { "switch": { "label": "Testnet" }, "update": { "notification": { "start": "Avvio del download dell'aggiornamento ...", "success": "Il download è pronto e verrà installato al prossimo riavvio!" }, "tooltip": "Aggiornamento disponibile" }, "title": { "testnet": "Account Testnet", "mainnet": "I miei account" } },
  notification: notification$1,
  "terms-and-conditions": { "action": { "confirm": "Conferma" }, "header": "Benvenuto in Sunce", "checkbox": { "1": { "label": "Sono consapevole di essere responsabile della sicurezza dei miei fondi e che Sunce non è in grado di recuperare i miei fondi in caso di perdita di dati o se perdo le mie credenziali." }, "2": { "label": "I have read, understood and agree to the <1>Terms and Conditions</1> <2>&amp;</2> <3>Privacy policy</3> of Sunce." } } }
};
const settings$2 = { "biometric-lock": { "text": { "primary": { "default": "Blocco delle impronte digitali", "ios": "Face ID / Touch ID" }, "secondary": { "disabled": "L'autenticazione biometrica è disabilitata", "enabled": "L'autenticazione biometrica è abilitata", "not-enrolled": "Configurare l'autenticazione biometrica nelle impostazioni del sistema operativo" } }, "prompt": { "enable": "Sblocca il dispositivo una volta per abilitare la funzione.", "disable": "Sblocca il dispositivo per disabilitare il blocco automatico." } }, "language": { "auto-detect": { "label": "auto" }, "text": { "primary": "Lingua", "secondary": "Cambia la lingua dell'interfaccia utente qui" } }, "memo": { "text": { "primary": "Mostra memo", "secondary": { "hidden": "I promemoria sono nascosti nella panoramica delle transazioni", "shown": "I promemoria vengono visualizzati nella panoramica delle transazioni" } } }, "multi-sig": { "text": { "primary": "Abilita firma multipla", "secondary": { "enabled": "Le funzionalità multi-firma sono abilitate", "disabled": "Le funzionalità multi-firma sono disabilitate" } } }, "testnet": { "text": { "primary": "Mostra account Testnet", "secondary": { "cannot-disable": "Non può essere disabilitato perché hai già aggiunto account testnet", "hidden": "Gli account Testnet sono nascosti", "shown": "Vengono visualizzati gli account Testnet" } } }, "title": "Impostazioni", "trusted-services": { "text": { "primary": "Gestisci servizi attendibili", "secondary": "Rimuovi servizi attendibili" } }, "saved-addresses-export": { "text": { "primary": "Importazione/esportazione di indirizzi salvati", "secondary": "Accesso rapido a tutti gli indirizzi salvati in formato JSON" } }, "dust": { "text": { "primary": "Mostra transazioni di polvere", "secondary": { "hidden": "Le transazioni inferiori a 0,001 XLM sono nascoste nella vista delle transazioni", "shown": "Le transazioni inferiori a 0,001 XLM vengono visualizzate nella vista delle transazioni" } } }, "create-claimable-balance": { "text": { "primary": "Mostra le transazioni Creare Saldo Reclamabile", "secondary": { "hidden": "Le transazioni Crea Saldo Reclamabile sono nascoste nella vista delle transazioni", "shown": "Le transazioni Crea Saldo Reclamabile sono visualizzate nella vista transazioni" } } } };
const AppSettings$1 = {
  settings: settings$2,
  "trusted-services": { "info": "I servizi attendibili sono servizi Web che possono interagire con il portafoglio Sunce richiedendo i dati dell'account o proponendo transazioni. È possibile aggiungere un nuovo servizio una volta che tenta di interagire con Sunce.", "service-selection": { "action": { "cancel": "Annulla", "confirm": "Conferma" }, "confirm": { "title": "Conferma la rimozione", "text": "Il servizio verrà rimosso dal tuo elenco di fiducia. Sei sicuro?" }, "no-services": "Nessun servizio affidabile" } }
};
const action$4 = { "cancel": "Annulla", "confirm": "Conferma", "create": "Crea un profilo", "import": "Importa account" };
const confirm$1 = { "text": "Stai per creare un account senza protezione tramite password. Chiunque abbia accesso al tuo dispositivo avrà accesso ai fondi del tuo account. <1 /> <3 /> Sei sicuro di voler continuare senza impostare una password?", "title": "Continua senza password" };
const header$1 = { "placeholder": { "mainnet": "Nuovo account", "testnet": "Nuovo account Testnet" } };
const inputs$5 = { "import": { "helper-text": "Una chiave segreta Stellar è lunga 56 caratteri alfanumerici e inizia con una S.", "placeholder": "SABCDEFGH ...", "label": "Chiave segreta", "title": "Importa esistente" }, "password": { "label": "Parola d'ordine", "placeholder": "Inserisci una password" }, "password-repeat": { "label": "Ripeti la password", "placeholder": "Ripeti la tua password" } };
const options$1 = { "import": { "label": "Importa chiave segreta", "description": "Ripristina l'account dal backup" }, "password": { "label": "Protezione della password", "protected": "La tua chiave segreta verrà crittografata", "unprotected": "La tua chiave segreta non sarà protetta" } };
const validation$5 = { "invalid-key": "Chiave privata stellare non valida.", "no-account-name": "Non è stato inserito alcun nome account.", "no-password": "Non è stata inserita alcuna password.", "password-no-match": "La password non corrisponde.", "same-account": "Già aggiunto questo account." };
const CreateAccount$1 = {
  action: action$4,
  "action-selection": { "create": { "description": "Crea un nuovo account vuoto", "label": "Crea un profilo" }, "import": { "description": "Ripristina l'account dal backup", "label": "Importa account" } },
  "base-name": { "mainnet": "Il mio account", "testnet": "Il mio account Testnet" },
  confirm: confirm$1,
  header: header$1,
  inputs: inputs$5,
  options: options$1,
  validation: validation$5
};
const error$1 = { "asset-not-depositable-error": "La risorsa {{asset}} sembra non essere depositabile tramite {{domain}}", "asset-not-withdrawable-error": "La risorsa {{asset}} sembra non essere ritirabile tramite {{domain}}", "boundary": { "header": "Oops! Qualcosa è andato storto...", "contact-us": "Contattaci tramite" }, "bad-response-error": "Risposta errata ({{status}}) dal server {{server}}", "bad-transaction-error": "Cattiva transazione data. Era prevista una transazione o TransactionRecord, ma ottenuto: {{transaction}}", "bio-auth-test-canceled": "Autenticazione biometrica annullata", "expected-json-response-error": "Previsto che {{url}} restituisse una risposta JSON. Il tipo di contenuto era invece {{contentType}}.", "existing-account-error": "Esiste già un account con quel nome.", "fetch-account-data-error": "Impossibile recuperare i dati dell'account di {{account}} da {{horizon}}", "fetch-signature-requests-error": "Recupero delle richieste di firma non riuscito: {{response}} \nService: {{service}}", "invariant-violation-error": "Violazione invariante: {{message}}", "low-reserve-order-error": "Impossibile effettuare l'ordine perché il saldo XLM spendibile è troppo basso.", "memo-already-specified-error": "Impossibile impostare un promemoria personalizzato. Il record della federazione di {{destination}} specifica già il memo.", "missing-info-error": "Impossibile effettuare la transazione, perché {{transferServer}} non sono state inviate tutte le informazioni richieste.", "multi-sig-event-stream-double-errored-error": "Multi-signature update event stream double-errored: {{url}}", "no-callback-url-error": "Impossibile inviare di nuovo al servizio multi-firma. Per la richiesta di firma non è stato impostato alcun URL di richiamata.", "non-existent-destination-error": "Non posso pagare {{assetCode}}, poiché l'account di destinazione non esiste ancora. Le creazioni dell'account devono sempre essere eseguite tramite XLM.", "only-interactive-kyc-supported-error": "Sono supportati solo KYC interattivi.", "password-required-error": "Account {{accountName}} è protetto da password, ma non è stata inserita alcuna password.", "promise-timeout-error": "Promessa scaduta dopo {{timeout}} ms", "request-failed-error": "Richiesta a {{target}} fallita {{status}}: {{message}}", "stellar-address-not-found-error": "Indirizzo stellare non trovato: {{address}}", "stellar-address-request-failed-error": "Risoluzione stellare dell'indirizzo di {{address}} non riuscita.", "stellar-uri-verification-error": "Non è stato possibile verificare la firma di Stellar URI.", "stellar-uri-callback-format-error": "Stellar URI's callback is not valid: {{reason}}", "submission-failed-error": "Invio della transazione a {{endpoint}} fallita {{status}}: {{message}}", "testnet-endpoint-not-available-error": "{{service}} non fornisce un endpoint testnet.", "timeout-error": "Richiesta scaduta", "unexpected-action-error": "Azione imprevista: {{action}}", "unexpected-state-error": "Stato imprevisto riscontrato: {{state}}", "unexpected-response-type-error": "Tipo di risposta imprevista: {{type}} / ${dataType}", "unexpected-stellar-uri-type-error": "L'uri in arrivo {{incomingURI}} non corrisponde a nessun tipo previsto.", "unknown-error": "Si è verificato un errore sconosciuto.", "update-already-running-error": "L'aggiornamento è già in esecuzione!", "wrong-password-error": "Password errata.", "wrong-request-start-error": "Richiesta prevista per iniziare con 'web+stellar:'", "submission-error": { "default": "Transazione rifiutata dalla rete. Error code(s): {{codes}}", "internal-server-error": "Il server ha avuto problemi a elaborare questa richiesta. Per favore riprova.", "op-result-code": { "op_cross_self": "L'ordine contrasterebbe un tuo ordine aperto.", "op_has_sub_entries": "L'account ha ancora linee di fiducia (attività) o ordini di trading aperti.", "op_immutable_set": "L'account non è modificabile (set di flag AUTH_IMMUTABLE).", "op_line_full": "Il saldo dell'account di destinazione supererebbe la fiducia della destinazione nella risorsa.", "op_low_reserve": "Transazione rifiutata dalla rete. Il saldo del conto di origine o di destinazione sarebbe inferiore al saldo minimo.", "op_no_account": "L'account di destinazione non esiste.", "op_no_issuer": "La risorsa non è valida. Emittente di risorsa errato.", "op_no_trust": "L'account di destinazione non considera attendibile la risorsa che stai tentando di inviare.", "op_offer_not_found": "L'offerta non esiste.", "op_self_not_allowed": "L'account non può fidarsi delle risorse emesse da solo.", "op_underfunded": "Fondi insufficienti per eseguire questa operazione." }, "tx-result-code": { "insufficient_fee": "La rete richiede tariffe più elevate rispetto a quelle stabilite nella transazione.", "internal_error": "Si è verificato un errore sconosciuto sul server Stellar.", "no_account": "Account di origine non trovato.", "tx_bad_auth": "Troppe poche firme valide o rete sbagliata.", "tx_bad_auth_extra": "Firme inutilizzate allegate alla transazione.", "tx_bad_seq": "Mancata corrispondenza del numero di sequenza. Ricrea la transazione.", "tx_insufficient_balance": "Saldo insufficiente. Il saldo scenderebbe al di sotto della riserva minima.", "tx_too_late": "La bozza della transazione è scaduta. Riprova." }, "timeout": "Il server non ha risposto. Per favore riprova." } };
const Generic$1 = {
  "dialog-actions": { "close": { "label": "Vicino" } },
  error: error$1,
  "qr-reader": { "action": { "cancel": "Annulla" } },
  "submission-progress": { "pending": "Invio alla rete ...", "success": { "default": "Successo", "multisig": "Attesa per le firme mancanti", "third-party": "Attesa per l'autorizzazione del servizio di terze-parti" } },
  "testnet-badge": { "label": "Testnet" },
  "user-interface": { "copied-to-clipboard": "Copiato negli appunti." }
};
const payment$4 = { "summary": { "amount": "Quantità", "destination": "Destinazione", "source": "Fonte" }, "title": "Pagamento" };
const Operations$1 = {
  "account-merge": { "summary": { "account": "account", "merge-into": "Unisciti a" }, "title": "Unisci account" },
  "change-trust": { "summary": { "asset": "Risorsa", "issued-by": "Rilasciato da", "limit": { "label": "Limite", "value": { "unlimited": "Illimitato", "limited-to": "Limitato a {{limit}} {{code}}" } } }, "title": { "add-asset": "Aggiungi risorsa", "remove-asset": "Rimuovi risorsa" } },
  "create-account": { "summary": { "account": "Account da creare", "funding-account": "Conto di finanziamento", "funding-amount": "Importo del finanziamento" }, "title": "Crea un profilo" },
  "manage-buy-offer": { "title": { "create": "Crea ordine di acquisto", "delete": "Cancella l'ordine", "update": "Aggiorna ordine di acquisto" } },
  "manage-data": { "title": "Imposta i dati dell'account" },
  "manage-offer": { "summary": { "buy": "Acquistare", "sell": "Vendere" } },
  "manage-sell-offer": { "title": { "create": "Crea ordine di vendita", "delete": "Cancella l'ordine", "update": "Aggiorna ordine di vendita" } },
  "offer-details": { "string": "Acquista {{price}} {{buyingCode}} per {{amount}} {{sellingCode}}" },
  payment: payment$4,
  "set-options": { "add-signer": { "summary": { "account": "Account a cui aggiungere il firmatario", "key-weight": "Peso chiave", "new-signer": "Nuovo firmatario" }, "title": "Aggiungi firmatario" }, "change-signature-setup": { "summary": { "key-thresholds": { "label": "Nuove soglie chiave", "value": { "low": "Soglia bassa:    {{threshold}}", "medium": "Soglia media: {{threshold}}", "high": "Soglia alta:   {{threshold}}" } }, "required-signatures": "Firme richieste" }, "title": "Modifica la configurazione della firma" }, "remove-signer": { "summary": { "account": "Account da cui rimuovere il firmatario", "signer": "Firmatario" }, "title": "Rimuovi firmatario" }, "set-account-options": { "title": "Imposta le opzioni dell'account" }, "set-home-domain": { "title": "Imposta il dominio di casa" }, "set-inflation-destination": { "summary": { "new-destination": "Nuova destinazione" }, "title": "Imposta la destinazione dell'inflazione" }, "set-master-key-weight": { "title": "Imposta il peso della chiave master" } }
};
const actions$1 = { "dismiss": "Respingi", "submit": "Spedisci ora" };
const inputs$4 = { "destination": { "label": "Indirizzo di destinazione", "placeholder": "GABCD..., MABCD... o alice*example.org" }, "price": { "label": "Quantità", "placeholder": "Max. {{amount}}" } };
const title$6 = { "send": "Invia fondi", "receive": "Ricevi fondi" };
const validation$4 = { "memo-required": "Imposta un promemoria quando invii fondi a {{destination}}", "memo-too-long": "Memo troppo lungo.", "no-destination": "Nessuna destinazione specificata.", "no-price": "Nessun importo specificato.", "not-enough-funds": "Fondi insufficienti.", "invalid-destination": "Attesa una chiave pubblica o un indirizzo stellare.", "invalid-price": "Importo non valido.", "integer-memo-required": "Il memo deve essere un numero intero.", "asset-missing": "Nessuna risorsa selezionata." };
const Payment$1 = {
  actions: actions$1,
  "memo-metadata": { "label": { "default": "Memo", "id": "Memo (ID)", "text": "Memo (testo)" }, "placeholder": { "optional": "Descrizione (facoltativa)", "mandatory": "Descrizione (obbligatoria)" } },
  inputs: inputs$4,
  title: title$6,
  validation: validation$4
};
const action$3 = { "add-asset": "Aggiungi risorsa", "submit": "Invia ordine" };
const advanced$1 = { "header": "Avanzate" };
const inputs$3 = { "estimated-costs": { "label": { "buy": "Costi stimati", "sell": "Rendimento stimato" } }, "primary-amount": { "label": { "buy": "Importo da acquistare", "sell": "Importo da vendere" }, "max-button": { "label": "Max" }, "placeholder": "Max. {{amount}}" }, "primary-asset-selector": { "label": { "buy": "Tu compri", "sell": "Tu vendi" } }, "secondary-asset-selector": { "label": { "buy": "Trascorrere", "sell": "Ricevere" } } };
const title$5 = "Negozia";
const validation$3 = { "primary-amount-missing": "Nessun importo specificato.", "primary-asset-missing": "Nessuna risorsa selezionata.", "secondary-asset-missing": "Nessuna risorsa selezionata.", "invalid-amount": "Importo specificato non valido.", "invalid-price": "Prezzo non valido" };
const warning$1 = { "title": "Avvertimento", "message": "La differenza tra prezzo di acquisto e prezzo di vendita è circa {{spread}}%." };
const Trading$1 = {
  action: action$3,
  "action-selection": { "buy": { "description": "Acquista una certa quantità di un bene sullo scambio distribuito", "label": "Acquista risorsa" }, "sell": { "description": "Scambia una certa quantità di una risorsa con un altra", "label": "Vendi risorsa" } },
  advanced: advanced$1,
  inputs: inputs$3,
  "no-assets-info": "Questo account non utilizza ancora risorse diverse da Stellar Lumens.",
  title: title$5,
  "trading-price": { "default-label": "Prezzo (limite)", "label": "Prezzo per {{unit}} (limite)" },
  validation: validation$3,
  warning: warning$1
};
const payment$3 = { "account-selector": "Select the account to use", "action": { "dismiss": "Dismiss", "select": "Select" }, "error": { "no-activated-accounts": "No activated accounts found.", "no-accounts-with-trustline": "No accounts with matching trustline found." }, "uri-content": { "message": "Message" } };
const transaction$2 = { "account-selector": { "source-account": "Select the source account", "signing-account": "Select the account that will sign the transaction" }, "action": { "dismiss": "Dismiss", "select": "Select" }, "error": { "signer-not-imported": "The transaction request specified '{{signer}}' as the target signer but this account is not imported.", "no-eligible-accounts": "No eligible account found." }, "hint": "Hint", "uri-content": { "message": "Message" }, "warning": "The origin of this request cannot be verified! Decline when in doubt." };
const TransactionRequest$1 = {
  "no-accounts": { "action": { "dismiss": "Dismiss" }, "info": { "1": "No accounts found for the specified network.", "2": "You must import an account before you can sign transaction requests." }, "title": "Transaction proposed" },
  payment: payment$3,
  transaction: transaction$2,
  "stellar-uri": { "header": { "origin-domain": "The following transaction has been proposed by <1>{{originDomain}}<3>", "warning": "The origin of this request cannot be verified! Decline when in doubt." }, "title": "Transaction proposed" },
  "verify-trusted-service": { "action": { "trust": "Trust", "cancel": "Cancel" }, "info": { "1": "You opened a Stellar URI originating from an unknown origin", "2": "If you trust this domain you can add this service to your list of trusted services.", "3": "You can view and edit your list of trusted services anytime in the application settings." }, "title": "Verify Trusted Service" }
};
const authentication$1 = { "sidebar": { "headline": "Autenticazione", "info": { "1": "L'emittente della risorsa richiede che tu acceda al suo servizio utilizzando il tuo account.", "2": "Verrà firmata una transazione di autenticazione per dimostrare la proprietà di tale account." } } };
const initial$1 = { "action": { "proceed": "Procedi" }, "body": { "asset-selector": { "label": { "deposit": "Risorsa", "short": "Risorsa", "withdrawal": "Attività da ritirare" }, "no-assets": "Nessun patrimonio prelevabile" }, "method-selector": { "info-item": { "asset": "Seleziona un tipo", "no-asset": "Seleziona prima una risorsa" }, "label": { "deposit": "Tipo di deposito", "withdrawal": "Tipo di ritiro" } } }, "sidebar": { "deposit": { "headline": "Finanzia il tuo account", "info": { "1": "Acquista Stellar lumen (XLM) o deposita risorse per finanziare il tuo account. Invia EURO dal tuo conto bancario, ETH dal tuo portafoglio Ethereum, ecc", "2": "Sunce agisce solo come cliente del servizio offerto dall'emittente della risorsa." } }, "withdrawal": { "headline": "Cosa ritirare", "info": { "1": "Preleva risorse dal tuo account, come EURO sul tuo conto bancario o ETH sul tuo portafoglio Ethereum.", "2": "Sunce agisce solo come cliente del servizio offerto dall'emittente della risorsa." } } } };
const title$4 = { "deposit": "Aggiungi fondi", "withdrawal": "Preleva fondi" };
const TransferService$1 = {
  authentication: authentication$1,
  "deposit-success": { "action": { "close": "Chiuso" }, "body": { "deposit-pending": "Deposito in attesa", "info": { "1": "{{domain}} sta aspettando il tuo deposito.", "2": "I fondi verranno accreditati sul tuo account Stellar quando il deposito viene accreditato all'emittente della risorsa." } }, "sidebar": { "headline": "Fatto", "info": "Il tuo deposito è stato accettato e verrà elaborato dall'emittente della risorsa quando il tuo pagamento arriverà." } },
  "form-builder": { "placeholder": { "optional": "(Facoltativo) {{name}}" } },
  initial: initial$1,
  "kyc-denied": { "sidebar": { "headline": "Conosci il tuo cliente", "info": "Sei stato rifiutato: il servizio è disabilitato per te. Si prega di contattare l'emittente della risorsa." } },
  "kyc-pending": { "action": { "continue": "Continua", "open-again": "Apri di nuovo" }, "body": { "additional-info-needed": "Sono necessarie ulteriori informazioni" }, "sidebar": { "headline": "Conosci il tuo cliente", "info": { "1": "Il servizio funzionerà solo se fornisci informazioni personali su di te.", "2": "Questo di solito accade per motivi legali." } } },
  "no-withdrawable-assets": { "action": { "add-asset": "Aggiungi risorsa" }, "body": { "no-withdrawable-assets": "Questo conto non contiene risorse prelevabili." } },
  "purchase-lumens": { "sidebar": { "headline": "Acquista Stellar lumen", "info": { "1": "Offriamo opzioni per acquistare lumen che non coinvolgono un emittente di risorse Stellar.", "2": "I lumen stellari (XLM) sono i token nativi sulla rete Stellar. Vengono utilizzati per pagare le commissioni di transazione, tra le altre cose" } } },
  title: title$4,
  "transaction-details": { "action": { "done": "Fatto", "withdraw": "Ritira" }, "body": { "amount": { "label": { "deposit": "Ammontare da depositare", "withdrawal": "Importo da prelevare" } }, "amount-to-receive": { "label": "Importo da ricevere" }, "deposit-instructions": { "label": "Istruzioni di deposito" }, "eta": { "label": "ETA", "not-available": "N / A" }, "fees": { "label": "Commissioni", "value": { "unknown": "sconosciuto" } }, "information": { "label": "Informazione" } }, "sidebar": { "deposit": { "headline": "Riepilogo del deposito", "info": { "1": "Assicurati di inviare i fondi alla destinazione giusta.", "2": "L'emittente della risorsa accrediterà i token una volta che il tuo deposito è stato accreditato." } }, "withdrawal": { "headline": "Quasi fatto", "info": { "1": "Controllare il modulo e fornire un importo da prelevare se necessario.", "2": "Il ritiro è quasi pronto." } } } },
  "transaction-status": { "error": { "rejected": { "deposit": "Deposito rifiutato", "withdrawal": "Ritiro rifiutato" }, "contact": "Contatta {{domain}}." }, "incomplete": { "already-redirected": { "info": { "1": "{{domain}} sta controllando le tue informazioni personali. Per favore riprova più tardi.", "2": "Tempo stimato per il completamento: {{eta}}" } }, "not-redirected": { "info": "{{domain}} richiede di fornire informazioni aggiuntive." } }, "more-info-url": { "info": "Per maggiori informazioni visita" }, "pending-user-transfer-start": { "info": "{{domain}} richiede ulteriori informazioni da parte tua." } },
  "withdrawal-success": { "action": { "close": "Chiuso" }, "body": { "withdrawal-in-progress": "Ritiro in corso", "info": { "1": "{{domain}} sta conducendo il ritiro.", "2": "I fondi sono stati detratti dal tuo account Stellar e dovrebbero essere accreditati a breve sulla destinazione del prelievo." } }, "sidebar": { "headline": "Fatto", "info": "Il tuo prelievo è stato accettato e verrà elaborato dall'emittente della risorsa." } },
  "transfer-details": { "action": { "proceed": "Procedi" }, "body": { "destination": { "name": "Account di destinazione" }, "dest_extra": { "name": "Dati di destinazione extra (nessuna descrizione)" }, "min-max-amount": { "label": "Quantità", "max-amount": "Max. {{amount}} {{assetCode}}", "min-amount": "Min. {{amount}} {{assetCode}}" }, "fee": { "helper-text": "Come addebitato da {{domain}}", "label": { "deposit": "Commissione di deposito", "withdrawal": "Commissione di prelievo" } } }, "sidebar": { "deposit": { "headline": "Dettagli del deposito", "info": { "1": "Ulteriori dettagli sul deposito previsto.", "2": "A seconda di ciò che l'emittente della risorsa richiede, potresti dover inserire ulteriori informazioni qui." } }, "withdrawal": { "headline": "Dettagli sul ritiro", "info": { "1": "Ulteriori dettagli sul deposito previsto.", "2": "A seconda di ciò che l'emittente della risorsa richiede, potresti dover inserire ulteriori informazioni qui." } } } }
};
const translations$1 = {
  "account-settings": AccountSettings$1,
  account: Account$1,
  app: App$2,
  "app-settings": AppSettings$1,
  "create-account": CreateAccount$1,
  generic: Generic$1,
  operations: Operations$1,
  payment: Payment$1,
  trading: Trading$1,
  "transaction-request": TransactionRequest$1,
  "transfer-service": TransferService$1
};
const settings$1 = { "delete-account": { "text": { "primary": "Объединить или Удалить Аккаунт" } }, "export-secret-key": { "text": { "primary": "Экспортировать Секретный Ключ", "secondary": "Расшифровать и показать секретный ключ" } }, "multi-sig": { "text": { "primary": "Мульти-Подпись", "secondary": { "cosigner-of": "Этот аккаунт является ко-подписантом", "short": "Управление ко-подписантами", "long": "Сделать аккаунт мульти-подписным и управлять ко-подписантами" } } }, "set-password": { "text": { "primary": { "account-protected": "Изменить Пароль", "account-not-protected": "Установить Пароль" }, "secondary": { "account-protected": "Ваш аккаунт защищен паролем", "account-not-protected": "Ваш аккаунт не защищен" } } } };
const AccountSettings = {
  "account-deletion": { "action": { "cancel": "Отмена", "confirm": "Подтвердить", "delete": "Удалить", "merge": { "long": "Объединить с", "short": "Объединить" } }, "confirm": { "title": "Подтверждение удаления", "text": { "confirm": "Вы уверены?", "delete": "Аккаунт будет удален", "merge": "и оставшиеся средства будут переведены" } }, "remaining-funds": { "text": "Отправить оставшиеся средства на" }, "text": { "1": 'Вы уверены, что хотите удалить аккаунт "{{accountName}}" из Sunce? Вы все еще можете использовать его в другом месте, если сохраните секретный ключ.', "2": " Убедитесь, что вы сделали резервную копию вашего секретного ключа или объединили средства с другим вашим аккаунтом, так как на счету еще остались средства!" }, "title": "Подтверждение удаление аккаунта", "warning-dialog": { "close": { "label": "Ок" } }, "warnings": { "cannot-merge": { "text": "Невозможно объединить аккаунты. Сначала вам нужно отменить все открытые торговые ордера и удалить все активы.", "title": "Требуется ручное действие" } } },
  "custom-trustline": { "action": { "cancel": "Отмена", "trust": { "long": "Добавить актив", "short": "Добавить" } }, "textfield": { "code": { "label": "Код" }, "issuer": { "label": "Эмитент", "placeholder": "Публичный ключ эмитента" }, "limit": { "label": "Лимит (необязательно)", "placeholder": "Ограничить доверие к этому активу / максимальный баланс для хранения" } }, "title": "Добавить пользовательский актив" },
  "export-key": { "action": { "confirm": "Done", "reveal": { "long": "Показать ключ", "short": "Нажмите, чтобы показать секретный ключ" } }, "info": { "backup": { "title": "Сделайте резервную копию вашего секретного ключа сейчас", "paragraph-1": "Резервная копия секретного ключа - единственный способ восстановить ваши средства, если вы забудете пароль или не сможете получить доступ к вашему устройству.", "paragraph-2": "Запишите ключ или распечатайте его. Храните его в безопасном месте и не делитесь им с кем-либо." }, "export": { "paragraph-1": "Резервная копия секретного ключа - единственный способ восстановить ваши средства, если вы забудете пароль или не сможете получить доступ к вашему устройству.", "paragraph-2": "Запишите ключ или распечатайте его. Храните его в безопасном месте и не делитесь им с кем-либо." }, "secret-key": "Запишите ключ на бумаге и храните в безопасном месте.", "tap-to-copy": "Нажмите, чтобы скопировать" }, "textfield": { "password": { "label": "Пароль" } }, "title": { "default": "Экспорт секретного ключа", "initial-backup": "Резервное копирование секретного ключа" } },
  "manage-signers": { "action": { "add-signer": "Добавить подписанта", "apply": { "long": "Применить изменения", "short": "Применить" }, "cancel": "Отмена", "proceed": "Продолжить" }, "preset-description": { "m-out-of-n": "Добавить или удалить подписантов с аккаунта. Любая единичная подпись авторизует транзакции.", "m-out-of-n_plural": "Добавить или удалить подписантов с аккаунта. {{ count }} подписей авторизуют транзакции.", "one-out-of-n": "Добавить или удалить подписантов с аккаунта. Любой единичный подписант может авторизовать транзакции.", "single-signature": "Выберите ключ, который будет единственным подписантом аккаунта." }, "preset-description-extra": { "m-out-of-n": "Перейдите в 'Добавить аккаунт' > 'Присоединиться к аккаунту' в ко-подписывающем кошельке Sunce, чтобы создать новый ключ ко-подписанта.", "one-out-of-n": "Перейдите в 'Добавить аккаунт' > 'Присоединиться к аккаунту' в ко-подписывающем кошельке Sunce, чтобы создать новый ключ ко-подписанта." }, "preset-selector": { "options": { "m-out-of-n": { "primary": "Коллективная подпись", "secondary": "Несколько подписантов должны подписать транзакцию." }, "one-out-of-n": { "primary": "Резервные ключи", "secondary": "Каждый подписант может подписать транзакции самостоятельно." }, "single-signature": { "primary": "Единственная подпись", "secondary": "Нет ко-подписантов. Только одна пара ключей." } }, "title": "Выберите, как должен работать ваш аккаунт" }, "signers-editor": { "list": { "item": { "weight": "Вес", "local-key": "Локальный ключ" } }, "new-signer": { "label": "Публичный ключ или Stellar адрес", "placeholder": { "long": "GABC… или адрес", "short": "GABCDEFGHIJK… или alice*example.org" } }, "threshold": { "primary": "Требуемые подписи", "secondary": "Кол-во подписей для авторизации транзакций" }, "validation": { "existing-signer": "Нельзя добавить существующего подписанта.", "integer-required": "Должно быть целым числом.", "invalid-stellar-address": "Ожидается публичный ключ или stellar адрес." } }, "title": { "long": "Управление подписантами", "short": "Управление подписантами аккаунта" }, "validation": { "no-signers": "Не осталось подписантов. Не блокируйте себя!", "invalid-weight-type": "Вес должен быть целым числом", "threshold-higher-than-weights": "Порог выше, чем суммарный вес ключей", "no-threshold": "Пожалуйста, установите порог" } },
  "set-password": { "action": { "change-password": { "long": "Изменить пароль", "short": "Изменить" }, "remove-password": { "long": "Удалить пароль", "short": "Удалить" } }, "notification": { "password-changed": "Пароль изменен.", "password-set": "Пароль установлен.", "password-removed": "Пароль удален." }, "textfield": { "prev-password": { "label": "Текущий пароль" }, "next-password": { "label": "Новый пароль" }, "next-password-repeat": { "label": "Повторите новый пароль" } }, "title": { "change-password": "Изменить пароль", "set-password": "Установить пароль" }, "validation": { "next-password-missing": 'Введите пароль или выберите "удалить пароль".', "next-password-repeat-missing": "Пожалуйста, повторите пароль.", "passwords-no-match": "Пароли не совпадают", "previous-password-missing": "Текущий пароль отсутствует." } },
  settings: settings$1
};
const action$2 = { "receive": "Получить", "send": "Отправить" };
const cosigner = { "not-cosigner-yet": { "label": "Ваш публичный ключ:", "note": "Ваш ключ ещё не является подписантом аккаунта. Пожалуйста, попросите владельца аккаунта добавить вас." } };
const transactions = { "action": { "friendbot": { "description": "Получите немного бесплатных тестовых луменов", "label": "Обратиться к friendbot" }, "navigate-to-deposit": { "description": "Через кредитную карту, банковский перевод и т.д.", "label": "Пополнить счет" } }, "offer-list": { "text": { "buy": "Купить <1 /> за <3 />", "sell": "Продать <1 /> за <3 />", "for": "за" }, "title": "Открытые ордера" }, "transaction-list": { "offer-description": { "prefix": { "default": "Ордер", "cancel": "Отменить ордер", "update": "Обновить ордер" }, "buy": "Купить {{buyingAmount}} {{buyingCode}} за {{sellingAmount}} {{sellingCode}}", "sell": "Продать {{sellingAmount}} {{sellingCode}} за {{buyingAmount}} {{buyingCode}}" }, "item": { "from": "От", "to": "Кому", "memo": "Заметка", "remote-public-keys": { "more": "ещё" }, "trust": { "add-trust": "Доверять активу {{asset}}", "remove-trust": "Отменить доверие активу {{asset}}" } }, "load-more": { "label": "Загрузить больше" }, "title": "Последние операции" }, "signature-request-list": { "title": { "requests-to-cosign": "Транзакции для совместной подписи", "requests-waiting-for-others": "Ожидание дополнительных подписей" } } };
const title$3 = { "password-status": { "protected": "Защищено паролем", "unprotected": "Без пароля" }, "tooltip": { "multi-sig-account": "Аккаунт с мультиподписью", "security-service": "Защита {{service}}" }, "placeholder": "Название аккаунта...", "testnet": "Тестовая сеть" };
const Account = {
  action: action$2,
  "add-asset": { "action": { "add-asset": "Добавить актив в аккаунт", "remove": "Удалить", "trade": "Торговать" }, "button": { "add-custom-asset": { "label": "Добавить пользовательский актив" } }, "item": { "issuer": { "secondary": { "one-asset": "Один соответствующий актив", "more-than-one-asset": "{{amount}} соответствующих активов" } }, "no-result": { "primary": "Соответствующих активов нет", "secondary": "Ни один актив или эмитент не соответствует вашему поиску" } }, "search-field": { "placeholder": "Поиск активов по коду или названию…" }, "title": "Добавить актив" },
  "asset-details": { "lumen": { "description": { "label": "Описание", "text": "Основной токен сети Stellar.\n\n Каждый аккаунт в сети имеет баланс луменов. Лумены используются для оплаты комиссий за транзакции." } }, "general": { "account-flags": { "auth-required": "Требуется авторизация эмитентом", "auth-not-required": "Авторизация не требуется", "auth-revocable": "Авторизация может быть отозвана", "auth-not-revocable": "Авторизация не может быть отозвана", "auth-immutable": "Эти флаги неизменны", "auth-mutable": "Эмитент может изменить эти флаги", "label": "Флаги аккаунта" }, "anchor-asset": { "label": "Привязан к" }, "conditions": { "label": "Условия" }, "description": { "label": "Описание" }, "issuing-account": { "label": "Эмитирующий аккаунт" }, "organisation": { "address": { "label": "Адрес" }, "dba": { "label": "Торговое наименование" }, "description": { "label": "Описание" }, "email": { "label": "Электронная почта" }, "name": { "label": "Название организации" }, "phone-number": { "label": "Номер телефона" }, "website": { "label": "Веб-сайт" } }, "redemption-instructions": { "label": "Инструкции по погашению" } } },
  "balance-details": { "button": { "add-asset": { "label": "Добавить актив в аккаунт" } }, "item": { "spendable-balance": { "primary": "Доступный баланс" } }, "spendable-balances": { "base-reserve": { "primary": "Базовый резерв", "secondary": "Фиксированный базовый резерв" }, "data-reserve": { "primary": "Резерв данных", "secondary": "Поля данных аккаунта" }, "headline": "Суммы в XLM", "open-orders-reserve": { "primary": "Резерв открытых ордеров", "secondary": "Резерв на ордер" }, "selling-liabilities": { "primary": "Сумма к продаже", "secondary": "Зарезервировано в открытых ордерах" }, "signers-reserve": { "primary": "Резерв подписантов аккаунта", "secondary": { "single-key": "Резерв одного ключа", "multiple-keys": "Основной ключ + со-подписанты" } }, "spendable-balance": { "primary": "Доступный баланс", "secondary": "Свободно используемая сумма" }, "total-balance": { "primary": "Общий баланс", "secondary": "Ваш баланс, вкл. недоступное" }, "trustline-reserve": { "primary": "Резерв трастлайнов", "secondary": "На каждый баланс, не в XLM" } } },
  "saved-addresses": { "title": "Сохраненные адреса", "search-field": { "placeholder": "Искать по имени или адресу…" }, "item": { "no-result": { "primary": "Соответствующих записей нет", "secondary": "Ни одно имя или адрес не соответствует вашему поиску" } }, "button": { "add": { "label": "Добавить адрес" } } },
  "saved-address-details": { "address": { "label": "Адрес", "placeholder": "Адрес" }, "label": { "label": "Метка", "placeholder": "Метка" }, "validation": { "no-address": "Введите адрес", "no-label": "Введите метку", "label-too-long": "Метка слишком длинная. Максимум {{max}} символа", "invalid-address": "Адрес некорректен" }, "button": { "add": { "label": "Сохранить" }, "remove": { "label": "Удалить" } } },
  "context-menu": { "account-settings": { "label": "Настройки аккаунта" }, "assets-and-balances": { "label": "Активы и балансы" }, "deposit": { "label": "Пополнить счет" }, "trade": { "label": "Торговля" }, "transactions": { "label": "Транзакции" }, "withdraw": { "label": "Вывести средства" }, "saved-addresses": { "label": "Сохранённые адреса" } },
  cosigner,
  "purchase-lumens": { "legal-confirmation": { "action": { "confirm": "Я понимаю" } }, "moonpay": { "text": { "primary": "MoonPay", "secondary": "Купить Stellar Lumens мгновенно с помощью вашей дебетовой/кредитной карты или Apple Pay" }, "legal-confirmation": " Вы будете перенаправлены на moonpay.io, сервис третьей стороны. Процесс пополнения управляется Moon Pay Ltd, а не Sunce или Монтелиберо. <1 /> <2 /> Пожалуйста, обратитесь в службу поддержки moonpay.io по вопросам, связанным с вашим пополнением." }, "title": "Купить Stellar lumens" },
  "remove-trustline": { "action": { "cancel": "Отмена", "remove": "Удалить" }, "text": { "warning": "Вы не можете удалить этот актив, пока баланс актива не будет равен нулю.", "info": 'Вы собираетесь удалить <1>{{asset}}</1> с аккаунта "{{accountName}}".' }, "title": "Подтвердите удаление актива" },
  transactions,
  "transaction-review": { "action": { "confirm": "Подтвердить", "cancel-order": "Отменить ордер", "dismiss": "Отменить", "inspect": "Инспектировать", "show-more": "Показать больше информации" }, "account-creation-warning": { "primary": "Пополнение нового аккаунта", "secondary": "Пополнение пустого аккаунта. Убедитесь, что адресат указан верно." }, "add-signer-warning": { "primary": "Добавление другого подписанта", "secondary": "Убедитесь, что вы добавляете правильного со-подписанта. Добавление неизвестного ключа может навсегда заблокировать ваш аккаунт." }, "dangerous-transaction-warning": { "primary": "Транзакция инициирована неизвестным аккаунтом", "secondary": "Пожалуйста, внимательно проверьте. В случае сомнений, лучше отклоните." }, "dismissal": { "action": { "cancel": "Отмена", "confirm": "Подтвердить" }, "header": "Отклонить ожидающую мультиподписную транзакцию?", "title": "Подтверждение" }, "signers": { "heading-details": { "single-signature": "Одиночная подпись", "default-signatures": "{{threshold}} из {{length}} мультиподпись", "custom-consensus": "Мультиподпись с пользовательским консенсусом" }, "label": "Подписанты {{details}}" }, "signer-status": { "tooltip": { "has-signed": "Подписал транзакцию", "has-not-signed": "Ожидает его подписи" } }, "summary": { "item": { "account": { "label": "Аккаунт" }, "authenticating-account": { "label": "Аутентификация аккаунта" }, "expiry": { "label": "Истечение срока" }, "max-fee": { "label": "Максимальная комиссия" }, "service": { "label": "Сервис" }, "submission": { "label": "Подача" }, "tx-hash": { "label": "Хеш транзакции" } } }, "textfield": { "password": { "label": "Пароль" } }, "title": { "transaction": "Транзакция", "payment": "Платеж", "delete-orders-operation": "Удаление торговых ордеров", "web-auth": "Веб-аутентификация" }, "transaction-memo": { "label": "{{type}} Заметка" }, "validation": { "no-account-data": "Нарушение инвариантности: Невозможно найти данные аккаунта источника транзакции в наборе подписок на данные аккаунта.", "no-manage-data-operation": "Нарушение инвариантности: Транзакция веб-аутентификации Stellar должна содержать операцию manage_data.", "password-required": "Требуется пароль" } },
  title: title$3
};
const notification = { "desktop": { "new-signature-request": { "title": "Новая транзакция для совместной подписи", "body": "От {{signersHavingSigned}}" }, "received-payment": { "title": "Получен платеж | {{account}}", "body": "Получено {{amount}} {{assetCode}}" }, "trade-completed": { "title": "Торговля завершена | {{account}}" } }, "details": { "action": { "dismiss": "Закрыть" }, "support": "Проблемы с приложением? <1/> Свяжитесь с нами через", "title": "Ошибка", "offline": "Не в сети" }, "permission": { "app-notification": { "error": "Включите в настройках операционной системы", "granted": { "title": "Уведомления включены", "text": "Sunce теперь будет показывать уведомления" }, "message": "Включить уведомления приложения" }, "protocol-handler": { "error": "Не удалось назначить Sunce обработчиком по умолчанию.", "message": "Назначить Sunce для открытия интерактивных ссылок Stellar на этом устройстве (рекомендуется)?", "success": "Sunce успешно назначен обработчиком по умолчанию.", "tooltip": { "dismiss": "Закрыть", "install": "Назначить" } } } };
const App$1 = {
  "account-list": { "add-account-card": { "label": "Добавить аккаунт" }, "badges": { "tooltip": { "multi-sig": "Аккаунт с мультиподписью", "security-service": "Защита {{service}}" } } },
  "all-accounts": { "switch": { "label": "Тестовая сеть" }, "update": { "notification": { "start": "Начинается загрузка обновления...", "success": "Загрузка завершена и будет установлена при следующем перезапуске!" }, "tooltip": "Доступно обновление" }, "title": { "testnet": "Testnet Accounts", "mainnet": "Мои адреса" } },
  notification,
  "terms-and-conditions": { "action": { "confirm": "Подтвердить" }, "header": "Добро пожаловать в Sunce", "checkbox": { "1": { "label": "Я понимаю, что я несу ответственность за безопасность моих средств и что Sunce не может восстановить мои средства в случае потери данных или если я потеряю свои учетные данные." }, "2": { "label": "Я прочитал, понял и согласен с <1>Условиями использования</1> <2>&amp;</2> <3>Политикой конфиденциальности</3> Sunce." } } }
};
const settings = { "biometric-lock": { "text": { "primary": { "default": "Блокировка по отпечатку пальца", "ios": "Face ID / Сенсорный ID" }, "secondary": { "disabled": "Биометрическая аутентификация отключена", "enabled": "Биометрическая аутентификация включена", "not-enrolled": "Настройте биометрическую аутентификацию в настройках операционной системы" } }, "prompt": { "enable": "Разблокируйте устройство один раз, чтобы включить функцию.", "disable": "Разблокируйте устройство, чтобы отключить автоблокировку." } }, "language": { "auto-detect": { "label": "auto" }, "text": { "primary": "Язык", "secondary": "Выбрать язык интерфейса" } }, "memo": { "text": { "primary": "Показывать мемо", "secondary": { "hidden": "Мемо будут скрыты в списке транзакций", "shown": "Мемо будут отображаться в списке транзакций" } } }, "multi-sig": { "text": { "primary": "Включить мультиподпись", "secondary": { "enabled": "Инструменты мультиподписи включены", "disabled": "Инструменты мультиподписи выключены" } } }, "protocol-handler": { "text": { "primary": "Обрабатывать запросы протокола Stellar", "secondary": { "default": "Sunce автоматически открывает ссылки Stellar", "non-default": "Использовать Sunce для открытия всех ссылок Stellar" } } }, "testnet": { "text": { "primary": "Отображать аккаунты Testnet", "secondary": { "cannot-disable": "Нельзя выключить, потому что уже добавлены аккаунты из Testnet", "hidden": "Testnet аккаунты скрыты", "shown": "Testnet аккаунты отображаются" } } }, "title": "Настройки", "trusted-services": { "text": { "primary": "Управление доверенными сервисами", "secondary": "Удаление доверенных сервисов" } }, "saved-addresses-export": { "text": { "primary": "Импорт/Экспорт сохраненных адресов", "secondary": "Быстрый доступ к всем сохранённым адресам в JSON-формате" } }, "dust": { "text": { "primary": "Показывать пыль", "secondary": { "hidden": "Транзакции меньше, чем 0.01 XLM, скрыты в списке транзакций", "shown": "Транзакции меньше, чем 0.01 XLM, видны в списке транзакций" } } }, "create-claimable-balance": { "text": { "primary": "Показывать траназакции Create Claimable Balance", "secondary": { "hidden": "Транзакции Create Claimable Balance скрыты в списке транзакций", "shown": "Транзакции Create Claimable Balance видны в списке транзакций" } } } };
const AppSettings = {
  settings,
  "trusted-services": { "info": "Доверенные сервисы - это веб-сервисы, которым разрешено взаимодействовать с кошельком Sunce, запрашивая данные аккаунта или предлагая транзакции. Вы можете добавить новый сервис, как только он попытается взаимодействовать с Sunce.", "service-selection": { "action": { "cancel": "Отмена", "confirm": "Подтвердить" }, "confirm": { "title": "Подтвердите удаление", "text": "Сервис будет удален из вашего списка доверенных. Вы уверены?" }, "no-services": "Нет доверенных сервисов" } }
};
const action$1 = { "cancel": "Отмена", "confirm": "Подтвердить", "create": "Создать аккаунт", "import": "Импортировать аккаунт", "join-shared": "Добавить аккаунт" };
const confirm = { "text": "Вы собираетесь создать аккаунт без защиты паролем. Любой, кто имеет доступ к вашему устройству, сможет получить доступ к средствам на вашем аккаунте. <1 /> <3 /> Вы уверены, что хотите продолжить без создания пароля?", "title": "Продолжить без пароля" };
const header = { "placeholder": { "mainnet": "Новый аккаунт", "testnet": "Новый аккаунт в тестовой сети" } };
const inputs$2 = { "import": { "helper-text": "Секретный ключ Stellar состоит из 56 алфавитно-цифровых символов и начинается с буквы S", "placeholder": "SABCDEFGH…", "label": "Секретный ключ", "title": "Импорт существующего" }, "multisig-account": { "explanation-long": "Убедитесь, что на аккаунте, к которому вы присоединяетесь, есть как минимум 2 XLM, чтобы они могли добавить вас в качестве со-подписанта.", "explanation-short": "Убедитесь, что аккаунт, к которому вы присоединяетесь, пополнен.", "helper-text": "Адрес мультиподписного аккаунта (публичный ключ)", "placeholder": "GABCDEFGH…", "label": "Мультиподписной аккаунт" }, "password": { "label": "Пароль", "placeholder": "Введите пароль" }, "password-repeat": { "label": "Повторите пароль", "placeholder": "Повторите ваш пароль" } };
const options = { "cosigner": { "label": "Присоединиться к общему аккаунту", "description": "Стать со-подписантом мультиподписного аккаунта" }, "cosigner-import": { "label": "Со-подписывает общий аккаунт", "description": "Ключ является подписантом другого аккаунта" }, "import": { "label": "Импортировать секретный ключ", "description": "Восстановить аккаунт из резервной копии" }, "password": { "label": "Защита паролем", "protected": "Ваш секретный ключ будет зашифрован", "unprotected": "Ваш секретный ключ будет без защиты" } };
const validation$2 = { "invalid-key": "Неверный секретный ключ Stellar.", "no-account-name": "Не введено имя аккаунта.", "no-password": "Не введен пароль.", "password-no-match": "Пароли не совпадают.", "same-account": "Этот аккаунт уже добавлен." };
const CreateAccount = {
  action: action$1,
  "action-selection": { "create": { "description": "Создать новый пустой аккаунт", "label": "Создать аккаунт" }, "import": { "description": "Восстановить аккаунт из резервной копии", "label": "Импортировать аккаунт" }, "join-shared": { "description": "Стать со-подписантом общего аккаунта", "label": "Присоединиться к аккаунту" } },
  "base-name": { "mainnet": "Мой аккаунт", "testnet": "Мой аккаунт в тестовой сети" },
  confirm,
  header,
  inputs: inputs$2,
  options,
  validation: validation$2
};
const error = { "asset-not-depositable-error": "Актив {{asset}} кажется недоступным для депозита через {{domain}}", "asset-not-withdrawable-error": "Актив {{asset}} кажется недоступным для вывода через {{domain}}", "boundary": { "header": "Упс, что-то пошло не так...", "contact-us": "Свяжитесь с нами через" }, "bad-response-error": "Плохой ответ ({{status}}) от сервера {{server}}", "bad-transaction-error": "Получена неверная транзакция. Ожидалась транзакция или запись транзакции, но получено: {{transaction}}", "bio-auth-test-canceled": "Отменена биометрическая аутентификация", "cosigner-lacking-key": "Невозможно добавить пару ключей в качестве со-подписанта учетной записи, поскольку для учетной записи, которую нужно со-подписать, не предоставлен общедоступный ключ", "expected-json-response-error": "Ожидался ответ в формате JSON от {{url}}. Вместо этого был получен тип содержимого {{contentType}}.", "existing-account-error": "Учетная запись с таким именем уже существует.", "fetch-account-data-error": "Невозможно получить данные учетной записи {{account}} с {{horizon}}", "fetch-signature-requests-error": "Сбой при получении запросов на подпись: {{response}} \nСервис: {{service}}", "fetch-web-auth-challenge-error": "Невозможно получить вызов веб-аутентификации", "http-request-error": "Сбой HTTP-запроса: {{response}} \nСервис: {{service}}", "invariant-violation-error": "Нарушение инварианта: {{message}}", "low-reserve-order-error": "Невозможно разместить заказ, поскольку доступный баланс XLM слишком низок.", "memo-already-specified-error": "Невозможно установить пользовательское примечание. Запись федерации для {{destination}} уже содержит примечание.", "missing-info-error": "Невозможно создать транзакцию, поскольку {{transferServer}} не отправил всю необходимую информацию.", "multi-sig-config-threshold-lock": "Слишком высокий порог подписи. Вы заблокируете свою учетную запись.", "multi-sig-config-threshold-too-low": "Слишком низкий порог подписи.", "multi-sig-event-stream-double-errored-error": "Поток событий обновления мультиподписи дважды завершился с ошибкой: {{url}}", "multi-sig-service-not-locatable": "Сервис мультиподписи не может быть найден: {{domain}}", "no-callback-url-error": "Невозможно отправить обратно на сервис мультиподписи. Запрос на подпись не имеет установленного URL обратного вызова.", "non-existent-destination-error": "Невозможно оплатить в {{assetCode}}, поскольку учетная запись назначения еще не существует. Создание учетных записей всегда должно выполняться через XLM.", "only-interactive-kyc-supported-error": "Поддерживаются только интерактивные KYC.", "password-required-error": "Учетная запись {{accountName}} защищена паролем, но пароль не был передан.", "promise-timeout-error": "Обещание завершилось по истечении времени {{timeout}} мс", "request-failed-error": "Запрос к {{target}} завершился с ошибкой статуса {{status}}: {{message}}", "stellar-address-not-found-error": "Адрес Stellar не найден: {{address}}", "stellar-address-request-failed-error": "Не удалось найти адрес Stellar {{address}}.", "stellar-uri-verification-error": "Не удалось верифицировать Stellar URI.", "stellar-uri-callback-format-error": "Проблема с параметром callback: {{reason}}", "submission-failed-error": "Не удалось отправить транзакцию на {{endpoint}} с ошибкой статуса {{status}}: {{message}}", "testnet-endpoint-not-available-error": "{{service}} не предоставляет конечную точку тестовой сети.", "timeout-error": "Время запроса истекло", "unexpected-action-error": "Неожиданное действие: {{action}}", "unexpected-state-error": "Обнаружено неожиданное состояние: {{state}}", "unexpected-response-type-error": "Неожиданный тип ответа: {{type}} / ${dataType}", "unexpected-stellar-uri-type-error": "Запрос {{incomingURI}} не поддерживается", "unknown-error": "Произошла неизвестная ошибка.", "update-already-running-error": "Обновление уже запущено!", "wrong-password-error": "Неверный пароль.", "wrong-request-start-error": "Ожидался запрос, начинающийся с 'web+stellar:'", "submission-error": { "default": "Транзакция отклонена сетью. Код(ы) ошибки: {{codes}}", "internal-server-error": "Серверу не удалось обработать этот запрос. Пожалуйста, попробуйте еще раз.", "op-result-code": { "op_cross_self": "Заказ противоречил вашему открытому заказу.", "op_has_sub_entries": "Учетная запись все еще имеет доверительные отношения (активы) или открытые торговые ордера.", "op_immutable_set": "Учетная запись неизменяема (установлен флаг AUTH_IMMUTABLE).", "op_line_full": "Баланс учетной записи назначения превысил доверие учетной записи к активу.", "op_low_reserve": "Транзакция отклонена сетью. Баланс учетной записи отправителя или получателя будет ниже минимального баланса.", "op_no_account": "Учетная запись назначения не существует.", "op_no_issuer": "Актив недействителен. Неверный эмитент актива.", "op_no_trust": "Учетная запись назначения не доверяет активу, который вы пытаетесь отправить.", "op_offer_not_found": "Предложение не существует.", "op_self_not_allowed": "Учетная запись не может доверять активам, выпущенным самой собой.", "op_underfunded": "Недостаточно средств для выполнения этой операции." }, "prefix": { "server-error": "Ошибка сервера" }, "tx-result-code": { "insufficient_fee": "Сеть требует более высоких комиссий, чем указано в транзакции.", "internal_error": "На сервере Stellar произошла неизвестная ошибка.", "no_account": "Учетная запись отправителя не найдена.", "tx_bad_auth": "Слишком мало действительных подписей или неверная сеть.", "tx_bad_auth_extra": "К транзакции прикреплены неиспользуемые подписи.", "tx_bad_seq": "Несоответствие номера последовательности. Пожалуйста, создайте транзакцию заново.", "tx_insufficient_balance": "Недостаточный баланс. Баланс упадет ниже минимального резерва.", "tx_too_late": "Черновик транзакции истек. Попробуйте еще раз." }, "timeout": "Сервер не ответил. Пожалуйста, попробуйте еще раз." } };
const Generic = {
  "dialog-actions": { "close": { "label": "Закрыть" }, "retry": { "label": "Повторить" } },
  error,
  "qr-reader": { "action": { "cancel": "Отмена" } },
  "submission-progress": { "pending": "Отправка в сеть ...", "success": { "default": "Успешно", "multisig": "Ожидание недостающих подписей", "third-party": "Ожидание авторизации стороннего сервиса" } },
  "testnet-badge": { "label": "Тестовая сеть" },
  "user-interface": { "copied-to-clipboard": "Скопировано в буфер обмена." }
};
const payment$2 = { "summary": { "amount": "Сумма", "destination": "Получатель", "source": "Источник" }, "title": "Платеж" };
const Operations = {
  "account-merge": { "summary": { "account": "Учетная запись", "merge-into": "Слияние в" }, "title": "Слияние учетных записей" },
  "change-trust": { "summary": { "asset": "Актив", "issued-by": "Выпущено", "limit": { "label": "Лимит", "value": { "unlimited": "Неограниченно", "limited-to": "Ограничено до {{limit}} {{code}}" } } }, "title": { "add-asset": "Добавить актив", "remove-asset": "Удалить актив" } },
  "create-account": { "summary": { "account": "Создать учетную запись", "funding-account": "Финансирующий аккаунт", "funding-amount": "Сумма финансирования" }, "title": "Создание учетной записи" },
  "manage-buy-offer": { "title": { "create": "Создать ордер на покупку", "delete": "Ордер на покупку", "update": "Обновить ордер на покупку" } },
  "manage-data": { "title": "Установить данные учетной записи" },
  "manage-offer": { "summary": { "buy": "Купить", "sell": "Продать" } },
  "manage-sell-offer": { "title": { "create": "Создать ордер на продажу", "delete": "Ордер на продажу", "update": "Обновить ордер на продажу" } },
  "offer-details": { "string": "Купить {{price}} {{buyingCode}} за {{amount}} {{sellingCode}}" },
  payment: payment$2,
  "set-options": { "add-signer": { "summary": { "account": "Учетная запись для добавления подписанта", "key-weight": "Вес ключа", "new-signer": "Новый подписант" }, "title": "Добавить подписанта" }, "change-signature-setup": { "summary": { "key-thresholds": { "label": "Новые пороговые значения ключа", "value": { "low": "Низкий порог:    {{threshold}}", "medium": "Средний порог: {{threshold}}", "high": "Высокий порог:   {{threshold}}" } }, "required-signatures": "Новый порог веса ключа" }, "title": "Изменение настроек подписи" }, "remove-signer": { "summary": { "account": "Учетная запись для удаления подписанта", "signer": "Подписант" }, "title": "Удалить подписанта" }, "set-account-options": { "title": "Настройка параметров учетной записи" }, "set-home-domain": { "title": "Установить домашний домен" }, "set-inflation-destination": { "summary": { "new-destination": "Новое направление" }, "title": "Установить направление инфляции" }, "set-master-key-weight": { "title": "Установить вес основного ключа" } }
};
const actions = { "dismiss": "Отменить", "submit": "Отправить сейчас" };
const inputs$1 = { "destination": { "label": "Адрес получателя", "placeholder": "GABCD..., MABCD... или alice*example.org" }, "price": { "label": "Сумма", "placeholder": "Макс. {{amount}}" } };
const note = { "multisig-pubkey": "Адрес мультиподписного аккаунта, а не ваш локальный ключ совместной подписи." };
const title$2 = { "send": "Отправить средства", "receive": "Получить средства" };
const validation$1 = { "memo-required": "Укажите заметку при отправке средств на {{destination}}", "memo-too-long": "Заметка слишком длинная.", "no-destination": "Не указан адрес получателя.", "no-price": "Не указана сумма.", "not-enough-funds": "Недостаточно средств.", "invalid-destination": "Ожидается публичный ключ или stellar адрес.", "invalid-price": "Неверная сумма.", "integer-memo-required": "Заметка должна быть числом.", "asset-missing": "Не выбран актив." };
const Payment = {
  actions,
  "memo-metadata": { "label": { "default": "Заметка", "id": "Заметка (ID)", "text": "Заметка (Текст)" }, "placeholder": { "optional": "Описание (необязательно)", "mandatory": "Описание (обязательно)" } },
  inputs: inputs$1,
  note,
  title: title$2,
  validation: validation$1
};
const action = { "add-asset": "Добавить актив", "submit": "Разместить ордер" };
const advanced = { "header": "Расширенные" };
const inputs = { "estimated-costs": { "label": { "buy": "Предполагаемые затраты", "sell": "Предполагаемая прибыль" } }, "primary-amount": { "label": { "buy": "Количество к покупке", "sell": "Количество к продаже" }, "max-button": { "label": "Макс" }, "placeholder": "Макс. {{amount}}" }, "primary-asset-selector": { "label": { "buy": "Вы покупаете", "sell": "Вы продаете" } }, "secondary-asset-selector": { "label": { "buy": "Тратить", "sell": "Получать" } } };
const title$1 = "Торговля";
const validation = { "primary-amount-missing": "Не указано количество.", "primary-asset-missing": "Не выбран актив.", "invalid-amount": "Указано неверное количество.", "invalid-price": "Неверная цена", "not-enough-balance": "Превышает доступный баланс", "secondary-asset-missing": "Не выбран актив." };
const warning = { "title": "Предупреждение", "message": "Разница между ценой покупки и продажи составляет около {{spread}}%." };
const Trading = {
  action,
  "action-selection": { "buy": { "description": "Купить некоторое количество актива на распределенной бирже", "label": "Купить актив" }, "sell": { "description": "Обменять некоторое количество одного актива на другой", "label": "Продать актив" } },
  advanced,
  inputs,
  "no-assets-info": "Этот аккаунт пока не использует никакие активы, кроме Stellar Lumens.",
  title: title$1,
  "trading-price": { "default-label": "Цена (лимит)", "label": "Цена за {{unit}} (лимит)" },
  validation,
  warning
};
const payment$1 = { "account-selector": "Выберите аккаунт", "action": { "dismiss": "Отменить", "select": "Выбрать" }, "error": { "no-activated-accounts": "Не найдено активных аккаунтов.", "no-accounts-with-trustline": "Нет аккаунтов с подходящей линией доверия." }, "uri-content": { "message": "Сообщение" } };
const transaction$1 = { "account-selector": { "source-account": "Выберите аккаунт источник", "signing-account": "Выберите аккаунт, который будет подписывать" }, "action": { "dismiss": "Отмена", "select": "Выбрать" }, "error": { "signer-not-imported": "Аккаунт '{{signer}}' выбран для подписи, но он не импортирован.", "no-eligible-accounts": "Нет подходящих аккаунтов." }, "hint": "Подсказка", "uri-content": { "message": "Сообщение" }, "warning": "Источник этого запроса не может быть верифицирован. Отклоните запрос, если сомневаетесь." };
const TransactionRequest = {
  "no-accounts": { "action": { "dismiss": "Закрыть" }, "info": { "1": "Нет аккаунтов для указанной сети.", "2": "Вы должны добавить аккаунт, чтобы подписывать платёжные запросы" }, "title": "Предложена транзакция" },
  payment: payment$1,
  transaction: transaction$1,
  "stellar-uri": { "header": { "origin-domain": "Данная транзакция была предложена <1>{{originDomain}}<3>", "warning": "Источник этого запроса не может быть верифицирован. Отклоните запрос, если сомневаетесь." }, "title": "Предложена транзакция" },
  "verify-trusted-service": { "action": { "trust": "Доверять", "cancel": "Отменить" }, "info": { "1": "Вы открыли Stellar URI от неизвестного источника", "2": "Если вы доверяете этому домену, то вы можете добавить этот сервис в список доверенных.", "3": "Вы можете смотреть и редактировать список доверенных сервисов в настройках приложения." }, "title": "Верифицировать доверенный сервис" }
};
const authentication = { "sidebar": { "headline": "Аутентификация", "info": { "1": "Эмитент активов требует, чтобы вы вошли в свою учетную запись на его сервисе.", "2": "Для подтверждения владения этой учетной записью будет подписана транзакция аутентификации." } } };
const initial = { "action": { "proceed": "Обработано" }, "body": { "asset-selector": { "label": { "deposit": "Актив", "short": "Актив", "withdrawal": "Актив для вывода" }, "no-assets": "Нет активов для вывода" }, "method-selector": { "info-item": { "asset": "Пожалуйста, выберите тип", "no-asset": "Сначала выберите актив" }, "label": { "deposit": "Тип депозита", "withdrawal": "Тип вывода" } } }, "sidebar": { "deposit": { "headline": "Пополните свой счет", "info": { "1": "Приобретите люмены Stellar (XLM) или внесите активы для пополнения своего счета. Отправьте USD со своего банковского счета, ETH из своего кошелька Ethereum и т. д.", "2": "Sunce выступает в качестве клиента сервиса, предлагаемого эмитентом активов." } }, "withdrawal": { "headline": "Что вывести", "info": { "1": "Выведите активы со своего счета, например, USD на свой банковский счет или ETH в свой кошелек Ethereum.", "2": "Sunce выступает в качестве клиента сервиса, предлагаемого эмитентом активов." } } } };
const title = { "deposit": "Пополнить счет", "withdrawal": "Вывести средства" };
const TransferService = {
  authentication,
  "deposit-success": { "action": { "close": "Закрыть" }, "body": { "deposit-pending": "Deposit pending", "info": { "1": "{{domain}} ждет ваш депозит.", "2": "Средства будут зачислены на ваш счет Stellar, когда депозит будет зачислен эмитентом активов." } }, "sidebar": { "headline": "Готово", "info": "Ваш депозит принят и будет обработан эмитентом активов, когда ваш платеж поступит." } },
  "form-builder": { "placeholder": { "optional": "(Опционально) {{name}}" } },
  initial,
  "kyc-denied": { "sidebar": { "headline": "Know Your Customer", "info": "Вам отказано – сервис отключен для вас. Пожалуйста, свяжитесь с эмитентом активов." } },
  "kyc-pending": { "action": { "continue": "Продолжить", "open-again": "Открыть снова" }, "body": { "additional-info-needed": "Требуется дополнительная информация" }, "sidebar": { "headline": "Know Your Customer", "info": { "1": "Сервис будет работать только если вы предоставите личную информацию о себе.", "2": "Это обычно происходит по юридическим причинам." } } },
  "no-withdrawable-assets": { "action": { "add-asset": "Добавить актив" }, "body": { "no-withdrawable-assets": "На этом счете нет активов для вывода." } },
  "purchase-lumens": { "sidebar": { "headline": "Купить Stellar люмены", "info": { "1": "Мы предлагаем варианты покупки люменов, которые не включают эмитента активов.", "2": "Stellar люмены (XLM) - это внутренние токены на сети Stellar. Они используются для оплаты комиссий за транзакции, среди прочего." } } },
  title,
  "transaction-details": { "action": { "done": "Готово", "withdraw": "Вывести" }, "body": { "amount": { "error": { "amount-greater-than-balance": "Указанная сумма больше баланса" }, "label": { "deposit": "Сумма для депозита", "withdrawal": "Сумма для вывода" } }, "amount-to-receive": { "label": "Сумма к получению" }, "deposit-instructions": { "label": "Инструкции по депозиту" }, "eta": { "label": "Время до завершения", "not-available": "Н/Д" }, "fees": { "label": "Комиссии", "value": { "unknown": "неизвестно" } }, "information": { "label": "Информация" } }, "sidebar": { "deposit": { "headline": "Сводка по депозиту", "info": { "1": "Убедитесь, что вы отправляете средства в правильное место.", "2": "Эмитент активов зачислит токены, как только ваш депозит будет зачислен." } }, "withdrawal": { "headline": "Почти готово", "info": { "1": "Проверьте форму и, при необходимости, укажите сумму для вывода.", "2": "Вывод почти готов." } } } },
  "transaction-status": { "error": { "rejected": { "deposit": "Депозит отклонен", "withdrawal": "Вывод отклонен" }, "contact": "Пожалуйста, свяжитесь с {{domain}}." }, "incomplete": { "already-redirected": { "info": { "1": "{{domain}} проверяет вашу личную информацию. Пожалуйста, попробуйте позже.", "2": "Предполагаемое время завершения: {{eta}}" } }, "not-redirected": { "info": "{{domain}} требует, чтобы вы предоставили дополнительную информацию." } }, "more-info-url": { "info": "Для получения дополнительной информации посетите" }, "pending-user-transfer-start": { "info": "{{domain}} требует дополнительной информации от вас." } },
  "withdrawal-success": { "action": { "close": "Close" }, "body": { "withdrawal-in-progress": "Вывод в процессе", "info": { "1": "{{domain}} проводит вывод.", "2": "Средства были списаны с вашего счета Stellar и должны быть зачислены на место вывода в ближайшее время." } }, "sidebar": { "headline": "Готово", "info": "Ваш вывод принят и будет обработан эмитентом активов." } },
  "transfer-details": { "action": { "proceed": "Продолжить" }, "body": { "destination": { "name": "Счет назначения" }, "dest_extra": { "name": "Дополнительные данные назначения (без описания)" }, "min-max-amount": { "label": "Сумма", "max-amount": "Макс. {{amount}} {{assetCode}}", "min-amount": "Мин. {{amount}} {{assetCode}}", "not-enough-funds": "У вас недостаточно средств." }, "fee": { "helper-text": "Как взимается {{domain}}", "label": { "deposit": "Комиссия за депозит", "withdrawal": "Комиссия за вывод" } } }, "sidebar": { "deposit": { "headline": "Детали депозита", "info": { "1": "Дополнительные сведения о вашем намеченном депозите.", "2": "В зависимости от того, что требует эмитент активов, вам может потребоваться ввести здесь дополнительную информацию." } }, "withdrawal": { "headline": "Детали вывода", "info": { "1": "Дополнительные сведения о вашем намеченном депозите.", "2": "В зависимости от того, что требует эмитент активов, вам может потребоваться ввести здесь дополнительную информацию." } } } }
};
const translations = {
  "account-settings": AccountSettings,
  account: Account,
  app: App$1,
  "app-settings": AppSettings,
  "create-account": CreateAccount,
  generic: Generic,
  operations: Operations,
  payment: Payment,
  trading: Trading,
  "transaction-request": TransactionRequest,
  "transfer-service": TransferService
};
i18next.use(Browser).use(initReactI18next).init({
  debug: false,
  fallbackLng: "en",
  interpolation: {
    escapeValue: false
    // not needed for react as it escapes by default
  },
  resources: {
    en: {
      translation: translations$3
    },
    es: {
      translation: translations$2
    },
    it: {
      translation: translations$1
    },
    ru: {
      translation: translations
    }
  }
});
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise2 = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise2 = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise2.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports2) {
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
          var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
          else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l = performance;
      exports2.unstable_now = function() {
        return l.now();
      };
    } else {
      var p = Date, q = p.now();
      exports2.unstable_now = function() {
        return p.now() - q;
      };
    }
    var r = [], t2 = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t2); null !== b; ) {
        if (null === b.callback) k(t2);
        else if (b.startTime <= a) k(t2), b.sortIndex = b.expirationTime, f(r, b);
        else break;
        b = h(t2);
      }
    }
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h(r)) A = true, I(J);
      else {
        var b = h(t2);
        null !== b && K(H, b.startTime - a);
      }
    }
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y;
      try {
        G(b);
        for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports2.unstable_now();
            "function" === typeof e ? v.callback = e : v === h(r) && k(r);
            G(b);
          } else k(r);
          v = h(r);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t2);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    var N = false, O = null, L = -1, P2 = 5, Q = -1;
    function M() {
      return exports2.unstable_now() - Q < P2 ? false : true;
    }
    function R() {
      if (null !== O) {
        var a = exports2.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports2.unstable_now());
      }, b);
    }
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports2.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports2.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports2.unstable_getFirstCallbackNode = function() {
      return h(r);
    };
    exports2.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports2.unstable_pauseExecution = function() {
    };
    exports2.unstable_requestPaint = function() {
    };
    exports2.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports2.unstable_scheduleCallback = function(a, b, c) {
      var d = exports2.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d ? (a.sortIndex = c, f(t2, a), null === h(r) && a === h(t2) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
      return a;
    };
    exports2.unstable_shouldYield = M;
    exports2.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b) {
    ha(a, b);
    ha(a + "Capture", b);
  }
  function ha(a, b) {
    ea[a] = b;
    for (a = 0; a < b.length; a++) da.add(b[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a)) return true;
    if (ja.call(la, a)) return false;
    if (ka.test(a)) return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b, c, d) {
    if (null !== c && 0 === c.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d) return false;
        if (null !== c) return !c.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b, c, d) {
    if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
    if (d) return false;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a, b, c, d, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z[a] = new v(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    z[b] = new v(b, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z[a] = new v(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z[a] = new v(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    z[a] = new v(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    z[a] = new v(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      ra,
      sa
    );
    z[b] = new v(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta(a, b, c, d) {
    var e = z.hasOwnProperty(b) ? z[b] : null;
    if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A = Object.assign, La;
  function Ma(a) {
    if (void 0 === La) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b) {
    if (!a || Na) return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }
        a.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l) {
          d = l;
        }
        a();
      }
    } catch (l) {
      if (l && d && "string" === typeof l.stack) {
        for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
        for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h]) {
                var k = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                return k;
              }
            while (1 <= g && 0 <= h);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  function Ra(a) {
    var b = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a) {
    var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
    if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get, f = c.set;
      Object.defineProperty(a, b, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a2) {
        d = "" + a2;
        f.call(this, a2);
      } });
      Object.defineProperty(a, b, { enumerable: c.enumerable });
      return { getValue: function() {
        return d;
      }, setValue: function(a2) {
        d = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return false;
    var b = a._valueTracker;
    if (!b) return true;
    var c = b.getValue();
    var d = "";
    a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d;
    return a !== c ? (b.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;
    try {
      return a.activeElement || a.body;
    } catch (b) {
      return a.body;
    }
  }
  function Ya(a, b) {
    var c = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
  }
  function Za(a, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a, b) {
    b = b.checked;
    null != b && ta(a, "checked", b, false);
  }
  function bb(a, b) {
    ab(a, b);
    var c = Sa(b.value), d = b.type;
    if (null != c) if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
    else if ("submit" === d || "reset" === d) {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }
  function db(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a._wrapperState.initialValue;
      c || b === a.value || (a.value = b);
      a.defaultValue = b;
    }
    c = a.name;
    "" !== c && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c && (a.name = c);
  }
  function cb(a, b, c) {
    if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
  }
  var eb = Array.isArray;
  function fb(a, b, c, d) {
    a = a.options;
    if (b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
    } else {
      c = "" + Sa(c);
      b = null;
      for (e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = true;
          d && (a[e].defaultSelected = true);
          return;
        }
        null !== b || a[e].disabled || (b = a[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b) {
    var c = b.value;
    if (null == c) {
      c = b.children;
      b = b.defaultValue;
      if (null != c) {
        if (null != b) throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = "");
      c = b;
    }
    a._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a, b) {
    var c = Sa(b.value), d = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
    null != d && (a.defaultValue = "" + d);
  }
  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b, c, d, e);
      });
    } : a;
  }(function(a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b.firstChild; ) a.appendChild(b.firstChild);
    }
  });
  function ob(a, b) {
    if (b) {
      var c = a.firstChild;
      if (c && c === a.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }
    a.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b] = pb[a];
    });
  });
  function rb(a, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
  }
  function sb(a, b) {
    a = a.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a, b) {
    if (b) {
      if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
    }
  }
  function vb(a, b) {
    if (-1 === a.indexOf("-")) return "string" === typeof b.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(p(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b = Ab;
      Ab = zb = null;
      Bb(a);
      if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }
  function Gb(a, b) {
    return a(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b, c) {
    if (Ib) return a(b, c);
    Ib = true;
    try {
      return Gb(a, b, c);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a, b) {
    var c = a.stateNode;
    if (null === c) return null;
    var d = Db(c);
    if (null === d) return null;
    c = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
    if (a) return null;
    if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
  function Nb(a, b, c, d, e, f, g, h, k) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l);
    } catch (m) {
      this.onError(m);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
    Ob = true;
    Pb = a;
  } };
  function Tb(a, b, c, d, e, f, g, h, k) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b, c, d, e, f, g, h, k) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = true, Rb = l);
    }
  }
  function Vb(a) {
    var b = a, c = a;
    if (a.alternate) for (; b.return; ) b = b.return;
    else {
      a = b;
      do
        b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
      while (a);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b = a.memoizedState;
      null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p(188));
  }
  function Yb(a) {
    var b = a.alternate;
    if (!b) {
      b = Vb(a);
      if (null === b) throw Error(p(188));
      return b !== a ? null : a;
    }
    for (var c = a, d = b; ; ) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;
      if (null === f) {
        d = e.return;
        if (null !== d) {
          c = d;
          continue;
        }
        break;
      }
      if (e.child === f.child) {
        for (f = e.child; f; ) {
          if (f === c) return Xb(e), a;
          if (f === d) return Xb(e), b;
          f = f.sibling;
        }
        throw Error(p(188));
      }
      if (c.return !== d.return) c = e, d = f;
      else {
        for (var g = false, h = e.child; h; ) {
          if (h === c) {
            g = true;
            c = e;
            d = f;
            break;
          }
          if (h === d) {
            g = true;
            d = e;
            c = f;
            break;
          }
          h = h.sibling;
        }
        if (!g) {
          for (h = f.child; h; ) {
            if (h === c) {
              g = true;
              c = f;
              d = e;
              break;
            }
            if (h === d) {
              g = true;
              d = f;
              c = e;
              break;
            }
            h = h.sibling;
          }
          if (!g) throw Error(p(189));
        }
      }
      if (c.alternate !== d) throw Error(p(190));
    }
    if (3 !== c.tag) throw Error(p(188));
    return c.stateNode.current === c ? a : b;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag) return a;
    for (a = a.child; null !== a; ) {
      var b = $b(a);
      if (null !== b) return b;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec2 = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b) {
    var c = a.pendingLanes;
    if (0 === c) return 0;
    var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
    if (0 !== g) {
      var h = g & ~e;
      0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
    } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
    if (0 === d) return 0;
    if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
    0 !== (d & 4) && (d |= c & 16);
    b = a.entangledLanes;
    if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
    return d;
  }
  function vc(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b) {
    for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
      var g = 31 - oc(f), h = 1 << g, k = e[g];
      if (-1 === k) {
        if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
      } else k <= b && (a.expiredLanes |= h);
      f &= ~h;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);
    return b;
  }
  function Ac(a, b, c) {
    a.pendingLanes |= b;
    536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b = 31 - oc(b);
    a[b] = c;
  }
  function Bc(a, b) {
    var c = a.pendingLanes & ~b;
    a.pendingLanes = b;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b;
    a.mutableReadLanes &= b;
    a.entangledLanes &= b;
    b = a.entanglements;
    var d = a.eventTimes;
    for (a = a.expirationTimes; 0 < c; ) {
      var e = 31 - oc(c), f = 1 << e;
      b[e] = 0;
      d[e] = -1;
      a[e] = -1;
      c &= ~f;
    }
  }
  function Cc(a, b) {
    var c = a.entangledLanes |= b;
    for (a = a.entanglements; c; ) {
      var d = 31 - oc(c), e = 1 << d;
      e & b | a[d] & b && (a[d] |= b);
      c &= ~e;
    }
  }
  var C = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a, b, c, d, e, f) {
    if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
    a.eventSystemFlags |= d;
    b = a.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a;
  }
  function Uc(a, b, c, d, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a, b, c, d, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b, c, d, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b, c, d, e), true;
      case "pointerover":
        var f = e.pointerId;
        Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
        return true;
      case "gotpointercapture":
        return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
    }
    return false;
  }
  function Vc(a) {
    var b = Wc(a.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (b = c.tag, 13 === b) {
          if (b = Wb(c), null !== b) {
            a.blockedOn = b;
            Ic(a.priority, function() {
              Gc(c);
            });
            return;
          }
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn) return false;
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null === c) {
        c = a.nativeEvent;
        var d = new c.constructor(c.type, c);
        wb = d;
        c.target.dispatchEvent(d);
        wb = null;
      } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
      b.shift();
    }
    return true;
  }
  function Zc(a, b, c) {
    Xc(a) && c.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b) {
    a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b(b2) {
      return ad(b2, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c = 1; c < Kc.length; c++) {
        var d = Kc[c];
        d.blockedOn === a && (d.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function gd(a, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function fd(a, b, c, d) {
    if (dd) {
      var e = Yc(a, b, c, d);
      if (null === e) hd(a, b, d, id, c), Sc(a, d);
      else if (Uc(e, a, b, c, d)) d.stopPropagation();
      else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e; ) {
          var f = Cb(e);
          null !== f && Ec(f);
          f = Yc(a, b, c, d);
          null === f && hd(a, b, d, id, c);
          if (f === e) break;
          e = f;
        }
        null !== e && d.stopPropagation();
      } else hd(a, b, d, null, c);
    }
  }
  var id = null;
  function Yc(a, b, c, d) {
    id = null;
    a = xb(d);
    a = Wc(a);
    if (null !== a) if (b = Vb(a), null === b) a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a) return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else b !== a && (a = null);
    id = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec2()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
    for (a = 0; a < c && b[a] === e[a]; a++) ;
    var g = c - a;
    for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
    return md = e.slice(a, 1 < d ? 1 - d : void 0);
  }
  function od(a) {
    var b = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b(b2, d, e, f, g) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;
      for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie = false;
  function je(a, b) {
    switch (a) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b) {
    if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
  }
  function ne(a, b, c, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
  }
  var pe = null, qe = null;
  function re(a) {
    se(a, 0);
  }
  function te(a) {
    var b = ue(a);
    if (Wa(b)) return a;
  }
  function ve(a, b) {
    if ("change" === a) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a, xb(a));
      Jb(re, b);
    }
  }
  function Ce(a, b, c) {
    "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }
  function Ee(a, b) {
    if ("click" === a) return te(b);
  }
  function Fe(a, b) {
    if ("input" === a || "change" === a) return te(b);
  }
  function Ge(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b) {
    if (He(a, b)) return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
    var c = Object.keys(a), d = Object.keys(b);
    if (c.length !== d.length) return false;
    for (d = 0; d < c.length; d++) {
      var e = c[d];
      if (!ja.call(b, e) || !He(a[e], b[e])) return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke(a, b) {
    var c = Je(a);
    a = 0;
    for (var d; c; ) {
      if (3 === c.nodeType) {
        d = a + c.textContent.length;
        if (a <= b && d >= b) return { node: c, offset: b - a };
        a = d;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je(c);
    }
  }
  function Le(a, b) {
    return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c = false;
      }
      if (c) a = b.contentWindow;
      else break;
      b = Xa(a.document);
    }
    return b;
  }
  function Ne(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b = Me(), c = a.focusedElem, d = a.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (null !== d && Ne(c)) {
        if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
        else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e = c.textContent.length, f = Math.min(d.start, e);
          d = void 0 === d.end ? f : Math.min(d.end, e);
          !a.extend && f > d && (e = d, d = f, f = e);
          e = Ke(c, f);
          var g = Ke(
            c,
            d
          );
          e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
        }
      }
      b = [];
      for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      "function" === typeof c.focus && c.focus();
      for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b, c) {
    var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
  }
  function Ve(a, b) {
    var c = {};
    c[a.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a] = "webkit" + b;
    c["Moz" + a] = "moz" + b;
    return c;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a]) return Xe[a];
    if (!We[a]) return a;
    var b = We[a], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b) {
    df.set(a, b);
    fa(b, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b, c) {
    var d = a.type || "unknown-event";
    a.currentTarget = c;
    Ub(d, b, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b) {
    b = 0 !== (b & 4);
    for (var c = 0; c < a.length; c++) {
      var d = a[c], e = d.event;
      d = d.listeners;
      a: {
        var f = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
        else for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d = a + "__bubble";
    c.has(d) || (pf(b, a, 2, false), c.add(d));
  }
  function qf(a, b, c) {
    var d = 0;
    b && (d |= 4);
    pf(c, a, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
      });
      var b = 9 === a.nodeType ? a : a.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a, b, c, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
  }
  function hd(a, b, c, d, e) {
    var f = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
      if (null === d) return;
      var g = d.tag;
      if (3 === g || 4 === g) {
        var h = d.stateNode.containerInfo;
        if (h === e || 8 === h.nodeType && h.parentNode === e) break;
        if (4 === g) for (g = d.return; null !== g; ) {
          var k = g.tag;
          if (3 === k || 4 === k) {
            if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
          }
          g = g.return;
        }
        for (; null !== h; ) {
          g = Wc(h);
          if (null === g) return;
          k = g.tag;
          if (5 === k || 6 === k) {
            d = f = g;
            continue a;
          }
          h = h.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f, e2 = xb(c), g2 = [];
      a: {
        var h2 = df.get(a);
        if (void 0 !== h2) {
          var k2 = td, n = a;
          switch (a) {
            case "keypress":
              if (0 === od(c)) break a;
            case "keydown":
            case "keyup":
              k2 = Rd;
              break;
            case "focusin":
              n = "focus";
              k2 = Fd;
              break;
            case "focusout":
              n = "blur";
              k2 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k2 = Fd;
              break;
            case "click":
              if (2 === c.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k2 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k2 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k2 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k2 = Hd;
              break;
            case cf:
              k2 = Xd;
              break;
            case "scroll":
              k2 = vd;
              break;
            case "wheel":
              k2 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k2 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k2 = Td;
          }
          var t2 = 0 !== (b & 4), J = !t2 && "scroll" === a, x = t2 ? null !== h2 ? h2 + "Capture" : null : h2;
          t2 = [];
          for (var w = d2, u; null !== w; ) {
            u = w;
            var F = u.stateNode;
            5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t2.push(tf(w, F, u))));
            if (J) break;
            w = w.return;
          }
          0 < t2.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t2 }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h2 = "mouseover" === a || "pointerover" === a;
          k2 = "mouseout" === a || "pointerout" === a;
          if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
          if (k2 || h2) {
            h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
            if (k2) {
              if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
            } else k2 = null, n = d2;
            if (k2 !== n) {
              t2 = Bd;
              F = "onMouseLeave";
              x = "onMouseEnter";
              w = "mouse";
              if ("pointerout" === a || "pointerover" === a) t2 = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
              J = null == k2 ? h2 : ue(k2);
              u = null == n ? h2 : ue(n);
              h2 = new t2(F, w + "leave", k2, c, e2);
              h2.target = J;
              h2.relatedTarget = u;
              F = null;
              Wc(e2) === d2 && (t2 = new t2(x, w + "enter", n, c, e2), t2.target = u, t2.relatedTarget = J, F = t2);
              J = F;
              if (k2 && n) b: {
                t2 = k2;
                x = n;
                w = 0;
                for (u = t2; u; u = vf(u)) w++;
                u = 0;
                for (F = x; F; F = vf(F)) u++;
                for (; 0 < w - u; ) t2 = vf(t2), w--;
                for (; 0 < u - w; ) x = vf(x), u--;
                for (; w--; ) {
                  if (t2 === x || null !== x && t2 === x.alternate) break b;
                  t2 = vf(t2);
                  x = vf(x);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k2 && wf(g2, h2, k2, t2, false);
              null !== n && null !== J && wf(g2, J, n, t2, true);
            }
          }
        }
        a: {
          h2 = d2 ? ue(d2) : window;
          k2 = h2.nodeName && h2.nodeName.toLowerCase();
          if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
          else if (me(h2)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
          if (na && (na = na(a, d2))) {
            ne(g2, na, c, e2);
            break a;
          }
          xa && xa(a, h2, d2);
          "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
        }
        xa = d2 ? ue(d2) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c, e2);
        }
        var $a;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a, b, c) {
    return { instance: a, listener: b, currentTarget: c };
  }
  function oe(a, b) {
    for (var c = b + "Capture", d = []; null !== a; ) {
      var e = a, f = e.stateNode;
      5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
      a = a.return;
    }
    return d;
  }
  function vf(a) {
    if (null === a) return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b, c, d, e) {
    for (var f = b._reactName, g = []; null !== c && c !== d; ) {
      var h = c, k = h.alternate, l = h.stateNode;
      if (null !== k && k === d) break;
      5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
      c = c.return;
    }
    0 !== g.length && a.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b, c) {
    b = zf(b);
    if (zf(a) !== b && c) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b) {
    return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b) {
    var c = b, d = 0;
    do {
      var e = c.nextSibling;
      a.removeChild(c);
      if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e);
          bd(b);
          return;
        }
        d--;
      } else "$" !== c && "$?" !== c && "$!" !== c || d++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b = a.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b = 0; a; ) {
      if (8 === a.nodeType) {
        var c = a.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a;
          b--;
        } else "/$" === c && b++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b = a[Of];
    if (b) return b;
    for (var c = a.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
          if (c = a[Of]) return c;
          a = Mf(a);
        }
        return b;
      }
      a = c;
      c = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(p(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Vf;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f;
    for (f in c) e[f] = b[f];
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b, c) {
    if (H.current !== Vf) throw Error(p(168));
    G(H, b);
    G(Wf, c);
  }
  function bg(a, b, c) {
    var d = a.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();
    for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
    return A({}, c, d);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(p(169));
    c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [a] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b = C;
      try {
        var c = eg;
        for (C = 1; a < c.length; a++) {
          var d = c[a];
          do
            d = d(true);
          while (null !== d);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
      } finally {
        C = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b;
  }
  function ug(a, b, c) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d = rg;
    a = sg;
    var e = 32 - oc(d) - 1;
    d &= ~(1 << e);
    c += 1;
    var f = 32 - oc(b) + e;
    if (30 < f) {
      var g = e - e % 5;
      f = (d & (1 << g) - 1).toString(32);
      d >>= g;
      e -= g;
      rg = 1 << 32 - oc(b) + e | c << e | d;
      sg = f + a;
    } else rg = 1 << f | c << e | d, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED";
    c.stateNode = b;
    c.return = a;
    b = a.deletions;
    null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
  }
  function Cg(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a, b)) {
          if (Dg(a)) throw Error(p(418));
          b = Lf(c.nextSibling);
          var d = xg;
          b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg) return false;
    if (!I) return Fg(a), I = true, false;
    var b;
    (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(p(317));
      a: {
        a = a.nextSibling;
        for (b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("/$" === c) {
              if (0 === b) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b, c) {
    a = c.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;
        if (c) {
          if (1 !== c.tag) throw Error(p(309));
          var d = c.stateNode;
        }
        if (!d) throw Error(p(147, a));
        var e = d, f = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
        b = function(a2) {
          var b2 = e.refs;
          null === a2 ? delete b2[f] : b2[f] = a2;
        };
        b._stringRef = f;
        return b;
      }
      if ("string" !== typeof a) throw Error(p(284));
      if (!c._owner) throw Error(p(290, a));
    }
    return a;
  }
  function Mg(a, b) {
    a = Object.prototype.toString.call(b);
    throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b = a._init;
    return b(a._payload);
  }
  function Og(a) {
    function b(b2, c2) {
      if (a) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
      }
    }
    function c(c2, d2) {
      if (!a) return null;
      for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
      return null;
    }
    function d(a2, b2) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
      return a2;
    }
    function e(a2, b2) {
      a2 = Pg(a2, b2);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f(b2, c2, d2) {
      b2.index = d2;
      if (!a) return b2.flags |= 1048576, c2;
      d2 = b2.alternate;
      if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
      b2.flags |= 2;
      return c2;
    }
    function g(b2) {
      a && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h(a2, b2, c2, d2) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function k(a2, b2, c2, d2) {
      var f2 = c2.type;
      if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
      if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
      d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
      d2.ref = Lg(a2, b2, c2);
      d2.return = a2;
      return d2;
    }
    function l(a2, b2, c2, d2) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2.children || []);
      b2.return = a2;
      return b2;
    }
    function m(a2, b2, c2, d2, f2) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function q(a2, b2, c2) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
          case wa:
            return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
          case Ha:
            var d2 = b2._init;
            return q(a2, d2(b2._payload), c2);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
        Mg(a2, b2);
      }
      return null;
    }
    function r(a2, b2, c2, d2) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case va:
            return c2.key === e2 ? k(a2, b2, c2, d2) : null;
          case wa:
            return c2.key === e2 ? l(a2, b2, c2, d2) : null;
          case Ha:
            return e2 = c2._init, r(
              a2,
              b2,
              e2(c2._payload),
              d2
            );
        }
        if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
        Mg(a2, c2);
      }
      return null;
    }
    function y(a2, b2, c2, d2, e2) {
      if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
      if ("object" === typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
          case wa:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
          case Ha:
            var f2 = d2._init;
            return y(a2, b2, c2, f2(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n(e2, g2, h2, k2) {
      for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
        u.index > w ? (x = u, u = null) : x = u.sibling;
        var n2 = r(e2, u, h2[w], k2);
        if (null === n2) {
          null === u && (u = x);
          break;
        }
        a && u && null === n2.alternate && b(e2, u);
        g2 = f(n2, g2, w);
        null === m2 ? l2 = n2 : m2.sibling = n2;
        m2 = n2;
        u = x;
      }
      if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
      if (null === u) {
        for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
        I && tg(e2, w);
        return l2;
      }
      for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
      a && u.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function t2(e2, g2, h2, k2) {
      var l2 = Ka(h2);
      if ("function" !== typeof l2) throw Error(p(150));
      h2 = l2.call(h2);
      if (null == h2) throw Error(p(151));
      for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
        m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
        var t3 = r(e2, m2, n2.value, k2);
        if (null === t3) {
          null === m2 && (m2 = x);
          break;
        }
        a && m2 && null === t3.alternate && b(e2, m2);
        g2 = f(t3, g2, w);
        null === u ? l2 = t3 : u.sibling = t3;
        u = t3;
        m2 = x;
      }
      if (n2.done) return c(
        e2,
        m2
      ), I && tg(e2, w), l2;
      if (null === m2) {
        for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        I && tg(e2, w);
        return l2;
      }
      for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
      a && m2.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function J(a2, d2, f2, h2) {
      "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
      if ("object" === typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                if (l2.key === k2) {
                  k2 = f2.type;
                  if (k2 === ya) {
                    if (7 === l2.tag) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                  } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                    c(a2, l2.sibling);
                    d2 = e(l2, f2.props);
                    d2.ref = Lg(a2, l2, f2);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                  c(a2, l2);
                  break;
                } else b(a2, l2);
                l2 = l2.sibling;
              }
              f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
            }
            return g(a2);
          case wa:
            a: {
              for (l2 = f2.key; null !== d2; ) {
                if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
                else b(a2, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f2, a2.mode, h2);
              d2.return = a2;
              a2 = d2;
            }
            return g(a2);
          case Ha:
            return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
        }
        if (eb(f2)) return n(a2, d2, f2, h2);
        if (Ka(f2)) return t2(a2, d2, f2, h2);
        Mg(a2, f2);
      }
      return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b = Wg.current;
    E(Wg);
    a._currentValue = b;
  }
  function bh(a, b, c) {
    for (; null !== a; ) {
      var d = a.alternate;
      (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
      if (a === c) break;
      a = a.return;
    }
  }
  function ch(a, b) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh2 = true), a.firstContext = null);
  }
  function eh(a) {
    var b = a._currentValue;
    if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
      if (null === Xg) throw Error(p(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else Yg = Yg.next = a;
    return b;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [a] : fh.push(a);
  }
  function hh(a, b, c, d) {
    var e = b.interleaved;
    null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
    b.interleaved = c;
    return ih(a, d);
  }
  function ih(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    c = a;
    for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b) {
    return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b, c) {
    var d = a.updateQueue;
    if (null === d) return null;
    d = d.shared;
    if (0 !== (K & 2)) {
      var e = d.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d.pending = b;
      return ih(a, c);
    }
    e = d.interleaved;
    null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
    d.interleaved = b;
    return ih(a, c);
  }
  function oh(a, b, c) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  function ph(a, b) {
    var c = a.updateQueue, d = a.alternate;
    if (null !== d && (d = d.updateQueue, c === d)) {
      var e = null, f = null;
      c = c.firstBaseUpdate;
      if (null !== c) {
        do {
          var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          null === f ? e = f = g : f = f.next = g;
          c = c.next;
        } while (null !== c);
        null === f ? e = f = b : f = f.next = b;
      } else e = f = b;
      c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
      a.updateQueue = c;
      return;
    }
    a = c.lastBaseUpdate;
    null === a ? c.firstBaseUpdate = b : a.next = b;
    c.lastBaseUpdate = b;
  }
  function qh(a, b, c, d) {
    var e = a.updateQueue;
    jh = false;
    var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
    if (null !== h) {
      e.shared.pending = null;
      var k = h, l = k.next;
      k.next = null;
      null === g ? f = l : g.next = l;
      g = k;
      var m = a.alternate;
      null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
    }
    if (null !== f) {
      var q = e.baseState;
      g = 0;
      m = l = k = null;
      h = f;
      do {
        var r = h.lane, y = h.eventTime;
        if ((d & r) === r) {
          null !== m && (m = m.next = {
            eventTime: y,
            lane: 0,
            tag: h.tag,
            payload: h.payload,
            callback: h.callback,
            next: null
          });
          a: {
            var n = a, t2 = h;
            r = b;
            y = c;
            switch (t2.tag) {
              case 1:
                n = t2.payload;
                if ("function" === typeof n) {
                  q = n.call(y, q, r);
                  break a;
                }
                q = n;
                break a;
              case 3:
                n.flags = n.flags & -65537 | 128;
              case 0:
                n = t2.payload;
                r = "function" === typeof n ? n.call(y, q, r) : n;
                if (null === r || void 0 === r) break a;
                q = A({}, q, r);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
        } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
        h = h.next;
        if (null === h) if (h = e.shared.pending, null === h) break;
        else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
      } while (1);
      null === m && (k = q);
      e.baseState = k;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = m;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g |= e.lane, e = e.next;
        while (e !== b);
      } else null === f && (e.shared.lanes = 0);
      rh |= g;
      a.lanes = g;
      a.memoizedState = q;
    }
  }
  function sh(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e) throw Error(p(191, e));
        e.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p(174));
    return a;
  }
  function yh(a, b) {
    G(wh, b);
    G(vh, a);
    G(uh, th);
    a = b.nodeType;
    switch (a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b = xh(uh.current);
    var c = lb(b, a.type);
    b !== c && (G(vh, a), G(uh, c));
  }
  function Bh(a) {
    vh.current === a && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b = a; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P2() {
    throw Error(p(321));
  }
  function Mh(a, b) {
    if (null === b) return false;
    for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
    return true;
  }
  function Nh(a, b, c, d, e, f) {
    Hh = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c(d, e);
    if (Jh) {
      f = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f) throw Error(p(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a = c(d, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a;
    else {
      if (null === a) throw Error(p(310));
      N = a;
      a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function Wh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = N, e = d.baseQueue, f = c.pending;
    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }
      d.baseQueue = e = f;
      c.pending = null;
    }
    if (null !== e) {
      f = e.next;
      d = d.baseState;
      var h = g = null, k = null, l = f;
      do {
        var m = l.lane;
        if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
        else {
          var q = {
            lane: m,
            action: l.action,
            hasEagerState: l.hasEagerState,
            eagerState: l.eagerState,
            next: null
          };
          null === k ? (h = k = q, g = d) : k = k.next = q;
          M.lanes |= m;
          rh |= m;
        }
        l = l.next;
      } while (null !== l && l !== f);
      null === k ? g = d : k.next = h;
      He(d, b.memoizedState) || (dh2 = true);
      b.memoizedState = d;
      b.baseState = g;
      b.baseQueue = k;
      c.lastRenderedState = d;
    }
    a = c.interleaved;
    if (null !== a) {
      e = a;
      do
        f = e.lane, M.lanes |= f, rh |= f, e = e.next;
      while (e !== a);
    } else null === e && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function Xh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch, e = c.pending, f = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g = e = e.next;
      do
        f = a(f, g.action), g = g.next;
      while (g !== e);
      He(f, b.memoizedState) || (dh2 = true);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c.lastRenderedState = f;
    }
    return [f, d];
  }
  function Yh() {
  }
  function Zh(a, b) {
    var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
    f && (d.memoizedState = e, dh2 = true);
    d = d.queue;
    $h(ai.bind(null, c, d, a), [a]);
    if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
      c.flags |= 2048;
      bi(9, ci.bind(null, c, d, e, b), void 0, null);
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(c, b, e);
    }
    return e;
  }
  function di(a, b, c) {
    a.flags |= 16384;
    a = { getSnapshot: b, value: c };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
  }
  function ci(a, b, c, d) {
    b.value = c;
    b.getSnapshot = d;
    ei(b) && fi(a);
  }
  function ai(a, b, c) {
    return c(function() {
      ei(b) && fi(a);
    });
  }
  function ei(a) {
    var b = a.getSnapshot;
    a = a.value;
    try {
      var c = b();
      return !He(a, c);
    } catch (d) {
      return true;
    }
  }
  function fi(a) {
    var b = ih(a, 1);
    null !== b && gi(b, a, 1, -1);
  }
  function hi(a) {
    var b = Th();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
    b.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [b.memoizedState, a];
  }
  function bi(a, b, c, d) {
    a = { tag: a, create: b, destroy: c, deps: d, next: null };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b, c, d) {
    var e = Th();
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
  }
  function li(a, b, c, d) {
    var e = Uh();
    d = void 0 === d ? null : d;
    var f = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;
      if (null !== d && Mh(d, g.deps)) {
        e.memoizedState = bi(b, c, f, d);
        return;
      }
    }
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, f, d);
  }
  function mi(a, b) {
    return ki(8390656, 8, a, b);
  }
  function $h(a, b) {
    return li(2048, 8, a, b);
  }
  function ni(a, b) {
    return li(4, 2, a, b);
  }
  function oi(a, b) {
    return li(4, 4, a, b);
  }
  function pi(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
      b.current = null;
    };
  }
  function qi(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return li(4, 4, pi.bind(null, b, a), c);
  }
  function ri() {
  }
  function si(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    c.memoizedState = [a, b];
    return a;
  }
  function ti(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    a = a();
    c.memoizedState = [a, b];
    return a;
  }
  function ui(a, b, c) {
    if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh2 = true), a.memoizedState = c;
    He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
    return b;
  }
  function vi(a, b) {
    var c = C;
    C = 0 !== c && 4 > c ? c : 4;
    a(true);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b();
    } finally {
      C = c, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b, c) {
    var d = yi(a);
    c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, c);
    else if (c = hh(a, b, c, d), null !== c) {
      var e = R();
      gi(c, a, d, e);
      Bi(c, b, d);
    }
  }
  function ii(a, b, c) {
    var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, e);
    else {
      var f = a.alternate;
      if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState, h = f(g, c);
        e.hasEagerState = true;
        e.eagerState = h;
        if (He(h, g)) {
          var k = b.interleaved;
          null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l) {
      } finally {
      }
      c = hh(a, b, e, d);
      null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
    }
  }
  function zi(a) {
    var b = a.alternate;
    return a === M || null !== b && b === M;
  }
  function Ai(a, b) {
    Jh = Ih = true;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
  function Bi(a, b, c) {
    if (0 !== (c & 4194240)) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  var Rh = { readContext: eh, useCallback: P2, useContext: P2, useEffect: P2, useImperativeHandle: P2, useInsertionEffect: P2, useLayoutEffect: P2, useMemo: P2, useReducer: P2, useRef: P2, useState: P2, useDebugValue: P2, useDeferredValue: P2, useTransition: P2, useMutableSource: P2, useSyncExternalStore: P2, useId: P2, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
    Th().memoizedState = [a, void 0 === b ? null : b];
    return a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b, a),
      c
    );
  }, useLayoutEffect: function(a, b) {
    return ki(4194308, 4, a, b);
  }, useInsertionEffect: function(a, b) {
    return ki(4, 2, a, b);
  }, useMemo: function(a, b) {
    var c = Th();
    b = void 0 === b ? null : b;
    a = a();
    c.memoizedState = [a, b];
    return a;
  }, useReducer: function(a, b, c) {
    var d = Th();
    b = void 0 !== c ? c(b) : b;
    d.memoizedState = d.baseState = b;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
    d.queue = a;
    a = a.dispatch = xi.bind(null, M, a);
    return [d.memoizedState, a];
  }, useRef: function(a) {
    var b = Th();
    a = { current: a };
    return b.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(false), b = a[0];
    a = vi.bind(null, a[1]);
    Th().memoizedState = a;
    return [b, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b, c) {
    var d = M, e = Th();
    if (I) {
      if (void 0 === c) throw Error(p(407));
      c = c();
    } else {
      c = b();
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(d, b, c);
    }
    e.memoizedState = c;
    var f = { value: c, getSnapshot: b };
    e.queue = f;
    mi(ai.bind(
      null,
      d,
      f,
      a
    ), [a]);
    d.flags |= 2048;
    bi(9, ci.bind(null, d, f, c, b), void 0, null);
    return c;
  }, useId: function() {
    var a = Th(), b = Q.identifierPrefix;
    if (I) {
      var c = sg;
      var d = rg;
      c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
      b = ":" + b + "R" + c;
      c = Kh++;
      0 < c && (b += "H" + c.toString(32));
      b += ":";
    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
    return a.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return ui(b, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b = Uh();
    return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a, b) {
    if (a && a.defaultProps) {
      b = A({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Di(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : A({}, b, c);
    a.memoizedState = c;
    0 === a.lanes && (a.updateQueue.baseState = c);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : false;
  }, enqueueSetState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueReplaceState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueForceUpdate: function(a, b) {
    a = a._reactInternals;
    var c = R(), d = yi(a), e = mh(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = nh(a, e, d);
    null !== b && (gi(b, a, d, c), oh(b, a, d));
  } };
  function Fi(a, b, c, d, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
  }
  function Gi(a, b, c) {
    var d = false, e = Vf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a.stateNode = b;
    b._reactInternals = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }
  function Hi(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = {};
    kh(a);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
    e.state = a.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b) {
    try {
      var c = "", d = b;
      do
        c += Pa(d), d = d.return;
      while (d);
      var e = c;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a, source: b, stack: e, digest: null };
  }
  function Ki(a, b, c) {
    return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
  }
  function Li(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    c.payload = { element: null };
    var d = b.value;
    c.callback = function() {
      Oi || (Oi = true, Pi = d);
      Li(a, b);
    };
    return c;
  }
  function Qi(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;
    if ("function" === typeof d) {
      var e = b.value;
      c.payload = function() {
        return d(e);
      };
      c.callback = function() {
        Li(a, b);
      };
    }
    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
      Li(a, b);
      "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
    });
    return c;
  }
  function Si(a, b, c) {
    var d = a.pingCache;
    if (null === d) {
      d = a.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
  }
  function Ui(a) {
    do {
      var b;
      if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b, c, d, e) {
    if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh2 = false;
  function Xi(a, b, c, d) {
    b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
  }
  function Yi(a, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    ch(b, e);
    d = Nh(a, b, c, d, f, e);
    c = Sh();
    if (null !== a && !dh2) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && c && vg(b);
    b.flags |= 1;
    Xi(a, b, d, e);
    return b.child;
  }
  function $i(a, b, c, d, e) {
    if (null === a) {
      var f = c.type;
      if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
      a = Rg(c.type, null, d, b, b.mode, e);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    f = a.child;
    if (0 === (a.lanes & e)) {
      var g = f.memoizedProps;
      c = c.compare;
      c = null !== c ? c : Ie;
      if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
    }
    b.flags |= 1;
    a = Pg(f, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  function bj(a, b, c, d, e) {
    if (null !== a) {
      var f = a.memoizedProps;
      if (Ie(f, d) && a.ref === b.ref) if (dh2 = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh2 = true);
      else return b.lanes = a.lanes, Zi(a, b, e);
    }
    return cj(a, b, c, d, e);
  }
  function dj(a, b, c) {
    var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
    if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f ? f.baseLanes : c;
      G(ej, fj);
      fj |= d;
    }
    else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
    Xi(a, b, e, c);
    return b.child;
  }
  function gj(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a, b, c, d, e) {
    var f = Zf(c) ? Xf : H.current;
    f = Yf(b, f);
    ch(b, e);
    c = Nh(a, b, c, d, f, e);
    d = Sh();
    if (null !== a && !dh2) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && d && vg(b);
    b.flags |= 1;
    Xi(a, b, c, e);
    return b.child;
  }
  function hj(a, b, c, d, e) {
    if (Zf(c)) {
      var f = true;
      cg(b);
    } else f = false;
    ch(b, e);
    if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
    else if (null === a) {
      var g = b.stateNode, h = b.memoizedProps;
      g.props = h;
      var k = g.context, l = c.contextType;
      "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
      var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
      q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
      jh = false;
      var r = b.memoizedState;
      g.state = r;
      qh(b, d, g, e);
      k = b.memoizedState;
      h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode;
      lh(a, b);
      h = b.memoizedProps;
      l = b.type === b.elementType ? h : Ci(b.type, h);
      g.props = l;
      q = b.pendingProps;
      r = g.context;
      k = c.contextType;
      "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
      var y = c.getDerivedStateFromProps;
      (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
      jh = false;
      r = b.memoizedState;
      g.state = r;
      qh(b, d, g, e);
      var n = b.memoizedState;
      h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
    }
    return jj(a, b, c, d, f, e);
  }
  function jj(a, b, c, d, e, f) {
    gj(a, b);
    var g = 0 !== (b.flags & 128);
    if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
    d = b.stateNode;
    Wi.current = b;
    var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
    b.memoizedState = d.state;
    e && dg(b, c, true);
    return b.child;
  }
  function kj(a) {
    var b = a.stateNode;
    b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
    yh(a, b.containerInfo);
  }
  function lj(a, b, c, d, e) {
    Ig();
    Jg(e);
    b.flags |= 256;
    Xi(a, b, c, d);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b, c) {
    var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
    (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
    if (h) f = true, b.flags &= -129;
    else if (null === a || null !== a.memoizedState) e |= 1;
    G(L, e & 1);
    if (null === a) {
      Eg(b);
      a = b.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d.children;
      a = d.fallback;
      return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
    }
    e = a.memoizedState;
    if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
    if (f) {
      f = d.fallback;
      g = b.mode;
      e = a.child;
      h = e.sibling;
      var k = { mode: "hidden", children: d.children };
      0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
      f.return = b;
      d.return = b;
      d.sibling = f;
      b.child = d;
      d = f;
      f = b.child;
      g = a.child.memoizedState;
      g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
      f.memoizedState = g;
      f.childLanes = a.childLanes & ~c;
      b.memoizedState = mj;
      return d;
    }
    f = a.child;
    a = f.sibling;
    d = Pg(f, { mode: "visible", children: d.children });
    0 === (b.mode & 1) && (d.lanes = c);
    d.return = b;
    d.sibling = null;
    null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
    b.child = d;
    b.memoizedState = null;
    return d;
  }
  function qj(a, b) {
    b = pj({ mode: "visible", children: b }, a.mode, 0, null);
    b.return = a;
    return a.child = b;
  }
  function sj(a, b, c, d) {
    null !== d && Jg(d);
    Ug(b, a.child, null, c);
    a = qj(b, b.pendingProps.children);
    a.flags |= 2;
    b.memoizedState = null;
    return a;
  }
  function rj(a, b, c, d, e, f, g) {
    if (c) {
      if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
      if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
      f = d.fallback;
      e = b.mode;
      d = pj({ mode: "visible", children: d.children }, e, 0, null);
      f = Tg(f, e, g, null);
      f.flags |= 2;
      d.return = b;
      f.return = b;
      d.sibling = f;
      b.child = d;
      0 !== (b.mode & 1) && Ug(b, a.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f;
    }
    if (0 === (b.mode & 1)) return sj(a, b, g, null);
    if ("$!" === e.data) {
      d = e.nextSibling && e.nextSibling.dataset;
      if (d) var h = d.dgst;
      d = h;
      f = Error(p(419));
      d = Ki(f, d, void 0);
      return sj(a, b, g, d);
    }
    h = 0 !== (g & a.childLanes);
    if (dh2 || h) {
      d = Q;
      if (null !== d) {
        switch (g & -g) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
        0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
      }
      tj();
      d = Ki(Error(p(421)));
      return sj(a, b, g, d);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
    a = f.treeContext;
    yg = Lf(e.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
    b = qj(b, d.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a, b, c) {
    a.lanes |= b;
    var d = a.alternate;
    null !== d && (d.lanes |= b);
    bh(a.return, b, c);
  }
  function wj(a, b, c, d, e) {
    var f = a.memoizedState;
    null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
  }
  function xj(a, b, c) {
    var d = b.pendingProps, e = d.revealOrder, f = d.tail;
    Xi(a, b, d.children, c);
    d = L.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
        if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
        else if (19 === a.tag) vj(a, c, b);
        else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;
        for (; null === a.sibling; ) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }
        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    G(L, d);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        wj(b, false, e, c, f);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === Ch(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        wj(b, true, c, null, f);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a, b) {
    0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    rh |= b.lanes;
    if (0 === (c & b.childLanes)) return null;
    if (null !== a && b.child !== a.child) throw Error(p(153));
    if (null !== b.child) {
      a = b.child;
      c = Pg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a, b, c) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e = b.memoizedProps.value;
        G(Wg, d._currentValue);
        d._currentValue = e;
        break;
      case 13:
        d = b.memoizedState;
        if (null !== d) {
          if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
          G(L, L.current & 1);
          a = Zi(a, b, c);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d = 0 !== (c & b.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d) return xj(a, b, c);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G(L, L.current);
        if (d) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a, b, c);
    }
    return Zi(a, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return;
      c = c.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b, c, d) {
    var e = a.memoizedProps;
    if (e !== d) {
      a = b.stateNode;
      xh(uh.current);
      var f = null;
      switch (c) {
        case "input":
          e = Ya(a, e);
          d = Ya(a, d);
          f = [];
          break;
        case "select":
          e = A({}, e, { value: void 0 });
          d = A({}, d, { value: void 0 });
          f = [];
          break;
        case "textarea":
          e = gb(a, e);
          d = gb(a, d);
          f = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
      }
      ub(c, d);
      var g;
      c = null;
      for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];
        for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
      for (l in d) {
        var k = d[l];
        h = null != e ? e[l] : void 0;
        if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
        } else c || (f || (f = []), f.push(
          l,
          c
        )), c = k;
        else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
      }
      c && (f = f || []).push("style", c);
      var l = f;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };
  Cj = function(a, b, c, d) {
    c !== d && (b.flags |= 4);
  };
  function Dj(a, b) {
    if (!I) switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }
  function S(a) {
    var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
    if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
    else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
    a.subtreeFlags |= d;
    a.childLanes = c;
    return b;
  }
  function Ej(a, b, c) {
    var d = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        c = b.type;
        if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode) throw Error(p(166));
            S(b);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.type;
            var f = b.memoizedProps;
            d[Of] = b;
            d[Pf] = f;
            a = 0 !== (b.mode & 1);
            switch (c) {
              case "dialog":
                D("cancel", d);
                D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d
                );
                D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f);
                D("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f.multiple };
                D("invalid", d);
                break;
              case "textarea":
                hb(d, f), D("invalid", d);
            }
            ub(c, f);
            e = null;
            for (var g in f) if (f.hasOwnProperty(g)) {
              var h = f[g];
              "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                d.textContent,
                h,
                a
              ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
            }
            switch (c) {
              case "input":
                Va(d);
                db(d, f, true);
                break;
              case "textarea":
                Va(d);
                jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f.onClick && (d.onclick = Bf);
            }
            d = e;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
            a[Of] = b;
            a[Pf] = d;
            zj(a, b, false, false);
            b.stateNode = a;
            a: {
              g = vb(c, d);
              switch (c) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], a);
                  e = d;
                  break;
                case "source":
                  D("error", a);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a
                  );
                  D("load", a);
                  e = d;
                  break;
                case "details":
                  D("toggle", a);
                  e = d;
                  break;
                case "input":
                  Za(a, d);
                  e = Ya(a, d);
                  D("invalid", a);
                  break;
                case "option":
                  e = d;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d.multiple };
                  e = A({}, d, { value: void 0 });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d);
                  e = gb(a, d);
                  D("invalid", a);
                  break;
                default:
                  e = d;
              }
              ub(c, e);
              h = e;
              for (f in h) if (h.hasOwnProperty(f)) {
                var k = h[f];
                "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
              }
              switch (c) {
                case "input":
                  Va(a);
                  db(a, d, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d.value && a.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple;
                  f = d.value;
                  null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                    a,
                    !!d.multiple,
                    d.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
        else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
          c = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.memoizedProps;
            d[Of] = b;
            if (f = d.nodeValue !== c) {
              if (a = xg, null !== a) switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
            }
            f && (b.flags |= 4);
          } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d = b.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a) {
              if (!f) throw Error(p(318));
              f = b.memoizedState;
              f = null !== f ? f.dehydrated : null;
              if (!f) throw Error(p(317));
              f[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f = false;
          } else null !== zg && (Fj(zg), zg = null), f = true;
          if (!f) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c, b;
        d = null !== d;
        d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f = b.memoizedState;
        if (null === f) return S(b), null;
        d = 0 !== (b.flags & 128);
        g = f.rendering;
        if (null === g) if (d) Dj(f, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
            g = Ch(a);
            if (null !== g) {
              b.flags |= 128;
              Dj(f, false);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;
              for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
        }
        else {
          if (!d) if (a = Ch(g), null !== a) {
            if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
        }
        if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a = b.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b.alternate) throw Error(p(340));
          Ig();
        }
        a = b.flags;
        return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a, b) {
    var c = a.ref;
    if (null !== c) if ("function" === typeof c) try {
      c(null);
    } catch (d) {
      W(a, b, d);
    }
    else c.current = null;
  }
  function Mj(a, b, c) {
    try {
      c();
    } catch (d) {
      W(a, b, d);
    }
  }
  var Nj = false;
  function Oj(a, b) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
      else a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e = d.anchorOffset, f = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f.nodeType;
          } catch (F) {
            c = null;
            break a;
          }
          var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
          b: for (; ; ) {
            for (var y; ; ) {
              q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
              q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
              3 === q.nodeType && (g += q.nodeValue.length);
              if (null === (y = q.firstChild)) break;
              r = q;
              q = y;
            }
            for (; ; ) {
              if (q === a) break b;
              r === c && ++l === e && (h = g);
              r === f && ++m === d && (k = g);
              if (null !== (y = q.nextSibling)) break;
              q = r;
              r = q.parentNode;
            }
            q = y;
          }
          c = -1 === h || -1 === k ? null : { start: h, end: k };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    Df = { focusedElem: a, selectionRange: c };
    dd = false;
    for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
    else for (; null !== V; ) {
      b = V;
      try {
        var n = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n) {
              var t2 = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J);
              x.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          case 3:
            var u = b.stateNode.containerInfo;
            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }
      a = b.sibling;
      if (null !== a) {
        a.return = b.return;
        V = a;
        break;
      }
      V = b.return;
    }
    n = Nj;
    Nj = false;
    return n;
  }
  function Pj(a, b, c) {
    var d = b.updateQueue;
    d = null !== d ? d.lastEffect : null;
    if (null !== d) {
      var e = d = d.next;
      do {
        if ((e.tag & a) === a) {
          var f = e.destroy;
          e.destroy = void 0;
          void 0 !== f && Mj(b, c, f);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Qj(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c = b = b.next;
      do {
        if ((c.tag & a) === a) {
          var d = c.create;
          c.destroy = d();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a) {
    var b = a.ref;
    if (null !== b) {
      var c = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c;
          break;
        default:
          a = c;
      }
      "function" === typeof b ? b(a) : b.current = a;
    }
  }
  function Sj(a) {
    var b = a.alternate;
    null !== b && (a.alternate = null, Sj(b));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return)) return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2) continue a;
        if (null === a.child || 4 === a.tag) continue a;
        else a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
  }
  function Wj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
    else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
  }
  var X = null, Xj = false;
  function Yj(a, b, c) {
    for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
  }
  function Zj(a, b, c) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h) {
    }
    switch (c.tag) {
      case 5:
        U || Lj(c, b);
      case 6:
        var d = X, e = Xj;
        X = null;
        Yj(a, b, c);
        X = d;
        Xj = e;
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
        break;
      case 4:
        d = X;
        e = Xj;
        X = c.stateNode.containerInfo;
        Xj = true;
        Yj(a, b, c);
        X = d;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
          e = d = d.next;
          do {
            var f = e, g = f.destroy;
            f = f.tag;
            void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
            e = e.next;
          } while (e !== d);
        }
        Yj(a, b, c);
        break;
      case 1:
        if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h) {
          W(c, b, h);
        }
        Yj(a, b, c);
        break;
      case 21:
        Yj(a, b, c);
        break;
      case 22:
        c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
        break;
      default:
        Yj(a, b, c);
    }
  }
  function ak(a) {
    var b = a.updateQueue;
    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Kj());
      b.forEach(function(b2) {
        var d = bk.bind(null, a, b2);
        c.has(b2) || (c.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a, b) {
    var c = b.deletions;
    if (null !== c) for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f = a, g = b, h = g;
        a: for (; null !== h; ) {
          switch (h.tag) {
            case 5:
              X = h.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h = h.return;
        }
        if (null === X) throw Error(p(160));
        Zj(f, g, e);
        X = null;
        Xj = false;
        var k = e.alternate;
        null !== k && (k.return = null);
        e.return = null;
      } catch (l) {
        W(e, b, l);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
  }
  function dk(a, b) {
    var c = a.alternate, d = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a);
        ek(a);
        if (d & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t2) {
            W(a, a.return, t2);
          }
          try {
            Pj(5, a, a.return);
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 1:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        break;
      case 5:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        if (a.flags & 32) {
          var e = a.stateNode;
          try {
            ob(e, "");
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        if (d & 4 && (e = a.stateNode, null != e)) {
          var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
          a.updateQueue = null;
          if (null !== k) try {
            "input" === h && "radio" === f.type && null != f.name && ab(e, f);
            vb(h, g);
            var l = vb(h, f);
            for (g = 0; g < k.length; g += 2) {
              var m = k[g], q = k[g + 1];
              "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
            }
            switch (h) {
              case "input":
                bb(e, f);
                break;
              case "textarea":
                ib(e, f);
                break;
              case "select":
                var r = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f.multiple;
                var y = f.value;
                null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                  e,
                  !!f.multiple,
                  f.defaultValue,
                  true
                ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
            }
            e[Pf] = f;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 6:
        ck(b, a);
        ek(a);
        if (d & 4) {
          if (null === a.stateNode) throw Error(p(162));
          e = a.stateNode;
          f = a.memoizedProps;
          try {
            e.nodeValue = f;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 3:
        ck(b, a);
        ek(a);
        if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
        break;
      case 4:
        ck(b, a);
        ek(a);
        break;
      case 13:
        ck(b, a);
        ek(a);
        e = a.child;
        e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
        d & 4 && ak(a);
        break;
      case 22:
        m = null !== c && null !== c.memoizedState;
        a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
        ek(a);
        if (d & 8192) {
          l = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
            for (q = V = m; null !== V; ) {
              r = V;
              y = r.child;
              switch (r.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r, r.return);
                  break;
                case 1:
                  Lj(r, r.return);
                  var n = r.stateNode;
                  if ("function" === typeof n.componentWillUnmount) {
                    d = r;
                    c = r.return;
                    try {
                      b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                    } catch (t2) {
                      W(d, c, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r, r.return);
                  break;
                case 22:
                  if (null !== r.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y ? (y.return = r, V = y) : gk(q);
            }
            m = m.sibling;
          }
          a: for (m = null, q = a; ; ) {
            if (5 === q.tag) {
              if (null === m) {
                m = q;
                try {
                  e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q.tag) {
              if (null === m) try {
                q.stateNode.nodeValue = l ? "" : q.memoizedProps;
              } catch (t2) {
                W(a, a.return, t2);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a) break a;
              m === q && (m = null);
              q = q.return;
            }
            m === q && (m = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b, a);
        ek(a);
        d & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b = a.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a.return; null !== c; ) {
            if (Tj(c)) {
              var d = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            d.flags & 32 && (ob(e, ""), d.flags &= -33);
            var f = Uj(a);
            Wj(a, f, e);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo, h = Uj(a);
            Vj(a, h, g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k) {
        W(a, a.return, k);
      }
      a.flags &= -3;
    }
    b & 4096 && (a.flags &= -4097);
  }
  function hk(a, b, c) {
    V = a;
    ik(a);
  }
  function ik(a, b, c) {
    for (var d = 0 !== (a.mode & 1); null !== V; ) {
      var e = V, f = e.child;
      if (22 === e.tag && d) {
        var g = null !== e.memoizedState || Jj;
        if (!g) {
          var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
          h = Jj;
          var l = U;
          Jj = g;
          if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
          for (; null !== f; ) V = f, ik(f), f = f.sibling;
          V = e;
          Jj = h;
          U = l;
        }
        kk(a);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V; ) {
      var b = V;
      if (0 !== (b.flags & 8772)) {
        var c = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f = b.updateQueue;
              null !== f && sh(b, f, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh(b, g, c);
              }
              break;
            case 5:
              var h = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h;
                var k = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k.autoFocus && c.focus();
                    break;
                  case "img":
                    k.src && (c.src = k.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l = b.alternate;
                if (null !== l) {
                  var m = l.memoizedState;
                  if (null !== m) {
                    var q = m.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r) {
          W(b, b.return, r);
        }
      }
      if (b === a) {
        V = null;
        break;
      }
      c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function gk(a) {
    for (; null !== V; ) {
      var b = V;
      if (b === a) {
        V = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function jk(a) {
    for (; null !== V; ) {
      var b = V;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k) {
              W(b, c, k);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" === typeof d.componentDidMount) {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k) {
                W(b, e, k);
              }
            }
            var f = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a) {
        V = null;
        break;
      }
      var h = b.sibling;
      if (null !== h) {
        h.return = b.return;
        V = h;
        break;
      }
      V = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a = C;
    if (0 !== a) return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b, c, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a, c, d);
    if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b) {
    var c = a.callbackNode;
    wc(a, b);
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
    else if (b = d & -d, a.callbackPriority !== b) {
      null != c && bc(c);
      if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
      else {
        switch (Dc(d)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
            c = hc;
            break;
          case 536870912:
            c = jc;
            break;
          default:
            c = hc;
        }
        c = Fk(c, Gk.bind(null, a));
      }
      a.callbackPriority = b;
      a.callbackNode = c;
    }
  }
  function Gk(a, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p(327));
    var c = a.callbackNode;
    if (Hk() && a.callbackNode !== c) return null;
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) return null;
    if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
    else {
      b = d;
      var e = K;
      K |= 2;
      var f = Jk();
      if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
      do
        try {
          Lk();
          break;
        } catch (h) {
          Mk(a, h);
        }
      while (1);
      $g();
      mk.current = f;
      K = e;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
      if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      if (6 === b) Ck(a, d);
      else {
        e = a.current.alternate;
        if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        a.finishedWork = e;
        a.finishedLanes = d;
        switch (b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            Ck(a, d);
            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a, 0)) break;
              e = a.suspendedLanes;
              if ((e & d) !== d) {
                R();
                a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            Ck(a, d);
            if ((d & 4194240) === d) break;
            b = a.eventTimes;
            for (e = -1; 0 < d; ) {
              var g = 31 - oc(d);
              f = 1 << g;
              g = b[g];
              g > e && (e = g);
              d &= ~f;
            }
            d = e;
            d = B() - d;
            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
            if (10 < d) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c ? Gk.bind(null, a) : null;
  }
  function Nk(a, b) {
    var c = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
    a = Ik(a, b);
    2 !== a && (b = tk, tk = c, null !== b && Fj(b));
    return a;
  }
  function Fj(a) {
    null === tk ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b = a; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
          var e = c[d], f = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f(), e)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c = b.child;
      if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
      else {
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a, b) {
    b &= ~rk;
    b &= ~qk;
    a.suspendedLanes |= b;
    a.pingedLanes &= ~b;
    for (a = a.expirationTimes; 0 < b; ) {
      var c = 31 - oc(b), d = 1 << c;
      a[c] = -1;
      b &= ~d;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6)) throw Error(p(327));
    Hk();
    var b = uc(a, 0);
    if (0 === (b & 1)) return Dk(a, B()), null;
    var c = Ik(a, b);
    if (0 !== a.tag && 2 === c) {
      var d = xc(a);
      0 !== d && (b = d, c = Nk(a, d));
    }
    if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
    if (6 === c) throw Error(p(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b;
    Pk(a, tk, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b) {
    var c = K;
    K |= 1;
    try {
      return a(b);
    } finally {
      K = c, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c = ok.transition, d = C;
    try {
      if (ok.transition = null, C = 1, a) return a();
    } finally {
      C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c = a.timeoutHandle;
    -1 !== c && (a.timeoutHandle = -1, Gf(c));
    if (null !== Y) for (c = Y.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e = d.next, f = c.pending;
        if (null !== f) {
          var g = f.next;
          f.next = e;
          d.next = g;
        }
        c.pending = d;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b) {
    do {
      var c = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d = M.memoizedState; null !== d; ) {
            var e = d.queue;
            null !== e && (e.pending = null);
            d = d.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c || null === c.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f = a, g = c.return, h = c, k = b;
          b = Z;
          h.flags |= 32768;
          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l = k, m = h, q = m.tag;
            if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r = m.alternate;
              r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
            }
            var y = Ui(g);
            if (null !== y) {
              y.flags &= -257;
              Vi(y, g, h, f, b);
              y.mode & 1 && Si(f, l, b);
              b = y;
              k = l;
              var n = b.updateQueue;
              if (null === n) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k);
                b.updateQueue = t2;
              } else n.add(k);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f, l, b);
                tj();
                break a;
              }
              k = Error(p(426));
            }
          } else if (I && h.mode & 1) {
            var J = Ui(g);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g, h, f, b);
              Jg(Ji(k, h));
              break a;
            }
          }
          f = k = Ji(k, h);
          4 !== T && (T = 2);
          null === sk ? sk = [f] : sk.push(f);
          f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var x = Ni(f, k, b);
                ph(f, x);
                break a;
              case 1:
                h = k;
                var w = f.type, u = f.stateNode;
                if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var F = Qi(f, h, b);
                  ph(f, F);
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Sk(c);
      } catch (na) {
        b = na;
        Y === c && null !== c && (Y = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b) {
    var c = K;
    K |= 2;
    var d = Jk();
    if (Q !== a || Z !== b) uk = null, Kk(a, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a, e);
      }
    while (1);
    $g();
    K = c;
    mk.current = d;
    if (null !== Y) throw Error(p(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a) {
    var b = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b ? Sk(a) : Y = b;
    nk.current = null;
  }
  function Sk(a) {
    var b = a;
    do {
      var c = b.alternate;
      a = b.return;
      if (0 === (b.flags & 32768)) {
        if (c = Ej(c, b, fj), null !== c) {
          Y = c;
          return;
        }
      } else {
        c = Ij(c, b);
        if (null !== c) {
          c.flags &= 32767;
          Y = c;
          return;
        }
        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a, b, c) {
    var d = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a, b, c, d);
    } finally {
      ok.transition = e, C = d;
    }
    return null;
  }
  function Wk(a, b, c, d) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p(327));
    c = a.finishedWork;
    var e = a.finishedLanes;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c === a.current) throw Error(p(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f = c.lanes | c.childLanes;
    Bc(a, f);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f = 0 !== (c.flags & 15990);
    if (0 !== (c.subtreeFlags & 15990) || f) {
      f = ok.transition;
      ok.transition = null;
      var g = C;
      C = 1;
      var h = K;
      K |= 4;
      nk.current = null;
      Oj(a, c);
      dk(c, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c;
      hk(c);
      dc();
      K = h;
      C = g;
      ok.transition = f;
    } else a.current = c;
    vk && (vk = false, wk = a, xk = e);
    f = a.pendingLanes;
    0 === f && (Ri = null);
    mc(c.stateNode);
    Dk(a, B());
    if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f = a.pendingLanes;
    0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b = ok.transition, c = C;
      try {
        ok.transition = null;
        C = 16 > a ? 16 : a;
        if (null === wk) var d = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p(331));
          var e = K;
          K |= 4;
          for (V = a.current; null !== V; ) {
            var f = V, g = f.child;
            if (0 !== (V.flags & 16)) {
              var h = f.deletions;
              if (null !== h) {
                for (var k = 0; k < h.length; k++) {
                  var l = h[k];
                  for (V = l; null !== V; ) {
                    var m = V;
                    switch (m.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m, f);
                    }
                    var q = m.child;
                    if (null !== q) q.return = m, V = q;
                    else for (; null !== V; ) {
                      m = V;
                      var r = m.sibling, y = m.return;
                      Sj(m);
                      if (m === l) {
                        V = null;
                        break;
                      }
                      if (null !== r) {
                        r.return = y;
                        V = r;
                        break;
                      }
                      V = y;
                    }
                  }
                }
                var n = f.alternate;
                if (null !== n) {
                  var t2 = n.child;
                  if (null !== t2) {
                    n.child = null;
                    do {
                      var J = t2.sibling;
                      t2.sibling = null;
                      t2 = J;
                    } while (null !== t2);
                  }
                }
                V = f;
              }
            }
            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
            else b: for (; null !== V; ) {
              f = V;
              if (0 !== (f.flags & 2048)) switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f, f.return);
              }
              var x = f.sibling;
              if (null !== x) {
                x.return = f.return;
                V = x;
                break b;
              }
              V = f.return;
            }
          }
          var w = a.current;
          for (V = w; null !== V; ) {
            g = V;
            var u = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
            else b: for (g = w; null !== V; ) {
              h = V;
              if (0 !== (h.flags & 2048)) try {
                switch (h.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h);
                }
              } catch (na) {
                W(h, h.return, na);
              }
              if (h === g) {
                V = null;
                break b;
              }
              var F = h.sibling;
              if (null !== F) {
                F.return = h.return;
                V = F;
                break b;
              }
              V = h.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
          d = true;
        }
        return d;
      } finally {
        C = c, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a, b, c) {
    b = Ji(c, b);
    b = Ni(a, b, 1);
    a = nh(a, b, 1);
    b = R();
    null !== a && (Ac(a, 1, b), Dk(a, b));
  }
  function W(a, b, c) {
    if (3 === a.tag) Xk(a, a, c);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a = Ji(c, a);
          a = Qi(b, a, 1);
          b = nh(b, a, 1);
          a = R();
          null !== b && (Ac(b, 1, a), Dk(b, a));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    b = R();
    a.pingedLanes |= a.suspendedLanes & c;
    Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
    Dk(a, b);
  }
  function Yk(a, b) {
    0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c = R();
    a = ih(a, b);
    null !== a && (Ac(a, b, c), Dk(a, c));
  }
  function uj(a) {
    var b = a.memoizedState, c = 0;
    null !== b && (c = b.retryLane);
    Yk(a, c);
  }
  function bk(a, b) {
    var c = 0;
    switch (a.tag) {
      case 13:
        var d = a.stateNode;
        var e = a.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d = a.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d && d.delete(b);
    Yk(a, c);
  }
  var Vk;
  Vk = function(a, b, c) {
    if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh2 = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh2 = false, yj(a, b, c);
      dh2 = 0 !== (a.flags & 131072) ? true : false;
    }
    else dh2 = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d = b.type;
        ij(a, b);
        a = b.pendingProps;
        var e = Yf(b, H.current);
        ch(b, c);
        e = Nh(null, b, d, a, e, c);
        var f = Sh();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
        return b;
      case 16:
        d = b.elementType;
        a: {
          ij(a, b);
          a = b.pendingProps;
          e = d._init;
          d = e(d._payload);
          b.type = d;
          e = b.tag = Zk(d);
          a = Ci(d, a);
          switch (e) {
            case 0:
              b = cj(null, b, d, a, c);
              break a;
            case 1:
              b = hj(null, b, d, a, c);
              break a;
            case 11:
              b = Yi(null, b, d, a, c);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a), c);
              break a;
          }
          throw Error(p(
            306,
            d,
            ""
          ));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
      case 3:
        a: {
          kj(b);
          if (null === a) throw Error(p(387));
          d = b.pendingProps;
          f = b.memoizedState;
          e = f.element;
          lh(a, b);
          qh(b, d, null, c);
          var g = b.memoizedState;
          d = g.element;
          if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ji(Error(p(423)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ji(Error(p(424)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            Ig();
            if (d === e) {
              b = Zi(a, b, c);
              break a;
            }
            Xi(a, b, d, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
      case 6:
        return null === a && Eg(b), null;
      case 13:
        return oj(a, b, c);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
      case 7:
        return Xi(a, b, b.pendingProps, c), b.child;
      case 8:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          f = b.memoizedProps;
          g = e.value;
          G(Wg, d._currentValue);
          d._currentValue = g;
          if (null !== f) if (He(f.value, g)) {
            if (f.children === e.children && !Wf.current) {
              b = Zi(a, b, c);
              break a;
            }
          } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
            var h = f.dependencies;
            if (null !== h) {
              g = f.child;
              for (var k = h.firstContext; null !== k; ) {
                if (k.context === d) {
                  if (1 === f.tag) {
                    k = mh(-1, c & -c);
                    k.tag = 2;
                    var l = f.updateQueue;
                    if (null !== l) {
                      l = l.shared;
                      var m = l.pending;
                      null === m ? k.next = k : (k.next = m.next, m.next = k);
                      l.pending = k;
                    }
                  }
                  f.lanes |= c;
                  k = f.alternate;
                  null !== k && (k.lanes |= c);
                  bh(
                    f.return,
                    c,
                    b
                  );
                  h.lanes |= c;
                  break;
                }
                k = k.next;
              }
            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
            else if (18 === f.tag) {
              g = f.return;
              if (null === g) throw Error(p(341));
              g.lanes |= c;
              h = g.alternate;
              null !== h && (h.lanes |= c);
              bh(g, c, b);
              g = f.sibling;
            } else g = f.child;
            if (null !== g) g.return = f;
            else for (g = f; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f = g.sibling;
              if (null !== f) {
                f.return = g.return;
                g = f;
                break;
              }
              g = g.return;
            }
            f = g;
          }
          Xi(a, b, e.children, c);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
      case 14:
        return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
      case 15:
        return bj(a, b, b.type, b.pendingProps, c);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
      case 19:
        return xj(a, b, c);
      case 22:
        return dj(a, b, c);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a, b) {
    return ac(a, b);
  }
  function $k(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b, c, d) {
    return new $k(a, b, c, d);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a) return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b) {
    var c = a.alternate;
    null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
    c.flags = a.flags & 14680064;
    c.childLanes = a.childLanes;
    c.lanes = a.lanes;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }
  function Rg(a, b, c, d, e, f) {
    var g = 2;
    d = a;
    if ("function" === typeof a) aj(a) && (g = 1);
    else if ("string" === typeof a) g = 5;
    else a: switch (a) {
      case ya:
        return Tg(c.children, e, f, b);
      case za:
        g = 8;
        e |= 8;
        break;
      case Aa:
        return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
      case Ea:
        return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
      case Fa:
        return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
      case Ia:
        return pj(c, e, f, b);
      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d = null;
            break a;
        }
        throw Error(p(130, null == a ? a : typeof a, ""));
    }
    b = Bg(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.lanes = f;
    return b;
  }
  function Tg(a, b, c, d) {
    a = Bg(7, a, d, b);
    a.lanes = c;
    return a;
  }
  function pj(a, b, c, d) {
    a = Bg(22, a, d, b);
    a.elementType = Ia;
    a.lanes = c;
    a.stateNode = { isHidden: false };
    return a;
  }
  function Qg(a, b, c) {
    a = Bg(6, a, null, b);
    a.lanes = c;
    return a;
  }
  function Sg(a, b, c) {
    b = Bg(4, null !== a.children ? a.children : [], a.key, b);
    b.lanes = c;
    b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b;
  }
  function al(a, b, c, d, e) {
    this.tag = b;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b, c, d, e, f, g, h, k) {
    a = new al(a, b, c, h, k);
    1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
    f = Bg(3, null, null, b);
    a.current = f;
    f.stateNode = a;
    f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f);
    return a;
  }
  function cl(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
      var b = a;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a.tag) {
      var c = a.type;
      if (Zf(c)) return bg(a, c, b);
    }
    return b;
  }
  function el2(a, b, c, d, e, f, g, h, k) {
    a = bl(c, d, true, a, e, f, g, h, k);
    a.context = dl(null);
    c = a.current;
    d = R();
    e = yi(c);
    f = mh(d, e);
    f.callback = void 0 !== b && null !== b ? b : null;
    nh(c, f, e);
    a.current.lanes = e;
    Ac(a, e, d);
    Dk(a, d);
    return a;
  }
  function fl(a, b, c, d) {
    var e = b.current, f = R(), g = yi(e);
    c = dl(c);
    null === b.context ? b.context = c : b.pendingContext = c;
    b = mh(f, g);
    b.payload = { element: a };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    a = nh(e, b, g);
    null !== a && (gi(a, e, g, f), oh(a, e, g));
    return g;
  }
  function gl(a) {
    a = a.current;
    if (!a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c = a.retryLane;
      a.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function il(a, b) {
    hl(a, b);
    (a = a.alternate) && hl(a, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b = this._internalRoot;
    if (null === b) throw Error(p(409));
    fl(a, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b = Hc();
      a = { blockedOn: null, target: a, priority: b };
      for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
      Qc.splice(c, 0, a);
      0 === c && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b, c, d, e) {
    if (e) {
      if ("function" === typeof d) {
        var f = d;
        d = function() {
          var a2 = gl(g);
          f.call(a2);
        };
      }
      var g = el2(b, d, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g;
      a[uf] = g.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g;
    }
    for (; e = a.lastChild; ) a.removeChild(e);
    if ("function" === typeof d) {
      var h = d;
      d = function() {
        var a2 = gl(k);
        h.call(a2);
      };
    }
    var k = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k;
    a[uf] = k.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b, k, c, d);
    });
    return k;
  }
  function rl(a, b, c, d, e) {
    var f = c._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" === typeof e) {
        var h = e;
        e = function() {
          var a2 = gl(g);
          h.call(a2);
        };
      }
      fl(b, g, a, e);
    } else g = ql(c, b, a, e, d);
    return gl(g);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b = a.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a, 1);
          if (null !== b2) {
            var c2 = R();
            gi(b2, a, 1, c2);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b = ih(a, 134217728);
      if (null !== b) {
        var c = R();
        gi(b, a, 134217728, c);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b = yi(a), c = ih(a, b);
      if (null !== c) {
        var d = R();
        gi(c, a, b, d);
      }
      il(a, b);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a, b) {
    var c = C;
    try {
      return C = a, b();
    } finally {
      C = c;
    }
  };
  yb = function(a, b, c) {
    switch (b) {
      case "input":
        bb(a, c);
        b = c.name;
        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode; ) c = c.parentNode;
          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c.length; b++) {
            var d = c[b];
            if (d !== a && d.form === a.form) {
              var e = Db(d);
              if (!e) throw Error(p(90));
              Wa(d);
              bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c);
        break;
      case "select":
        b = c.value, null != b && fb(a, !!c.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a, b, null, c);
  };
  reactDom_production_min.createRoot = function(a, b) {
    if (!nl(a)) throw Error(p(299));
    var c = false, d = "", e = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl(a, 1, false, null, null, c, false, d, e);
    a[uf] = b.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(p(188));
      a = Object.keys(a).join(",");
      throw Error(p(268, a));
    }
    a = Zb(b);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, true, c);
  };
  reactDom_production_min.hydrateRoot = function(a, b, c) {
    if (!nl(a)) throw Error(p(405));
    var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
    null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
    b = el2(b, null, a, 1, null != c ? c : null, e, false, f, g);
    a[uf] = b.current;
    sf(a);
    if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
      c,
      e
    );
    return new ml(b);
  };
  reactDom_production_min.render = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, false, c);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
    if (!ol(c)) throw Error(p(200));
    if (null == a || void 0 === a._reactInternals) throw Error(p(38));
    return rl(a, b, c, false, d);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m = requireReactDom();
  {
    client.createRoot = m.createRoot;
    client.hydrateRoot = m.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
function _inheritsLoose(t2, o) {
  t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location2, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes.exports;
  hasRequiredPropTypes = 1;
  {
    propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
  }
  return propTypes.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes();
const t = /* @__PURE__ */ getDefaultExportFromCjs$1(propTypesExports);
var gud$1;
var hasRequiredGud;
function requireGud() {
  if (hasRequiredGud) return gud$1;
  hasRequiredGud = 1;
  var key2 = "__global_unique_id__";
  gud$1 = function() {
    return commonjsGlobal[key2] = (commonjsGlobal[key2] || 0) + 1;
  };
  return gud$1;
}
var gudExports = requireGud();
const gud = /* @__PURE__ */ getDefaultExportFromCjs$1(gudExports);
var MAX_SIGNED_31_BIT_INT = 1073741823;
function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h) {
        return h !== handler;
      });
    },
    get: function get3() {
      return value;
    },
    set: function set3(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + gud() + "__";
  var Provider = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(Provider2, _Component);
    function Provider2() {
      var _this;
      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider2.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref3;
      return _ref3 = {}, _ref3[contextProp] = this.emitter, _ref3;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render() {
      return this.props.children;
    };
    return Provider2;
  }(reactExports.Component);
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = t.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_Component2) {
    _inheritsLoose(Consumer2, _Component2);
    function Consumer2() {
      var _this2;
      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(reactExports.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = t.object, _Consumer$contextType);
  return {
    Provider,
    Consumer
  };
}
var index$1 = React.createContext || createReactContext;
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r in t2) ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
    }
    return n;
  }, _extends$1.apply(null, arguments);
}
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list, index2) {
  for (var i2 = index2, k = i2 + 1, n = list.length; k < n; i2 += 1, k += 1) {
    list[i2] = list[k];
  }
  list.pop();
}
function resolvePathname(to, from) {
  if (from === void 0) from = "";
  var toParts = to && to.split("/") || [];
  var fromParts = from && from.split("/") || [];
  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to && isAbsolute(to)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length) return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === "." || last === ".." || last === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i2 = fromParts.length; i2 >= 0; i2--) {
    var part = fromParts[i2];
    if (part === ".") {
      spliceOne(fromParts, i2);
    } else if (part === "..") {
      spliceOne(fromParts, i2);
      up++;
    } else if (up) {
      spliceOne(fromParts, i2);
      up--;
    }
  }
  if (!mustEndAbs) for (; up--; up) fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/") result += "/";
  return result;
}
var prefix$1 = "Invariant failed";
function invariant(condition, message) {
  {
    throw new Error(prefix$1);
  }
}
function addLeadingSlash$1(path2) {
  return path2.charAt(0) === "/" ? path2 : "/" + path2;
}
function stripLeadingSlash(path2) {
  return path2.charAt(0) === "/" ? path2.substr(1) : path2;
}
function hasBasename(path2, prefix2) {
  return path2.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path2.charAt(prefix2.length)) !== -1;
}
function stripBasename$1(path2, prefix2) {
  return hasBasename(path2, prefix2) ? path2.substr(prefix2.length) : path2;
}
function stripTrailingSlash(path2) {
  return path2.charAt(path2.length - 1) === "/" ? path2.slice(0, -1) : path2;
}
function parsePath(path2) {
  var pathname = path2 || "/";
  var search = "";
  var hash2 = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash2 = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search === "?" ? "" : search,
    hash: hash2 === "#" ? "" : hash2
  };
}
function createPath(location2) {
  var pathname = location2.pathname, search = location2.search, hash2 = location2.hash;
  var path2 = pathname || "/";
  if (search && search !== "?") path2 += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") path2 += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return path2;
}
function createLocation(path2, state2, key2, currentLocation) {
  var location2;
  if (typeof path2 === "string") {
    location2 = parsePath(path2);
    location2.state = state2;
  } else {
    location2 = _extends$1({}, path2);
    if (location2.pathname === void 0) location2.pathname = "";
    if (location2.search) {
      if (location2.search.charAt(0) !== "?") location2.search = "?" + location2.search;
    } else {
      location2.search = "";
    }
    if (location2.hash) {
      if (location2.hash.charAt(0) !== "#") location2.hash = "#" + location2.hash;
    } else {
      location2.hash = "";
    }
    if (state2 !== void 0 && location2.state === void 0) location2.state = state2;
  }
  try {
    location2.pathname = decodeURI(location2.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location2.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }
  if (key2) location2.key = key2;
  if (currentLocation) {
    if (!location2.pathname) {
      location2.pathname = currentLocation.pathname;
    } else if (location2.pathname.charAt(0) !== "/") {
      location2.pathname = resolvePathname(location2.pathname, currentLocation.pathname);
    }
  } else {
    if (!location2.pathname) {
      location2.pathname = "/";
    }
  }
  return location2;
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt) prompt = null;
    };
  }
  function confirmTransitionTo(location2, action2, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location2, action2) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners = [];
  function appendListener(fn) {
    var isActive = true;
    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }
    listeners.push(listener);
    return function() {
      isActive = false;
      listeners = listeners.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message));
}
function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1) return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event) {
  return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    return {};
  }
}
function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant() : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref3 = historyState || {}, key2 = _ref3.key, state2 = _ref3.state;
    var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash2 = _window$location.hash;
    var path2 = pathname + search + hash2;
    if (basename) path2 = stripBasename$1(path2, basename);
    return createLocation(path2, state2, key2);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$1(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event) {
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action2 = "POP";
      transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action: action2,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location2) {
    return basename + createPath(location2);
  }
  function push(path2, state2) {
    var action2 = "PUSH";
    var location2 = createLocation(path2, state2, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
      if (!ok) return;
      var href = createHref(location2);
      var key2 = location2.key, state22 = location2.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key: key2,
          state: state22
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location2.key);
          allKeys = nextKeys;
          setState({
            action: action2,
            location: location2
          });
        }
      } else {
        window.location.href = href;
      }
    });
  }
  function replace(path2, state2) {
    var action2 = "REPLACE";
    var location2 = createLocation(path2, state2, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
      if (!ok) return;
      var href = createHref(location2);
      var key2 = location2.key, state22 = location2.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key: key2,
          state: state22
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location2.key;
          setState({
            action: action2,
            location: location2
          });
        }
      } else {
        window.location.replace(href);
      }
    });
  }
  function go(n) {
    globalHistory.go(n);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path2) {
      return path2.charAt(0) === "!" ? path2 : "!/" + stripLeadingSlash(path2);
    },
    decodePath: function decodePath(path2) {
      return path2.charAt(0) === "!" ? path2.substr(1) : path2;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash$1
  },
  slash: {
    encodePath: addLeadingSlash$1,
    decodePath: addLeadingSlash$1
  }
};
function stripHash(url2) {
  var hashIndex = url2.indexOf("#");
  return hashIndex === -1 ? url2 : url2.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path2) {
  window.location.hash = path2;
}
function replaceHashPath(path2) {
  window.location.replace(stripHash(window.location.href) + "#" + path2);
}
function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant() : void 0;
  var globalHistory = window.history;
  supportsGoWithoutReloadUsingHash();
  var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path22 = decodePath2(getHashPath());
    if (basename) path22 = stripBasename$1(path22, basename);
    return createLocation(path22);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$1(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }
  function handleHashChange() {
    var path22 = getHashPath();
    var encodedPath2 = encodePath2(path22);
    if (path22 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location2 = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location2)) return;
      if (ignorePath === createPath(location2)) return;
      ignorePath = null;
      handlePop(location2);
    }
  }
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action2 = "POP";
      transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action: action2,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var path2 = getHashPath();
  var encodedPath = encodePath2(path2);
  if (path2 !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location2) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename + createPath(location2));
  }
  function push(path22, state2) {
    var action2 = "PUSH";
    var location2 = createLocation(path22, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
      if (!ok) return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path3);
        allPaths = nextPaths;
        setState({
          action: action2,
          location: location2
        });
      } else {
        setState();
      }
    });
  }
  function replace(path22, state2) {
    var action2 = "REPLACE";
    var location2 = createLocation(path22, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
      if (!ok) return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path3;
      setState({
        action: action2,
        location: location2
      });
    });
  }
  function go(n) {
    globalHistory.go(n);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
function clamp$1(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$1(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index2 = clamp$1(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push(path2, state2) {
    var action2 = "PUSH";
    var location2 = createLocation(path2, state2, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location2);
      } else {
        nextEntries.push(location2);
      }
      setState({
        action: action2,
        location: location2,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace(path2, state2) {
    var action2 = "REPLACE";
    var location2 = createLocation(path2, state2, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
      if (!ok) return;
      history.entries[history.index] = location2;
      setState({
        action: action2,
        location: location2
      });
    });
  }
  function go(n) {
    var nextIndex = clamp$1(history.index + n, 0, history.entries.length - 1);
    var action2 = "POP";
    var location2 = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location2, action2, getUserConfirmation, function(ok) {
      if (ok) {
        setState({
          action: action2,
          location: location2,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries.length,
    action: "POP",
    location: entries[index2],
    index: index2,
    entries,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };
  return history;
}
var pathToRegexp$1 = { exports: {} };
var isarray$1;
var hasRequiredIsarray$1;
function requireIsarray$1() {
  if (hasRequiredIsarray$1) return isarray$1;
  hasRequiredIsarray$1 = 1;
  isarray$1 = Array.isArray || function(arr2) {
    return Object.prototype.toString.call(arr2) == "[object Array]";
  };
  return isarray$1;
}
var hasRequiredPathToRegexp;
function requirePathToRegexp() {
  if (hasRequiredPathToRegexp) return pathToRegexp$1.exports;
  hasRequiredPathToRegexp = 1;
  var isarray2 = requireIsarray$1();
  pathToRegexp$1.exports = pathToRegexp2;
  pathToRegexp$1.exports.parse = parse2;
  pathToRegexp$1.exports.compile = compile;
  pathToRegexp$1.exports.tokensToFunction = tokensToFunction;
  pathToRegexp$1.exports.tokensToRegExp = tokensToRegExp;
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    "(\\\\.)",
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
    // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
    // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
    "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
  ].join("|"), "g");
  function parse2(str, options2) {
    var tokens = [];
    var key2 = 0;
    var index2 = 0;
    var path2 = "";
    var defaultDelimiter = options2 && options2.delimiter || "/";
    var res;
    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path2 += str.slice(index2, offset);
      index2 = offset + m.length;
      if (escaped) {
        path2 += escaped[1];
        continue;
      }
      var next = str[index2];
      var prefix2 = res[2];
      var name = res[3];
      var capture = res[4];
      var group = res[5];
      var modifier = res[6];
      var asterisk = res[7];
      if (path2) {
        tokens.push(path2);
        path2 = "";
      }
      var partial = prefix2 != null && next != null && next !== prefix2;
      var repeat = modifier === "+" || modifier === "*";
      var optional = modifier === "?" || modifier === "*";
      var delimiter = prefix2 || defaultDelimiter;
      var pattern = capture || group;
      var prevText = prefix2 || (typeof tokens[tokens.length - 1] === "string" ? tokens[tokens.length - 1] : "");
      tokens.push({
        name: name || key2++,
        prefix: prefix2 || "",
        delimiter,
        optional,
        repeat,
        partial,
        asterisk: !!asterisk,
        pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : restrictBacktrack(delimiter, prevText)
      });
    }
    if (index2 < str.length) {
      path2 += str.substr(index2);
    }
    if (path2) {
      tokens.push(path2);
    }
    return tokens;
  }
  function restrictBacktrack(delimiter, prevText) {
    if (!prevText || prevText.indexOf(delimiter) > -1) {
      return "[^" + escapeString(delimiter) + "]+?";
    }
    return escapeString(prevText) + "|(?:(?!" + escapeString(prevText) + ")[^" + escapeString(delimiter) + "])+?";
  }
  function compile(str, options2) {
    return tokensToFunction(parse2(str, options2), options2);
  }
  function encodeURIComponentPretty(str) {
    return encodeURI(str).replace(/[\/?#]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeAsterisk(str) {
    return encodeURI(str).replace(/[?#]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function tokensToFunction(tokens, options2) {
    var matches = new Array(tokens.length);
    for (var i2 = 0; i2 < tokens.length; i2++) {
      if (typeof tokens[i2] === "object") {
        matches[i2] = new RegExp("^(?:" + tokens[i2].pattern + ")$", flags(options2));
      }
    }
    return function(obj, opts) {
      var path2 = "";
      var data = obj || {};
      var options3 = opts || {};
      var encode = options3.pretty ? encodeURIComponentPretty : encodeURIComponent;
      for (var i3 = 0; i3 < tokens.length; i3++) {
        var token = tokens[i3];
        if (typeof token === "string") {
          path2 += token;
          continue;
        }
        var value = data[token.name];
        var segment;
        if (value == null) {
          if (token.optional) {
            if (token.partial) {
              path2 += token.prefix;
            }
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined');
          }
        }
        if (isarray2(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
          }
          if (value.length === 0) {
            if (token.optional) {
              continue;
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }
          }
          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j]);
            if (!matches[i3].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
            }
            path2 += (j === 0 ? token.prefix : token.delimiter) + segment;
          }
          continue;
        }
        segment = token.asterisk ? encodeAsterisk(value) : encode(value);
        if (!matches[i3].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
        }
        path2 += token.prefix + segment;
      }
      return path2;
    };
  }
  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
  }
  function escapeGroup(group) {
    return group.replace(/([=!:$\/()])/g, "\\$1");
  }
  function attachKeys(re, keys2) {
    re.keys = keys2;
    return re;
  }
  function flags(options2) {
    return options2 && options2.sensitive ? "" : "i";
  }
  function regexpToRegexp(path2, keys2) {
    var groups = path2.source.match(/\((?!\?)/g);
    if (groups) {
      for (var i2 = 0; i2 < groups.length; i2++) {
        keys2.push({
          name: i2,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        });
      }
    }
    return attachKeys(path2, keys2);
  }
  function arrayToRegexp(path2, keys2, options2) {
    var parts = [];
    for (var i2 = 0; i2 < path2.length; i2++) {
      parts.push(pathToRegexp2(path2[i2], keys2, options2).source);
    }
    var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options2));
    return attachKeys(regexp, keys2);
  }
  function stringToRegexp(path2, keys2, options2) {
    return tokensToRegExp(parse2(path2, options2), keys2, options2);
  }
  function tokensToRegExp(tokens, keys2, options2) {
    if (!isarray2(keys2)) {
      options2 = /** @type {!Object} */
      keys2 || options2;
      keys2 = [];
    }
    options2 = options2 || {};
    var strict = options2.strict;
    var end = options2.end !== false;
    var route = "";
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (typeof token === "string") {
        route += escapeString(token);
      } else {
        var prefix2 = escapeString(token.prefix);
        var capture = "(?:" + token.pattern + ")";
        keys2.push(token);
        if (token.repeat) {
          capture += "(?:" + prefix2 + capture + ")*";
        }
        if (token.optional) {
          if (!token.partial) {
            capture = "(?:" + prefix2 + "(" + capture + "))?";
          } else {
            capture = prefix2 + "(" + capture + ")?";
          }
        } else {
          capture = prefix2 + "(" + capture + ")";
        }
        route += capture;
      }
    }
    var delimiter = escapeString(options2.delimiter || "/");
    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
    if (!strict) {
      route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
    }
    if (end) {
      route += "$";
    } else {
      route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
    }
    return attachKeys(new RegExp("^" + route, flags(options2)), keys2);
  }
  function pathToRegexp2(path2, keys2, options2) {
    if (!isarray2(keys2)) {
      options2 = /** @type {!Object} */
      keys2 || options2;
      keys2 = [];
    }
    options2 = options2 || {};
    if (path2 instanceof RegExp) {
      return regexpToRegexp(
        path2,
        /** @type {!Array} */
        keys2
      );
    }
    if (isarray2(path2)) {
      return arrayToRegexp(
        /** @type {!Array} */
        path2,
        /** @type {!Array} */
        keys2,
        options2
      );
    }
    return stringToRegexp(
      /** @type {string} */
      path2,
      /** @type {!Array} */
      keys2,
      options2
    );
  }
  return pathToRegexp$1.exports;
}
var pathToRegexpExports = requirePathToRegexp();
const pathToRegexp = /* @__PURE__ */ getDefaultExportFromCjs$1(pathToRegexpExports);
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t2 = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t2:
                case r:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t2;
  reactIs_production_min.Memo = r;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a) {
    return z(a) === k;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z(a) === t2;
  };
  reactIs_production_min.isMemo = function(a) {
    return z(a) === r;
  };
  reactIs_production_min.isPortal = function(a) {
    return z(a) === d;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z(a) === g;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z(a) === p;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t2 || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  reactIs_production_min.typeOf = z;
  return reactIs_production_min;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = requireReactIs_production_min();
  }
  return reactIs.exports;
}
requireReactIs();
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var ReactIs = requireReactIs();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[ReactIs.ForwardRef] = FORWARD_REF_STATICS;
  function getStatics(component) {
    if (ReactIs.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty2 = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys2 = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i2 = 0; i2 < keys2.length; ++i2) {
        var key2 = keys2[i2];
        if (!KNOWN_STATICS[key2] && !(blacklist && blacklist[key2]) && !(sourceStatics && sourceStatics[key2]) && !(targetStatics && targetStatics[key2])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key2);
          try {
            defineProperty2(targetComponent, key2, descriptor);
          } catch (e) {
          }
        }
      }
      return targetComponent;
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics2;
  return hoistNonReactStatics_cjs;
}
var hoistNonReactStatics_cjsExports = requireHoistNonReactStatics_cjs();
const hoistNonReactStatics = /* @__PURE__ */ getDefaultExportFromCjs$1(hoistNonReactStatics_cjsExports);
var createNamedContext = function createNamedContext2(name) {
  var context2 = index$1();
  context2.displayName = name;
  return context2;
};
var context = /* @__PURE__ */ createNamedContext("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location2) {
        if (_this._isMounted) {
          _this.setState({
            location: location2
          });
        } else {
          _this._pendingLocation = location2;
        }
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) this.unlisten();
  };
  _proto.render = function render() {
    return React.createElement(context.Provider, {
      children: this.props.children || null,
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    });
  };
  return Router2;
}(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render() {
    return React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
})(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };
  _proto.render = function render() {
    return null;
  };
  return Lifecycle2;
})(React.Component);
var cache$1$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path2, options2) {
  var cacheKey = "" + options2.end + options2.strict + options2.sensitive;
  var pathCache = cache$1$1[cacheKey] || (cache$1$1[cacheKey] = {});
  if (pathCache[path2]) return pathCache[path2];
  var keys2 = [];
  var regexp = pathToRegexp(path2, keys2, options2);
  var result = {
    regexp,
    keys: keys2
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path2] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (typeof options2 === "string") options2 = {
    path: options2
  };
  var _options = options2, path2 = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path2);
  return paths.reduce(function(matched, path22) {
    if (!path22) return null;
    if (matched) return matched;
    var _compilePath = compilePath$1(path22, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys2 = _compilePath.keys;
    var match = regexp.exec(pathname);
    if (!match) return null;
    var url2 = match[0], values2 = match.slice(1);
    var isExact = pathname === url2;
    if (exact && !isExact) return null;
    return {
      path: path22,
      // the path used to match
      url: path22 === "/" && url2 === "" ? "/" : url2,
      // the matched portion of the URL
      isExact,
      // whether or not we matched exactly
      params: keys2.reduce(function(memo2, key2, index2) {
        memo2[key2.name] = values2[index2];
        return memo2;
      }, {})
    };
  }, null);
}
function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render() {
    var _this = this;
    return React.createElement(context.Consumer, null, function(context$$1) {
      !context$$1 ? invariant() : void 0;
      var location2 = _this.props.location || context$$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location2.pathname, _this.props) : context$$1.match;
      var props = _extends$1({}, context$$1, {
        location: location2,
        match
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render2 = _this$props.render;
      if (Array.isArray(children) && children.length === 0) {
        children = null;
      }
      if (typeof children === "function") {
        children = children(props);
        if (children === void 0) {
          children = null;
        }
      }
      return React.createElement(context.Provider, {
        value: props
      }, children && !isEmptyChildren(children) ? children : props.match ? component ? React.createElement(component, props) : render2 ? render2(props) : null : null);
    });
  };
  return Route2;
}(React.Component);
function addLeadingSlash(path2) {
  return path2.charAt(0) === "/" ? path2 : "/" + path2;
}
function addBasename(basename, location2) {
  if (!basename) return location2;
  return _extends$1({}, location2, {
    pathname: addLeadingSlash(basename) + location2.pathname
  });
}
function stripBasename(basename, location2) {
  if (!basename) return location2;
  var base2 = addLeadingSlash(basename);
  if (location2.pathname.indexOf(base2) !== 0) return location2;
  return _extends$1({}, location2, {
    pathname: location2.pathname.substr(base2.length)
  });
}
function createURL(location2) {
  return typeof location2 === "string" ? location2 : createPath(location2);
}
function staticHandler(methodName) {
  return function() {
    invariant();
  };
}
function noop$1() {
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location2) {
      return _this.navigateTo(location2, "PUSH");
    };
    _this.handleReplace = function(location2) {
      return _this.navigateTo(location2, "REPLACE");
    };
    _this.handleListen = function() {
      return noop$1;
    };
    _this.handleBlock = function() {
      return noop$1;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location2, action2) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action2;
    context2.location = addBasename(basename, createLocation(location2));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location2 = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path2) {
        return addLeadingSlash(basename + createURL(path2));
      },
      action: "POP",
      location: stripBasename(basename, createLocation(location2)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return React.createElement(Router, _extends$1({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter2;
})(React.Component);
var Switch = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render() {
    var _this = this;
    return React.createElement(context.Consumer, null, function(context$$1) {
      !context$$1 ? invariant() : void 0;
      var location2 = _this.props.location || context$$1.location;
      var element, match;
      React.Children.forEach(_this.props.children, function(child) {
        if (match == null && React.isValidElement(child)) {
          element = child;
          var path2 = child.props.path || child.props.from;
          match = path2 ? matchPath(location2.pathname, _extends$1({}, child.props, {
            path: path2
          })) : context$$1.match;
        }
      });
      return match ? React.cloneElement(element, {
        location: location2,
        computedMatch: match
      }) : null;
    });
  };
  return Switch2;
}(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(BrowserRouter2, _React$Component);
  function BrowserRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }
  var _proto = BrowserRouter2.prototype;
  _proto.render = function render() {
    return React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return BrowserRouter2;
})(React.Component);
var HashRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(HashRouter2, _React$Component);
  function HashRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }
  var _proto = HashRouter2.prototype;
  _proto.render = function render() {
    return React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return HashRouter2;
}(React.Component);
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Link2, _React$Component);
  function Link2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Link2.prototype;
  _proto.handleClick = function handleClick(event, history) {
    try {
      if (this.props.onClick) this.props.onClick(event);
    } catch (ex) {
      event.preventDefault();
      throw ex;
    }
    if (!event.defaultPrevented && // onClick prevented default
    event.button === 0 && // ignore everything but left clicks
    (!this.props.target || this.props.target === "_self") && // let browser handle "target=_blank" etc.
    !isModifiedEvent(event)) {
      event.preventDefault();
      var method = this.props.replace ? history.replace : history.push;
      method(this.props.to);
    }
  };
  _proto.render = function render() {
    var _this = this;
    var _this$props = this.props, innerRef = _this$props.innerRef;
    _this$props.replace;
    var to = _this$props.to, rest = _objectWithoutPropertiesLoose(_this$props, ["innerRef", "replace", "to"]);
    return React.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant() : void 0;
      var location2 = typeof to === "string" ? createLocation(to, null, null, context2.location) : to;
      var href = location2 ? context2.history.createHref(location2) : "";
      return React.createElement("a", _extends$1({}, rest, {
        onClick: function onClick(event) {
          return _this.handleClick(event, context2.history);
        },
        href,
        ref: innerRef
      }));
    });
  };
  return Link2;
})(React.Component);
function clamp(value) {
  var min2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (value < min2) {
    return min2;
  }
  if (value > max2) {
    return max2;
  }
  return value;
}
function hexToRgb(color) {
  color = color.substr(1);
  var re = new RegExp(".{1,".concat(color.length / 3, "}"), "g");
  var colors = color.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map(function(n) {
      return n + n;
    });
  }
  return colors ? "rgb(".concat(colors.map(function(n) {
    return parseInt(n, 16);
  }).join(", "), ")") : "";
}
function hslToRgb(color) {
  color = decomposeColor(color);
  var _color = color, values2 = _color.values;
  var h = values2[0];
  var s = values2[1] / 100;
  var l = values2[2] / 100;
  var a = s * Math.min(l, 1 - l);
  var f = function f2(n) {
    var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (n + h / 30) % 12;
    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  };
  var type2 = "rgb";
  var rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color.type === "hsla") {
    type2 += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type: type2,
    values: rgb
  });
}
function decomposeColor(color) {
  if (color.type) {
    return color;
  }
  if (color.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color));
  }
  var marker = color.indexOf("(");
  var type2 = color.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla"].indexOf(type2) === -1) {
    throw new Error(["Material-UI: unsupported `".concat(color, "` color."), "We support the following formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()."].join("\n"));
  }
  var values2 = color.substring(marker + 1, color.length - 1).split(",");
  values2 = values2.map(function(value) {
    return parseFloat(value);
  });
  return {
    type: type2,
    values: values2
  };
}
function recomposeColor(color) {
  var type2 = color.type;
  var values2 = color.values;
  if (type2.indexOf("rgb") !== -1) {
    values2 = values2.map(function(n, i2) {
      return i2 < 3 ? parseInt(n, 10) : n;
    });
  } else if (type2.indexOf("hsl") !== -1) {
    values2[1] = "".concat(values2[1], "%");
    values2[2] = "".concat(values2[2], "%");
  }
  return "".concat(type2, "(").concat(values2.join(", "), ")");
}
function getContrastRatio(foreground, background) {
  var lumA = getLuminance(foreground);
  var lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function getLuminance(color) {
  color = decomposeColor(color);
  var rgb = color.type === "hsl" ? decomposeColor(hslToRgb(color)).values : color.values;
  rgb = rgb.map(function(val) {
    val /= 255;
    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function emphasize(color) {
  var coefficient = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.15;
  return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
}
function fade(color, value) {
  color = decomposeColor(color);
  value = clamp(value);
  if (color.type === "rgb" || color.type === "hsl") {
    color.type += "a";
  }
  color.values[3] = value;
  return recomposeColor(color);
}
function darken(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);
  if (color.type.indexOf("hsl") !== -1) {
    color.values[2] *= 1 - coefficient;
  } else if (color.type.indexOf("rgb") !== -1) {
    for (var i2 = 0; i2 < 3; i2 += 1) {
      color.values[i2] *= 1 - coefficient;
    }
  }
  return recomposeColor(color);
}
function lighten(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);
  if (color.type.indexOf("hsl") !== -1) {
    color.values[2] += (100 - color.values[2]) * coefficient;
  } else if (color.type.indexOf("rgb") !== -1) {
    for (var i2 = 0; i2 < 3; i2 += 1) {
      color.values[i2] += (255 - color.values[i2]) * coefficient;
    }
  }
  return recomposeColor(color);
}
var cjs;
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options2) {
    return options2.clone !== false && options2.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options2) : value;
  }
  function defaultArrayMerge(target, source, options2) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options2);
    });
  }
  function getMergeFunction(key2, options2) {
    if (!options2.customMerge) {
      return deepmerge2;
    }
    var customMerge = options2.customMerge(key2);
    return typeof customMerge === "function" ? customMerge : deepmerge2;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_23) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key2) {
    return propertyIsOnObject(target, key2) && !(Object.hasOwnProperty.call(target, key2) && Object.propertyIsEnumerable.call(target, key2));
  }
  function mergeObject(target, source, options2) {
    var destination = {};
    if (options2.isMergeableObject(target)) {
      getKeys(target).forEach(function(key2) {
        destination[key2] = cloneUnlessOtherwiseSpecified(target[key2], options2);
      });
    }
    getKeys(source).forEach(function(key2) {
      if (propertyIsUnsafe(target, key2)) {
        return;
      }
      if (propertyIsOnObject(target, key2) && options2.isMergeableObject(source[key2])) {
        destination[key2] = getMergeFunction(key2, options2)(target[key2], source[key2], options2);
      } else {
        destination[key2] = cloneUnlessOtherwiseSpecified(source[key2], options2);
      }
    });
    return destination;
  }
  function deepmerge2(target, source, options2) {
    options2 = options2 || {};
    options2.arrayMerge = options2.arrayMerge || defaultArrayMerge;
    options2.isMergeableObject = options2.isMergeableObject || isMergeableObject;
    options2.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options2);
    } else if (sourceIsArray) {
      return options2.arrayMerge(target, source, options2);
    } else {
      return mergeObject(target, source, options2);
    }
  }
  deepmerge2.all = function deepmergeAll(array2, options2) {
    if (!Array.isArray(array2)) {
      throw new Error("first argument should be an array");
    }
    return array2.reduce(function(prev, next) {
      return deepmerge2(prev, next, options2);
    }, {});
  };
  var deepmerge_1 = deepmerge2;
  cjs = deepmerge_1;
  return cjs;
}
var cjsExports = requireCjs();
const deepmerge = /* @__PURE__ */ getDefaultExportFromCjs$1(cjsExports);
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$1(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObjectObject(o) {
  return isObject$1(o) === true && Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObjectObject(o) === false) return false;
  ctor = o.constructor;
  if (typeof ctor !== "function") return false;
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
const isPlainObject$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: isPlainObject
}, Symbol.toStringTag, { value: "Module" }));
var keys = ["xs", "sm", "md", "lg", "xl"];
function createBreakpoints$2(breakpoints2) {
  var _breakpoints$values = breakpoints2.values, values2 = _breakpoints$values === void 0 ? {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920
  } : _breakpoints$values, _breakpoints$unit = breakpoints2.unit, unit = _breakpoints$unit === void 0 ? "px" : _breakpoints$unit, _breakpoints$step = breakpoints2.step, step = _breakpoints$step === void 0 ? 5 : _breakpoints$step, other = _objectWithoutProperties(breakpoints2, ["values", "unit", "step"]);
  function up(key2) {
    var value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return "@media (min-width:".concat(value).concat(unit, ")");
  }
  function down(key2) {
    var endIndex = keys.indexOf(key2) + 1;
    var upperbound = values2[keys[endIndex]];
    if (endIndex === keys.length) {
      return up("xs");
    }
    var value = typeof upperbound === "number" && endIndex > 0 ? upperbound : key2;
    return "@media (max-width:".concat(value - step / 100).concat(unit, ")");
  }
  function between(start, end) {
    var endIndex = keys.indexOf(end) + 1;
    if (endIndex === keys.length) {
      return up(start);
    }
    return "@media (min-width:".concat(values2[start]).concat(unit, ") and ") + "(max-width:".concat(values2[keys[endIndex]] - step / 100).concat(unit, ")");
  }
  function only(key2) {
    return between(key2, key2);
  }
  function width(key2) {
    return values2[key2];
  }
  return _extends$1({
    keys,
    values: values2,
    up,
    down,
    between,
    only,
    width
  }, other);
}
function createMixins$1(breakpoints2, spacing, mixins) {
  var _toolbar;
  return _extends$1({
    gutters: function gutters() {
      var styles3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _extends$1({
        paddingLeft: spacing(2),
        paddingRight: spacing(2)
      }, styles3, _defineProperty$1({}, breakpoints2.up("sm"), _extends$1({
        paddingLeft: spacing(3),
        paddingRight: spacing(3)
      }, styles3[breakpoints2.up("sm")])));
    },
    toolbar: (_toolbar = {
      minHeight: 56
    }, _defineProperty$1(_toolbar, "".concat(breakpoints2.up("xs"), " and (orientation: landscape)"), {
      minHeight: 48
    }), _defineProperty$1(_toolbar, breakpoints2.up("sm"), {
      minHeight: 64
    }), _toolbar)
  }, mixins);
}
var indigo$1 = {
  300: "#7986cb",
  500: "#3f51b5",
  700: "#303f9f"
};
var pink$1 = {
  A200: "#ff4081",
  A400: "#f50057",
  A700: "#c51162"
};
var grey$2 = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#d5d5d5",
  A200: "#aaaaaa",
  A400: "#303030",
  A700: "#616161"
};
var red$1 = {
  300: "#e57373",
  500: "#f44336",
  700: "#d32f2f"
};
var common$3 = {
  black: "#000",
  white: "#fff"
};
var light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.54)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)",
    // Text hints.
    hint: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$3.white,
    default: grey$2[50]
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.08)",
    hoverOpacity: 0.08,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.14)",
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)"
  }
};
var dark = {
  text: {
    primary: common$3.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    hint: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: grey$2[800],
    default: "#303030"
  },
  action: {
    active: common$3.white,
    hover: "rgba(255, 255, 255, 0.1)",
    hoverOpacity: 0.1,
    selected: "rgba(255, 255, 255, 0.2)",
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)"
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffset);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffset * 1.5);
    }
  }
}
function createPalette$1(palette) {
  var _palette$primary = palette.primary, primary = _palette$primary === void 0 ? {
    light: indigo$1[300],
    main: indigo$1[500],
    dark: indigo$1[700]
  } : _palette$primary, _palette$secondary = palette.secondary, secondary = _palette$secondary === void 0 ? {
    light: pink$1.A200,
    main: pink$1.A400,
    dark: pink$1.A700
  } : _palette$secondary, _palette$error = palette.error, error3 = _palette$error === void 0 ? {
    light: red$1[300],
    main: red$1[500],
    dark: red$1[700]
  } : _palette$error, _palette$type = palette.type, type2 = _palette$type === void 0 ? "light" : _palette$type, _palette$contrastThre = palette.contrastThreshold, contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre, _palette$tonalOffset = palette.tonalOffset, tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset, other = _objectWithoutProperties(palette, ["primary", "secondary", "error", "type", "contrastThreshold", "tonalOffset"]);
  function getContrastText(background) {
    var contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  function augmentColor(color) {
    var mainShade = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 500;
    var lightShade = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300;
    var darkShade = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 700;
    color = _extends$1({}, color);
    if (!color.main && color[mainShade]) {
      color.main = color[mainShade];
    }
    addLightOrDark(color, "light", lightShade, tonalOffset);
    addLightOrDark(color, "dark", darkShade, tonalOffset);
    if (!color.contrastText) {
      color.contrastText = getContrastText(color.main);
    }
    return color;
  }
  var types2 = {
    dark,
    light
  };
  var paletteOutput = deepmerge(_extends$1({
    // A collection of common colors.
    common: common$3,
    // The palette type, can be light or dark.
    type: type2,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor(primary),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor(secondary, "A400", "A200", "A700"),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor(error3),
    // The grey colors.
    grey: grey$2,
    // Used by `getContrastText()` to maximize the contrast between the background and
    // the text.
    contrastThreshold,
    // Take a background color and return the color of the text to maximize the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, types2[type2]), other, {
    clone: false
    // No need to clone deep
  });
  return paletteOutput;
}
function round$2(value) {
  return Math.round(value * 1e5) / 1e5;
}
var caseAllCaps = {
  textTransform: "uppercase"
};
var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography$1(palette, typography) {
  var _ref3 = typeof typography === "function" ? typography(palette) : typography, _ref$fontFamily = _ref3.fontFamily, fontFamily = _ref$fontFamily === void 0 ? defaultFontFamily : _ref$fontFamily, _ref$fontSize = _ref3.fontSize, fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize, _ref$fontWeightLight = _ref3.fontWeightLight, fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight, _ref$fontWeightRegula = _ref3.fontWeightRegular, fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula, _ref$fontWeightMedium = _ref3.fontWeightMedium, fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium, _ref$fontWeightBold = _ref3.fontWeightBold, fontWeightBold = _ref$fontWeightBold === void 0 ? 700 : _ref$fontWeightBold, _ref$htmlFontSize = _ref3.htmlFontSize, htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize, allVariants = _ref3.allVariants, pxToRem2 = _ref3.pxToRem, other = _objectWithoutProperties(_ref3, ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"]);
  var coef = fontSize / 14;
  var pxToRem = pxToRem2 || function(size) {
    return "".concat(size / htmlFontSize * coef, "rem");
  };
  var buildVariant = function buildVariant2(fontWeight, size, lineHeight, letterSpacing, casing) {
    return _extends$1({
      fontFamily,
      fontWeight,
      fontSize: pxToRem(size),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight
    }, fontFamily === defaultFontFamily ? {
      letterSpacing: "".concat(round$2(letterSpacing / size), "em")
    } : {}, {}, casing, {}, allVariants);
  };
  var variants = {
    h1: buildVariant(fontWeightLight, 96, 1, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.04, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.17, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.33, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends$1({
    htmlFontSize,
    pxToRem,
    round: round$2,
    // TODO To remove in v5?
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
var shadowKeyUmbraOpacity = 0.2;
var shadowKeyPenumbraOpacity = 0.14;
var shadowAmbientShadowOpacity = 0.12;
function createShadow() {
  return ["".concat(arguments.length <= 0 ? void 0 : arguments[0], "px ").concat(arguments.length <= 1 ? void 0 : arguments[1], "px ").concat(arguments.length <= 2 ? void 0 : arguments[2], "px ").concat(arguments.length <= 3 ? void 0 : arguments[3], "px rgba(0,0,0,").concat(shadowKeyUmbraOpacity, ")"), "".concat(arguments.length <= 4 ? void 0 : arguments[4], "px ").concat(arguments.length <= 5 ? void 0 : arguments[5], "px ").concat(arguments.length <= 6 ? void 0 : arguments[6], "px ").concat(arguments.length <= 7 ? void 0 : arguments[7], "px rgba(0,0,0,").concat(shadowKeyPenumbraOpacity, ")"), "".concat(arguments.length <= 8 ? void 0 : arguments[8], "px ").concat(arguments.length <= 9 ? void 0 : arguments[9], "px ").concat(arguments.length <= 10 ? void 0 : arguments[10], "px ").concat(arguments.length <= 11 ? void 0 : arguments[11], "px rgba(0,0,0,").concat(shadowAmbientShadowOpacity, ")")].join(",");
}
var shadows$1 = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
var shape$1 = {
  borderRadius: 4
};
function createSpacing$1() {
  var spacingInput = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;
  if (spacingInput.mui) {
    return spacingInput;
  }
  var transform2;
  if (typeof spacingInput === "function") {
    transform2 = spacingInput;
  } else {
    transform2 = function transform22(factor) {
      return spacingInput * factor;
    };
  }
  var spacing = function spacing2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 0) {
      return transform2(1);
    }
    if (args.length === 1) {
      return transform2(args[0]);
    }
    return args.map(function(factor) {
      var output2 = transform2(factor);
      return typeof output2 === "number" ? "".concat(output2, "px") : output2;
    }).join(" ");
  };
  Object.defineProperty(spacing, "unit", {
    get: function get3() {
      return spacingInput;
    }
  });
  spacing.mui = true;
  return spacing;
}
var easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
var duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
var formatMs = function formatMs2(milliseconds) {
  return "".concat(Math.round(milliseconds), "ms");
};
const transitions$1 = {
  easing,
  duration,
  create: function create3() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["all"];
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _options$duration = options2.duration, durationOption = _options$duration === void 0 ? duration.standard : _options$duration, _options$easing = options2.easing, easingOption = _options$easing === void 0 ? easing.easeInOut : _options$easing, _options$delay = options2.delay, delay = _options$delay === void 0 ? 0 : _options$delay;
    _objectWithoutProperties(options2, ["duration", "easing", "delay"]);
    return (Array.isArray(props) ? props : [props]).map(function(animatedProp) {
      return "".concat(animatedProp, " ").concat(typeof durationOption === "string" ? durationOption : formatMs(durationOption), " ").concat(easingOption, " ").concat(typeof delay === "string" ? delay : formatMs(delay));
    }).join(",");
  },
  getAutoHeightDuration: function getAutoHeightDuration(height) {
    if (!height) {
      return 0;
    }
    var constant = height / 36;
    return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
  }
};
var zIndex$1 = {
  mobileStepper: 1e3,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function createMuiTheme$1() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _options$breakpoints = options2.breakpoints, breakpointsInput = _options$breakpoints === void 0 ? {} : _options$breakpoints, _options$mixins = options2.mixins, mixinsInput = _options$mixins === void 0 ? {} : _options$mixins, _options$palette = options2.palette, paletteInput = _options$palette === void 0 ? {} : _options$palette, shadowsInput = options2.shadows, spacingInput = options2.spacing, _options$typography = options2.typography, typographyInput = _options$typography === void 0 ? {} : _options$typography, other = _objectWithoutProperties(options2, ["breakpoints", "mixins", "palette", "shadows", "spacing", "typography"]);
  var palette = createPalette$1(paletteInput);
  var breakpoints2 = createBreakpoints$2(breakpointsInput);
  var spacing = createSpacing$1(spacingInput);
  var muiTheme = _extends$1({
    breakpoints: breakpoints2,
    direction: "ltr",
    mixins: createMixins$1(breakpoints2, spacing, mixinsInput),
    overrides: {},
    // Inject custom styles
    palette,
    props: {},
    // Inject custom props
    shadows: shadowsInput || shadows$1,
    typography: createTypography$1(palette, typographyInput),
    spacing
  }, deepmerge({
    shape: shape$1,
    transitions: transitions$1,
    zIndex: zIndex$1
  }, other, {
    isMergeableObject: isPlainObject
  }));
  return muiTheme;
}
var hasSymbol$1 = typeof Symbol === "function" && Symbol.for;
const nested = hasSymbol$1 ? Symbol.for("mui.nested") : "__THEME_NESTED__";
var pseudoClasses = ["checked", "disabled", "error", "focused", "focusVisible", "required", "expanded", "selected"];
function createGenerateClassName() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _options$disableGloba = options2.disableGlobal, disableGlobal = _options$disableGloba === void 0 ? false : _options$disableGloba, _options$productionPr = options2.productionPrefix, productionPrefix = _options$productionPr === void 0 ? "jss" : _options$productionPr, _options$seed = options2.seed, seed = _options$seed === void 0 ? "" : _options$seed;
  var seedPrefix = seed === "" ? "" : "".concat(seed, "-");
  var ruleCounter = 0;
  return function(rule, styleSheet) {
    ruleCounter += 1;
    var name = styleSheet.options.name;
    if (name && name.indexOf("Mui") === 0 && !styleSheet.options.link && !disableGlobal) {
      if (pseudoClasses.indexOf(rule.key) !== -1) {
        return "Mui-".concat(rule.key);
      }
      var prefix2 = "".concat(seedPrefix).concat(name, "-").concat(rule.key);
      if (!styleSheet.options.theme[nested] || seed !== "") {
        return prefix2;
      }
      return "".concat(prefix2, "-").concat(ruleCounter);
    }
    {
      return "".concat(seedPrefix).concat(productionPrefix).concat(ruleCounter);
    }
  };
}
function createStyles(styles3) {
  return styles3;
}
function getThemeProps(params) {
  var theme2 = params.theme, name = params.name, props = params.props;
  if (!theme2 || !theme2.props || !theme2.props[name]) {
    return props;
  }
  var defaultProps2 = theme2.props[name];
  var propName;
  for (propName in defaultProps2) {
    if (props[propName] === void 0) {
      props[propName] = defaultProps2[propName];
    }
  }
  return props;
}
var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof$1(document)) === "object" && document.nodeType === 9;
var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style2) {
  if (style2 == null || typeof style2 !== "object") return style2;
  if (Array.isArray(style2)) return style2.map(cloneStyle);
  if (style2.constructor !== plainObjectConstrurctor) return style2;
  var newStyle = {};
  for (var name in style2) {
    newStyle[name] = cloneStyle(style2[name]);
  }
  return newStyle;
}
function createRule(name, decl, options2) {
  if (name === void 0) {
    name = "unnamed";
  }
  var jss2 = options2.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss2.plugins.onCreateRule(name, declCopy, options2);
  if (rule) return rule;
  if (name[0] === "@") ;
  return null;
}
var join = function join2(value, by) {
  var result = "";
  for (var i2 = 0; i2 < value.length; i2++) {
    if (value[i2] === "!important") break;
    if (result) result += by;
    result += value[i2];
  }
  return result;
};
function toCssValue(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }
  if (!Array.isArray(value)) return value;
  var cssValue = "";
  if (Array.isArray(value[0])) {
    for (var i2 = 0; i2 < value.length; i2++) {
      if (value[i2] === "!important") break;
      if (cssValue) cssValue += ", ";
      cssValue += join(value[i2], " ");
    }
  } else cssValue = join(value, ", ");
  if (!ignoreImportant && value[value.length - 1] === "!important") {
    cssValue += " !important";
  }
  return cssValue;
}
function indentStr(str, indent) {
  var result = "";
  for (var index2 = 0; index2 < indent; index2++) {
    result += "  ";
  }
  return result + str;
}
function toCss(selector, style2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var result = "";
  if (!style2) return result;
  var _options = options2, _options$indent = _options.indent, indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style2.fallbacks;
  if (selector) indent++;
  if (fallbacks) {
    if (Array.isArray(fallbacks)) {
      for (var index2 = 0; index2 < fallbacks.length; index2++) {
        var fallback = fallbacks[index2];
        for (var prop in fallback) {
          var value = fallback[prop];
          if (value != null) {
            if (result) result += "\n";
            result += "" + indentStr(prop + ": " + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];
        if (_value != null) {
          if (result) result += "\n";
          result += "" + indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
        }
      }
    }
  }
  for (var _prop2 in style2) {
    var _value2 = style2[_prop2];
    if (_value2 != null && _prop2 !== "fallbacks") {
      if (result) result += "\n";
      result += "" + indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
    }
  }
  if (!result && !options2.allowEmpty) return result;
  if (!selector) return result;
  indent--;
  if (result) result = "\n" + result + "\n";
  return indentStr(selector + " {" + result, indent) + indentStr("}", indent);
}
var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== "undefined" && CSS.escape;
var escape$1 = function(str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, "\\$1");
};
var BaseStyleRule = /* @__PURE__ */ function() {
  function BaseStyleRule2(key2, style2, options2) {
    this.type = "style";
    this.key = void 0;
    this.isProcessed = false;
    this.style = void 0;
    this.renderer = void 0;
    this.renderable = void 0;
    this.options = void 0;
    var sheet = options2.sheet, Renderer = options2.Renderer;
    this.key = key2;
    this.options = options2;
    this.style = style2;
    if (sheet) this.renderer = sheet.renderer;
    else if (Renderer) this.renderer = new Renderer();
  }
  var _proto = BaseStyleRule2.prototype;
  _proto.prop = function prop(name, value, options2) {
    if (value === void 0) return this.style[name];
    var force = options2 ? options2.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;
    if (!options2 || options2.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }
    var isEmpty2 = newValue == null || newValue === false;
    var isDefined = name in this.style;
    if (isEmpty2 && !isDefined && !force) return this;
    var remove3 = isEmpty2 && isDefined;
    if (remove3) delete this.style[name];
    else this.style[name] = newValue;
    if (this.renderable && this.renderer) {
      if (remove3) this.renderer.removeProperty(this.renderable, name);
      else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }
    var sheet = this.options.sheet;
    if (sheet && sheet.attached) ;
    return this;
  };
  return BaseStyleRule2;
}();
var StyleRule = /* @__PURE__ */ function(_BaseStyleRule) {
  _inheritsLoose(StyleRule2, _BaseStyleRule);
  function StyleRule2(key2, style2, options2) {
    var _this;
    _this = _BaseStyleRule.call(this, key2, style2, options2) || this;
    _this.selectorText = void 0;
    _this.id = void 0;
    _this.renderable = void 0;
    var selector = options2.selector, scoped = options2.scoped, sheet = options2.sheet, generateId = options2.generateId;
    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
      _this.selectorText = "." + escape$1(_this.id);
    }
    return _this;
  }
  var _proto2 = StyleRule2.prototype;
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;
    if (renderer) {
      var json = this.toJSON();
      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }
    return this;
  };
  _proto2.toJSON = function toJSON() {
    var json = {};
    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== "object") json[prop] = value;
      else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }
    return json;
  };
  _proto2.toString = function toString2(options2) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends$1({}, options2, {
      allowEmpty: true
    }) : options2;
    return toCss(this.selectorText, this.style, opts);
  };
  _createClass(StyleRule2, [{
    key: "selector",
    set: function set3(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer, renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector);
      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    },
    get: function get3() {
      return this.selectorText;
    }
  }]);
  return StyleRule2;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(name, style2, options2) {
    if (name[0] === "@" || options2.parent && options2.parent.type === "keyframes") {
      return null;
    }
    return new StyleRule(name, style2, options2);
  }
};
var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
var ConditionalRule = /* @__PURE__ */ function() {
  function ConditionalRule2(key2, styles3, options2) {
    this.type = "conditional";
    this.at = void 0;
    this.key = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key2;
    var atMatch = key2.match(atRegExp);
    this.at = atMatch ? atMatch[1] : "unknown";
    this.options = options2;
    this.rules = new RuleList(_extends$1({}, options2, {
      parent: this
    }));
    for (var name in styles3) {
      this.rules.add(name, styles3[name]);
    }
    this.rules.process();
  }
  var _proto = ConditionalRule2.prototype;
  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  };
  _proto.indexOf = function indexOf2(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.addRule = function addRule(name, style2, options2) {
    var rule = this.rules.add(name, style2, options2);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.toString = function toString2(options2) {
    if (options2 === void 0) {
      options2 = defaultToStringOptions;
    }
    if (options2.indent == null) options2.indent = defaultToStringOptions.indent;
    if (options2.children == null) options2.children = defaultToStringOptions.children;
    if (options2.children === false) {
      return this.key + " {}";
    }
    var children = this.rules.toString(options2);
    return children ? this.key + " {\n" + children + "\n}" : "";
  };
  return ConditionalRule2;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule2(key2, styles3, options2) {
    return keyRegExp.test(key2) ? new ConditionalRule(key2, styles3, options2) : null;
  }
};
var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
var KeyframesRule = /* @__PURE__ */ function() {
  function KeyframesRule2(key2, frames, options2) {
    this.type = "keyframes";
    this.at = "@keyframes";
    this.key = void 0;
    this.name = void 0;
    this.id = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    var nameMatch = key2.match(nameRegExp);
    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = "noname";
    }
    this.key = this.type + "-" + this.name;
    this.options = options2;
    var scoped = options2.scoped, sheet = options2.sheet, generateId = options2.generateId;
    this.id = scoped === false ? this.name : escape$1(generateId(this, sheet));
    this.rules = new RuleList(_extends$1({}, options2, {
      parent: this
    }));
    for (var name in frames) {
      this.rules.add(name, frames[name], _extends$1({}, options2, {
        parent: this
      }));
    }
    this.rules.process();
  }
  var _proto = KeyframesRule2.prototype;
  _proto.toString = function toString2(options2) {
    if (options2 === void 0) {
      options2 = defaultToStringOptions$1;
    }
    if (options2.indent == null) options2.indent = defaultToStringOptions$1.indent;
    if (options2.children == null) options2.children = defaultToStringOptions$1.children;
    if (options2.children === false) {
      return this.at + " " + this.id + " {}";
    }
    var children = this.rules.toString(options2);
    if (children) children = "\n" + children + "\n";
    return this.at + " " + this.id + " {" + children + "}";
  };
  return KeyframesRule2;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp$1 = /\$([\w-]+)/g;
var findReferencedKeyframe = function findReferencedKeyframe2(val, keyframes) {
  if (typeof val === "string") {
    return val.replace(refRegExp$1, function(match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }
      return match;
    });
  }
  return val;
};
var replaceRef = function replaceRef2(style2, prop, keyframes) {
  var value = style2[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);
  if (refKeyframe !== value) {
    style2[prop] = refKeyframe;
  }
};
var plugin = {
  onCreateRule: function onCreateRule3(key2, frames, options2) {
    return typeof key2 === "string" && keyRegExp$1.test(key2) ? new KeyframesRule(key2, frames, options2) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style2, rule, sheet) {
    if (rule.type !== "style" || !sheet) return style2;
    if ("animation-name" in style2) replaceRef(style2, "animation-name", sheet.keyframes);
    if ("animation" in style2) replaceRef(style2, "animation", sheet.keyframes);
    return style2;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;
    if (!sheet) {
      return val;
    }
    switch (prop) {
      case "animation":
        return findReferencedKeyframe(val, sheet.keyframes);
      case "animation-name":
        return findReferencedKeyframe(val, sheet.keyframes);
      default:
        return val;
    }
  }
};
var KeyframeRule = /* @__PURE__ */ function(_BaseStyleRule) {
  _inheritsLoose(KeyframeRule2, _BaseStyleRule);
  function KeyframeRule2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;
    _this.renderable = void 0;
    return _this;
  }
  var _proto = KeyframeRule2.prototype;
  _proto.toString = function toString2(options2) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends$1({}, options2, {
      allowEmpty: true
    }) : options2;
    return toCss(this.key, this.style, opts);
  };
  return KeyframeRule2;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule4(key2, style2, options2) {
    if (options2.parent && options2.parent.type === "keyframes") {
      return new KeyframeRule(key2, style2, options2);
    }
    return null;
  }
};
var FontFaceRule = /* @__PURE__ */ function() {
  function FontFaceRule2(key2, style2, options2) {
    this.type = "font-face";
    this.at = "@font-face";
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key2;
    this.style = style2;
    this.options = options2;
  }
  var _proto = FontFaceRule2.prototype;
  _proto.toString = function toString2(options2) {
    if (Array.isArray(this.style)) {
      var str = "";
      for (var index2 = 0; index2 < this.style.length; index2++) {
        str += toCss(this.key, this.style[index2]);
        if (this.style[index2 + 1]) str += "\n";
      }
      return str;
    }
    return toCss(this.key, this.style, options2);
  };
  return FontFaceRule2;
}();
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule5(key2, style2, options2) {
    return key2 === "@font-face" ? new FontFaceRule(key2, style2, options2) : null;
  }
};
var ViewportRule = /* @__PURE__ */ function() {
  function ViewportRule2(key2, style2, options2) {
    this.type = "viewport";
    this.at = "@viewport";
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key2;
    this.style = style2;
    this.options = options2;
  }
  var _proto = ViewportRule2.prototype;
  _proto.toString = function toString2(options2) {
    return toCss(this.key, this.style, options2);
  };
  return ViewportRule2;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule6(key2, style2, options2) {
    return key2 === "@viewport" || key2 === "@-ms-viewport" ? new ViewportRule(key2, style2, options2) : null;
  }
};
var SimpleRule = /* @__PURE__ */ function() {
  function SimpleRule2(key2, value, options2) {
    this.type = "simple";
    this.key = void 0;
    this.value = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key2;
    this.value = value;
    this.options = options2;
  }
  var _proto = SimpleRule2.prototype;
  _proto.toString = function toString2(options2) {
    if (Array.isArray(this.value)) {
      var str = "";
      for (var index2 = 0; index2 < this.value.length; index2++) {
        str += this.key + " " + this.value[index2] + ";";
        if (this.value[index2 + 1]) str += "\n";
      }
      return str;
    }
    return this.key + " " + this.value + ";";
  };
  return SimpleRule2;
}();
var keysMap = {
  "@charset": true,
  "@import": true,
  "@namespace": true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule7(key2, value, options2) {
    return key2 in keysMap ? new SimpleRule(key2, value, options2) : null;
  }
};
var plugins$1 = [pluginStyleRule, pluginConditionalRule, plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];
var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */
};
var RuleList = /* @__PURE__ */ function() {
  function RuleList2(options2) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.options = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.options = options2;
    this.classes = options2.classes;
    this.keyframes = options2.keyframes;
  }
  var _proto = RuleList2.prototype;
  _proto.add = function add(key2, decl, ruleOptions) {
    var _this$options = this.options, parent2 = _this$options.parent, sheet = _this$options.sheet, jss2 = _this$options.jss, Renderer = _this$options.Renderer, generateId = _this$options.generateId, scoped = _this$options.scoped;
    var options2 = _extends$1({
      classes: this.classes,
      parent: parent2,
      sheet,
      jss: jss2,
      Renderer,
      generateId,
      scoped
    }, ruleOptions);
    this.raw[key2] = decl;
    if (key2 in this.classes) {
      options2.selector = "." + escape$1(this.classes[key2]);
    }
    var rule = createRule(key2, decl, options2);
    if (!rule) return null;
    this.register(rule);
    var index2 = options2.index === void 0 ? this.index.length : options2.index;
    this.index.splice(index2, 0, rule);
    return rule;
  };
  _proto.get = function get3(name) {
    return this.map[name];
  };
  _proto.remove = function remove3(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.indexOf(rule), 1);
  };
  _proto.indexOf = function indexOf2(rule) {
    return this.index.indexOf(rule);
  };
  _proto.process = function process2() {
    var plugins$$1 = this.options.jss.plugins;
    this.index.slice(0).forEach(plugins$$1.onProcessRule, plugins$$1);
  };
  _proto.register = function register2(rule) {
    this.map[rule.key] = rule;
    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  };
  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];
    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  };
  _proto.update = function update2() {
    var name;
    var data;
    var options2;
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "string") {
      name = arguments.length <= 0 ? void 0 : arguments[0];
      data = arguments.length <= 1 ? void 0 : arguments[1];
      options2 = arguments.length <= 2 ? void 0 : arguments[2];
    } else {
      data = arguments.length <= 0 ? void 0 : arguments[0];
      options2 = arguments.length <= 1 ? void 0 : arguments[1];
      name = null;
    }
    if (name) {
      this.onUpdate(data, this.get(name), options2);
    } else {
      for (var index2 = 0; index2 < this.index.length; index2++) {
        this.onUpdate(data, this.index[index2], options2);
      }
    }
  };
  _proto.onUpdate = function onUpdate(data, rule, options2) {
    if (options2 === void 0) {
      options2 = defaultUpdateOptions;
    }
    var _this$options2 = this.options, plugins$$1 = _this$options2.jss.plugins, sheet = _this$options2.sheet;
    if (rule.rules instanceof RuleList2) {
      rule.rules.update(data, options2);
      return;
    }
    var styleRule = rule;
    var style2 = styleRule.style;
    plugins$$1.onUpdate(data, rule, sheet, options2);
    if (options2.process && style2 && style2 !== styleRule.style) {
      plugins$$1.onProcessStyle(styleRule.style, styleRule, sheet);
      for (var prop in styleRule.style) {
        var nextValue = styleRule.style[prop];
        var prevValue = style2[prop];
        if (nextValue !== prevValue) {
          styleRule.prop(prop, nextValue, forceUpdateOptions);
        }
      }
      for (var _prop in style2) {
        var _nextValue = styleRule.style[_prop];
        var _prevValue = style2[_prop];
        if (_nextValue == null && _nextValue !== _prevValue) {
          styleRule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  };
  _proto.toString = function toString2(options2) {
    var str = "";
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    for (var index2 = 0; index2 < this.index.length; index2++) {
      var rule = this.index[index2];
      var css2 = rule.toString(options2);
      if (!css2 && !link) continue;
      if (str) str += "\n";
      str += css2;
    }
    return str;
  };
  return RuleList2;
}();
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(styles3, options2) {
    this.options = void 0;
    this.deployed = void 0;
    this.attached = void 0;
    this.rules = void 0;
    this.renderer = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.queue = void 0;
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends$1({}, options2, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });
    if (options2.Renderer) {
      this.renderer = new options2.Renderer(this);
    }
    this.rules = new RuleList(this.options);
    for (var name in styles3) {
      this.rules.add(name, styles3[name]);
    }
    this.rules.process();
  }
  var _proto = StyleSheet2.prototype;
  _proto.attach = function attach2() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true;
    if (!this.deployed) this.deploy();
    return this;
  };
  _proto.detach = function detach2() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  };
  _proto.addRule = function addRule(name, decl, options2) {
    var queue2 = this.queue;
    if (this.attached && !queue2) this.queue = [];
    var rule = this.rules.add(name, decl, options2);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    if (this.attached) {
      if (!this.deployed) return rule;
      if (queue2) queue2.push(rule);
      else {
        this.insertRule(rule);
        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = void 0;
        }
      }
      return rule;
    }
    this.deployed = false;
    return rule;
  };
  _proto.insertRule = function insertRule2(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  };
  _proto.addRules = function addRules(styles3, options2) {
    var added = [];
    for (var name in styles3) {
      var rule = this.addRule(name, styles3[name], options2);
      if (rule) added.push(rule);
    }
    return added;
  };
  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  };
  _proto.deleteRule = function deleteRule(name) {
    var rule = this.rules.get(name);
    if (!rule) return false;
    this.rules.remove(rule);
    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }
    return true;
  };
  _proto.indexOf = function indexOf2(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  };
  _proto.update = function update2() {
    var _this$rules;
    (_this$rules = this.rules).update.apply(_this$rules, arguments);
    return this;
  };
  _proto.toString = function toString2(options2) {
    return this.rules.toString(options2);
  };
  return StyleSheet2;
}();
var PluginsRegistry = /* @__PURE__ */ function() {
  function PluginsRegistry2() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = void 0;
  }
  var _proto = PluginsRegistry2.prototype;
  _proto.onCreateRule = function onCreateRule8(name, decl, options2) {
    for (var i2 = 0; i2 < this.registry.onCreateRule.length; i2++) {
      var rule = this.registry.onCreateRule[i2](name, decl, options2);
      if (rule) return rule;
    }
    return null;
  };
  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;
    for (var i2 = 0; i2 < this.registry.onProcessRule.length; i2++) {
      this.registry.onProcessRule[i2](rule, sheet);
    }
    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  };
  _proto.onProcessStyle = function onProcessStyle2(style2, rule, sheet) {
    for (var i2 = 0; i2 < this.registry.onProcessStyle.length; i2++) {
      rule.style = this.registry.onProcessStyle[i2](rule.style, rule, sheet);
    }
  };
  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i2 = 0; i2 < this.registry.onProcessSheet.length; i2++) {
      this.registry.onProcessSheet[i2](sheet);
    }
  };
  _proto.onUpdate = function onUpdate(data, rule, sheet, options2) {
    for (var i2 = 0; i2 < this.registry.onUpdate.length; i2++) {
      this.registry.onUpdate[i2](data, rule, sheet, options2);
    }
  };
  _proto.onChangeValue = function onChangeValue2(value, prop, rule) {
    var processedValue = value;
    for (var i2 = 0; i2 < this.registry.onChangeValue.length; i2++) {
      processedValue = this.registry.onChangeValue[i2](processedValue, prop, rule);
    }
    return processedValue;
  };
  _proto.use = function use(newPlugin, options2) {
    if (options2 === void 0) {
      options2 = {
        queue: "external"
      };
    }
    var plugins2 = this.plugins[options2.queue];
    if (plugins2.indexOf(newPlugin) !== -1) {
      return;
    }
    plugins2.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(registry, plugin2) {
      for (var name in plugin2) {
        if (name in registry) {
          registry[name].push(plugin2[name]);
        }
      }
      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };
  return PluginsRegistry2;
}();
var SheetsRegistry = /* @__PURE__ */ function() {
  function SheetsRegistry2() {
    this.registry = [];
  }
  var _proto = SheetsRegistry2.prototype;
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index2 = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;
    if (registry.length === 0 || index2 >= this.index) {
      registry.push(sheet);
      return;
    }
    for (var i2 = 0; i2 < registry.length; i2++) {
      if (registry[i2].options.index > index2) {
        registry.splice(i2, 0, sheet);
        return;
      }
    }
  };
  _proto.reset = function reset() {
    this.registry = [];
  };
  _proto.remove = function remove3(sheet) {
    var index2 = this.registry.indexOf(sheet);
    this.registry.splice(index2, 1);
  };
  _proto.toString = function toString2(_temp) {
    var _ref3 = _temp === void 0 ? {} : _temp, attached = _ref3.attached, options2 = _objectWithoutPropertiesLoose(_ref3, ["attached"]);
    var css2 = "";
    for (var i2 = 0; i2 < this.registry.length; i2++) {
      var sheet = this.registry[i2];
      if (attached != null && sheet.attached !== attached) {
        continue;
      }
      if (css2) css2 += "\n";
      css2 += sheet.toString(options2);
    }
    return css2;
  };
  _createClass(SheetsRegistry2, [{
    key: "index",
    /**
     * Current highest index number.
     */
    get: function get3() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);
  return SheetsRegistry2;
}();
var sheets = new SheetsRegistry();
var globalThis$1 = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
var ns = "2f1acc6c3a606b082e5eef5e54414ffb";
if (globalThis$1[ns] == null) globalThis$1[ns] = 0;
var moduleId = globalThis$1[ns]++;
var createGenerateId = function createGenerateId2(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var ruleCounter = 0;
  return function(rule, sheet) {
    ruleCounter += 1;
    var jssId = "";
    var prefix2 = "";
    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix2 = sheet.options.classNamePrefix;
      }
      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }
    if (options2.minify) {
      return "" + (prefix2 || "c") + moduleId + jssId + ruleCounter;
    }
    return prefix2 + rule.key + "-" + moduleId + (jssId ? "-" + jssId : "") + "-" + ruleCounter;
  };
};
var memoize = function memoize2(fn) {
  var value;
  return function() {
    if (!value) value = fn();
    return value;
  };
};
function getPropertyValue(cssRule, prop) {
  try {
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }
    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    return "";
  }
}
function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;
    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);
      if (value[value.length - 1] === "!important") {
        cssRule.style.setProperty(prop, cssValue, "important");
        return true;
      }
    }
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    return false;
  }
  return true;
}
function removeProperty(cssRule, prop) {
  try {
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
  }
}
function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText;
  return cssRule.selectorText === selectorText;
}
var getHead = memoize(function() {
  return document.querySelector("head");
});
function findHigherSheet(registry, options2) {
  for (var i2 = 0; i2 < registry.length; i2++) {
    var sheet = registry[i2];
    if (sheet.attached && sheet.options.index > options2.index && sheet.options.insertionPoint === options2.insertionPoint) {
      return sheet;
    }
  }
  return null;
}
function findHighestSheet(registry, options2) {
  for (var i2 = registry.length - 1; i2 >= 0; i2--) {
    var sheet = registry[i2];
    if (sheet.attached && sheet.options.insertionPoint === options2.insertionPoint) {
      return sheet;
    }
  }
  return null;
}
function findCommentNode(text) {
  var head = getHead();
  for (var i2 = 0; i2 < head.childNodes.length; i2++) {
    var node2 = head.childNodes[i2];
    if (node2.nodeType === 8 && node2.nodeValue.trim() === text) {
      return node2;
    }
  }
  return null;
}
function findPrevNode(options2) {
  var registry = sheets.registry;
  if (registry.length > 0) {
    var sheet = findHigherSheet(registry, options2);
    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    }
    sheet = findHighestSheet(registry, options2);
    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  }
  var insertionPoint = options2.insertionPoint;
  if (insertionPoint && typeof insertionPoint === "string") {
    var comment = findCommentNode(insertionPoint);
    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    }
  }
  return false;
}
function insertStyle(style2, options2) {
  var insertionPoint = options2.insertionPoint;
  var nextNode = findPrevNode(options2);
  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style2, nextNode.node);
    return;
  }
  if (insertionPoint && typeof insertionPoint.nodeType === "number") {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style2, insertionPointElement.nextSibling);
    return;
  }
  getHead().appendChild(style2);
}
var getNonce = memoize(function() {
  var node2 = document.querySelector('meta[property="csp-nonce"]');
  return node2 ? node2.getAttribute("content") : null;
});
var _insertRule = function insertRule(container, rule, index2) {
  var maxIndex = container.cssRules.length;
  if (index2 === void 0 || index2 > maxIndex) {
    index2 = maxIndex;
  }
  try {
    if ("insertRule" in container) {
      var c = container;
      c.insertRule(rule, index2);
    } else if ("appendRule" in container) {
      var _c = container;
      _c.appendRule(rule);
    }
  } catch (err) {
    return false;
  }
  return container.cssRules[index2];
};
var createStyle = function createStyle2() {
  var el2 = document.createElement("style");
  el2.textContent = "\n";
  return el2;
};
var DomRenderer = /* @__PURE__ */ function() {
  function DomRenderer2(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.element = void 0;
    this.sheet = void 0;
    this.hasInsertedRules = false;
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;
    var _ref3 = this.sheet ? this.sheet.options : {}, media = _ref3.media, meta = _ref3.meta, element = _ref3.element;
    this.element = element || createStyle();
    this.element.setAttribute("data-jss", "");
    if (media) this.element.setAttribute("media", media);
    if (meta) this.element.setAttribute("data-meta", meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute("nonce", nonce);
  }
  var _proto = DomRenderer2.prototype;
  _proto.attach = function attach2() {
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options);
    var deployed = Boolean(this.sheet && this.sheet.deployed);
    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  };
  _proto.detach = function detach2() {
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element);
  };
  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;
    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }
    this.element.textContent = "\n" + sheet.toString() + "\n";
  };
  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i2 = 0; i2 < rules.index.length; i2++) {
      this.insertRule(rules.index[i2], i2, nativeParent);
    }
  };
  _proto.insertRule = function insertRule2(rule, index2, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }
    if (rule.rules) {
      var parent2 = rule;
      var latestNativeParent = nativeParent;
      if (rule.type === "conditional" || rule.type === "keyframes") {
        latestNativeParent = _insertRule(nativeParent, parent2.toString({
          children: false
        }), index2);
        if (latestNativeParent === false) {
          return false;
        }
      }
      this.insertRules(parent2.rules, latestNativeParent);
      return latestNativeParent;
    }
    if (rule.renderable && rule.renderable.parentStyleSheet === this.element.sheet) {
      return rule.renderable;
    }
    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var nativeRule = _insertRule(nativeParent, ruleStr, index2);
    if (nativeRule === false) {
      return false;
    }
    this.hasInsertedRules = true;
    rule.renderable = nativeRule;
    return nativeRule;
  };
  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index2 = this.indexOf(cssRule);
    if (index2 === -1) return false;
    sheet.deleteRule(index2);
    return true;
  };
  _proto.indexOf = function indexOf2(cssRule) {
    var cssRules = this.element.sheet.cssRules;
    for (var index2 = 0; index2 < cssRules.length; index2++) {
      if (cssRule === cssRules[index2]) return index2;
    }
    return -1;
  };
  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index2 = this.indexOf(cssRule);
    if (index2 === -1) return false;
    this.element.sheet.deleteRule(index2);
    return this.insertRule(rule, index2);
  };
  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };
  return DomRenderer2;
}();
var instanceCounter = 0;
var Jss = /* @__PURE__ */ function() {
  function Jss2(options2) {
    this.id = instanceCounter++;
    this.version = "10.0.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId,
      Renderer: isBrowser ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });
    for (var i2 = 0; i2 < plugins$1.length; i2++) {
      this.plugins.use(plugins$1[i2], {
        queue: "internal"
      });
    }
    this.setup(options2);
  }
  var _proto = Jss2.prototype;
  _proto.setup = function setup(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (options2.createGenerateId) {
      this.options.createGenerateId = options2.createGenerateId;
    }
    if (options2.id) {
      this.options.id = _extends$1({}, this.options.id, options2.id);
    }
    if (options2.createGenerateId || options2.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }
    if (options2.insertionPoint != null) this.options.insertionPoint = options2.insertionPoint;
    if ("Renderer" in options2) {
      this.options.Renderer = options2.Renderer;
    }
    if (options2.plugins) this.use.apply(this, options2.plugins);
    return this;
  };
  _proto.createStyleSheet = function createStyleSheet(styles3, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, index2 = _options.index;
    if (typeof index2 !== "number") {
      index2 = sheets.index === 0 ? 0 : sheets.index + 1;
    }
    var sheet = new StyleSheet(styles3, _extends$1({}, options2, {
      jss: this,
      generateId: options2.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index2
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  };
  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  };
  _proto.createRule = function createRule$$1(name, style2, options2) {
    if (style2 === void 0) {
      style2 = {};
    }
    if (options2 === void 0) {
      options2 = {};
    }
    if (typeof name === "object") {
      return this.createRule(void 0, name, style2);
    }
    var ruleOptions = _extends$1({}, options2, {
      jss: this,
      Renderer: this.options.Renderer
    });
    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};
    var rule = createRule(name, style2, ruleOptions);
    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.use = function use() {
    var _this = this;
    for (var _len = arguments.length, plugins$$1 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins$$1[_key] = arguments[_key];
    }
    plugins$$1.forEach(function(plugin2) {
      _this.plugins.use(plugin2);
    });
    return this;
  };
  return Jss2;
}();
function getDynamicStyles(styles3) {
  var to = null;
  for (var key2 in styles3) {
    var value = styles3[key2];
    var type2 = typeof value;
    if (type2 === "function") {
      if (!to) to = {};
      to[key2] = value;
    } else if (type2 === "object" && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);
      if (extracted) {
        if (!to) to = {};
        to[key2] = extracted;
      }
    }
  }
  return to;
}
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
var hasCSSTOMSupport = typeof CSS !== "undefined" && CSS && "number" in CSS;
var create = function create22(options2) {
  return new Jss(options2);
};
create();
var now = Date.now();
var fnValuesNs = "fnValues" + now;
var fnRuleNs = "fnStyle" + ++now;
function functionPlugin() {
  return {
    onCreateRule: function onCreateRule8(name, decl, options2) {
      if (typeof decl !== "function") return null;
      var rule = createRule(name, {}, options2);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle2(style2, rule) {
      if (fnValuesNs in rule || fnRuleNs in rule) return style2;
      var fnValues = {};
      for (var prop in style2) {
        var value = style2[prop];
        if (typeof value !== "function") continue;
        delete style2[prop];
        fnValues[prop] = value;
      }
      rule[fnValuesNs] = fnValues;
      return style2;
    },
    onUpdate: function onUpdate(data, rule, sheet, options2) {
      var styleRule = rule;
      var fnRule = styleRule[fnRuleNs];
      if (fnRule) {
        styleRule.style = fnRule(data) || {};
      }
      var fnValues = styleRule[fnValuesNs];
      if (fnValues) {
        for (var prop in fnValues) {
          styleRule.prop(prop, fnValues[prop](data), options2);
        }
      }
    }
  };
}
var at = "@global";
var atPrefix = "@global ";
var GlobalContainerRule = /* @__PURE__ */ function() {
  function GlobalContainerRule2(key2, styles3, options2) {
    this.type = "global";
    this.at = at;
    this.rules = void 0;
    this.options = void 0;
    this.key = void 0;
    this.isProcessed = false;
    this.key = key2;
    this.options = options2;
    this.rules = new RuleList(_extends$1({}, options2, {
      parent: this
    }));
    for (var selector in styles3) {
      this.rules.add(selector, styles3[selector]);
    }
    this.rules.process();
  }
  var _proto = GlobalContainerRule2.prototype;
  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  };
  _proto.addRule = function addRule(name, style2, options2) {
    var rule = this.rules.add(name, style2, options2);
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.indexOf = function indexOf2(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.toString = function toString2() {
    return this.rules.toString();
  };
  return GlobalContainerRule2;
}();
var GlobalPrefixedRule = /* @__PURE__ */ function() {
  function GlobalPrefixedRule2(key2, style2, options2) {
    this.type = "global";
    this.at = at;
    this.options = void 0;
    this.rule = void 0;
    this.isProcessed = false;
    this.key = void 0;
    this.key = key2;
    this.options = options2;
    var selector = key2.substr(atPrefix.length);
    this.rule = options2.jss.createRule(selector, style2, _extends$1({}, options2, {
      parent: this
    }));
  }
  var _proto2 = GlobalPrefixedRule2.prototype;
  _proto2.toString = function toString2(options2) {
    return this.rule ? this.rule.toString(options2) : "";
  };
  return GlobalPrefixedRule2;
}();
var separatorRegExp$1 = /\s*,\s*/g;
function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp$1);
  var scoped = "";
  for (var i2 = 0; i2 < parts.length; i2++) {
    scoped += scope + " " + parts[i2].trim();
    if (parts[i2 + 1]) scoped += ", ";
  }
  return scoped;
}
function handleNestedGlobalContainerRule(rule) {
  var options2 = rule.options, style2 = rule.style;
  var rules = style2 ? style2[at] : null;
  if (!rules) return;
  for (var name in rules) {
    options2.sheet.addRule(name, rules[name], _extends$1({}, options2, {
      selector: addScope(name, rule.selector)
    }));
  }
  delete style2[at];
}
function handlePrefixedGlobalRule(rule) {
  var options2 = rule.options, style2 = rule.style;
  for (var prop in style2) {
    if (prop[0] !== "@" || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    options2.sheet.addRule(selector, style2[prop], _extends$1({}, options2, {
      selector
    }));
    delete style2[prop];
  }
}
function jssGlobal() {
  function onCreateRule8(name, styles3, options2) {
    if (!name) return null;
    if (name === at) {
      return new GlobalContainerRule(name, styles3, options2);
    }
    if (name[0] === "@" && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles3, options2);
    }
    var parent2 = options2.parent;
    if (parent2) {
      if (parent2.type === "global" || parent2.options.parent && parent2.options.parent.type === "global") {
        options2.scoped = false;
      }
    }
    if (options2.scoped === false) {
      options2.selector = name;
    }
    return null;
  }
  function onProcessRule(rule) {
    if (rule.type !== "style") return;
    handleNestedGlobalContainerRule(rule);
    handlePrefixedGlobalRule(rule);
  }
  return {
    onCreateRule: onCreateRule8,
    onProcessRule
  };
}
var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
function jssNested() {
  function getReplaceRef(container, sheet) {
    return function(match, key2) {
      var rule = container.getRule(key2) || sheet && sheet.getRule(key2);
      if (rule) {
        rule = rule;
        return rule.selector;
      }
      return key2;
    };
  }
  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = "";
    for (var i2 = 0; i2 < parentSelectors.length; i2++) {
      var parent2 = parentSelectors[i2];
      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested2 = nestedSelectors[j];
        if (result) result += ", ";
        result += nested2.indexOf("&") !== -1 ? nested2.replace(parentRegExp, parent2) : parent2 + " " + nested2;
      }
    }
    return result;
  }
  function getOptions(rule, container, options2) {
    if (options2) return _extends$1({}, options2, {
      index: options2.index + 1
    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === void 0 ? 1 : nestingLevel + 1;
    return _extends$1({}, rule.options, {
      nestingLevel,
      index: container.indexOf(rule) + 1
    });
  }
  function onProcessStyle2(style2, rule, sheet) {
    if (rule.type !== "style") return style2;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options2;
    var replaceRef3;
    for (var prop in style2) {
      var isNested = prop.indexOf("&") !== -1;
      var isNestedConditional = prop[0] === "@";
      if (!isNested && !isNestedConditional) continue;
      options2 = getOptions(styleRule, container, options2);
      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector);
        if (!replaceRef3) replaceRef3 = getReplaceRef(container, sheet);
        selector = selector.replace(refRegExp, replaceRef3);
        container.addRule(selector, style2[prop], _extends$1({}, options2, {
          selector
        }));
      } else if (isNestedConditional) {
        container.addRule(prop, {}, options2).addRule(styleRule.key, style2[prop], {
          selector: styleRule.selector
        });
      }
      delete style2[prop];
    }
    return style2;
  }
  return {
    onProcessStyle: onProcessStyle2
  };
}
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache$2 = {};
function toHyphenLower(match) {
  return "-" + match.toLowerCase();
}
function hyphenateStyleName(name) {
  if (cache$2.hasOwnProperty(name)) {
    return cache$2[name];
  }
  var hName = name.replace(uppercasePattern, toHyphenLower);
  return cache$2[name] = msPattern.test(hName) ? "-" + hName : hName;
}
function convertCase(style2) {
  var converted = {};
  for (var prop in style2) {
    var key2 = prop.indexOf("--") === 0 ? prop : hyphenateStyleName(prop);
    converted[key2] = style2[prop];
  }
  if (style2.fallbacks) {
    if (Array.isArray(style2.fallbacks)) converted.fallbacks = style2.fallbacks.map(convertCase);
    else converted.fallbacks = convertCase(style2.fallbacks);
  }
  return converted;
}
function camelCase() {
  function onProcessStyle2(style2) {
    if (Array.isArray(style2)) {
      for (var index2 = 0; index2 < style2.length; index2++) {
        style2[index2] = convertCase(style2[index2]);
      }
      return style2;
    }
    return convertCase(style2);
  }
  function onChangeValue2(value, prop, rule) {
    if (prop.indexOf("--") === 0) {
      return value;
    }
    var hyphenatedProp = hyphenateStyleName(prop);
    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value);
    return null;
  }
  return {
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var px = hasCSSTOMSupport && CSS ? CSS.px : "px";
var ms = hasCSSTOMSupport && CSS ? CSS.ms : "ms";
var percent = hasCSSTOMSupport && CSS ? CSS.percent : "%";
var defaultUnits = {
  // Animation properties
  "animation-delay": ms,
  "animation-duration": ms,
  // Background properties
  "background-position": px,
  "background-position-x": px,
  "background-position-y": px,
  "background-size": px,
  // Border Properties
  border: px,
  "border-bottom": px,
  "border-bottom-left-radius": px,
  "border-bottom-right-radius": px,
  "border-bottom-width": px,
  "border-left": px,
  "border-left-width": px,
  "border-radius": px,
  "border-right": px,
  "border-right-width": px,
  "border-top": px,
  "border-top-left-radius": px,
  "border-top-right-radius": px,
  "border-top-width": px,
  "border-width": px,
  // Margin properties
  margin: px,
  "margin-bottom": px,
  "margin-left": px,
  "margin-right": px,
  "margin-top": px,
  // Padding properties
  padding: px,
  "padding-bottom": px,
  "padding-left": px,
  "padding-right": px,
  "padding-top": px,
  // Mask properties
  "mask-position-x": px,
  "mask-position-y": px,
  "mask-size": px,
  // Width and height properties
  height: px,
  width: px,
  "min-height": px,
  "max-height": px,
  "min-width": px,
  "max-width": px,
  // Position properties
  bottom: px,
  left: px,
  top: px,
  right: px,
  // Shadow properties
  "box-shadow": px,
  "text-shadow": px,
  // Column properties
  "column-gap": px,
  "column-rule": px,
  "column-rule-width": px,
  "column-width": px,
  // Font and text properties
  "font-size": px,
  "font-size-delta": px,
  "letter-spacing": px,
  "text-indent": px,
  "text-stroke": px,
  "text-stroke-width": px,
  "word-spacing": px,
  // Motion properties
  motion: px,
  "motion-offset": px,
  // Outline properties
  outline: px,
  "outline-offset": px,
  "outline-width": px,
  // Perspective properties
  perspective: px,
  "perspective-origin-x": percent,
  "perspective-origin-y": percent,
  // Transform properties
  "transform-origin": percent,
  "transform-origin-x": percent,
  "transform-origin-y": percent,
  "transform-origin-z": percent,
  // Transition properties
  "transition-delay": ms,
  "transition-duration": ms,
  // Alignment properties
  "vertical-align": px,
  "flex-basis": px,
  // Some random properties
  "shape-margin": px,
  size: px,
  // Grid properties
  grid: px,
  "grid-gap": px,
  "grid-row-gap": px,
  "grid-column-gap": px,
  "grid-template-rows": px,
  "grid-template-columns": px,
  "grid-auto-rows": px,
  "grid-auto-columns": px,
  // Not existing properties.
  // Used to avoid issues with jss-plugin-expand integration.
  "box-shadow-x": px,
  "box-shadow-y": px,
  "box-shadow-blur": px,
  "box-shadow-spread": px,
  "font-line-height": px,
  "text-shadow-x": px,
  "text-shadow-y": px,
  "text-shadow-blur": px
};
function addCamelCasedVersion(obj) {
  var regExp2 = /(-[a-z])/g;
  var replace = function replace2(str) {
    return str[1].toUpperCase();
  };
  var newObj = {};
  for (var _key in obj) {
    newObj[_key] = obj[_key];
    newObj[_key.replace(regExp2, replace)] = obj[_key];
  }
  return newObj;
}
var units = addCamelCasedVersion(defaultUnits);
function iterate(prop, value, options2) {
  if (!value) return value;
  if (Array.isArray(value)) {
    for (var i2 = 0; i2 < value.length; i2++) {
      value[i2] = iterate(prop, value[i2], options2);
    }
  } else if (typeof value === "object") {
    if (prop === "fallbacks") {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options2);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options2);
      }
    }
  } else if (typeof value === "number") {
    if (options2[prop]) {
      return "" + value + options2[prop];
    }
    if (units[prop]) {
      return typeof units[prop] === "function" ? units[prop](value).toString() : "" + value + units[prop];
    }
    return value.toString();
  }
  return value;
}
function defaultUnit(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var camelCasedOptions = addCamelCasedVersion(options2);
  function onProcessStyle2(style2, rule) {
    if (rule.type !== "style") return style2;
    for (var prop in style2) {
      style2[prop] = iterate(prop, style2[prop], camelCasedOptions);
    }
    return style2;
  }
  function onChangeValue2(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }
  return {
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var js = "";
var css = "";
var vendor = "";
var isTouch = isBrowser && "ontouchstart" in document.documentElement;
if (isBrowser) {
  var jsCssMap = {
    Moz: "-moz-",
    ms: "-ms-",
    O: "-o-",
    Webkit: "-webkit-"
  };
  var _document$createEleme = document.createElement("p"), style = _document$createEleme.style;
  var testProp = "Transform";
  for (var key$2 in jsCssMap) {
    if (key$2 + testProp in style) {
      js = key$2;
      css = jsCssMap[key$2];
      break;
    }
  }
  if (js === "Webkit" && "msHyphens" in style) {
    js = "ms";
    css = jsCssMap.ms;
  }
  if (js === "Webkit" && "-apple-trailing-word" in style) {
    vendor = "apple";
  }
}
var prefix = {
  js,
  css,
  vendor,
  isTouch
};
function supportedKeyframes(key2) {
  if (key2[1] === "-") return key2;
  if (prefix.js === "ms") return key2;
  return "@" + prefix.css + "keyframes" + key2.substr(10);
}
var appearence = {
  noPrefill: ["appearance"],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== "appearance") return false;
    if (prefix.js === "ms") return "-webkit-" + prop;
    return prefix.css + prop;
  }
};
var colorAdjust = {
  noPrefill: ["color-adjust"],
  supportedProperty: function supportedProperty2(prop) {
    if (prop !== "color-adjust") return false;
    if (prefix.js === "Webkit") return prefix.css + "print-" + prop;
    return prop;
  }
};
var regExp = /[-\s]+(.)?/g;
function toUpper(match, c) {
  return c ? c.toUpperCase() : "";
}
function camelize(str) {
  return str.replace(regExp, toUpper);
}
function pascalize(str) {
  return camelize("-" + str);
}
var mask = {
  noPrefill: ["mask"],
  supportedProperty: function supportedProperty3(prop, style2) {
    if (!/^mask/.test(prop)) return false;
    if (prefix.js === "Webkit") {
      var longhand = "mask-image";
      if (camelize(longhand) in style2) {
        return prop;
      }
      if (prefix.js + pascalize(longhand) in style2) {
        return prefix.css + prop;
      }
    }
    return prop;
  }
};
var textOrientation = {
  noPrefill: ["text-orientation"],
  supportedProperty: function supportedProperty4(prop) {
    if (prop !== "text-orientation") return false;
    if (prefix.vendor === "apple" && !prefix.isTouch) {
      return prefix.css + prop;
    }
    return prop;
  }
};
var transform = {
  noPrefill: ["transform"],
  supportedProperty: function supportedProperty5(prop, style2, options2) {
    if (prop !== "transform") return false;
    if (options2.transform) {
      return prop;
    }
    return prefix.css + prop;
  }
};
var transition = {
  noPrefill: ["transition"],
  supportedProperty: function supportedProperty6(prop, style2, options2) {
    if (prop !== "transition") return false;
    if (options2.transition) {
      return prop;
    }
    return prefix.css + prop;
  }
};
var writingMode = {
  noPrefill: ["writing-mode"],
  supportedProperty: function supportedProperty7(prop) {
    if (prop !== "writing-mode") return false;
    if (prefix.js === "Webkit" || prefix.js === "ms") {
      return prefix.css + prop;
    }
    return prop;
  }
};
var userSelect = {
  noPrefill: ["user-select"],
  supportedProperty: function supportedProperty8(prop) {
    if (prop !== "user-select") return false;
    if (prefix.js === "Moz" || prefix.js === "ms" || prefix.vendor === "apple") {
      return prefix.css + prop;
    }
    return prop;
  }
};
var breakPropsOld = {
  supportedProperty: function supportedProperty9(prop, style2) {
    if (!/^break-/.test(prop)) return false;
    if (prefix.js === "Webkit") {
      var jsProp = "WebkitColumn" + pascalize(prop);
      return jsProp in style2 ? prefix.css + "column-" + prop : false;
    }
    if (prefix.js === "Moz") {
      var _jsProp = "page" + pascalize(prop);
      return _jsProp in style2 ? "page-" + prop : false;
    }
    return false;
  }
};
var inlineLogicalOld = {
  supportedProperty: function supportedProperty10(prop, style2) {
    if (!/^(border|margin|padding)-inline/.test(prop)) return false;
    if (prefix.js === "Moz") return prop;
    var newProp = prop.replace("-inline", "");
    return prefix.js + pascalize(newProp) in style2 ? prefix.css + newProp : false;
  }
};
var unprefixed = {
  supportedProperty: function supportedProperty11(prop, style2) {
    return camelize(prop) in style2 ? prop : false;
  }
};
var prefixed = {
  supportedProperty: function supportedProperty12(prop, style2) {
    var pascalized = pascalize(prop);
    if (prop[0] === "-") return prop;
    if (prop[0] === "-" && prop[1] === "-") return prop;
    if (prefix.js + pascalized in style2) return prefix.css + prop;
    if (prefix.js !== "Webkit" && "Webkit" + pascalized in style2) return "-webkit-" + prop;
    return false;
  }
};
var scrollSnap = {
  supportedProperty: function supportedProperty13(prop) {
    if (prop.substring(0, 11) !== "scroll-snap") return false;
    if (prefix.js === "ms") {
      return "" + prefix.css + prop;
    }
    return prop;
  }
};
var overscrollBehavior = {
  supportedProperty: function supportedProperty14(prop) {
    if (prop !== "overscroll-behavior") return false;
    if (prefix.js === "ms") {
      return prefix.css + "scroll-chaining";
    }
    return prop;
  }
};
var propMap = {
  "flex-grow": "flex-positive",
  "flex-shrink": "flex-negative",
  "flex-basis": "flex-preferred-size",
  "justify-content": "flex-pack",
  order: "flex-order",
  "align-items": "flex-align",
  "align-content": "flex-line-pack"
  // 'align-self' is handled by 'align-self' plugin.
};
var flex2012 = {
  supportedProperty: function supportedProperty15(prop, style2) {
    var newProp = propMap[prop];
    if (!newProp) return false;
    return prefix.js + pascalize(newProp) in style2 ? prefix.css + newProp : false;
  }
};
var propMap$1 = {
  flex: "box-flex",
  "flex-grow": "box-flex",
  "flex-direction": ["box-orient", "box-direction"],
  order: "box-ordinal-group",
  "align-items": "box-align",
  "flex-flow": ["box-orient", "box-direction"],
  "justify-content": "box-pack"
};
var propKeys = Object.keys(propMap$1);
var prefixCss = function prefixCss2(p) {
  return prefix.css + p;
};
var flex2009 = {
  supportedProperty: function supportedProperty16(prop, style2, _ref3) {
    var multiple = _ref3.multiple;
    if (propKeys.indexOf(prop) > -1) {
      var newProp = propMap$1[prop];
      if (!Array.isArray(newProp)) {
        return prefix.js + pascalize(newProp) in style2 ? prefix.css + newProp : false;
      }
      if (!multiple) return false;
      for (var i2 = 0; i2 < newProp.length; i2++) {
        if (!(prefix.js + pascalize(newProp[0]) in style2)) {
          return false;
        }
      }
      return newProp.map(prefixCss);
    }
    return false;
  }
};
var plugins = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
var propertyDetectors = plugins.filter(function(p) {
  return p.supportedProperty;
}).map(function(p) {
  return p.supportedProperty;
});
var noPrefill = plugins.filter(function(p) {
  return p.noPrefill;
}).reduce(function(a, p) {
  a.push.apply(a, _toConsumableArray(p.noPrefill));
  return a;
}, []);
var el;
var cache = {};
if (isBrowser) {
  el = document.createElement("p");
  var computed = window.getComputedStyle(document.documentElement, "");
  for (var key$1$1 in computed) {
    if (!isNaN(key$1$1)) cache[computed[key$1$1]] = computed[key$1$1];
  }
  noPrefill.forEach(function(x) {
    return delete cache[x];
  });
}
function supportedProperty17(prop, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (!el) return prop;
  if (cache[prop] != null) {
    return cache[prop];
  }
  if (prop === "transition" || prop === "transform") {
    options2[prop] = prop in el.style;
  }
  for (var i2 = 0; i2 < propertyDetectors.length; i2++) {
    cache[prop] = propertyDetectors[i2](prop, el.style, options2);
    if (cache[prop]) break;
  }
  try {
    el.style[prop] = "";
  } catch (err) {
    return false;
  }
  return cache[prop];
}
var cache$1 = {};
var transitionProperties = {
  transition: 1,
  "transition-property": 1,
  "-webkit-transition": 1,
  "-webkit-transition-property": 1
};
var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var el$1;
function prefixTransitionCallback(match, p1, p2) {
  if (p1 === "var") return "var";
  if (p1 === "all") return "all";
  if (p2 === "all") return ", all";
  var prefixedValue = p1 ? supportedProperty17(p1) : ", " + supportedProperty17(p2);
  if (!prefixedValue) return p1 || p2;
  return prefixedValue;
}
if (isBrowser) el$1 = document.createElement("p");
function supportedValue(property, value) {
  var prefixedValue = value;
  if (!el$1 || property === "content") return value;
  if (typeof prefixedValue !== "string" || !isNaN(parseInt(prefixedValue, 10))) {
    return prefixedValue;
  }
  var cacheKey = property + prefixedValue;
  if (cache$1[cacheKey] != null) {
    return cache$1[cacheKey];
  }
  try {
    el$1.style[property] = prefixedValue;
  } catch (err) {
    cache$1[cacheKey] = false;
    return false;
  }
  if (transitionProperties[property]) {
    prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
  } else if (el$1.style[property] === "") {
    prefixedValue = prefix.css + prefixedValue;
    if (prefixedValue === "-ms-flex") el$1.style[property] = "-ms-flexbox";
    el$1.style[property] = prefixedValue;
    if (el$1.style[property] === "") {
      cache$1[cacheKey] = false;
      return false;
    }
  }
  el$1.style[property] = "";
  cache$1[cacheKey] = prefixedValue;
  return cache$1[cacheKey];
}
function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === "keyframes") {
      var atRule = rule;
      atRule.at = supportedKeyframes(atRule.at);
    }
  }
  function prefixStyle(style2) {
    for (var prop in style2) {
      var value = style2[prop];
      if (prop === "fallbacks" && Array.isArray(value)) {
        style2[prop] = value.map(prefixStyle);
        continue;
      }
      var changeProp = false;
      var supportedProp = supportedProperty17(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;
      var changeValue = false;
      var supportedValue$$1 = supportedValue(supportedProp, toCssValue(value));
      if (supportedValue$$1 && supportedValue$$1 !== value) changeValue = true;
      if (changeProp || changeValue) {
        if (changeProp) delete style2[prop];
        style2[supportedProp || prop] = supportedValue$$1 || value;
      }
    }
    return style2;
  }
  function onProcessStyle2(style2, rule) {
    if (rule.type !== "style") return style2;
    return prefixStyle(style2);
  }
  function onChangeValue2(value, prop) {
    return supportedValue(prop, toCssValue(value)) || value;
  }
  return {
    onProcessRule,
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
function jssPropsSort() {
  var sort = function sort2(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }
    return prop0.length - prop1.length;
  };
  return {
    onProcessStyle: function onProcessStyle2(style2, rule) {
      if (rule.type !== "style") return style2;
      var newStyle = {};
      var props = Object.keys(style2).sort(sort);
      for (var i2 = 0; i2 < props.length; i2++) {
        newStyle[props[i2]] = style2[props[i2]];
      }
      return newStyle;
    }
  };
}
function jssPreset() {
  return {
    plugins: [
      functionPlugin(),
      jssGlobal(),
      jssNested(),
      camelCase(),
      defaultUnit(),
      // Disable the vendor prefixer server-side, it does nothing.
      // This way, we can get a performance boost.
      // In the documentation, we are using `autoprefixer` to solve this problem.
      typeof window === "undefined" ? null : jssVendorPrefixer(),
      jssPropsSort()
    ]
  };
}
function mergeClasses() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var baseClasses = options2.baseClasses, newClasses = options2.newClasses;
  options2.Component;
  if (!newClasses) {
    return baseClasses;
  }
  var nextClasses = _extends$1({}, baseClasses);
  Object.keys(newClasses).forEach(function(key2) {
    if (newClasses[key2]) {
      nextClasses[key2] = "".concat(baseClasses[key2], " ").concat(newClasses[key2]);
    }
  });
  return nextClasses;
}
var multiKeyStore = {
  set: function set2(cache2, key1, key2, value) {
    var subCache = cache2.get(key1);
    if (!subCache) {
      subCache = /* @__PURE__ */ new Map();
      cache2.set(key1, subCache);
    }
    subCache.set(key2, value);
  },
  get: function get2(cache2, key1, key2) {
    var subCache = cache2.get(key1);
    return subCache ? subCache.get(key2) : void 0;
  },
  delete: function _delete(cache2, key1, key2) {
    var subCache = cache2.get(key1);
    subCache.delete(key2);
  }
};
var ThemeContext = React.createContext(null);
function useTheme$1() {
  return React.useContext(ThemeContext);
}
var jss = create(jssPreset());
var generateClassName = createGenerateClassName();
var sheetsManager = /* @__PURE__ */ new Map();
var defaultOptions = {
  disableGeneration: false,
  generateClassName,
  jss,
  sheetsCache: null,
  sheetsManager,
  sheetsRegistry: null
};
var StylesContext = React.createContext(defaultOptions);
var injectFirstNode;
function StylesProvider(props) {
  var children = props.children, _props$injectFirst = props.injectFirst, injectFirst = _props$injectFirst === void 0 ? false : _props$injectFirst, _props$disableGenerat = props.disableGeneration, disableGeneration = _props$disableGenerat === void 0 ? false : _props$disableGenerat, localOptions = _objectWithoutProperties(props, ["children", "injectFirst", "disableGeneration"]);
  var outerOptions = React.useContext(StylesContext);
  var context2 = _extends$1({}, outerOptions, {
    disableGeneration
  }, localOptions);
  if (!context2.jss.options.insertionPoint && injectFirst && typeof window !== "undefined") {
    if (!injectFirstNode) {
      var head = document.head;
      injectFirstNode = document.createComment("mui-inject-first");
      head.insertBefore(injectFirstNode, head.firstChild);
    }
    context2.jss = create({
      plugins: jssPreset().plugins,
      insertionPoint: injectFirstNode
    });
  }
  return React.createElement(StylesContext.Provider, {
    value: context2
  }, children);
}
var indexCounter = -1e9;
function increment() {
  indexCounter += 1;
  return indexCounter;
}
var noopTheme = {};
function arrayMerge(destination, source) {
  return source;
}
function getStylesCreator(stylesOrCreator) {
  var themingEnabled = typeof stylesOrCreator === "function";
  return {
    create: function create4(theme2, name) {
      var styles3;
      try {
        styles3 = themingEnabled ? stylesOrCreator(theme2) : stylesOrCreator;
      } catch (err) {
        throw err;
      }
      if (!name || !theme2.overrides || !theme2.overrides[name]) {
        return styles3;
      }
      var overrides = theme2.overrides[name];
      var stylesWithOverrides = _extends$1({}, styles3);
      Object.keys(overrides).forEach(function(key2) {
        stylesWithOverrides[key2] = deepmerge(stylesWithOverrides[key2], overrides[key2], {
          arrayMerge
        });
      });
      return stylesWithOverrides;
    },
    options: {}
  };
}
function getClasses(_ref3, classes, Component) {
  var state2 = _ref3.state, stylesOptions = _ref3.stylesOptions;
  if (stylesOptions.disableGeneration) {
    return classes || {};
  }
  if (!state2.cacheClasses) {
    state2.cacheClasses = {
      // Cache for the finalized classes value.
      value: null,
      // Cache for the last used classes prop pointer.
      lastProp: null,
      // Cache for the last used rendered classes pointer.
      lastJSS: {}
    };
  }
  var generate = false;
  if (state2.classes !== state2.cacheClasses.lastJSS) {
    state2.cacheClasses.lastJSS = state2.classes;
    generate = true;
  }
  if (classes !== state2.cacheClasses.lastProp) {
    state2.cacheClasses.lastProp = classes;
    generate = true;
  }
  if (generate) {
    state2.cacheClasses.value = mergeClasses({
      baseClasses: state2.cacheClasses.lastJSS,
      newClasses: classes,
      Component
    });
  }
  return state2.cacheClasses.value;
}
function attach(_ref22, props) {
  var state2 = _ref22.state, theme2 = _ref22.theme, stylesOptions = _ref22.stylesOptions, stylesCreator = _ref22.stylesCreator, name = _ref22.name;
  if (stylesOptions.disableGeneration) {
    return;
  }
  var sheetManager = multiKeyStore.get(stylesOptions.sheetsManager, stylesCreator, theme2);
  if (!sheetManager) {
    sheetManager = {
      refs: 0,
      staticSheet: null,
      dynamicStyles: null
    };
    multiKeyStore.set(stylesOptions.sheetsManager, stylesCreator, theme2, sheetManager);
  }
  var options2 = _extends$1({}, stylesCreator.options, {}, stylesOptions, {
    theme: theme2,
    flip: typeof stylesOptions.flip === "boolean" ? stylesOptions.flip : theme2.direction === "rtl"
  });
  options2.generateId = options2.serverGenerateClassName || options2.generateClassName;
  var sheetsRegistry = stylesOptions.sheetsRegistry;
  if (sheetManager.refs === 0) {
    var staticSheet;
    if (stylesOptions.sheetsCache) {
      staticSheet = multiKeyStore.get(stylesOptions.sheetsCache, stylesCreator, theme2);
    }
    var styles3 = stylesCreator.create(theme2, name);
    if (!staticSheet) {
      staticSheet = stylesOptions.jss.createStyleSheet(styles3, _extends$1({
        link: false
      }, options2));
      staticSheet.attach();
      if (stylesOptions.sheetsCache) {
        multiKeyStore.set(stylesOptions.sheetsCache, stylesCreator, theme2, staticSheet);
      }
    }
    if (sheetsRegistry) {
      sheetsRegistry.add(staticSheet);
    }
    sheetManager.staticSheet = staticSheet;
    sheetManager.dynamicStyles = getDynamicStyles(styles3);
  }
  if (sheetManager.dynamicStyles) {
    var dynamicSheet = stylesOptions.jss.createStyleSheet(sheetManager.dynamicStyles, _extends$1({
      link: true
    }, options2));
    dynamicSheet.update(props).attach();
    state2.dynamicSheet = dynamicSheet;
    state2.classes = mergeClasses({
      baseClasses: sheetManager.staticSheet.classes,
      newClasses: dynamicSheet.classes
    });
    if (sheetsRegistry) {
      sheetsRegistry.add(dynamicSheet);
    }
  } else {
    state2.classes = sheetManager.staticSheet.classes;
  }
  sheetManager.refs += 1;
}
function update(_ref3, props) {
  var state2 = _ref3.state;
  if (state2.dynamicSheet) {
    state2.dynamicSheet.update(props);
  }
}
function detach(_ref4) {
  var state2 = _ref4.state, theme2 = _ref4.theme, stylesOptions = _ref4.stylesOptions, stylesCreator = _ref4.stylesCreator;
  if (stylesOptions.disableGeneration) {
    return;
  }
  var sheetManager = multiKeyStore.get(stylesOptions.sheetsManager, stylesCreator, theme2);
  sheetManager.refs -= 1;
  var sheetsRegistry = stylesOptions.sheetsRegistry;
  if (sheetManager.refs === 0) {
    multiKeyStore.delete(stylesOptions.sheetsManager, stylesCreator, theme2);
    stylesOptions.jss.removeStyleSheet(sheetManager.staticSheet);
    if (sheetsRegistry) {
      sheetsRegistry.remove(sheetManager.staticSheet);
    }
  }
  if (state2.dynamicSheet) {
    stylesOptions.jss.removeStyleSheet(state2.dynamicSheet);
    if (sheetsRegistry) {
      sheetsRegistry.remove(state2.dynamicSheet);
    }
  }
}
function useSynchronousEffect(func, values2) {
  var key2 = React.useRef([]);
  var output2;
  var currentKey = React.useMemo(function() {
    return {};
  }, values2);
  if (key2.current !== currentKey) {
    key2.current = currentKey;
    output2 = func();
  }
  React.useEffect(
    function() {
      return function() {
        if (output2) {
          output2();
        }
      };
    },
    [currentKey]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
}
function makeStyles$3(stylesOrCreator) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var name = options2.name, classNamePrefixOption = options2.classNamePrefix, Component = options2.Component, _options$defaultTheme = options2.defaultTheme, defaultTheme2 = _options$defaultTheme === void 0 ? noopTheme : _options$defaultTheme, stylesOptions2 = _objectWithoutProperties(options2, ["name", "classNamePrefix", "Component", "defaultTheme"]);
  var stylesCreator = getStylesCreator(stylesOrCreator);
  var classNamePrefix = name || classNamePrefixOption || "makeStyles";
  stylesCreator.options = {
    index: increment(),
    name,
    meta: classNamePrefix,
    classNamePrefix
  };
  return function() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var theme2 = useTheme$1() || defaultTheme2;
    var stylesOptions = _extends$1({}, React.useContext(StylesContext), {}, stylesOptions2);
    var instance = React.useRef();
    var shouldUpdate = React.useRef();
    useSynchronousEffect(function() {
      var current = {
        name,
        state: {},
        stylesCreator,
        stylesOptions,
        theme: theme2
      };
      attach(current, props);
      shouldUpdate.current = false;
      instance.current = current;
      return function() {
        detach(current);
      };
    }, [theme2, stylesCreator]);
    React.useEffect(function() {
      if (shouldUpdate.current) {
        update(instance.current, props);
      }
      shouldUpdate.current = true;
    });
    return getClasses(instance.current, props.classes, Component);
  };
}
var ServerStyleSheets = /* @__PURE__ */ function() {
  function ServerStyleSheets2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, ServerStyleSheets2);
    this.options = options2;
  }
  _createClass(ServerStyleSheets2, [{
    key: "collect",
    value: function collect(children) {
      var sheetsManager2 = /* @__PURE__ */ new Map();
      this.sheetsRegistry = new SheetsRegistry();
      var generateClassName2 = createGenerateClassName();
      return React.createElement(StylesProvider, _extends$1({
        sheetsManager: sheetsManager2,
        serverGenerateClassName: generateClassName2,
        sheetsRegistry: this.sheetsRegistry
      }, this.options), children);
    }
  }, {
    key: "toString",
    value: function toString2() {
      return this.sheetsRegistry ? this.sheetsRegistry.toString() : "";
    }
  }, {
    key: "getStyleElement",
    value: function getStyleElement(props) {
      return React.createElement("style", _extends$1({
        id: "jss-server-side",
        key: "jss-server-side",
        dangerouslySetInnerHTML: {
          __html: this.toString()
        }
      }, props));
    }
  }]);
  return ServerStyleSheets2;
}();
function toVal(mix) {
  var k, y, str = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k = 0; k < mix.length; k++) {
        if (mix[k]) {
          if (y = toVal(mix[k])) {
            str && (str += " ");
            str += y;
          }
        }
      }
    } else {
      for (k in mix) {
        if (mix[k]) {
          str && (str += " ");
          str += k;
        }
      }
    }
  }
  return str;
}
function clsx() {
  var i2 = 0, tmp, x, str = "";
  while (i2 < arguments.length) {
    if (tmp = arguments[i2++]) {
      if (x = toVal(tmp)) {
        str && (str += " ");
        str += x;
      }
    }
  }
  return str;
}
function omit(input, fields) {
  var output2 = {};
  Object.keys(input).forEach(function(prop) {
    if (fields.indexOf(prop) === -1) {
      output2[prop] = input[prop];
    }
  });
  return output2;
}
function styled(Component) {
  var componentCreator = function componentCreator2(style2) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var name = options2.name, stylesOptions = _objectWithoutProperties(options2, ["name"]);
    var classNamePrefix = name;
    var stylesOrCreator = typeof style2 === "function" ? function(theme2) {
      return {
        root: function root(props) {
          return style2(_extends$1({
            theme: theme2
          }, props));
        }
      };
    } : {
      root: style2
    };
    var useStyles = makeStyles$3(stylesOrCreator, _extends$1({
      Component,
      name: name || Component.displayName,
      classNamePrefix
    }, stylesOptions));
    var filterProps;
    if (style2.filterProps) {
      filterProps = style2.filterProps;
      delete style2.filterProps;
    }
    if (style2.propTypes) {
      style2.propTypes;
      delete style2.propTypes;
    }
    var StyledComponent = React.forwardRef(function StyledComponent2(props, ref2) {
      var children = props.children, classNameProp = props.className, clone = props.clone, ComponentProp = props.component, other = _objectWithoutProperties(props, ["children", "className", "clone", "component"]);
      var classes = useStyles(props);
      var className = clsx(classes.root, classNameProp);
      var spread2 = other;
      if (filterProps) {
        spread2 = omit(spread2, filterProps);
      }
      if (clone) {
        return React.cloneElement(children, _extends$1({
          className: clsx(children.props.className, className)
        }, spread2));
      }
      if (typeof children === "function") {
        return children(_extends$1({
          className
        }, spread2));
      }
      var FinalComponent = ComponentProp || Component;
      return React.createElement(FinalComponent, _extends$1({
        ref: ref2,
        className
      }, spread2), children);
    });
    hoistNonReactStatics(StyledComponent, Component);
    return StyledComponent;
  };
  return componentCreator;
}
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    var mergedTheme = localTheme(outerTheme);
    return mergedTheme;
  }
  return _extends$1({}, outerTheme, {}, localTheme);
}
function ThemeProvider(props) {
  var children = props.children, localTheme = props.theme;
  var outerTheme = useTheme$1();
  var theme2 = React.useMemo(function() {
    var output2 = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output2 != null) {
      output2[nested] = outerTheme !== null;
    }
    return output2;
  }, [localTheme, outerTheme]);
  return React.createElement(ThemeContext.Provider, {
    value: theme2
  }, children);
}
var withStyles$1 = function withStyles2(stylesOrCreator) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function(Component) {
    var defaultTheme2 = options2.defaultTheme, _options$withTheme = options2.withTheme, withTheme2 = _options$withTheme === void 0 ? false : _options$withTheme, name = options2.name, stylesOptions = _objectWithoutProperties(options2, ["defaultTheme", "withTheme", "name"]);
    var classNamePrefix = name;
    var useStyles = makeStyles$3(stylesOrCreator, _extends$1({
      defaultTheme: defaultTheme2,
      Component,
      name: name || Component.displayName,
      classNamePrefix
    }, stylesOptions));
    var WithStyles = React.forwardRef(function WithStyles2(props, ref2) {
      props.classes;
      var innerRef = props.innerRef, other = _objectWithoutProperties(props, ["classes", "innerRef"]);
      var classes = useStyles(props);
      var theme2;
      var more = other;
      if (typeof name === "string" || withTheme2) {
        theme2 = useTheme$1() || defaultTheme2;
        if (name) {
          more = getThemeProps({
            theme: theme2,
            name,
            props: other
          });
        }
        if (withTheme2 && !more.theme) {
          more.theme = theme2;
        }
      }
      return React.createElement(Component, _extends$1({
        ref: innerRef || ref2,
        classes
      }, more));
    });
    hoistNonReactStatics(WithStyles, Component);
    return WithStyles;
  };
};
function withThemeCreator() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var defaultTheme2 = options2.defaultTheme;
  var withTheme2 = function withTheme3(Component) {
    var WithTheme = React.forwardRef(function WithTheme2(props, ref2) {
      var innerRef = props.innerRef, other = _objectWithoutProperties(props, ["innerRef"]);
      var theme2 = useTheme$1() || defaultTheme2;
      return React.createElement(Component, _extends$1({
        theme: theme2,
        ref: innerRef || ref2
      }, other));
    });
    hoistNonReactStatics(WithTheme, Component);
    return WithTheme;
  };
  return withTheme2;
}
var withTheme = withThemeCreator();
/** @license Material-UI v4.5.0
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ServerStyleSheets,
  StylesProvider,
  ThemeProvider,
  createGenerateClassName,
  createStyles,
  getThemeProps,
  jssPreset,
  makeStyles: makeStyles$3,
  mergeClasses,
  styled,
  useTheme: useTheme$1,
  withStyles: withStyles$1,
  withTheme,
  withThemeCreator
}, Symbol.toStringTag, { value: "Module" }));
var defaultTheme$1 = createMuiTheme$1();
function makeStyles$2(stylesOrCreator) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return makeStyles$3(stylesOrCreator, _extends$1({
    defaultTheme: defaultTheme$1
  }, options2));
}
function useTheme() {
  return useTheme$1() || defaultTheme$1;
}
function withStyles(stylesOrCreator, options2) {
  return withStyles$1(stylesOrCreator, _extends$1({
    defaultTheme: defaultTheme$1
  }, options2));
}
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var SIZE = 44;
function getRelativeValue(value, min2, max2) {
  var clampedValue = Math.min(Math.max(min2, value), max2);
  return (clampedValue - min2) / (max2 - min2);
}
function easeOut(t2) {
  t2 = getRelativeValue(t2, 0, 1);
  t2 = (t2 -= 1) * t2 * t2 + 1;
  return t2;
}
function easeIn(t2) {
  return t2 * t2;
}
var styles$z = function styles2(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "inline-block"
    },
    /* Styles applied to the root element if `variant="static"`. */
    static: {
      transition: theme2.transitions.create("transform")
    },
    /* Styles applied to the root element if `variant="indeterminate"`. */
    indeterminate: {
      animation: "$circular-rotate 1.4s linear infinite"
    },
    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      color: theme2.palette.primary.main
    },
    /* Styles applied to the root element if `color="secondary"`. */
    colorSecondary: {
      color: theme2.palette.secondary.main
    },
    /* Styles applied to the `svg` element. */
    svg: {
      display: "block"
      // Keeps the progress centered
    },
    /* Styles applied to the `circle` svg path. */
    circle: {
      stroke: "currentColor"
      // Use butt to follow the specification, by chance, it's already the default CSS value.
      // strokeLinecap: 'butt',
    },
    /* Styles applied to the `circle` svg path if `variant="static"`. */
    circleStatic: {
      transition: theme2.transitions.create("stroke-dashoffset")
    },
    /* Styles applied to the `circle` svg path if `variant="indeterminate"`. */
    circleIndeterminate: {
      animation: "$circular-dash 1.4s ease-in-out infinite",
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: "0px"
      // Add the unit to fix a Edge 16 and below bug.
    },
    "@keyframes circular-rotate": {
      "100%": {
        transform: "rotate(360deg)"
      }
    },
    "@keyframes circular-dash": {
      "0%": {
        strokeDasharray: "1px, 200px",
        strokeDashoffset: "0px"
      },
      "50%": {
        strokeDasharray: "100px, 200px",
        strokeDashoffset: "-15px"
      },
      "100%": {
        strokeDasharray: "100px, 200px",
        strokeDashoffset: "-125px"
      }
    },
    /* Styles applied to the `circle` svg path if `disableShrink={true}`. */
    circleDisableShrink: {
      animation: "none"
    }
  };
};
var CircularProgress = React.forwardRef(function CircularProgress2(props, ref2) {
  var classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "primary" : _props$color, _props$disableShrink = props.disableShrink, disableShrink = _props$disableShrink === void 0 ? false : _props$disableShrink, _props$size = props.size, size = _props$size === void 0 ? 40 : _props$size, style2 = props.style, _props$thickness = props.thickness, thickness = _props$thickness === void 0 ? 3.6 : _props$thickness, _props$value = props.value, value = _props$value === void 0 ? 0 : _props$value, _props$variant = props.variant, variant = _props$variant === void 0 ? "indeterminate" : _props$variant, other = _objectWithoutProperties(props, ["classes", "className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"]);
  var circleStyle = {};
  var rootStyle = {};
  var rootProps = {};
  if (variant === "determinate" || variant === "static") {
    var circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    if (variant === "static") {
      circleStyle.strokeDashoffset = "".concat(((100 - value) / 100 * circumference).toFixed(3), "px");
      rootStyle.transform = "rotate(-90deg)";
    } else {
      circleStyle.strokeDashoffset = "".concat((easeIn((100 - value) / 100) * circumference).toFixed(3), "px");
      rootStyle.transform = "rotate(".concat((easeOut(value / 70) * 270).toFixed(3), "deg)");
    }
  }
  return React.createElement("div", _extends$1({
    className: clsx(classes.root, className, color !== "inherit" && classes["color".concat(capitalize(color))], {
      indeterminate: classes.indeterminate,
      static: classes.static
    }[variant]),
    style: _extends$1({
      width: size,
      height: size
    }, rootStyle, {}, style2),
    ref: ref2,
    role: "progressbar"
  }, rootProps, other), React.createElement("svg", {
    className: classes.svg,
    viewBox: "".concat(SIZE / 2, " ").concat(SIZE / 2, " ").concat(SIZE, " ").concat(SIZE)
  }, React.createElement("circle", {
    className: clsx(classes.circle, disableShrink && classes.circleDisableShrink, {
      indeterminate: classes.circleIndeterminate,
      static: classes.circleStatic
    }[variant]),
    style: circleStyle,
    cx: SIZE,
    cy: SIZE,
    r: (SIZE - thickness) / 2,
    fill: "none",
    strokeWidth: thickness
  })));
});
const CircularProgress$1 = withStyles(styles$z, {
  name: "MuiCircularProgress",
  flip: false
})(CircularProgress);
function ViewLoading(props) {
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      style: {
        display: "flex",
        width: "100%",
        height: props.height || "100%",
        alignItems: "center",
        flexShrink: 0,
        justifyContent: "center",
        ...props.style
      }
    },
    /* @__PURE__ */ React.createElement(CircularProgress$1, null)
  );
}
const ViewLoading$1 = React.memo(ViewLoading);
var lib$3 = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest$1(s, e) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
}
function __decorate(decorators, target, key2, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key2, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
  return c > 3 && r && Object.defineProperty(target, key2, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _23 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_23) try {
      if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
      if (y = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _23.label++;
          return { value: op[1], done: false };
        case 5:
          _23.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _23.ops.pop();
          _23.trys.pop();
          continue;
        default:
          if (!(t2 = _23.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _23 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _23.label = op[1];
            break;
          }
          if (op[0] === 6 && _23.label < t2[1]) {
            _23.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _23.label < t2[2]) {
            _23.label = t2[2];
            _23.ops.push(op);
            break;
          }
          if (t2[2]) _23.ops.pop();
          _23.trys.pop();
          continue;
      }
      op = body.call(thisArg, _23);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports2) {
  for (var p in m) if (p !== "default" && !exports2.hasOwnProperty(p)) exports2[p] = m[p];
}
function __values$1(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i2 >= o.length) o = void 0;
      return { value: o && o[i2++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done) ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"])) m.call(i2);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s += arguments[i2].length;
  for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
    for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n) {
    if (g[n]) i2[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle2(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i2, p;
  return i2 = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n, f) {
    i2[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values$1 === "function" ? __values$1(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n) {
    i2[n] = o[n] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n](v), settle2(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle2(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest: __rest$1,
  __spread,
  __spreadArrays,
  __values: __values$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var es6Promise$1 = { exports: {} };
var es6Promise = es6Promise$1.exports;
var hasRequiredEs6Promise;
function requireEs6Promise() {
  if (hasRequiredEs6Promise) return es6Promise$1.exports;
  hasRequiredEs6Promise = 1;
  (function(module, exports2) {
    (function(global2, factory) {
      module.exports = factory();
    })(es6Promise, function() {
      function objectOrFunction(x) {
        var type2 = typeof x;
        return x !== null && (type2 === "object" || type2 === "function");
      }
      function isFunction2(x) {
        return typeof x === "function";
      }
      var _isArray = void 0;
      if (Array.isArray) {
        _isArray = Array.isArray;
      } else {
        _isArray = function(x) {
          return Object.prototype.toString.call(x) === "[object Array]";
        };
      }
      var isArray2 = _isArray;
      var len2 = 0;
      var vertxNext = void 0;
      var customSchedulerFn = void 0;
      var asap = function asap2(callback, arg) {
        queue2[len2] = callback;
        queue2[len2 + 1] = arg;
        len2 += 2;
        if (len2 === 2) {
          if (customSchedulerFn) {
            customSchedulerFn(flush);
          } else {
            scheduleFlush();
          }
        }
      };
      function setScheduler(scheduleFn) {
        customSchedulerFn = scheduleFn;
      }
      function setAsap(asapFn) {
        asap = asapFn;
      }
      var browserWindow = typeof window !== "undefined" ? window : void 0;
      var browserGlobal = browserWindow || {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var isNode = typeof self === "undefined" && typeof process$1 !== "undefined" && {}.toString.call(process$1) === "[object process]";
      var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
      function useNextTick() {
        return function() {
          return process$1.nextTick(flush);
        };
      }
      function useVertxTimer() {
        if (typeof vertxNext !== "undefined") {
          return function() {
            vertxNext(flush);
          };
        }
        return useSetTimeout();
      }
      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node2 = document.createTextNode("");
        observer.observe(node2, { characterData: true });
        return function() {
          node2.data = iterations = ++iterations % 2;
        };
      }
      function useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = flush;
        return function() {
          return channel.port2.postMessage(0);
        };
      }
      function useSetTimeout() {
        var globalSetTimeout = setTimeout;
        return function() {
          return globalSetTimeout(flush, 1);
        };
      }
      var queue2 = new Array(1e3);
      function flush() {
        for (var i2 = 0; i2 < len2; i2 += 2) {
          var callback = queue2[i2];
          var arg = queue2[i2 + 1];
          callback(arg);
          queue2[i2] = void 0;
          queue2[i2 + 1] = void 0;
        }
        len2 = 0;
      }
      function attemptVertx() {
        try {
          var vertx = Function("return this")().require("vertx");
          vertxNext = vertx.runOnLoop || vertx.runOnContext;
          return useVertxTimer();
        } catch (e) {
          return useSetTimeout();
        }
      }
      var scheduleFlush = void 0;
      if (isNode) {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else if (isWorker) {
        scheduleFlush = useMessageChannel();
      } else if (browserWindow === void 0 && typeof commonjsRequire === "function") {
        scheduleFlush = attemptVertx();
      } else {
        scheduleFlush = useSetTimeout();
      }
      function then(onFulfillment, onRejection) {
        var parent2 = this;
        var child = new this.constructor(noop2);
        if (child[PROMISE_ID] === void 0) {
          makePromise(child);
        }
        var _state = parent2._state;
        if (_state) {
          var callback = arguments[_state - 1];
          asap(function() {
            return invokeCallback(_state, child, callback, parent2._result);
          });
        } else {
          subscribe(parent2, child, onFulfillment, onRejection);
        }
        return child;
      }
      function resolve$12(object) {
        var Constructor = this;
        if (object && typeof object === "object" && object.constructor === Constructor) {
          return object;
        }
        var promise2 = new Constructor(noop2);
        resolve2(promise2, object);
        return promise2;
      }
      var PROMISE_ID = Math.random().toString(36).substring(2);
      function noop2() {
      }
      var PENDING = void 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      function selfFulfillment() {
        return new TypeError("You cannot resolve a promise with itself");
      }
      function cannotReturnOwn() {
        return new TypeError("A promises callback cannot return that same promise.");
      }
      function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
        try {
          then$$1.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
          return e;
        }
      }
      function handleForeignThenable(promise2, thenable, then$$1) {
        asap(function(promise3) {
          var sealed = false;
          var error3 = tryThen(then$$1, thenable, function(value) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value) {
              resolve2(promise3, value);
            } else {
              fulfill(promise3, value);
            }
          }, function(reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            reject(promise3, reason);
          }, "Settle: " + (promise3._label || " unknown promise"));
          if (!sealed && error3) {
            sealed = true;
            reject(promise3, error3);
          }
        }, promise2);
      }
      function handleOwnThenable(promise2, thenable) {
        if (thenable._state === FULFILLED) {
          fulfill(promise2, thenable._result);
        } else if (thenable._state === REJECTED) {
          reject(promise2, thenable._result);
        } else {
          subscribe(thenable, void 0, function(value) {
            return resolve2(promise2, value);
          }, function(reason) {
            return reject(promise2, reason);
          });
        }
      }
      function handleMaybeThenable(promise2, maybeThenable, then$$1) {
        if (maybeThenable.constructor === promise2.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$12) {
          handleOwnThenable(promise2, maybeThenable);
        } else {
          if (then$$1 === void 0) {
            fulfill(promise2, maybeThenable);
          } else if (isFunction2(then$$1)) {
            handleForeignThenable(promise2, maybeThenable, then$$1);
          } else {
            fulfill(promise2, maybeThenable);
          }
        }
      }
      function resolve2(promise2, value) {
        if (promise2 === value) {
          reject(promise2, selfFulfillment());
        } else if (objectOrFunction(value)) {
          var then$$1 = void 0;
          try {
            then$$1 = value.then;
          } catch (error3) {
            reject(promise2, error3);
            return;
          }
          handleMaybeThenable(promise2, value, then$$1);
        } else {
          fulfill(promise2, value);
        }
      }
      function publishRejection(promise2) {
        if (promise2._onerror) {
          promise2._onerror(promise2._result);
        }
        publish(promise2);
      }
      function fulfill(promise2, value) {
        if (promise2._state !== PENDING) {
          return;
        }
        promise2._result = value;
        promise2._state = FULFILLED;
        if (promise2._subscribers.length !== 0) {
          asap(publish, promise2);
        }
      }
      function reject(promise2, reason) {
        if (promise2._state !== PENDING) {
          return;
        }
        promise2._state = REJECTED;
        promise2._result = reason;
        asap(publishRejection, promise2);
      }
      function subscribe(parent2, child, onFulfillment, onRejection) {
        var _subscribers = parent2._subscribers;
        var length = _subscribers.length;
        parent2._onerror = null;
        _subscribers[length] = child;
        _subscribers[length + FULFILLED] = onFulfillment;
        _subscribers[length + REJECTED] = onRejection;
        if (length === 0 && parent2._state) {
          asap(publish, parent2);
        }
      }
      function publish(promise2) {
        var subscribers = promise2._subscribers;
        var settled = promise2._state;
        if (subscribers.length === 0) {
          return;
        }
        var child = void 0, callback = void 0, detail = promise2._result;
        for (var i2 = 0; i2 < subscribers.length; i2 += 3) {
          child = subscribers[i2];
          callback = subscribers[i2 + settled];
          if (child) {
            invokeCallback(settled, child, callback, detail);
          } else {
            callback(detail);
          }
        }
        promise2._subscribers.length = 0;
      }
      function invokeCallback(settled, promise2, callback, detail) {
        var hasCallback = isFunction2(callback), value = void 0, error3 = void 0, succeeded = true;
        if (hasCallback) {
          try {
            value = callback(detail);
          } catch (e) {
            succeeded = false;
            error3 = e;
          }
          if (promise2 === value) {
            reject(promise2, cannotReturnOwn());
            return;
          }
        } else {
          value = detail;
        }
        if (promise2._state !== PENDING) ;
        else if (hasCallback && succeeded) {
          resolve2(promise2, value);
        } else if (succeeded === false) {
          reject(promise2, error3);
        } else if (settled === FULFILLED) {
          fulfill(promise2, value);
        } else if (settled === REJECTED) {
          reject(promise2, value);
        }
      }
      function initializePromise(promise2, resolver) {
        try {
          resolver(function resolvePromise(value) {
            resolve2(promise2, value);
          }, function rejectPromise(reason) {
            reject(promise2, reason);
          });
        } catch (e) {
          reject(promise2, e);
        }
      }
      var id = 0;
      function nextId() {
        return id++;
      }
      function makePromise(promise2) {
        promise2[PROMISE_ID] = id++;
        promise2._state = void 0;
        promise2._result = void 0;
        promise2._subscribers = [];
      }
      function validationError() {
        return new Error("Array Methods must be provided an Array");
      }
      var Enumerator = function() {
        function Enumerator2(Constructor, input) {
          this._instanceConstructor = Constructor;
          this.promise = new Constructor(noop2);
          if (!this.promise[PROMISE_ID]) {
            makePromise(this.promise);
          }
          if (isArray2(input)) {
            this.length = input.length;
            this._remaining = input.length;
            this._result = new Array(this.length);
            if (this.length === 0) {
              fulfill(this.promise, this._result);
            } else {
              this.length = this.length || 0;
              this._enumerate(input);
              if (this._remaining === 0) {
                fulfill(this.promise, this._result);
              }
            }
          } else {
            reject(this.promise, validationError());
          }
        }
        Enumerator2.prototype._enumerate = function _enumerate(input) {
          for (var i2 = 0; this._state === PENDING && i2 < input.length; i2++) {
            this._eachEntry(input[i2], i2);
          }
        };
        Enumerator2.prototype._eachEntry = function _eachEntry(entry, i2) {
          var c = this._instanceConstructor;
          var resolve$$1 = c.resolve;
          if (resolve$$1 === resolve$12) {
            var _then = void 0;
            var error3 = void 0;
            var didError = false;
            try {
              _then = entry.then;
            } catch (e) {
              didError = true;
              error3 = e;
            }
            if (_then === then && entry._state !== PENDING) {
              this._settledAt(entry._state, i2, entry._result);
            } else if (typeof _then !== "function") {
              this._remaining--;
              this._result[i2] = entry;
            } else if (c === Promise$1) {
              var promise2 = new c(noop2);
              if (didError) {
                reject(promise2, error3);
              } else {
                handleMaybeThenable(promise2, entry, _then);
              }
              this._willSettleAt(promise2, i2);
            } else {
              this._willSettleAt(new c(function(resolve$$12) {
                return resolve$$12(entry);
              }), i2);
            }
          } else {
            this._willSettleAt(resolve$$1(entry), i2);
          }
        };
        Enumerator2.prototype._settledAt = function _settledAt(state2, i2, value) {
          var promise2 = this.promise;
          if (promise2._state === PENDING) {
            this._remaining--;
            if (state2 === REJECTED) {
              reject(promise2, value);
            } else {
              this._result[i2] = value;
            }
          }
          if (this._remaining === 0) {
            fulfill(promise2, this._result);
          }
        };
        Enumerator2.prototype._willSettleAt = function _willSettleAt(promise2, i2) {
          var enumerator = this;
          subscribe(promise2, void 0, function(value) {
            return enumerator._settledAt(FULFILLED, i2, value);
          }, function(reason) {
            return enumerator._settledAt(REJECTED, i2, reason);
          });
        };
        return Enumerator2;
      }();
      function all(entries) {
        return new Enumerator(this, entries).promise;
      }
      function race(entries) {
        var Constructor = this;
        if (!isArray2(entries)) {
          return new Constructor(function(_23, reject2) {
            return reject2(new TypeError("You must pass an array to race."));
          });
        } else {
          return new Constructor(function(resolve3, reject2) {
            var length = entries.length;
            for (var i2 = 0; i2 < length; i2++) {
              Constructor.resolve(entries[i2]).then(resolve3, reject2);
            }
          });
        }
      }
      function reject$1(reason) {
        var Constructor = this;
        var promise2 = new Constructor(noop2);
        reject(promise2, reason);
        return promise2;
      }
      function needsResolver() {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
      }
      function needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      var Promise$1 = function() {
        function Promise2(resolver) {
          this[PROMISE_ID] = nextId();
          this._result = this._state = void 0;
          this._subscribers = [];
          if (noop2 !== resolver) {
            typeof resolver !== "function" && needsResolver();
            this instanceof Promise2 ? initializePromise(this, resolver) : needsNew();
          }
        }
        Promise2.prototype.catch = function _catch(onRejection) {
          return this.then(null, onRejection);
        };
        Promise2.prototype.finally = function _finally(callback) {
          var promise2 = this;
          var constructor = promise2.constructor;
          if (isFunction2(callback)) {
            return promise2.then(function(value) {
              return constructor.resolve(callback()).then(function() {
                return value;
              });
            }, function(reason) {
              return constructor.resolve(callback()).then(function() {
                throw reason;
              });
            });
          }
          return promise2.then(callback, callback);
        };
        return Promise2;
      }();
      Promise$1.prototype.then = then;
      Promise$1.all = all;
      Promise$1.race = race;
      Promise$1.resolve = resolve$12;
      Promise$1.reject = reject$1;
      Promise$1._setScheduler = setScheduler;
      Promise$1._setAsap = setAsap;
      Promise$1._asap = asap;
      function polyfill2() {
        var local = void 0;
        if (typeof commonjsGlobal !== "undefined") {
          local = commonjsGlobal;
        } else if (typeof self !== "undefined") {
          local = self;
        } else {
          try {
            local = Function("return this")();
          } catch (e) {
            throw new Error("polyfill failed because global object is unavailable in this environment");
          }
        }
        var P2 = local.Promise;
        if (P2) {
          var promiseToString = null;
          try {
            promiseToString = Object.prototype.toString.call(P2.resolve());
          } catch (e) {
          }
          if (promiseToString === "[object Promise]" && !P2.cast) {
            return;
          }
        }
        local.Promise = Promise$1;
      }
      Promise$1.polyfill = polyfill2;
      Promise$1.Promise = Promise$1;
      return Promise$1;
    });
  })(es6Promise$1);
  return es6Promise$1.exports;
}
const version$3 = "9.1.0";
const require$$2$2 = {
  version: version$3
};
var horizon_api = {};
var hasRequiredHorizon_api;
function requireHorizon_api() {
  if (hasRequiredHorizon_api) return horizon_api;
  hasRequiredHorizon_api = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Horizon = void 0;
    (function(Horizon) {
      (function(LiquidityPoolType) {
        LiquidityPoolType["constantProduct"] = "constant_product";
      })(Horizon.LiquidityPoolType || (Horizon.LiquidityPoolType = {}));
      (function(OperationResponseType) {
        OperationResponseType["createAccount"] = "create_account";
        OperationResponseType["payment"] = "payment";
        OperationResponseType["pathPayment"] = "path_payment_strict_receive";
        OperationResponseType["createPassiveOffer"] = "create_passive_sell_offer";
        OperationResponseType["manageOffer"] = "manage_sell_offer";
        OperationResponseType["setOptions"] = "set_options";
        OperationResponseType["changeTrust"] = "change_trust";
        OperationResponseType["allowTrust"] = "allow_trust";
        OperationResponseType["accountMerge"] = "account_merge";
        OperationResponseType["inflation"] = "inflation";
        OperationResponseType["manageData"] = "manage_data";
        OperationResponseType["bumpSequence"] = "bump_sequence";
        OperationResponseType["manageBuyOffer"] = "manage_buy_offer";
        OperationResponseType["pathPaymentStrictSend"] = "path_payment_strict_send";
        OperationResponseType["createClaimableBalance"] = "create_claimable_balance";
        OperationResponseType["claimClaimableBalance"] = "claim_claimable_balance";
        OperationResponseType["beginSponsoringFutureReserves"] = "begin_sponsoring_future_reserves";
        OperationResponseType["endSponsoringFutureReserves"] = "end_sponsoring_future_reserves";
        OperationResponseType["revokeSponsorship"] = "revoke_sponsorship";
        OperationResponseType["clawback"] = "clawback";
        OperationResponseType["clawbackClaimableBalance"] = "clawback_claimable_balance";
        OperationResponseType["setTrustLineFlags"] = "set_trust_line_flags";
        OperationResponseType["liquidityPoolDeposit"] = "liquidity_pool_deposit";
        OperationResponseType["liquidityPoolWithdraw"] = "liquidity_pool_withdraw";
      })(Horizon.OperationResponseType || (Horizon.OperationResponseType = {}));
      (function(OperationResponseTypeI) {
        OperationResponseTypeI[OperationResponseTypeI["createAccount"] = 0] = "createAccount";
        OperationResponseTypeI[OperationResponseTypeI["payment"] = 1] = "payment";
        OperationResponseTypeI[OperationResponseTypeI["pathPayment"] = 2] = "pathPayment";
        OperationResponseTypeI[OperationResponseTypeI["createPassiveOffer"] = 3] = "createPassiveOffer";
        OperationResponseTypeI[OperationResponseTypeI["manageOffer"] = 4] = "manageOffer";
        OperationResponseTypeI[OperationResponseTypeI["setOptions"] = 5] = "setOptions";
        OperationResponseTypeI[OperationResponseTypeI["changeTrust"] = 6] = "changeTrust";
        OperationResponseTypeI[OperationResponseTypeI["allowTrust"] = 7] = "allowTrust";
        OperationResponseTypeI[OperationResponseTypeI["accountMerge"] = 8] = "accountMerge";
        OperationResponseTypeI[OperationResponseTypeI["inflation"] = 9] = "inflation";
        OperationResponseTypeI[OperationResponseTypeI["manageData"] = 10] = "manageData";
        OperationResponseTypeI[OperationResponseTypeI["bumpSequence"] = 11] = "bumpSequence";
        OperationResponseTypeI[OperationResponseTypeI["manageBuyOffer"] = 12] = "manageBuyOffer";
        OperationResponseTypeI[OperationResponseTypeI["pathPaymentStrictSend"] = 13] = "pathPaymentStrictSend";
        OperationResponseTypeI[OperationResponseTypeI["createClaimableBalance"] = 14] = "createClaimableBalance";
        OperationResponseTypeI[OperationResponseTypeI["claimClaimableBalance"] = 15] = "claimClaimableBalance";
        OperationResponseTypeI[OperationResponseTypeI["beginSponsoringFutureReserves"] = 16] = "beginSponsoringFutureReserves";
        OperationResponseTypeI[OperationResponseTypeI["endSponsoringFutureReserves"] = 17] = "endSponsoringFutureReserves";
        OperationResponseTypeI[OperationResponseTypeI["revokeSponsorship"] = 18] = "revokeSponsorship";
        OperationResponseTypeI[OperationResponseTypeI["clawback"] = 19] = "clawback";
        OperationResponseTypeI[OperationResponseTypeI["clawbackClaimableBalance"] = 20] = "clawbackClaimableBalance";
        OperationResponseTypeI[OperationResponseTypeI["setTrustLineFlags"] = 21] = "setTrustLineFlags";
        OperationResponseTypeI[OperationResponseTypeI["liquidityPoolDeposit"] = 22] = "liquidityPoolDeposit";
        OperationResponseTypeI[OperationResponseTypeI["liquidityPoolWithdraw"] = 23] = "liquidityPoolWithdraw";
      })(Horizon.OperationResponseTypeI || (Horizon.OperationResponseTypeI = {}));
      (function(TransactionFailedResultCodes) {
        TransactionFailedResultCodes["TX_FAILED"] = "tx_failed";
        TransactionFailedResultCodes["TX_BAD_SEQ"] = "tx_bad_seq";
        TransactionFailedResultCodes["TX_BAD_AUTH"] = "tx_bad_auth";
        TransactionFailedResultCodes["TX_BAD_AUTH_EXTRA"] = "tx_bad_auth_extra";
        TransactionFailedResultCodes["TX_FEE_BUMP_INNER_SUCCESS"] = "tx_fee_bump_inner_success";
        TransactionFailedResultCodes["TX_FEE_BUMP_INNER_FAILED"] = "tx_fee_bump_inner_failed";
        TransactionFailedResultCodes["TX_NOT_SUPPORTED"] = "tx_not_supported";
        TransactionFailedResultCodes["TX_SUCCESS"] = "tx_success";
        TransactionFailedResultCodes["TX_TOO_EARLY"] = "tx_too_early";
        TransactionFailedResultCodes["TX_TOO_LATE"] = "tx_too_late";
        TransactionFailedResultCodes["TX_MISSING_OPERATION"] = "tx_missing_operation";
        TransactionFailedResultCodes["TX_INSUFFICIENT_BALANCE"] = "tx_insufficient_balance";
        TransactionFailedResultCodes["TX_NO_SOURCE_ACCOUNT"] = "tx_no_source_account";
        TransactionFailedResultCodes["TX_INSUFFICIENT_FEE"] = "tx_insufficient_fee";
        TransactionFailedResultCodes["TX_INTERNAL_ERROR"] = "tx_internal_error";
      })(Horizon.TransactionFailedResultCodes || (Horizon.TransactionFailedResultCodes = {}));
    })(exports2.Horizon || (exports2.Horizon = {}));
  })(horizon_api);
  return horizon_api;
}
var server_api = {};
var hasRequiredServer_api;
function requireServer_api() {
  if (hasRequiredServer_api) return server_api;
  hasRequiredServer_api = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerApi = void 0;
    (function(ServerApi) {
      (function(TradeType) {
        TradeType["all"] = "all";
        TradeType["liquidityPools"] = "liquidity_pools";
        TradeType["orderbook"] = "orderbook";
      })(ServerApi.TradeType || (ServerApi.TradeType = {}));
    })(exports2.ServerApi || (exports2.ServerApi = {}));
  })(server_api);
  return server_api;
}
var account_response = {};
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor) return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key2 = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key2], key2, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor) return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity_1;
  hasRequiredIdentity = 1;
  function identity(value) {
    return value;
  }
  identity_1 = identity;
  return identity_1;
}
var _castFunction;
var hasRequired_castFunction;
function require_castFunction() {
  if (hasRequired_castFunction) return _castFunction;
  hasRequired_castFunction = 1;
  var identity = requireIdentity();
  function castFunction(value) {
    return typeof value == "function" ? value : identity;
  }
  _castFunction = castFunction;
  return _castFunction;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes) return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  _root = root;
  return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var root = require_root();
  var Symbol2 = root.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments) return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1) return isArguments_1;
  hasRequiredIsArguments$1 = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments2 = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments2;
  return isArguments_1;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var isArray2 = Array.isArray;
  isArray_1 = isArray2;
  return isArray_1;
}
var isBuffer = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse) return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}
isBuffer.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer) return isBuffer.exports;
  hasRequiredIsBuffer = 1;
  (function(module, exports2) {
    var root = require_root(), stubFalse = requireStubFalse();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer2;
  })(isBuffer, isBuffer.exports);
  return isBuffer.exports;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type2 = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  _isIndex = isIndex;
  return _isIndex;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1 = isLength;
  return isLength_1;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary) return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil) return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module, exports2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray$1;
function requireIsTypedArray$1() {
  if (hasRequiredIsTypedArray$1) return isTypedArray_1;
  hasRequiredIsTypedArray$1 = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray2;
  return isTypedArray_1;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments2 = requireIsArguments$1(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray2 = requireIsTypedArray$1();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key2 in value) {
      if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length)))) {
        result.push(key2);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  isObject_1 = isObject2;
  return isObject_1;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype) return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  _isPrototype = isPrototype;
  return _isPrototype;
}
var _nativeKeysIn;
var hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn) return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key2 in Object(object)) {
        result.push(key2);
      }
    }
    return result;
  }
  _nativeKeysIn = nativeKeysIn;
  return _nativeKeysIn;
}
var _baseKeysIn;
var hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn) return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var isObject2 = requireIsObject(), isPrototype = require_isPrototype(), nativeKeysIn = require_nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key2 in object) {
      if (!(key2 == "constructor" && (isProto || !hasOwnProperty.call(object, key2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  _baseKeysIn = baseKeysIn;
  return _baseKeysIn;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject2 = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction2;
  return isFunction_1;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction2 = requireIsFunction(), isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}
var keysIn_1;
var hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn) return keysIn_1;
  hasRequiredKeysIn = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeysIn = require_baseKeysIn(), isArrayLike = requireIsArrayLike();
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  keysIn_1 = keysIn;
  return keysIn_1;
}
var forIn_1;
var hasRequiredForIn;
function requireForIn() {
  if (hasRequiredForIn) return forIn_1;
  hasRequiredForIn = 1;
  var baseFor = require_baseFor(), castFunction = require_castFunction(), keysIn = requireKeysIn();
  function forIn(object, iteratee) {
    return object == null ? object : baseFor(object, castFunction(iteratee), keysIn);
  }
  forIn_1 = forIn;
  return forIn_1;
}
var lib$2 = { exports: {} };
var hashing = {};
var sha_js = { exports: {} };
var inherits_browser$4 = { exports: {} };
var hasRequiredInherits_browser$4;
function requireInherits_browser$4() {
  if (hasRequiredInherits_browser$4) return inherits_browser$4.exports;
  hasRequiredInherits_browser$4 = 1;
  if (typeof Object.create === "function") {
    inherits_browser$4.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits_browser$4.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  return inherits_browser$4.exports;
}
var safeBuffer$3 = { exports: {} };
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports2) {
    Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    var buffer2 = {};
    var base64Js2 = {};
    base64Js2.byteLength = byteLength2;
    base64Js2.toByteArray = toByteArray2;
    base64Js2.fromByteArray = fromByteArray2;
    var lookup9 = [];
    var revLookup2 = [];
    var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len2 = code2.length; i2 < len2; ++i2) {
      lookup9[i2] = code2[i2];
      revLookup2[code2.charCodeAt(i2)] = i2;
    }
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
    function getLens2(b64) {
      var len3 = b64.length;
      if (len3 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len3;
      var placeHoldersLen = validLen === len3 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength2(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr2 = new Arr2(_byteLength2(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len3 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len3; i3 += 4) {
        tmp = revLookup2[b64.charCodeAt(i3)] << 18 | revLookup2[b64.charCodeAt(i3 + 1)] << 12 | revLookup2[b64.charCodeAt(i3 + 2)] << 6 | revLookup2[b64.charCodeAt(i3 + 3)];
        arr2[curByte++] = tmp >> 16 & 255;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup2[b64.charCodeAt(i3)] << 2 | revLookup2[b64.charCodeAt(i3 + 1)] >> 4;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup2[b64.charCodeAt(i3)] << 10 | revLookup2[b64.charCodeAt(i3 + 1)] << 4 | revLookup2[b64.charCodeAt(i3 + 2)] >> 2;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      return arr2;
    }
    function tripletToBase642(num) {
      return lookup9[num >> 18 & 63] + lookup9[num >> 12 & 63] + lookup9[num >> 6 & 63] + lookup9[num & 63];
    }
    function encodeChunk2(uint8, start, end) {
      var tmp;
      var output2 = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output2.push(tripletToBase642(tmp));
      }
      return output2.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len3 = uint8.length;
      var extraBytes = len3 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len3 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk2(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len3 - 1];
        parts.push(
          lookup9[tmp >> 2] + lookup9[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len3 - 2] << 8) + uint8[len3 - 1];
        parts.push(
          lookup9[tmp >> 10] + lookup9[tmp >> 4 & 63] + lookup9[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    var ieee7542 = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    ieee7542.read = function(buffer3, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i3 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer3[offset + i3];
      i3 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer3[offset + i3], i3 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer3[offset + i3], i3 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    ieee7542.write = function(buffer3, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i3 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer3[offset + i3] = m & 255, i3 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer3[offset + i3] = e & 255, i3 += d, e /= 256, eLen -= 8) {
      }
      buffer3[offset + i3 - d] |= s * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(exports3) {
      const base64 = base64Js2;
      const ieee754$1 = ieee7542;
      const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports3.Buffer = Buffer3;
      exports3.SlowBuffer = SlowBuffer;
      exports3.INSPECT_MAX_BYTES = 50;
      const K_MAX_LENGTH = 2147483647;
      exports3.kMaxLength = K_MAX_LENGTH;
      const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr2 = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr2, proto);
          return arr2.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer3.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer3.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer2(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function Buffer3(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer3.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer3.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer3, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer2(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer2(size).fill(fill, encoding) : createBuffer2(size).fill(fill);
        }
        return createBuffer2(size);
      }
      Buffer3.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer2(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer3.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer3.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string2, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength3(string2, encoding) | 0;
        let buf = createBuffer2(length);
        const actual = buf.write(string2, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array2) {
        const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
        const buf = createBuffer2(length);
        for (let i3 = 0; i3 < length; i3 += 1) {
          buf[i3] = array2[i3] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy2 = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array2, byteOffset, length) {
        if (byteOffset < 0 || array2.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array2.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array2);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array2, byteOffset);
        } else {
          buf = new GlobalUint8Array(array2, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer3.isBuffer(obj)) {
          const len3 = checked(obj.length) | 0;
          const buf = createBuffer2(len3);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len3);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer2(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer3.alloc(+length);
      }
      Buffer3.isBuffer = function isBuffer2(b) {
        return b != null && b._isBuffer === true && b !== Buffer3.prototype;
      };
      Buffer3.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
        if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i3 = 0, len3 = Math.min(x, y); i3 < len3; ++i3) {
          if (a[i3] !== b[i3]) {
            x = a[i3];
            y = b[i3];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        let i3;
        if (length === void 0) {
          length = 0;
          for (i3 = 0; i3 < list.length; ++i3) {
            length += list[i3].length;
          }
        }
        const buffer3 = Buffer3.allocUnsafe(length);
        let pos = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          let buf = list[i3];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer3.length) {
              if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
              buf.copy(buffer3, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer3,
                buf,
                pos
              );
            }
          } else if (!Buffer3.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer3, pos);
          }
          pos += buf.length;
        }
        return buffer3;
      };
      function byteLength3(string2, encoding) {
        if (Buffer3.isBuffer(string2)) {
          return string2.length;
        }
        if (GlobalArrayBuffer.isView(string2) || isInstance(string2, GlobalArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
          );
        }
        const len3 = string2.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len3 === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len3;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len3 * 2;
            case "hex":
              return len3 >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string2).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.byteLength = byteLength3;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i3 = b[n];
        b[n] = b[m];
        b[m] = i3;
      }
      Buffer3.prototype.swap16 = function swap16() {
        const len3 = this.length;
        if (len3 % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i3 = 0; i3 < len3; i3 += 2) {
          swap(this, i3, i3 + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap32() {
        const len3 = this.length;
        if (len3 % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i3 = 0; i3 < len3; i3 += 4) {
          swap(this, i3, i3 + 3);
          swap(this, i3 + 1, i3 + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap64() {
        const len3 = this.length;
        if (len3 % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i3 = 0; i3 < len3; i3 += 8) {
          swap(this, i3, i3 + 7);
          swap(this, i3 + 1, i3 + 6);
          swap(this, i3 + 2, i3 + 5);
          swap(this, i3 + 3, i3 + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString2() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
      Buffer3.prototype.equals = function equals(b) {
        if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer3.compare(this, b) === 0;
      };
      Buffer3.prototype.inspect = function inspect() {
        let str = "";
        const max2 = exports3.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max2) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
      }
      Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer3.from(target, target.offset, target.byteLength);
        }
        if (!Buffer3.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len3 = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i3 = 0; i3 < len3; ++i3) {
          if (thisCopy[i3] !== targetCopy[i3]) {
            x = thisCopy[i3];
            y = targetCopy[i3];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
        if (buffer3.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer3.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer3.length + byteOffset;
        if (byteOffset >= buffer3.length) {
          if (dir) return -1;
          else byteOffset = buffer3.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer3.from(val, encoding);
        }
        if (Buffer3.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr2.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr2.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i4) {
          if (indexSize === 1) {
            return buf[i4];
          } else {
            return buf.readUInt16BE(i4 * indexSize);
          }
        }
        let i3;
        if (dir) {
          let foundIndex = -1;
          for (i3 = byteOffset; i3 < arrLength; i3++) {
            if (read2(arr2, i3) === read2(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
              if (foundIndex === -1) foundIndex = i3;
              if (i3 - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i3 -= i3 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i3 = byteOffset; i3 >= 0; i3--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read2(arr2, i3 + j) !== read2(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i3;
          }
        }
        return -1;
      }
      Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string2, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string2.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i3;
        for (i3 = 0; i3 < length; ++i3) {
          const parsed = parseInt(string2.substr(i3 * 2, 2), 16);
          if (numberIsNaN(parsed)) return i3;
          buf[offset + i3] = parsed;
        }
        return i3;
      }
      function utf8Write(buf, string2, offset, length) {
        return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string2, offset, length) {
        return blitBuffer(asciiToBytes(string2), buf, offset, length);
      }
      function base64Write(buf, string2, offset, length) {
        return blitBuffer(base64ToBytes(string2), buf, offset, length);
      }
      function ucs2Write(buf, string2, offset, length) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
      }
      Buffer3.prototype.write = function write(string2, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string2, offset, length);
            case "base64":
              return base64Write(this, string2, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i3 = start;
        while (i3 < end) {
          const firstByte = buf[i3];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i3 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i3 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i3 + 1];
                thirdByte = buf[i3 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i3 + 1];
                thirdByte = buf[i3 + 2];
                fourthByte = buf[i3 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i3 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      const MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len3 = codePoints.length;
        if (len3 <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i3 = 0;
        while (i3 < len3) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i3 = start; i3 < end; ++i3) {
          ret += String.fromCharCode(buf[i3] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i3 = start; i3 < end; ++i3) {
          ret += String.fromCharCode(buf[i3]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len3 = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len3) end = len3;
        let out = "";
        for (let i3 = start; i3 < end; ++i3) {
          out += hexSliceLookupTable[buf[i3]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i3 = 0; i3 < bytes.length - 1; i3 += 2) {
          res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
        }
        return res;
      }
      Buffer3.prototype.slice = function slice2(start, end) {
        const len3 = this.length;
        start = ~~start;
        end = end === void 0 ? len3 : ~~end;
        if (start < 0) {
          start += len3;
          if (start < 0) start = 0;
        } else if (start > len3) {
          start = len3;
        }
        if (end < 0) {
          end += len3;
          if (end < 0) end = 0;
        } else if (end > len3) {
          end = len3;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer3.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let val = this[offset];
        let mul = 1;
        let i3 = 0;
        while (++i3 < byteLength4 && (mul *= 256)) {
          val += this[offset + i3] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength4, this.length);
        }
        let val = this[offset + --byteLength4];
        let mul = 1;
        while (byteLength4 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength4] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let val = this[offset];
        let mul = 1;
        let i3 = 0;
        while (++i3 < byteLength4 && (mul *= 256)) {
          val += this[offset + i3] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let i3 = byteLength4;
        let mul = 1;
        let val = this[offset + --i3];
        while (i3 > 0 && (mul *= 256)) {
          val += this[offset + --i3] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max2, min2) {
        if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt(this, value, offset, byteLength4, maxBytes, 0);
        }
        let mul = 1;
        let i3 = 0;
        this[offset] = value & 255;
        while (++i3 < byteLength4 && (mul *= 256)) {
          this[offset + i3] = value / mul & 255;
        }
        return offset + byteLength4;
      };
      Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt(this, value, offset, byteLength4, maxBytes, 0);
        }
        let i3 = byteLength4 - 1;
        let mul = 1;
        this[offset + i3] = value & 255;
        while (--i3 >= 0 && (mul *= 256)) {
          this[offset + i3] = value / mul & 255;
        }
        return offset + byteLength4;
      };
      Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt(this, value, offset, byteLength4, limit - 1, -limit);
        }
        let i3 = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i3 < byteLength4 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i3] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength4;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt(this, value, offset, byteLength4, limit - 1, -limit);
        }
        let i3 = byteLength4 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i3] = value & 255;
        while (--i3 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i3] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength4;
      };
      Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max2, min2) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len3 = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len3;
      };
      Buffer3.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code3 = val.charCodeAt(0);
            if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
              val = code3;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i3;
        if (typeof val === "number") {
          for (i3 = start; i3 < end; ++i3) {
            this[i3] = val;
          }
        } else {
          const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
          const len3 = bytes.length;
          if (len3 === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i3 = 0; i3 < end - start; ++i3) {
            this[i3 + start] = bytes[i3 % len3];
          }
        }
        return this;
      };
      const errors2 = {};
      function E(sym, getMessage, Base) {
        errors2[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range2, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range2}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i3 = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i3 >= start + 4; i3 -= 3) {
          res = `_${val.slice(i3 - 3, i3)}${res}`;
        }
        return `${val.slice(0, i3)}${res}`;
      }
      function checkBounds(buf, offset, byteLength4) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength4] === void 0) {
          boundsError(offset, buf.length - (byteLength4 + 1));
        }
      }
      function checkIntBI(value, min2, max2, buf, offset, byteLength4) {
        if (value > max2 || value < min2) {
          const n = typeof min2 === "bigint" ? "n" : "";
          let range2;
          {
            if (min2 === 0 || min2 === BigInt(0)) {
              range2 = `>= 0${n} and < 2${n} ** ${(byteLength4 + 1) * 8}${n}`;
            } else {
              range2 = `>= -(2${n} ** ${(byteLength4 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength4 + 1) * 8 - 1}${n}`;
            }
          }
          throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
        }
        checkBounds(buf, offset, byteLength4);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors2.ERR_OUT_OF_RANGE(
          "offset",
          `>= ${0} and <= ${length}`,
          value
        );
      }
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string2, units2) {
        units2 = units2 || Infinity;
        let codePoint;
        const length = string2.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i3 = 0; i3 < length; ++i3) {
          codePoint = string2.charCodeAt(i3);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i3 + 1 === length) {
                if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units2 -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units2 -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units2 -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units2 -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i3 = 0; i3 < str.length; ++i3) {
          byteArray.push(str.charCodeAt(i3) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units2) {
        let c, hi, lo;
        const byteArray = [];
        for (let i3 = 0; i3 < str.length; ++i3) {
          if ((units2 -= 2) < 0) break;
          c = str.charCodeAt(i3);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i3;
        for (i3 = 0; i3 < length; ++i3) {
          if (i3 + offset >= dst.length || i3 >= src.length) break;
          dst[i3 + offset] = src[i3];
        }
        return i3;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      const hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i3 = 0; i3 < 16; ++i3) {
          const i16 = i3 * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i3] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    })(buffer2);
    const Buffer2 = buffer2.Buffer;
    exports2.Blob = buffer2.Blob;
    exports2.BlobOptions = buffer2.BlobOptions;
    exports2.Buffer = buffer2.Buffer;
    exports2.File = buffer2.File;
    exports2.FileOptions = buffer2.FileOptions;
    exports2.INSPECT_MAX_BYTES = buffer2.INSPECT_MAX_BYTES;
    exports2.SlowBuffer = buffer2.SlowBuffer;
    exports2.TranscodeEncoding = buffer2.TranscodeEncoding;
    exports2.atob = buffer2.atob;
    exports2.btoa = buffer2.btoa;
    exports2.constants = buffer2.constants;
    exports2.default = Buffer2;
    exports2.isAscii = buffer2.isAscii;
    exports2.isUtf8 = buffer2.isUtf8;
    exports2.kMaxLength = buffer2.kMaxLength;
    exports2.kStringMaxLength = buffer2.kStringMaxLength;
    exports2.resolveObjectURL = buffer2.resolveObjectURL;
    exports2.transcode = buffer2.transcode;
  })(dist);
  return dist;
}
var hasRequiredSafeBuffer$3;
function requireSafeBuffer$3() {
  if (hasRequiredSafeBuffer$3) return safeBuffer$3.exports;
  hasRequiredSafeBuffer$3 = 1;
  (function(module, exports2) {
    var buffer2 = requireDist();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer$3, safeBuffer$3.exports);
  return safeBuffer$3.exports;
}
var hash$1;
var hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  function Hash(blockSize, finalSize) {
    this._block = Buffer2.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
  }
  Hash.prototype.update = function(data, enc) {
    if (typeof data === "string") {
      enc = enc || "utf8";
      data = Buffer2.from(data, enc);
    }
    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;
    for (var offset = 0; offset < length; ) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);
      for (var i2 = 0; i2 < remainder; i2++) {
        block[assigned + i2] = data[offset + i2];
      }
      accum += remainder;
      offset += remainder;
      if (accum % blockSize === 0) {
        this._update(block);
      }
    }
    this._len += length;
    return this;
  };
  Hash.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 128;
    this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
      this._update(this._block);
      this._block.fill(0);
    }
    var bits = this._len * 8;
    if (bits <= 4294967295) {
      this._block.writeUInt32BE(bits, this._blockSize - 4);
    } else {
      var lowBits = (bits & 4294967295) >>> 0;
      var highBits = (bits - lowBits) / 4294967296;
      this._block.writeUInt32BE(highBits, this._blockSize - 8);
      this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash2 = this._hash();
    return enc ? hash2.toString(enc) : hash2;
  };
  Hash.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  hash$1 = Hash;
  return hash$1;
}
var sha$1;
var hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var inherits = requireInherits_browser$4();
  var Hash = requireHash$1();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var K = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W = new Array(80);
  function Sha() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
  }
  inherits(Sha, Hash);
  Sha.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }
  Sha.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for (var i2 = 0; i2 < 16; ++i2) W2[i2] = M.readInt32BE(i2 * 4);
    for (; i2 < 80; ++i2) W2[i2] = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t2 = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t2;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };
  Sha.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };
  sha$1 = Sha;
  return sha$1;
}
var sha1;
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  var inherits = requireInherits_browser$4();
  var Hash = requireHash$1();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var K = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W = new Array(80);
  function Sha1() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
  }
  inherits(Sha1, Hash);
  Sha1.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl1(num) {
    return num << 1 | num >>> 31;
  }
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }
  Sha1.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for (var i2 = 0; i2 < 16; ++i2) W2[i2] = M.readInt32BE(i2 * 4);
    for (; i2 < 80; ++i2) W2[i2] = rotl1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16]);
    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t2 = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t2;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };
  Sha1.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };
  sha1 = Sha1;
  return sha1;
}
var sha256$1;
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$1;
  hasRequiredSha256 = 1;
  var inherits = requireInherits_browser$4();
  var Hash = requireHash$1();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  var W = new Array(64);
  function Sha256() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
  }
  inherits(Sha256, Hash);
  Sha256.prototype.init = function() {
    this._a = 1779033703;
    this._b = 3144134277;
    this._c = 1013904242;
    this._d = 2773480762;
    this._e = 1359893119;
    this._f = 2600822924;
    this._g = 528734635;
    this._h = 1541459225;
    return this;
  };
  function ch(x, y, z) {
    return z ^ x & (y ^ z);
  }
  function maj(x, y, z) {
    return x & y | z & (x | y);
  }
  function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }
  function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }
  function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }
  function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }
  Sha256.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;
    for (var i2 = 0; i2 < 16; ++i2) W2[i2] = M.readInt32BE(i2 * 4);
    for (; i2 < 64; ++i2) W2[i2] = gamma1(W2[i2 - 2]) + W2[i2 - 7] + gamma0(W2[i2 - 15]) + W2[i2 - 16] | 0;
    for (var j = 0; j < 64; ++j) {
      var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
      var T2 = sigma0(a) + maj(a, b, c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + T1 | 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 | 0;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
  };
  Sha256.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
  };
  sha256$1 = Sha256;
  return sha256$1;
}
var sha224$1;
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var inherits = requireInherits_browser$4();
  var Sha256 = requireSha256();
  var Hash = requireHash$1();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var W = new Array(64);
  function Sha224() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
  }
  inherits(Sha224, Sha256);
  Sha224.prototype.init = function() {
    this._a = 3238371032;
    this._b = 914150663;
    this._c = 812702999;
    this._d = 4144912697;
    this._e = 4290775857;
    this._f = 1750603025;
    this._g = 1694076839;
    this._h = 3204075428;
    return this;
  };
  Sha224.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
  };
  sha224$1 = Sha224;
  return sha224$1;
}
var sha512$1;
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var inherits = requireInherits_browser$4();
  var Hash = requireHash$1();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  var W = new Array(160);
  function Sha512() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
  }
  inherits(Sha512, Hash);
  Sha512.prototype.init = function() {
    this._ah = 1779033703;
    this._bh = 3144134277;
    this._ch = 1013904242;
    this._dh = 2773480762;
    this._eh = 1359893119;
    this._fh = 2600822924;
    this._gh = 528734635;
    this._hh = 1541459225;
    this._al = 4089235720;
    this._bl = 2227873595;
    this._cl = 4271175723;
    this._dl = 1595750129;
    this._el = 2917565137;
    this._fl = 725511199;
    this._gl = 4215389547;
    this._hl = 327033209;
    return this;
  };
  function Ch(x, y, z) {
    return z ^ x & (y ^ z);
  }
  function maj(x, y, z) {
    return x & y | z & (x | y);
  }
  function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
  }
  function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
  }
  function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
  }
  function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
  }
  function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
  }
  function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
  }
  function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
  }
  Sha512.prototype._update = function(M) {
    var W2 = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh2 = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el2 = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;
    for (var i2 = 0; i2 < 32; i2 += 2) {
      W2[i2] = M.readInt32BE(i2 * 4);
      W2[i2 + 1] = M.readInt32BE(i2 * 4 + 4);
    }
    for (; i2 < 160; i2 += 2) {
      var xh = W2[i2 - 15 * 2];
      var xl = W2[i2 - 15 * 2 + 1];
      var gamma0 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = W2[i2 - 2 * 2];
      xl = W2[i2 - 2 * 2 + 1];
      var gamma1 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh);
      var Wi7h = W2[i2 - 7 * 2];
      var Wi7l = W2[i2 - 7 * 2 + 1];
      var Wi16h = W2[i2 - 16 * 2];
      var Wi16l = W2[i2 - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      W2[i2] = Wih;
      W2[i2 + 1] = Wil;
    }
    for (var j = 0; j < 160; j += 2) {
      Wih = W2[j];
      Wil = W2[j + 1];
      var majh = maj(ah, bh, ch);
      var majl = maj(al, bl, cl);
      var sigma0h = sigma0(ah, al);
      var sigma0l = sigma0(al, ah);
      var sigma1h = sigma1(eh, el2);
      var sigma1l = sigma1(el2, eh);
      var Kih = K[j];
      var Kil = K[j + 1];
      var chh = Ch(eh, fh, gh);
      var chl = Ch(el2, fl, gl);
      var t1l = hl + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el2;
      el2 = dl + t1l | 0;
      eh = dh2 + t1h + getCarry(el2, dl) | 0;
      dh2 = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el2 | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh2 + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el2) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
  };
  Sha512.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(64);
    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
  };
  sha512$1 = Sha512;
  return sha512$1;
}
var sha384$1;
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var inherits = requireInherits_browser$4();
  var SHA512 = requireSha512();
  var Hash = requireHash$1();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var W = new Array(160);
  function Sha384() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
  }
  inherits(Sha384, SHA512);
  Sha384.prototype.init = function() {
    this._ah = 3418070365;
    this._bh = 1654270250;
    this._ch = 2438529370;
    this._dh = 355462360;
    this._eh = 1731405415;
    this._fh = 2394180231;
    this._gh = 3675008525;
    this._hh = 1203062813;
    this._al = 3238371032;
    this._bl = 914150663;
    this._cl = 812702999;
    this._dl = 4144912697;
    this._el = 4290775857;
    this._fl = 1750603025;
    this._gl = 1694076839;
    this._hl = 3204075428;
    return this;
  };
  Sha384.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(48);
    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
  };
  sha384$1 = Sha384;
  return sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var exports2 = sha_js.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports2[algorithm];
    if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
    return new Algorithm();
  };
  exports2.sha = requireSha$1();
  exports2.sha1 = requireSha1();
  exports2.sha224 = requireSha224();
  exports2.sha256 = requireSha256();
  exports2.sha384 = requireSha384();
  exports2.sha512 = requireSha512();
  return sha_js.exports;
}
var hasRequiredHashing;
function requireHashing() {
  if (hasRequiredHashing) return hashing;
  hasRequiredHashing = 1;
  Object.defineProperty(hashing, "__esModule", {
    value: true
  });
  hashing.hash = hash2;
  var _sha = requireSha_js();
  function hash2(data) {
    var hasher = new _sha.sha256();
    hasher.update(data, "utf8");
    return hasher.digest();
  }
  return hashing;
}
var buffer$1 = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr2[curByte++] = tmp >> 16 & 255;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  return arr2;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i2];
  i2 += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr2 = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr2, proto);
      return arr2.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer2(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer2(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer2(size).fill(fill, encoding) : createBuffer2(size).fill(fill);
    }
    return createBuffer2(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer2(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string2, encoding) | 0;
    let buf = createBuffer2(length);
    const actual = buf.write(string2, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array2) {
    const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf = createBuffer2(length);
    for (let i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array2[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy2 = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array2);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array2, byteOffset);
    } else {
      buf = new GlobalUint8Array(array2, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf = createBuffer2(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer2(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, GlobalUint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
      if (a[i2] !== b[i2]) {
        x = a[i2];
        y = b[i2];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (GlobalArrayBuffer.isView(string2) || isInstance(string2, GlobalArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i2 = b[n];
    b[n] = b[m];
    b[m] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len2 = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2];
        y = targetCopy[i2];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr2.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr2, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1) foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read2(arr2, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string2.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed)) return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string2, offset, length) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string2, offset, length) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length);
  }
  function base64Write(buf, string2, offset, length) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length);
  }
  function ucs2Write(buf, string2, offset, length) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string2, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length);
        case "base64":
          return base64Write(this, string2, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len2 = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len2) end = len2;
    let out = "";
    for (let i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end) {
    const len2 = this.length;
    start = ~~start;
    end = end === void 0 ? len2 : ~~end;
    if (start < 0) {
      start += len2;
      if (start < 0) start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0) end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len2 = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n = typeof min2 === "bigint" ? "n" : "";
      let range2;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units2) {
    units2 = units2 || Infinity;
    let codePoint;
    const length = string2.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i2 = 0; i2 < length; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units2 -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units2 -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units2 -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units2 -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units2) {
    let c, hi, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units2 -= 2) < 0) break;
      c = str.charCodeAt(i2);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length) break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i2] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer = buffer$1.Buffer;
const Buffer$1 = buffer$1.Buffer;
var signing = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var naclFast = { exports: {} };
var cryptoBrowserify = {};
var browser$d = { exports: {} };
var hasRequiredBrowser$d;
function requireBrowser$d() {
  if (hasRequiredBrowser$d) return browser$d.exports;
  hasRequiredBrowser$d = 1;
  var MAX_BYTES = 65536;
  var MAX_UINT32 = 4294967295;
  function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
  }
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var crypto2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  if (crypto2 && crypto2.getRandomValues) {
    browser$d.exports = randomBytes;
  } else {
    browser$d.exports = oldBrowser;
  }
  function randomBytes(size, cb) {
    if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
    var bytes = Buffer2.allocUnsafe(size);
    if (size > 0) {
      if (size > MAX_BYTES) {
        for (var generated = 0; generated < size; generated += MAX_BYTES) {
          crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
        }
      } else {
        crypto2.getRandomValues(bytes);
      }
    }
    if (typeof cb === "function") {
      return process$1.nextTick(function() {
        cb(null, bytes);
      });
    }
    return bytes;
  }
  return browser$d.exports;
}
var events = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning2) {
    if (console && console.warn) console.warn(warning2);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter2() {
    EventEmitter2.init.call(this);
  }
  events.exports = EventEmitter2;
  events.exports.once = once;
  EventEmitter2.EventEmitter = EventEmitter2;
  EventEmitter2.prototype._events = void 0;
  EventEmitter2.prototype._eventsCount = 0;
  EventEmitter2.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter2.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter2.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter2.prototype.emit = function emit(type2) {
    var args = [];
    for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
    var doError = type2 === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type2];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len2 = handler.length;
      var listeners = arrayClone(handler, len2);
      for (var i2 = 0; i2 < len2; ++i2)
        ReflectApply(listeners[i2], this, args);
    }
    return true;
  };
  function _addListener(target, type2, listener, prepend) {
    var m;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type2,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type2];
    }
    if (existing === void 0) {
      existing = events2[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  EventEmitter2.prototype.addListener = function addListener(type2, listener) {
    return _addListener(this, type2, listener, false);
  };
  EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
  EventEmitter2.prototype.prependListener = function prependListener(type2, listener) {
    return _addListener(this, type2, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type2, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter2.prototype.once = function once2(type2, listener) {
    checkListener(listener);
    this.on(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
    checkListener(listener);
    this.prependListener(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter2.prototype.removeListener = function removeListener(type2, listener) {
    var list, events2, position, i2, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type2];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type2];
        if (events2.removeListener)
          this.emit("removeListener", type2, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i2 = list.length - 1; i2 >= 0; i2--) {
        if (list[i2] === listener || list[i2].listener === listener) {
          originalListener = list[i2].listener;
          position = i2;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne2(list, position);
      }
      if (list.length === 1)
        events2[type2] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type2, originalListener || listener);
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type2) {
    var listeners, events2, i2;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type2] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type2];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys2 = Object.keys(events2);
      var key2;
      for (i2 = 0; i2 < keys2.length; ++i2) {
        key2 = keys2[i2];
        if (key2 === "removeListener") continue;
        this.removeAllListeners(key2);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type2];
    if (typeof listeners === "function") {
      this.removeListener(type2, listeners);
    } else if (listeners !== void 0) {
      for (i2 = listeners.length - 1; i2 >= 0; i2--) {
        this.removeListener(type2, listeners[i2]);
      }
    }
    return this;
  };
  function _listeners(target, type2, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type2];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter2.prototype.listeners = function listeners(type2) {
    return _listeners(this, type2, true);
  };
  EventEmitter2.prototype.rawListeners = function rawListeners(type2) {
    return _listeners(this, type2, false);
  };
  EventEmitter2.listenerCount = function(emitter, type2) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type2);
    } else {
      return listenerCount.call(emitter, type2);
    }
  };
  EventEmitter2.prototype.listenerCount = listenerCount;
  function listenerCount(type2) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr2, n) {
    var copy2 = new Array(n);
    for (var i2 = 0; i2 < n; ++i2)
      copy2[i2] = arr2[i2];
    return copy2;
  }
  function spliceOne2(list, index2) {
    for (; index2 + 1 < list.length; index2++)
      list[index2] = list[index2 + 1];
    list.pop();
  }
  function unwrapListeners(arr2) {
    var ret = new Array(arr2.length);
    for (var i2 = 0; i2 < ret.length; ++i2) {
      ret[i2] = arr2[i2].listener || arr2[i2];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve2, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve2([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events.exports;
}
var inherits_browser$3 = { exports: {} };
var hasRequiredInherits_browser$3;
function requireInherits_browser$3() {
  if (hasRequiredInherits_browser$3) return inherits_browser$3.exports;
  hasRequiredInherits_browser$3 = 1;
  if (typeof Object.create === "function") {
    inherits_browser$3.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser$3.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser$3.exports;
}
var streamBrowser$2;
var hasRequiredStreamBrowser$2;
function requireStreamBrowser$2() {
  if (hasRequiredStreamBrowser$2) return streamBrowser$2;
  hasRequiredStreamBrowser$2 = 1;
  streamBrowser$2 = requireEvents().EventEmitter;
  return streamBrowser$2;
}
var util$2 = {};
var types$1 = {};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _23 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max$1;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max$1;
  hasRequiredMax = 1;
  max$1 = Math.max;
  return max$1;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round$1;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round$1;
  hasRequiredRound = 1;
  round$1 = Math.round;
  return round$1;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign$1;
var hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign$1 = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign$1;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var hasSymbols$1;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$1;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation$2;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation$2;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr2 = [];
    for (var i2 = 0; i2 < a.length; i2 += 1) {
      arr2[i2] = a[i2];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr2[j + a.length] = b[j];
    }
    return arr2;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr2 = [];
    for (var i2 = offset, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
      arr2[j] = arrLike[i2];
    }
    return arr2;
  };
  var joiny = function(arr2, joiner) {
    var str = "";
    for (var i2 = 0; i2 < arr2.length; i2 += 1) {
      str += arr2[i2];
      if (i2 + 1 < arr2.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation$2 = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs[i2] = "$" + i2;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation$2;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get$1;
var hasRequiredGet$1;
function requireGet$1() {
  if (hasRequiredGet$1) return get$1;
  hasRequiredGet$1 = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get$1 = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get$1;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet$1();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call2 = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call2, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign$1();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath2 = function stringToPath3(string2) {
    var first = $strSlice(string2, 0, 1);
    var last = $strSlice(string2, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath2(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i2 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBind = { exports: {} };
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
        return true;
      } catch (e) {
        return false;
      }
    }
    return false;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!hasPropertyDescriptors()) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var hasPropertyDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  var $SyntaxError = GetIntrinsic("%SyntaxError%");
  var $TypeError = GetIntrinsic("%TypeError%");
  var gopd2 = /* @__PURE__ */ requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var define = /* @__PURE__ */ requireDefineDataProperty();
  var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $TypeError = GetIntrinsic("%TypeError%");
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD2) {
      var desc = gOPD2(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(fn, "length", length, true, true);
      } else {
        define(fn, "length", length);
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var bind2 = requireFunctionBind();
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var setFunctionLength2 = requireSetFunctionLength();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind2(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind2, $call, arguments);
      return setFunctionLength2(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
var callBound$1;
var hasRequiredCallBound$1;
function requireCallBound$1() {
  if (hasRequiredCallBound$1) return callBound$1;
  hasRequiredCallBound$1 = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound$1 = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound$1;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound$1();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var toStr = Object.prototype.toString;
  var fnToStr = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag = requireShams()();
  var getProto2 = Object.getPrototypeOf;
  var getGeneratorFunc = function() {
    if (!hasToStringTag) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e) {
    }
  };
  var GeneratorFunction;
  isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex.test(fnToStr.call(fn))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr.call(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto2) {
      return false;
    }
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? getProto2(generatorFunc) : false;
    }
    return getProto2(fn) === GeneratorFunction;
  };
  return isGeneratorFunction;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_23) {
      if (_23 !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var forEach_1$1;
var hasRequiredForEach$1;
function requireForEach$1() {
  if (hasRequiredForEach$1) return forEach_1$1;
  hasRequiredForEach$1 = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array2, iterator2, receiver) {
    for (var i2 = 0, len2 = array2.length; i2 < len2; i2++) {
      if (hasOwnProperty.call(array2, i2)) {
        if (receiver == null) {
          iterator2(array2[i2], i2, array2);
        } else {
          iterator2.call(receiver, array2[i2], i2, array2);
        }
      }
    }
  };
  var forEachString = function forEachString2(string2, iterator2, receiver) {
    for (var i2 = 0, len2 = string2.length; i2 < len2; i2++) {
      if (receiver == null) {
        iterator2(string2.charAt(i2), i2, string2);
      } else {
        iterator2.call(receiver, string2.charAt(i2), i2, string2);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator2, receiver) {
    for (var k in object) {
      if (hasOwnProperty.call(object, k)) {
        if (receiver == null) {
          iterator2(object[k], k, object);
        } else {
          iterator2.call(receiver, object[k], k, object);
        }
      }
    }
  };
  var forEach2 = function forEach3(list, iterator2, thisArg) {
    if (!isCallable2(iterator2)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (toStr.call(list) === "[object Array]") {
      forEachArray(list, iterator2, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator2, receiver);
    } else {
      forEachObject(list, iterator2, receiver);
    }
  };
  forEach_1$1 = forEach2;
  return forEach_1$1;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ];
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i2 = 0; i2 < possibleNames.length; i2++) {
      if (typeof g[possibleNames[i2]] === "function") {
        out[out.length] = possibleNames[i2];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach2 = requireForEach$1();
  var availableTypedArrays2 = /* @__PURE__ */ requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = requireCallBound$1();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var getPrototypeOf = Object.getPrototypeOf;
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf2(array2, value) {
    for (var i2 = 0; i2 < array2.length; i2 += 1) {
      if (array2[i2] === value) {
        return i2;
      }
    }
    return -1;
  };
  var cache2 = { __proto__: null };
  if (hasToStringTag && gOPD2 && getPrototypeOf) {
    forEach2(typedArrays, function(typedArray) {
      var arr2 = new g[typedArray]();
      if (Symbol.toStringTag in arr2) {
        var proto = getPrototypeOf(arr2);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        cache2["$" + typedArray] = callBind2(descriptor.get);
      }
    });
  } else {
    forEach2(typedArrays, function(typedArray) {
      var arr2 = new g[typedArray]();
      var fn = arr2.slice || arr2.set;
      if (fn) {
        cache2["$" + typedArray] = callBind2(fn);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found = false;
    forEach2(cache2, function(getter, typedArray) {
      if (!found) {
        try {
          if ("$" + getter(value) === typedArray) {
            found = $slice(typedArray, 1);
          }
        } catch (e) {
        }
      }
    });
    return found;
  };
  var trySlices = function tryAllSlices(value) {
    var found = false;
    forEach2(cache2, function(getter, name) {
      if (!found) {
        try {
          getter(value);
          found = $slice(name, 1);
        } catch (e) {
        }
      }
    });
    return found;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD2) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var isTypedArray;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
  isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  (function(exports2) {
    var isArgumentsObject = requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
    var isTypedArray2 = requireIsTypedArray();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction2;
    exports2.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types$1);
  return types$1;
}
var isBufferBrowser;
var hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser) return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer2(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$2;
  hasRequiredUtil$2 = 1;
  (function(exports2) {
    var define_process_env_default = {};
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys2 = Object.keys(obj);
      var descriptors = {};
      for (var i2 = 0; i2 < keys2.length; i2++) {
        descriptors[keys2[i2]] = Object.getOwnPropertyDescriptor(obj, keys2[i2]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f) {
      if (!isString2(f)) {
        var objects = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          objects.push(inspect(arguments[i2]));
        }
        return objects.join(" ");
      }
      var i2 = 1;
      var args = arguments;
      var len2 = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i2 >= len2) return x2;
        switch (x2) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_23) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i2]; i2 < len2; x = args[++i2]) {
        if (isNull(x) || !isObject2(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (define_process_env_default.NODE_DEBUG) {
      var debugEnv = define_process_env_default.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports2.debuglog = function(set3) {
      set3 = set3.toUpperCase();
      if (!debugs[set3]) {
        if (debugEnvRegex.test(set3)) {
          var pid = process$1.pid;
          debugs[set3] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set3, pid, msg);
          };
        } else {
          debugs[set3] = function() {
          };
        }
      }
      return debugs[set3];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean2(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined2(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined2(ctx.depth)) ctx.depth = 2;
      if (isUndefined2(ctx.colors)) ctx.colors = false;
      if (isUndefined2(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style2 = inspect.styles[styleType];
      if (style2) {
        return "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array2) {
      var hash2 = {};
      array2.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString2(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys2 = Object.keys(value);
      var visibleKeys = arrayToHash(keys2);
      if (ctx.showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys2.length === 0) {
        if (isFunction2(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base2 = "", array2 = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array2 = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value)) {
        var n = value.name ? ": " + value.name : "";
        base2 = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base2 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base2 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base2 = " " + formatError(value);
      }
      if (keys2.length === 0 && (!array2 || value.length == 0)) {
        return braces[0] + base2 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output2;
      if (array2) {
        output2 = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
      } else {
        output2 = keys2.map(function(key2) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array2);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output2, base2, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined2(value))
        return ctx.stylize("undefined", "undefined");
      if (isString2(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean2(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
      var output2 = [];
      for (var i2 = 0, l = value.length; i2 < l; ++i2) {
        if (hasOwnProperty(value, String(i2))) {
          output2.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i2),
            true
          ));
        } else {
          output2.push("");
        }
      }
      keys2.forEach(function(key2) {
        if (!key2.match(/^\d+$/)) {
          output2.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key2,
            true
          ));
        }
      });
      return output2;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array2) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key2)) {
        name = "[" + key2 + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array2) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined2(name)) {
        if (array2 && key2.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key2);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output2, base2, braces) {
      var length = output2.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output2.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base2 + " " + output2.join(", ") + " " + braces[1];
    }
    exports2.types = requireTypes$1();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray2;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean2;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined2(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined2;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString2;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined2(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined2;
    function isRegExp(re) {
      return isObject2(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d) {
      return isObject2(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError(e) {
      return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = requireIsBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = requireInherits_browser$4();
    exports2._extend = function(origin, add) {
      if (!add || !isObject2(add)) return origin;
      var keys2 = Object.keys(add);
      var i2 = keys2.length;
      while (i2--) {
        origin[keys2[i2]] = add[keys2[i2]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original2) {
      if (typeof original2 !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original2[kCustomPromisifiedSymbol]) {
        var fn = original2[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise2 = new Promise(function(resolve2, reject) {
          promiseResolve = resolve2;
          promiseReject = reject;
        });
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original2.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise2;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original2));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original2)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original2) {
      if (typeof original2 !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original2.apply(this, args).then(
          function(ret) {
            process$1.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original2));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original2)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  })(util$2);
  return util$2;
}
var buffer_list$1;
var hasRequiredBuffer_list$1;
function requireBuffer_list$1() {
  if (hasRequiredBuffer_list$1) return buffer_list$1;
  hasRequiredBuffer_list$1 = 1;
  function ownKeys2(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols2);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key2) {
        _defineProperty2(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty2(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = requireDist(), Buffer2 = _require.Buffer;
  var _require2 = requireUtil$2(), inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  buffer_list$1 = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck2(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass2(BufferList2, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join3(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i2 = 0;
        while (p) {
          copyBuffer(p.data, ret, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_23, options2) {
        return inspect(this, _objectSpread2(_objectSpread2({}, options2), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list$1;
}
var destroy_1$2;
var hasRequiredDestroy$2;
function requireDestroy$2() {
  if (hasRequiredDestroy$2) return destroy_1$2;
  hasRequiredDestroy$2 = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1$2 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1$2;
}
var errorsBrowser$1 = {};
var hasRequiredErrorsBrowser$1;
function requireErrorsBrowser$1() {
  if (hasRequiredErrorsBrowser$1) return errorsBrowser$1;
  hasRequiredErrorsBrowser$1 = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code2, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inheritsLoose2(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code2;
    codes[code2] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len2 = expected.length;
      expected = expected.map(function(i2) {
        return String(i2);
      });
      if (len2 > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
      } else if (len2 === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser$1.codes = codes;
  return errorsBrowser$1;
}
var state$1;
var hasRequiredState$1;
function requireState$1() {
  if (hasRequiredState$1) return state$1;
  hasRequiredState$1 = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser$1().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options2, isDuplex, duplexKey) {
    return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
  }
  function getHighWaterMark(state2, options2, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state$1 = {
    getHighWaterMark
  };
  return state$1;
}
var browser$c;
var hasRequiredBrowser$c;
function requireBrowser$c() {
  if (hasRequiredBrowser$c) return browser$c;
  hasRequiredBrowser$c = 1;
  browser$c = deprecate;
  function deprecate(fn, msg) {
    if (config2("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config2("throwDeprecation")) {
          throw new Error(msg);
        } else if (config2("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config2(name) {
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_23) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return browser$c;
}
var _stream_writable$2;
var hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2) return _stream_writable$2;
  hasRequired_stream_writable$2 = 1;
  _stream_writable$2 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser$c()
  };
  var Stream = requireStreamBrowser$2();
  var Buffer2 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$2();
  var _require = requireState$1(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser$1().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits_browser$3()(Writable, Stream);
  function nop() {
  }
  function WritableState(options2, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex$2();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options2.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options2.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options2.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_23) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options2) {
    Duplex = Duplex || require_stream_duplex$2();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options2);
    this._writableState = new WritableState(options2, this, isDuplex);
    this.writable = true;
    if (options2) {
      if (typeof options2.write === "function") this._write = options2.write;
      if (typeof options2.writev === "function") this._writev = options2.writev;
      if (typeof options2.destroy === "function") this._destroy = options2.destroy;
      if (typeof options2.final === "function") this._final = options2.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len2 = state2.objectMode ? 1 : chunk.length;
    state2.length += len2;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len2, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
    state2.writelen = len2;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len2 = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len2, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set3(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable$2;
}
var _stream_duplex$2;
var hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2) return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key2 in obj) keys3.push(key2);
    return keys3;
  };
  _stream_duplex$2 = Duplex;
  var Readable = require_stream_readable$2();
  var Writable = require_stream_writable$2();
  requireInherits_browser$3()(Duplex, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v = 0; v < keys2.length; v++) {
      var method = keys2[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options2) {
    if (!(this instanceof Duplex)) return new Duplex(options2);
    Readable.call(this, options2);
    Writable.call(this, options2);
    this.allowHalfOpen = true;
    if (options2) {
      if (options2.readable === false) this.readable = false;
      if (options2.writable === false) this.writable = false;
      if (options2.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set3(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex$2;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i2;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i2 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i2 = 0;
    }
    if (i2 < buf.length) return r ? r + this.text(buf, i2) : this.text(buf, i2);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i2) {
    var j = buf.length - 1;
    if (j < i2) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i2 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i2 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i2) {
    var total = utf8CheckIncomplete(this, buf, i2);
    if (!this.lastNeed) return buf.toString("utf8", i2);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i2, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  function utf16Text(buf, i2) {
    if ((buf.length - i2) % 2 === 0) {
      var r = buf.toString("utf16le", i2);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i2, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i2) {
    var n = (buf.length - i2) % 3;
    if (n === 0) return buf.toString("base64", i2);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i2, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream$1;
var hasRequiredEndOfStream$1;
function requireEndOfStream$1() {
  if (hasRequiredEndOfStream$1) return endOfStream$1;
  hasRequiredEndOfStream$1 = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser$1().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream$1 = eos;
  return endOfStream$1;
}
var async_iterator$1;
var hasRequiredAsync_iterator$1;
function requireAsync_iterator$1() {
  if (hasRequiredAsync_iterator$1) return async_iterator$1;
  hasRequiredAsync_iterator$1 = 1;
  var _Object$setPrototypeO;
  function _defineProperty2(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream$1();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve2 = iter[kLastResolve];
    if (resolve2 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve2(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve2, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve2(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve2, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error3 = this[kError];
      if (error3 !== null) {
        return Promise.reject(error3);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve2, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve2(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise2;
      if (lastPromise) {
        promise2 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise2 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise2;
      return promise2;
    }
  }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve2, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty2(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty2(_Object$create, kHandlePromise, {
      value: function value(resolve2, reject) {
        var data = iterator2[kStream].read();
        if (data) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve2(createIterResult(data, false));
        } else {
          iterator2[kLastResolve] = resolve2;
          iterator2[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator2[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator2[kLastReject];
        if (reject !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          reject(err);
        }
        iterator2[kError] = err;
        return;
      }
      var resolve2 = iterator2[kLastResolve];
      if (resolve2 !== null) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        resolve2(createIterResult(void 0, true));
      }
      iterator2[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator2));
    return iterator2;
  };
  async_iterator$1 = createReadableStreamAsyncIterator;
  return async_iterator$1;
}
var fromBrowser$1;
var hasRequiredFromBrowser$1;
function requireFromBrowser$1() {
  if (hasRequiredFromBrowser$1) return fromBrowser$1;
  hasRequiredFromBrowser$1 = 1;
  fromBrowser$1 = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser$1;
}
var _stream_readable$2;
var hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2) return _stream_readable$2;
  hasRequired_stream_readable$2 = 1;
  _stream_readable$2 = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  requireEvents().EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser$2();
  var Buffer2 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil$2();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList2 = requireBuffer_list$1();
  var destroyImpl = requireDestroy$2();
  var _require = requireState$1(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser$1().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits_browser$3()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options2, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex$2();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options2.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options2.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options2.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options2.encoding);
      this.encoding = options2.encoding;
    }
  }
  function Readable(options2) {
    Duplex = Duplex || require_stream_duplex$2();
    if (!(this instanceof Readable)) return new Readable(options2);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options2, this, isDuplex);
    this.readable = true;
    if (options2) {
      if (typeof options2.read === "function") this._read = options2.read;
      if (typeof options2.destroy === "function") this._destroy = options2.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set3(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len2 = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len2 === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len2 = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i2 = 0; i2 < len2; i2++) dests[i2].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i2 in stream) {
      if (this[i2] === void 0 && typeof stream[i2] === "function") {
        this[i2] = /* @__PURE__ */ function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i2);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator$1();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.flowing;
    },
    set: function set3(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFromBrowser$1();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf2(xs, x) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x) return i2;
    }
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2;
var hasRequired_stream_transform$2;
function require_stream_transform$2() {
  if (hasRequired_stream_transform$2) return _stream_transform$2;
  hasRequired_stream_transform$2 = 1;
  _stream_transform$2 = Transform;
  var _require$codes = requireErrorsBrowser$1().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex$2();
  requireInherits_browser$3()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options2) {
    if (!(this instanceof Transform)) return new Transform(options2);
    Duplex.call(this, options2);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options2) {
      if (typeof options2.transform === "function") this._transform = options2.transform;
      if (typeof options2.flush === "function") this._flush = options2.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2;
var hasRequired_stream_passthrough$2;
function require_stream_passthrough$2() {
  if (hasRequired_stream_passthrough$2) return _stream_passthrough$2;
  hasRequired_stream_passthrough$2 = 1;
  _stream_passthrough$2 = PassThrough;
  var Transform = require_stream_transform$2();
  requireInherits_browser$3()(PassThrough, Transform);
  function PassThrough(options2) {
    if (!(this instanceof PassThrough)) return new PassThrough(options2);
    Transform.call(this, options2);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$2;
}
var pipeline_1$1;
var hasRequiredPipeline$1;
function requirePipeline$1() {
  if (hasRequiredPipeline$1) return pipeline_1$1;
  hasRequiredPipeline$1 = 1;
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser$1().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream$1();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call2(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error3;
    var destroys = streams.map(function(stream, i2) {
      var reading = i2 < streams.length - 1;
      var writing = i2 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error3) error3 = err;
        if (err) destroys.forEach(call2);
        if (reading) return;
        destroys.forEach(call2);
        callback(error3);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1$1 = pipeline;
  return pipeline_1$1;
}
var streamBrowserify;
var hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1;
  streamBrowserify = Stream;
  var EE = requireEvents().EventEmitter;
  var inherits = requireInherits_browser$3();
  inherits(Stream, EE);
  Stream.Readable = require_stream_readable$2();
  Stream.Writable = require_stream_writable$2();
  Stream.Duplex = require_stream_duplex$2();
  Stream.Transform = require_stream_transform$2();
  Stream.PassThrough = require_stream_passthrough$2();
  Stream.finished = requireEndOfStream$1();
  Stream.pipeline = requirePipeline$1();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options2) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options2 || options2.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return streamBrowserify;
}
var hashBase;
var hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var Transform = requireStreamBrowserify().Transform;
  var inherits = requireInherits_browser$4();
  function throwIfNotStringOrBuffer(val, prefix2) {
    if (!Buffer2.isBuffer(val) && typeof val !== "string") {
      throw new TypeError(prefix2 + " must be a string or a buffer");
    }
  }
  function HashBase(blockSize) {
    Transform.call(this);
    this._block = Buffer2.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._finalized = false;
  }
  inherits(HashBase, Transform);
  HashBase.prototype._transform = function(chunk, encoding, callback) {
    var error3 = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error3 = err;
    }
    callback(error3);
  };
  HashBase.prototype._flush = function(callback) {
    var error3 = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error3 = err;
    }
    callback(error3);
  };
  HashBase.prototype.update = function(data, encoding) {
    throwIfNotStringOrBuffer(data, "Data");
    if (this._finalized) throw new Error("Digest already called");
    if (!Buffer2.isBuffer(data)) data = Buffer2.from(data, encoding);
    var block = this._block;
    var offset = 0;
    while (this._blockOffset + data.length - offset >= this._blockSize) {
      for (var i2 = this._blockOffset; i2 < this._blockSize; ) block[i2++] = data[offset++];
      this._update();
      this._blockOffset = 0;
    }
    while (offset < data.length) block[this._blockOffset++] = data[offset++];
    for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
      this._length[j] += carry;
      carry = this._length[j] / 4294967296 | 0;
      if (carry > 0) this._length[j] -= 4294967296 * carry;
    }
    return this;
  };
  HashBase.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  HashBase.prototype.digest = function(encoding) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = true;
    var digest = this._digest();
    if (encoding !== void 0) digest = digest.toString(encoding);
    this._block.fill(0);
    this._blockOffset = 0;
    for (var i2 = 0; i2 < 4; ++i2) this._length[i2] = 0;
    return digest;
  };
  HashBase.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  hashBase = HashBase;
  return hashBase;
}
var md5_js;
var hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var inherits = requireInherits_browser$4();
  var HashBase = requireHashBase();
  var ARRAY16 = new Array(16);
  function MD5() {
    HashBase.call(this, 64);
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
  }
  inherits(MD5, HashBase);
  MD5.prototype._update = function() {
    var M = ARRAY16;
    for (var i2 = 0; i2 < 16; ++i2) M[i2] = this._block.readInt32LE(i2 * 4);
    var a = this._a;
    var b = this._b;
    var c = this._c;
    var d = this._d;
    a = fnF(a, b, c, d, M[0], 3614090360, 7);
    d = fnF(d, a, b, c, M[1], 3905402710, 12);
    c = fnF(c, d, a, b, M[2], 606105819, 17);
    b = fnF(b, c, d, a, M[3], 3250441966, 22);
    a = fnF(a, b, c, d, M[4], 4118548399, 7);
    d = fnF(d, a, b, c, M[5], 1200080426, 12);
    c = fnF(c, d, a, b, M[6], 2821735955, 17);
    b = fnF(b, c, d, a, M[7], 4249261313, 22);
    a = fnF(a, b, c, d, M[8], 1770035416, 7);
    d = fnF(d, a, b, c, M[9], 2336552879, 12);
    c = fnF(c, d, a, b, M[10], 4294925233, 17);
    b = fnF(b, c, d, a, M[11], 2304563134, 22);
    a = fnF(a, b, c, d, M[12], 1804603682, 7);
    d = fnF(d, a, b, c, M[13], 4254626195, 12);
    c = fnF(c, d, a, b, M[14], 2792965006, 17);
    b = fnF(b, c, d, a, M[15], 1236535329, 22);
    a = fnG(a, b, c, d, M[1], 4129170786, 5);
    d = fnG(d, a, b, c, M[6], 3225465664, 9);
    c = fnG(c, d, a, b, M[11], 643717713, 14);
    b = fnG(b, c, d, a, M[0], 3921069994, 20);
    a = fnG(a, b, c, d, M[5], 3593408605, 5);
    d = fnG(d, a, b, c, M[10], 38016083, 9);
    c = fnG(c, d, a, b, M[15], 3634488961, 14);
    b = fnG(b, c, d, a, M[4], 3889429448, 20);
    a = fnG(a, b, c, d, M[9], 568446438, 5);
    d = fnG(d, a, b, c, M[14], 3275163606, 9);
    c = fnG(c, d, a, b, M[3], 4107603335, 14);
    b = fnG(b, c, d, a, M[8], 1163531501, 20);
    a = fnG(a, b, c, d, M[13], 2850285829, 5);
    d = fnG(d, a, b, c, M[2], 4243563512, 9);
    c = fnG(c, d, a, b, M[7], 1735328473, 14);
    b = fnG(b, c, d, a, M[12], 2368359562, 20);
    a = fnH(a, b, c, d, M[5], 4294588738, 4);
    d = fnH(d, a, b, c, M[8], 2272392833, 11);
    c = fnH(c, d, a, b, M[11], 1839030562, 16);
    b = fnH(b, c, d, a, M[14], 4259657740, 23);
    a = fnH(a, b, c, d, M[1], 2763975236, 4);
    d = fnH(d, a, b, c, M[4], 1272893353, 11);
    c = fnH(c, d, a, b, M[7], 4139469664, 16);
    b = fnH(b, c, d, a, M[10], 3200236656, 23);
    a = fnH(a, b, c, d, M[13], 681279174, 4);
    d = fnH(d, a, b, c, M[0], 3936430074, 11);
    c = fnH(c, d, a, b, M[3], 3572445317, 16);
    b = fnH(b, c, d, a, M[6], 76029189, 23);
    a = fnH(a, b, c, d, M[9], 3654602809, 4);
    d = fnH(d, a, b, c, M[12], 3873151461, 11);
    c = fnH(c, d, a, b, M[15], 530742520, 16);
    b = fnH(b, c, d, a, M[2], 3299628645, 23);
    a = fnI(a, b, c, d, M[0], 4096336452, 6);
    d = fnI(d, a, b, c, M[7], 1126891415, 10);
    c = fnI(c, d, a, b, M[14], 2878612391, 15);
    b = fnI(b, c, d, a, M[5], 4237533241, 21);
    a = fnI(a, b, c, d, M[12], 1700485571, 6);
    d = fnI(d, a, b, c, M[3], 2399980690, 10);
    c = fnI(c, d, a, b, M[10], 4293915773, 15);
    b = fnI(b, c, d, a, M[1], 2240044497, 21);
    a = fnI(a, b, c, d, M[8], 1873313359, 6);
    d = fnI(d, a, b, c, M[15], 4264355552, 10);
    c = fnI(c, d, a, b, M[6], 2734768916, 15);
    b = fnI(b, c, d, a, M[13], 1309151649, 21);
    a = fnI(a, b, c, d, M[4], 4149444226, 6);
    d = fnI(d, a, b, c, M[11], 3174756917, 10);
    c = fnI(c, d, a, b, M[2], 718787259, 15);
    b = fnI(b, c, d, a, M[9], 3951481745, 21);
    this._a = this._a + a | 0;
    this._b = this._b + b | 0;
    this._c = this._c + c | 0;
    this._d = this._d + d | 0;
  };
  MD5.prototype._digest = function() {
    this._block[this._blockOffset++] = 128;
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);
      this._update();
      this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    var buffer2 = new Buffer(16);
    buffer2.writeInt32LE(this._a, 0);
    buffer2.writeInt32LE(this._b, 4);
    buffer2.writeInt32LE(this._c, 8);
    buffer2.writeInt32LE(this._d, 12);
    return buffer2;
  };
  function rotl(x, n) {
    return x << n | x >>> 32 - n;
  }
  function fnF(a, b, c, d, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
  }
  function fnG(a, b, c, d, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
  }
  function fnH(a, b, c, d, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
  }
  function fnI(a, b, c, d, m, k, s) {
    return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
  }
  md5_js = MD5;
  return md5_js;
}
var ripemd160;
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160;
  hasRequiredRipemd160 = 1;
  var Buffer2 = requireDist().Buffer;
  var inherits = requireInherits_browser$4();
  var HashBase = requireHashBase();
  var ARRAY16 = new Array(16);
  var zl = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var zr = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var sl = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sr = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
  var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function RIPEMD160() {
    HashBase.call(this, 64);
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
  }
  inherits(RIPEMD160, HashBase);
  RIPEMD160.prototype._update = function() {
    var words = ARRAY16;
    for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);
    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el2 = this._e | 0;
    var ar = this._a | 0;
    var br = this._b | 0;
    var cr = this._c | 0;
    var dr = this._d | 0;
    var er = this._e | 0;
    for (var i2 = 0; i2 < 80; i2 += 1) {
      var tl;
      var tr;
      if (i2 < 16) {
        tl = fn1(al, bl, cl, dl, el2, words[zl[i2]], hl[0], sl[i2]);
        tr = fn5(ar, br, cr, dr, er, words[zr[i2]], hr[0], sr[i2]);
      } else if (i2 < 32) {
        tl = fn2(al, bl, cl, dl, el2, words[zl[i2]], hl[1], sl[i2]);
        tr = fn4(ar, br, cr, dr, er, words[zr[i2]], hr[1], sr[i2]);
      } else if (i2 < 48) {
        tl = fn3(al, bl, cl, dl, el2, words[zl[i2]], hl[2], sl[i2]);
        tr = fn3(ar, br, cr, dr, er, words[zr[i2]], hr[2], sr[i2]);
      } else if (i2 < 64) {
        tl = fn4(al, bl, cl, dl, el2, words[zl[i2]], hl[3], sl[i2]);
        tr = fn2(ar, br, cr, dr, er, words[zr[i2]], hr[3], sr[i2]);
      } else {
        tl = fn5(al, bl, cl, dl, el2, words[zl[i2]], hl[4], sl[i2]);
        tr = fn1(ar, br, cr, dr, er, words[zr[i2]], hr[4], sr[i2]);
      }
      al = el2;
      el2 = dl;
      dl = rotl(cl, 10);
      cl = bl;
      bl = tl;
      ar = er;
      er = dr;
      dr = rotl(cr, 10);
      cr = br;
      br = tr;
    }
    var t2 = this._b + cl + dr | 0;
    this._b = this._c + dl + er | 0;
    this._c = this._d + el2 + ar | 0;
    this._d = this._e + al + br | 0;
    this._e = this._a + bl + cr | 0;
    this._a = t2;
  };
  RIPEMD160.prototype._digest = function() {
    this._block[this._blockOffset++] = 128;
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);
      this._update();
      this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    var buffer2 = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
    buffer2.writeInt32LE(this._a, 0);
    buffer2.writeInt32LE(this._b, 4);
    buffer2.writeInt32LE(this._c, 8);
    buffer2.writeInt32LE(this._d, 12);
    buffer2.writeInt32LE(this._e, 16);
    return buffer2;
  };
  function rotl(x, n) {
    return x << n | x >>> 32 - n;
  }
  function fn1(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
  }
  function fn2(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
  }
  function fn3(a, b, c, d, e, m, k, s) {
    return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
  }
  function fn4(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
  }
  function fn5(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
  }
  ripemd160 = RIPEMD160;
  return ripemd160;
}
var cipherBase;
var hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var Transform = requireStreamBrowserify().Transform;
  var StringDecoder = requireString_decoder().StringDecoder;
  var inherits = requireInherits_browser$4();
  function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
      this[hashMode] = this._finalOrDigest;
    } else {
      this.final = this._finalOrDigest;
    }
    if (this._final) {
      this.__final = this._final;
      this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
  }
  inherits(CipherBase, Transform);
  CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
    if (typeof data === "string") {
      data = Buffer2.from(data, inputEnc);
    }
    var outData = this._update(data);
    if (this.hashMode) return this;
    if (outputEnc) {
      outData = this._toString(outData, outputEnc);
    }
    return outData;
  };
  CipherBase.prototype.setAutoPadding = function() {
  };
  CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  CipherBase.prototype._transform = function(data, _23, next) {
    var err;
    try {
      if (this.hashMode) {
        this._update(data);
      } else {
        this.push(this._update(data));
      }
    } catch (e) {
      err = e;
    } finally {
      next(err);
    }
  };
  CipherBase.prototype._flush = function(done) {
    var err;
    try {
      this.push(this.__final());
    } catch (e) {
      err = e;
    }
    done(err);
  };
  CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer2.alloc(0);
    if (outputEnc) {
      outData = this._toString(outData, outputEnc, true);
    }
    return outData;
  };
  CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
      this._decoder = new StringDecoder(enc);
      this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) {
      out += this._decoder.end();
    }
    return out;
  };
  cipherBase = CipherBase;
  return cipherBase;
}
var browser$b;
var hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b;
  hasRequiredBrowser$b = 1;
  var inherits = requireInherits_browser$4();
  var MD5 = requireMd5_js();
  var RIPEMD160 = requireRipemd160();
  var sha2 = requireSha_js();
  var Base = requireCipherBase();
  function Hash(hash2) {
    Base.call(this, "digest");
    this._hash = hash2;
  }
  inherits(Hash, Base);
  Hash.prototype._update = function(data) {
    this._hash.update(data);
  };
  Hash.prototype._final = function() {
    return this._hash.digest();
  };
  browser$b = function createHash(alg) {
    alg = alg.toLowerCase();
    if (alg === "md5") return new MD5();
    if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD160();
    return new Hash(sha2(alg));
  };
  return browser$b;
}
var legacy;
var hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var inherits = requireInherits_browser$4();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var Base = requireCipherBase();
  var ZEROS = Buffer2.alloc(128);
  var blocksize = 64;
  function Hmac(alg, key2) {
    Base.call(this, "digest");
    if (typeof key2 === "string") {
      key2 = Buffer2.from(key2);
    }
    this._alg = alg;
    this._key = key2;
    if (key2.length > blocksize) {
      key2 = alg(key2);
    } else if (key2.length < blocksize) {
      key2 = Buffer2.concat([key2, ZEROS], blocksize);
    }
    var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
    var opad = this._opad = Buffer2.allocUnsafe(blocksize);
    for (var i2 = 0; i2 < blocksize; i2++) {
      ipad[i2] = key2[i2] ^ 54;
      opad[i2] = key2[i2] ^ 92;
    }
    this._hash = [ipad];
  }
  inherits(Hmac, Base);
  Hmac.prototype._update = function(data) {
    this._hash.push(data);
  };
  Hmac.prototype._final = function() {
    var h = this._alg(Buffer2.concat(this._hash));
    return this._alg(Buffer2.concat([this._opad, h]));
  };
  legacy = Hmac;
  return legacy;
}
var md5;
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var MD5 = requireMd5_js();
  md5 = function(buffer2) {
    return new MD5().update(buffer2).digest();
  };
  return md5;
}
var browser$a;
var hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1;
  var inherits = requireInherits_browser$4();
  var Legacy = requireLegacy();
  var Base = requireCipherBase();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var md52 = requireMd5();
  var RIPEMD160 = requireRipemd160();
  var sha2 = requireSha_js();
  var ZEROS = Buffer2.alloc(128);
  function Hmac(alg, key2) {
    Base.call(this, "digest");
    if (typeof key2 === "string") {
      key2 = Buffer2.from(key2);
    }
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    this._alg = alg;
    this._key = key2;
    if (key2.length > blocksize) {
      var hash2 = alg === "rmd160" ? new RIPEMD160() : sha2(alg);
      key2 = hash2.update(key2).digest();
    } else if (key2.length < blocksize) {
      key2 = Buffer2.concat([key2, ZEROS], blocksize);
    }
    var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
    var opad = this._opad = Buffer2.allocUnsafe(blocksize);
    for (var i2 = 0; i2 < blocksize; i2++) {
      ipad[i2] = key2[i2] ^ 54;
      opad[i2] = key2[i2] ^ 92;
    }
    this._hash = alg === "rmd160" ? new RIPEMD160() : sha2(alg);
    this._hash.update(ipad);
  }
  inherits(Hmac, Base);
  Hmac.prototype._update = function(data) {
    this._hash.update(data);
  };
  Hmac.prototype._final = function() {
    var h = this._hash.digest();
    var hash2 = this._alg === "rmd160" ? new RIPEMD160() : sha2(this._alg);
    return hash2.update(this._opad).update(h).digest();
  };
  browser$a = function createHmac(alg, key2) {
    alg = alg.toLowerCase();
    if (alg === "rmd160" || alg === "ripemd160") {
      return new Hmac("rmd160", key2);
    }
    if (alg === "md5") {
      return new Legacy(md52, key2);
    }
    return new Hmac(alg, key2);
  };
  return browser$a;
}
const sha224WithRSAEncryption = { "sign": "rsa", "hash": "sha224", "id": "302d300d06096086480165030402040500041c" };
const sha256WithRSAEncryption = { "sign": "rsa", "hash": "sha256", "id": "3031300d060960864801650304020105000420" };
const sha384WithRSAEncryption = { "sign": "rsa", "hash": "sha384", "id": "3041300d060960864801650304020205000430" };
const sha512WithRSAEncryption = { "sign": "rsa", "hash": "sha512", "id": "3051300d060960864801650304020305000440" };
const sha256 = { "sign": "ecdsa", "hash": "sha256", "id": "" };
const sha224 = { "sign": "ecdsa", "hash": "sha224", "id": "" };
const sha384 = { "sign": "ecdsa", "hash": "sha384", "id": "" };
const sha512 = { "sign": "ecdsa", "hash": "sha512", "id": "" };
const DSA = { "sign": "dsa", "hash": "sha1", "id": "" };
const ripemd160WithRSA = { "sign": "rsa", "hash": "rmd160", "id": "3021300906052b2403020105000414" };
const md5WithRSAEncryption = { "sign": "rsa", "hash": "md5", "id": "3020300c06082a864886f70d020505000410" };
const require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": { "sign": "ecdsa/rsa", "hash": "sha224", "id": "302d300d06096086480165030402040500041c" },
  sha256WithRSAEncryption,
  "RSA-SHA256": { "sign": "ecdsa/rsa", "hash": "sha256", "id": "3031300d060960864801650304020105000420" },
  sha384WithRSAEncryption,
  "RSA-SHA384": { "sign": "ecdsa/rsa", "hash": "sha384", "id": "3041300d060960864801650304020205000430" },
  sha512WithRSAEncryption,
  "RSA-SHA512": { "sign": "ecdsa/rsa", "hash": "sha512", "id": "3051300d060960864801650304020305000440" },
  "RSA-SHA1": { "sign": "rsa", "hash": "sha1", "id": "3021300906052b0e03021a05000414" },
  "ecdsa-with-SHA1": { "sign": "ecdsa", "hash": "sha1", "id": "" },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": { "sign": "dsa", "hash": "sha1", "id": "" },
  "DSA-SHA1": { "sign": "dsa", "hash": "sha1", "id": "" },
  DSA,
  "DSA-WITH-SHA224": { "sign": "dsa", "hash": "sha224", "id": "" },
  "DSA-SHA224": { "sign": "dsa", "hash": "sha224", "id": "" },
  "DSA-WITH-SHA256": { "sign": "dsa", "hash": "sha256", "id": "" },
  "DSA-SHA256": { "sign": "dsa", "hash": "sha256", "id": "" },
  "DSA-WITH-SHA384": { "sign": "dsa", "hash": "sha384", "id": "" },
  "DSA-SHA384": { "sign": "dsa", "hash": "sha384", "id": "" },
  "DSA-WITH-SHA512": { "sign": "dsa", "hash": "sha512", "id": "" },
  "DSA-SHA512": { "sign": "dsa", "hash": "sha512", "id": "" },
  "DSA-RIPEMD160": { "sign": "dsa", "hash": "rmd160", "id": "" },
  ripemd160WithRSA,
  "RSA-RIPEMD160": { "sign": "rsa", "hash": "rmd160", "id": "3021300906052b2403020105000414" },
  md5WithRSAEncryption,
  "RSA-MD5": { "sign": "rsa", "hash": "md5", "id": "3020300c06082a864886f70d020505000410" }
};
var algos;
var hasRequiredAlgos;
function requireAlgos() {
  if (hasRequiredAlgos) return algos;
  hasRequiredAlgos = 1;
  algos = require$$6;
  return algos;
}
var browser$9 = {};
var precondition;
var hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var MAX_ALLOC = Math.pow(2, 30) - 1;
  precondition = function(iterations, keylen) {
    if (typeof iterations !== "number") {
      throw new TypeError("Iterations not a number");
    }
    if (iterations < 0) {
      throw new TypeError("Bad iterations");
    }
    if (typeof keylen !== "number") {
      throw new TypeError("Key length not a number");
    }
    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
      throw new TypeError("Bad key length");
    }
  };
  return precondition;
}
var defaultEncoding_1;
var hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var defaultEncoding;
  if (commonjsGlobal.process && commonjsGlobal.process.browser) {
    defaultEncoding = "utf-8";
  } else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
    defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
  } else {
    defaultEncoding = "utf-8";
  }
  defaultEncoding_1 = defaultEncoding;
  return defaultEncoding_1;
}
var toBuffer;
var hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer;
  hasRequiredToBuffer = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  toBuffer = function(thing, encoding, name) {
    if (Buffer2.isBuffer(thing)) {
      return thing;
    } else if (typeof thing === "string") {
      return Buffer2.from(thing, encoding);
    } else if (ArrayBuffer.isView(thing)) {
      return Buffer2.from(thing.buffer);
    } else {
      throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
    }
  };
  return toBuffer;
}
var syncBrowser;
var hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var md52 = requireMd5();
  var RIPEMD160 = requireRipemd160();
  var sha2 = requireSha_js();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var checkParameters = requirePrecondition();
  var defaultEncoding = requireDefaultEncoding();
  var toBuffer2 = requireToBuffer();
  var ZEROS = Buffer2.alloc(128);
  var sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function Hmac(alg, key2, saltLen) {
    var hash2 = getDigest(alg);
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    if (key2.length > blocksize) {
      key2 = hash2(key2);
    } else if (key2.length < blocksize) {
      key2 = Buffer2.concat([key2, ZEROS], blocksize);
    }
    var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
    var opad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
    for (var i2 = 0; i2 < blocksize; i2++) {
      ipad[i2] = key2[i2] ^ 54;
      opad[i2] = key2[i2] ^ 92;
    }
    var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    this.ipad1 = ipad1;
    this.ipad2 = ipad;
    this.opad = opad;
    this.alg = alg;
    this.blocksize = blocksize;
    this.hash = hash2;
    this.size = sizes[alg];
  }
  Hmac.prototype.run = function(data, ipad) {
    data.copy(ipad, this.blocksize);
    var h = this.hash(ipad);
    h.copy(this.opad, this.blocksize);
    return this.hash(this.opad);
  };
  function getDigest(alg) {
    function shaFunc(data) {
      return sha2(alg).update(data).digest();
    }
    function rmd160Func(data) {
      return new RIPEMD160().update(data).digest();
    }
    if (alg === "rmd160" || alg === "ripemd160") return rmd160Func;
    if (alg === "md5") return md52;
    return shaFunc;
  }
  function pbkdf2(password, salt, iterations, keylen, digest) {
    checkParameters(iterations, keylen);
    password = toBuffer2(password, defaultEncoding, "Password");
    salt = toBuffer2(salt, defaultEncoding, "Salt");
    digest = digest || "sha1";
    var hmac2 = new Hmac(digest, password, salt.length);
    var DK = Buffer2.allocUnsafe(keylen);
    var block1 = Buffer2.allocUnsafe(salt.length + 4);
    salt.copy(block1, 0, 0, salt.length);
    var destPos = 0;
    var hLen = sizes[digest];
    var l = Math.ceil(keylen / hLen);
    for (var i2 = 1; i2 <= l; i2++) {
      block1.writeUInt32BE(i2, salt.length);
      var T = hmac2.run(block1, hmac2.ipad1);
      var U = T;
      for (var j = 1; j < iterations; j++) {
        U = hmac2.run(U, hmac2.ipad2);
        for (var k = 0; k < hLen; k++) T[k] ^= U[k];
      }
      T.copy(DK, destPos);
      destPos += hLen;
    }
    return DK;
  }
  syncBrowser = pbkdf2;
  return syncBrowser;
}
var async;
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var checkParameters = requirePrecondition();
  var defaultEncoding = requireDefaultEncoding();
  var sync = requireSyncBrowser();
  var toBuffer2 = requireToBuffer();
  var ZERO_BUF;
  var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
  var toBrowser = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  };
  var checks = [];
  function checkNative(algo) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
      return Promise.resolve(false);
    }
    if (!subtle || !subtle.importKey || !subtle.deriveBits) {
      return Promise.resolve(false);
    }
    if (checks[algo] !== void 0) {
      return checks[algo];
    }
    ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);
    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
      return true;
    }).catch(function() {
      return false;
    });
    checks[algo] = prom;
    return prom;
  }
  var nextTick;
  function getNextTick() {
    if (nextTick) {
      return nextTick;
    }
    if (commonjsGlobal.process && commonjsGlobal.process.nextTick) {
      nextTick = commonjsGlobal.process.nextTick;
    } else if (commonjsGlobal.queueMicrotask) {
      nextTick = commonjsGlobal.queueMicrotask;
    } else if (commonjsGlobal.setImmediate) {
      nextTick = commonjsGlobal.setImmediate;
    } else {
      nextTick = commonjsGlobal.setTimeout;
    }
    return nextTick;
  }
  function browserPbkdf2(password, salt, iterations, length, algo) {
    return subtle.importKey(
      "raw",
      password,
      { name: "PBKDF2" },
      false,
      ["deriveBits"]
    ).then(function(key2) {
      return subtle.deriveBits({
        name: "PBKDF2",
        salt,
        iterations,
        hash: {
          name: algo
        }
      }, key2, length << 3);
    }).then(function(res) {
      return Buffer2.from(res);
    });
  }
  function resolvePromise(promise2, callback) {
    promise2.then(function(out) {
      getNextTick()(function() {
        callback(null, out);
      });
    }, function(e) {
      getNextTick()(function() {
        callback(e);
      });
    });
  }
  async = function(password, salt, iterations, keylen, digest, callback) {
    if (typeof digest === "function") {
      callback = digest;
      digest = void 0;
    }
    digest = digest || "sha1";
    var algo = toBrowser[digest.toLowerCase()];
    if (!algo || typeof commonjsGlobal.Promise !== "function") {
      getNextTick()(function() {
        var out;
        try {
          out = sync(password, salt, iterations, keylen, digest);
        } catch (e) {
          return callback(e);
        }
        callback(null, out);
      });
      return;
    }
    checkParameters(iterations, keylen);
    password = toBuffer2(password, defaultEncoding, "Password");
    salt = toBuffer2(salt, defaultEncoding, "Salt");
    if (typeof callback !== "function") throw new Error("No callback provided to pbkdf2");
    resolvePromise(checkNative(algo).then(function(resp) {
      if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
      return sync(password, salt, iterations, keylen, digest);
    }), callback);
  };
  return async;
}
var hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  browser$9.pbkdf2 = requireAsync();
  browser$9.pbkdf2Sync = requireSyncBrowser();
  return browser$9;
}
var browser$8 = {};
var des = {};
var utils$6 = {};
var hasRequiredUtils$6;
function requireUtils$6() {
  if (hasRequiredUtils$6) return utils$6;
  hasRequiredUtils$6 = 1;
  utils$6.readUInt32BE = function readUInt32BE(bytes, off) {
    var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
    return res >>> 0;
  };
  utils$6.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
    bytes[0 + off] = value >>> 24;
    bytes[1 + off] = value >>> 16 & 255;
    bytes[2 + off] = value >>> 8 & 255;
    bytes[3 + off] = value & 255;
  };
  utils$6.ip = function ip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i2 = 6; i2 >= 0; i2 -= 2) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >>> j + i2 & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inL >>> j + i2 & 1;
      }
    }
    for (var i2 = 6; i2 >= 0; i2 -= 2) {
      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= inR >>> j + i2 & 1;
      }
      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= inL >>> j + i2 & 1;
      }
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  utils$6.rip = function rip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i2 = 0; i2 < 4; i2++) {
      for (var j = 24; j >= 0; j -= 8) {
        outL <<= 1;
        outL |= inR >>> j + i2 & 1;
        outL <<= 1;
        outL |= inL >>> j + i2 & 1;
      }
    }
    for (var i2 = 4; i2 < 8; i2++) {
      for (var j = 24; j >= 0; j -= 8) {
        outR <<= 1;
        outR |= inR >>> j + i2 & 1;
        outR <<= 1;
        outR |= inL >>> j + i2 & 1;
      }
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  utils$6.pc1 = function pc1(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i2 = 7; i2 >= 5; i2--) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i2 & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inL >> j + i2 & 1;
      }
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >> j + i2 & 1;
    }
    for (var i2 = 1; i2 <= 3; i2++) {
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inR >> j + i2 & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i2 & 1;
      }
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inL >> j + i2 & 1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  utils$6.r28shl = function r28shl(num, shift) {
    return num << shift & 268435455 | num >>> 28 - shift;
  };
  var pc2table = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$6.pc2 = function pc2(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    var len2 = pc2table.length >>> 1;
    for (var i2 = 0; i2 < len2; i2++) {
      outL <<= 1;
      outL |= inL >>> pc2table[i2] & 1;
    }
    for (var i2 = len2; i2 < pc2table.length; i2++) {
      outR <<= 1;
      outR |= inR >>> pc2table[i2] & 1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  utils$6.expand = function expand(r, out, off) {
    var outL = 0;
    var outR = 0;
    outL = (r & 1) << 5 | r >>> 27;
    for (var i2 = 23; i2 >= 15; i2 -= 4) {
      outL <<= 6;
      outL |= r >>> i2 & 63;
    }
    for (var i2 = 11; i2 >= 3; i2 -= 4) {
      outR |= r >>> i2 & 63;
      outR <<= 6;
    }
    outR |= (r & 31) << 1 | r >>> 31;
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  var sTable = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$6.substitute = function substitute(inL, inR) {
    var out = 0;
    for (var i2 = 0; i2 < 4; i2++) {
      var b = inL >>> 18 - i2 * 6 & 63;
      var sb = sTable[i2 * 64 + b];
      out <<= 4;
      out |= sb;
    }
    for (var i2 = 0; i2 < 4; i2++) {
      var b = inR >>> 18 - i2 * 6 & 63;
      var sb = sTable[4 * 64 + i2 * 64 + b];
      out <<= 4;
      out |= sb;
    }
    return out >>> 0;
  };
  var permuteTable = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  utils$6.permute = function permute(num) {
    var out = 0;
    for (var i2 = 0; i2 < permuteTable.length; i2++) {
      out <<= 1;
      out |= num >>> permuteTable[i2] & 1;
    }
    return out >>> 0;
  };
  utils$6.padSplit = function padSplit(num, size, group) {
    var str = num.toString(2);
    while (str.length < size)
      str = "0" + str;
    var out = [];
    for (var i2 = 0; i2 < size; i2 += group)
      out.push(str.slice(i2, i2 + group));
    return out.join(" ");
  };
  return utils$6;
}
var minimalisticAssert;
var hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1;
  minimalisticAssert = assert;
  function assert(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || "Assertion failed: " + l + " != " + r);
  };
  return minimalisticAssert;
}
var cipher;
var hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var assert = requireMinimalisticAssert();
  function Cipher(options2) {
    this.options = options2;
    this.type = this.options.type;
    this.blockSize = 8;
    this._init();
    this.buffer = new Array(this.blockSize);
    this.bufferOff = 0;
  }
  cipher = Cipher;
  Cipher.prototype._init = function _init() {
  };
  Cipher.prototype.update = function update2(data) {
    if (data.length === 0)
      return [];
    if (this.type === "decrypt")
      return this._updateDecrypt(data);
    else
      return this._updateEncrypt(data);
  };
  Cipher.prototype._buffer = function _buffer(data, off) {
    var min2 = Math.min(this.buffer.length - this.bufferOff, data.length - off);
    for (var i2 = 0; i2 < min2; i2++)
      this.buffer[this.bufferOff + i2] = data[off + i2];
    this.bufferOff += min2;
    return min2;
  };
  Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
    this._update(this.buffer, 0, out, off);
    this.bufferOff = 0;
    return this.blockSize;
  };
  Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
    var inputOff = 0;
    var outputOff = 0;
    var count = (this.bufferOff + data.length) / this.blockSize | 0;
    var out = new Array(count * this.blockSize);
    if (this.bufferOff !== 0) {
      inputOff += this._buffer(data, inputOff);
      if (this.bufferOff === this.buffer.length)
        outputOff += this._flushBuffer(out, outputOff);
    }
    var max2 = data.length - (data.length - inputOff) % this.blockSize;
    for (; inputOff < max2; inputOff += this.blockSize) {
      this._update(data, inputOff, out, outputOff);
      outputOff += this.blockSize;
    }
    for (; inputOff < data.length; inputOff++, this.bufferOff++)
      this.buffer[this.bufferOff] = data[inputOff];
    return out;
  };
  Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
    var inputOff = 0;
    var outputOff = 0;
    var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
    var out = new Array(count * this.blockSize);
    for (; count > 0; count--) {
      inputOff += this._buffer(data, inputOff);
      outputOff += this._flushBuffer(out, outputOff);
    }
    inputOff += this._buffer(data, inputOff);
    return out;
  };
  Cipher.prototype.final = function final(buffer2) {
    var first;
    if (buffer2)
      first = this.update(buffer2);
    var last;
    if (this.type === "encrypt")
      last = this._finalEncrypt();
    else
      last = this._finalDecrypt();
    if (first)
      return first.concat(last);
    else
      return last;
  };
  Cipher.prototype._pad = function _pad(buffer2, off) {
    if (off === 0)
      return false;
    while (off < buffer2.length)
      buffer2[off++] = 0;
    return true;
  };
  Cipher.prototype._finalEncrypt = function _finalEncrypt() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var out = new Array(this.blockSize);
    this._update(this.buffer, 0, out, 0);
    return out;
  };
  Cipher.prototype._unpad = function _unpad(buffer2) {
    return buffer2;
  };
  Cipher.prototype._finalDecrypt = function _finalDecrypt() {
    assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var out = new Array(this.blockSize);
    this._flushBuffer(out, 0);
    return this._unpad(out);
  };
  return cipher;
}
var des_1;
var hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des_1;
  hasRequiredDes$1 = 1;
  var assert = requireMinimalisticAssert();
  var inherits = requireInherits_browser$4();
  var des2 = requireDes();
  var utils2 = des2.utils;
  var Cipher = des2.Cipher;
  function DESState() {
    this.tmp = new Array(2);
    this.keys = null;
  }
  function DES(options2) {
    Cipher.call(this, options2);
    var state2 = new DESState();
    this._desState = state2;
    this.deriveKeys(state2, options2.key);
  }
  inherits(DES, Cipher);
  des_1 = DES;
  DES.create = function create4(options2) {
    return new DES(options2);
  };
  var shiftTable = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  DES.prototype.deriveKeys = function deriveKeys(state2, key2) {
    state2.keys = new Array(16 * 2);
    assert.equal(key2.length, this.blockSize, "Invalid key length");
    var kL = utils2.readUInt32BE(key2, 0);
    var kR = utils2.readUInt32BE(key2, 4);
    utils2.pc1(kL, kR, state2.tmp, 0);
    kL = state2.tmp[0];
    kR = state2.tmp[1];
    for (var i2 = 0; i2 < state2.keys.length; i2 += 2) {
      var shift = shiftTable[i2 >>> 1];
      kL = utils2.r28shl(kL, shift);
      kR = utils2.r28shl(kR, shift);
      utils2.pc2(kL, kR, state2.keys, i2);
    }
  };
  DES.prototype._update = function _update(inp, inOff, out, outOff) {
    var state2 = this._desState;
    var l = utils2.readUInt32BE(inp, inOff);
    var r = utils2.readUInt32BE(inp, inOff + 4);
    utils2.ip(l, r, state2.tmp, 0);
    l = state2.tmp[0];
    r = state2.tmp[1];
    if (this.type === "encrypt")
      this._encrypt(state2, l, r, state2.tmp, 0);
    else
      this._decrypt(state2, l, r, state2.tmp, 0);
    l = state2.tmp[0];
    r = state2.tmp[1];
    utils2.writeUInt32BE(out, l, outOff);
    utils2.writeUInt32BE(out, r, outOff + 4);
  };
  DES.prototype._pad = function _pad(buffer2, off) {
    var value = buffer2.length - off;
    for (var i2 = off; i2 < buffer2.length; i2++)
      buffer2[i2] = value;
    return true;
  };
  DES.prototype._unpad = function _unpad(buffer2) {
    var pad = buffer2[buffer2.length - 1];
    for (var i2 = buffer2.length - pad; i2 < buffer2.length; i2++)
      assert.equal(buffer2[i2], pad);
    return buffer2.slice(0, buffer2.length - pad);
  };
  DES.prototype._encrypt = function _encrypt(state2, lStart, rStart, out, off) {
    var l = lStart;
    var r = rStart;
    for (var i2 = 0; i2 < state2.keys.length; i2 += 2) {
      var keyL = state2.keys[i2];
      var keyR = state2.keys[i2 + 1];
      utils2.expand(r, state2.tmp, 0);
      keyL ^= state2.tmp[0];
      keyR ^= state2.tmp[1];
      var s = utils2.substitute(keyL, keyR);
      var f = utils2.permute(s);
      var t2 = r;
      r = (l ^ f) >>> 0;
      l = t2;
    }
    utils2.rip(r, l, out, off);
  };
  DES.prototype._decrypt = function _decrypt(state2, lStart, rStart, out, off) {
    var l = rStart;
    var r = lStart;
    for (var i2 = state2.keys.length - 2; i2 >= 0; i2 -= 2) {
      var keyL = state2.keys[i2];
      var keyR = state2.keys[i2 + 1];
      utils2.expand(l, state2.tmp, 0);
      keyL ^= state2.tmp[0];
      keyR ^= state2.tmp[1];
      var s = utils2.substitute(keyL, keyR);
      var f = utils2.permute(s);
      var t2 = l;
      l = (r ^ f) >>> 0;
      r = t2;
    }
    utils2.rip(l, r, out, off);
  };
  return des_1;
}
var cbc$1 = {};
var hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var assert = requireMinimalisticAssert();
  var inherits = requireInherits_browser$4();
  var proto = {};
  function CBCState(iv) {
    assert.equal(iv.length, 8, "Invalid IV length");
    this.iv = new Array(8);
    for (var i2 = 0; i2 < this.iv.length; i2++)
      this.iv[i2] = iv[i2];
  }
  function instantiate(Base) {
    function CBC(options2) {
      Base.call(this, options2);
      this._cbcInit();
    }
    inherits(CBC, Base);
    var keys2 = Object.keys(proto);
    for (var i2 = 0; i2 < keys2.length; i2++) {
      var key2 = keys2[i2];
      CBC.prototype[key2] = proto[key2];
    }
    CBC.create = function create4(options2) {
      return new CBC(options2);
    };
    return CBC;
  }
  cbc$1.instantiate = instantiate;
  proto._cbcInit = function _cbcInit() {
    var state2 = new CBCState(this.options.iv);
    this._cbcState = state2;
  };
  proto._update = function _update(inp, inOff, out, outOff) {
    var state2 = this._cbcState;
    var superProto = this.constructor.super_.prototype;
    var iv = state2.iv;
    if (this.type === "encrypt") {
      for (var i2 = 0; i2 < this.blockSize; i2++)
        iv[i2] ^= inp[inOff + i2];
      superProto._update.call(this, iv, 0, out, outOff);
      for (var i2 = 0; i2 < this.blockSize; i2++)
        iv[i2] = out[outOff + i2];
    } else {
      superProto._update.call(this, inp, inOff, out, outOff);
      for (var i2 = 0; i2 < this.blockSize; i2++)
        out[outOff + i2] ^= iv[i2];
      for (var i2 = 0; i2 < this.blockSize; i2++)
        iv[i2] = inp[inOff + i2];
    }
  };
  return cbc$1;
}
var ede;
var hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var assert = requireMinimalisticAssert();
  var inherits = requireInherits_browser$4();
  var des2 = requireDes();
  var Cipher = des2.Cipher;
  var DES = des2.DES;
  function EDEState(type2, key2) {
    assert.equal(key2.length, 24, "Invalid key length");
    var k1 = key2.slice(0, 8);
    var k2 = key2.slice(8, 16);
    var k3 = key2.slice(16, 24);
    if (type2 === "encrypt") {
      this.ciphers = [
        DES.create({ type: "encrypt", key: k1 }),
        DES.create({ type: "decrypt", key: k2 }),
        DES.create({ type: "encrypt", key: k3 })
      ];
    } else {
      this.ciphers = [
        DES.create({ type: "decrypt", key: k3 }),
        DES.create({ type: "encrypt", key: k2 }),
        DES.create({ type: "decrypt", key: k1 })
      ];
    }
  }
  function EDE(options2) {
    Cipher.call(this, options2);
    var state2 = new EDEState(this.type, this.options.key);
    this._edeState = state2;
  }
  inherits(EDE, Cipher);
  ede = EDE;
  EDE.create = function create4(options2) {
    return new EDE(options2);
  };
  EDE.prototype._update = function _update(inp, inOff, out, outOff) {
    var state2 = this._edeState;
    state2.ciphers[0]._update(inp, inOff, out, outOff);
    state2.ciphers[1]._update(out, outOff, out, outOff);
    state2.ciphers[2]._update(out, outOff, out, outOff);
  };
  EDE.prototype._pad = DES.prototype._pad;
  EDE.prototype._unpad = DES.prototype._unpad;
  return ede;
}
var hasRequiredDes;
function requireDes() {
  if (hasRequiredDes) return des;
  hasRequiredDes = 1;
  des.utils = requireUtils$6();
  des.Cipher = requireCipher();
  des.DES = requireDes$1();
  des.CBC = requireCbc$1();
  des.EDE = requireEde();
  return des;
}
var browserifyDes;
var hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var CipherBase = requireCipherBase();
  var des2 = requireDes();
  var inherits = requireInherits_browser$4();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var modes2 = {
    "des-ede3-cbc": des2.CBC.instantiate(des2.EDE),
    "des-ede3": des2.EDE,
    "des-ede-cbc": des2.CBC.instantiate(des2.EDE),
    "des-ede": des2.EDE,
    "des-cbc": des2.CBC.instantiate(des2.DES),
    "des-ecb": des2.DES
  };
  modes2.des = modes2["des-cbc"];
  modes2.des3 = modes2["des-ede3-cbc"];
  browserifyDes = DES;
  inherits(DES, CipherBase);
  function DES(opts) {
    CipherBase.call(this);
    var modeName = opts.mode.toLowerCase();
    var mode = modes2[modeName];
    var type2;
    if (opts.decrypt) {
      type2 = "decrypt";
    } else {
      type2 = "encrypt";
    }
    var key2 = opts.key;
    if (!Buffer2.isBuffer(key2)) {
      key2 = Buffer2.from(key2);
    }
    if (modeName === "des-ede" || modeName === "des-ede-cbc") {
      key2 = Buffer2.concat([key2, key2.slice(0, 8)]);
    }
    var iv = opts.iv;
    if (!Buffer2.isBuffer(iv)) {
      iv = Buffer2.from(iv);
    }
    this._des = mode.create({
      key: key2,
      iv,
      type: type2
    });
  }
  DES.prototype._update = function(data) {
    return Buffer2.from(this._des.update(data));
  };
  DES.prototype._final = function() {
    return Buffer2.from(this._des.final());
  };
  return browserifyDes;
}
var browser$7 = {};
var encrypter = {};
var ecb = {};
var hasRequiredEcb;
function requireEcb() {
  if (hasRequiredEcb) return ecb;
  hasRequiredEcb = 1;
  ecb.encrypt = function(self2, block) {
    return self2._cipher.encryptBlock(block);
  };
  ecb.decrypt = function(self2, block) {
    return self2._cipher.decryptBlock(block);
  };
  return ecb;
}
var cbc = {};
var bufferXor;
var hasRequiredBufferXor;
function requireBufferXor() {
  if (hasRequiredBufferXor) return bufferXor;
  hasRequiredBufferXor = 1;
  bufferXor = function xor2(a, b) {
    var length = Math.min(a.length, b.length);
    var buffer2 = new Buffer(length);
    for (var i2 = 0; i2 < length; ++i2) {
      buffer2[i2] = a[i2] ^ b[i2];
    }
    return buffer2;
  };
  return bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var xor2 = requireBufferXor();
  cbc.encrypt = function(self2, block) {
    var data = xor2(block, self2._prev);
    self2._prev = self2._cipher.encryptBlock(data);
    return self2._prev;
  };
  cbc.decrypt = function(self2, block) {
    var pad = self2._prev;
    self2._prev = block;
    var out = self2._cipher.decryptBlock(block);
    return xor2(out, pad);
  };
  return cbc;
}
var cfb = {};
var hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var xor2 = requireBufferXor();
  function encryptStart(self2, data, decrypt) {
    var len2 = data.length;
    var out = xor2(data, self2._cache);
    self2._cache = self2._cache.slice(len2);
    self2._prev = Buffer2.concat([self2._prev, decrypt ? data : out]);
    return out;
  }
  cfb.encrypt = function(self2, data, decrypt) {
    var out = Buffer2.allocUnsafe(0);
    var len2;
    while (data.length) {
      if (self2._cache.length === 0) {
        self2._cache = self2._cipher.encryptBlock(self2._prev);
        self2._prev = Buffer2.allocUnsafe(0);
      }
      if (self2._cache.length <= data.length) {
        len2 = self2._cache.length;
        out = Buffer2.concat([out, encryptStart(self2, data.slice(0, len2), decrypt)]);
        data = data.slice(len2);
      } else {
        out = Buffer2.concat([out, encryptStart(self2, data, decrypt)]);
        break;
      }
    }
    return out;
  };
  return cfb;
}
var cfb8 = {};
var hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  function encryptByte(self2, byteParam, decrypt) {
    var pad = self2._cipher.encryptBlock(self2._prev);
    var out = pad[0] ^ byteParam;
    self2._prev = Buffer2.concat([
      self2._prev.slice(1),
      Buffer2.from([decrypt ? byteParam : out])
    ]);
    return out;
  }
  cfb8.encrypt = function(self2, chunk, decrypt) {
    var len2 = chunk.length;
    var out = Buffer2.allocUnsafe(len2);
    var i2 = -1;
    while (++i2 < len2) {
      out[i2] = encryptByte(self2, chunk[i2], decrypt);
    }
    return out;
  };
  return cfb8;
}
var cfb1 = {};
var hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  function encryptByte(self2, byteParam, decrypt) {
    var pad;
    var i2 = -1;
    var len2 = 8;
    var out = 0;
    var bit, value;
    while (++i2 < len2) {
      pad = self2._cipher.encryptBlock(self2._prev);
      bit = byteParam & 1 << 7 - i2 ? 128 : 0;
      value = pad[0] ^ bit;
      out += (value & 128) >> i2 % 8;
      self2._prev = shiftIn(self2._prev, decrypt ? bit : value);
    }
    return out;
  }
  function shiftIn(buffer2, value) {
    var len2 = buffer2.length;
    var i2 = -1;
    var out = Buffer2.allocUnsafe(buffer2.length);
    buffer2 = Buffer2.concat([buffer2, Buffer2.from([value])]);
    while (++i2 < len2) {
      out[i2] = buffer2[i2] << 1 | buffer2[i2 + 1] >> 7;
    }
    return out;
  }
  cfb1.encrypt = function(self2, chunk, decrypt) {
    var len2 = chunk.length;
    var out = Buffer2.allocUnsafe(len2);
    var i2 = -1;
    while (++i2 < len2) {
      out[i2] = encryptByte(self2, chunk[i2], decrypt);
    }
    return out;
  };
  return cfb1;
}
var ofb = {};
var hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var xor2 = requireBufferXor();
  function getBlock(self2) {
    self2._prev = self2._cipher.encryptBlock(self2._prev);
    return self2._prev;
  }
  ofb.encrypt = function(self2, chunk) {
    while (self2._cache.length < chunk.length) {
      self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);
    }
    var pad = self2._cache.slice(0, chunk.length);
    self2._cache = self2._cache.slice(chunk.length);
    return xor2(chunk, pad);
  };
  return ofb;
}
var ctr = {};
var incr32_1;
var hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function incr32(iv) {
    var len2 = iv.length;
    var item;
    while (len2--) {
      item = iv.readUInt8(len2);
      if (item === 255) {
        iv.writeUInt8(0, len2);
      } else {
        item++;
        iv.writeUInt8(item, len2);
        break;
      }
    }
  }
  incr32_1 = incr32;
  return incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var xor2 = requireBufferXor();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var incr32 = requireIncr32();
  function getBlock(self2) {
    var out = self2._cipher.encryptBlockRaw(self2._prev);
    incr32(self2._prev);
    return out;
  }
  var blockSize = 16;
  ctr.encrypt = function(self2, chunk) {
    var chunkNum = Math.ceil(chunk.length / blockSize);
    var start = self2._cache.length;
    self2._cache = Buffer2.concat([
      self2._cache,
      Buffer2.allocUnsafe(chunkNum * blockSize)
    ]);
    for (var i2 = 0; i2 < chunkNum; i2++) {
      var out = getBlock(self2);
      var offset = start + i2 * blockSize;
      self2._cache.writeUInt32BE(out[0], offset + 0);
      self2._cache.writeUInt32BE(out[1], offset + 4);
      self2._cache.writeUInt32BE(out[2], offset + 8);
      self2._cache.writeUInt32BE(out[3], offset + 12);
    }
    var pad = self2._cache.slice(0, chunk.length);
    self2._cache = self2._cache.slice(chunk.length);
    return xor2(chunk, pad);
  };
  return ctr;
}
const aes128 = { "cipher": "AES", "key": 128, "iv": 16, "mode": "CBC", "type": "block" };
const aes192 = { "cipher": "AES", "key": 192, "iv": 16, "mode": "CBC", "type": "block" };
const aes256 = { "cipher": "AES", "key": 256, "iv": 16, "mode": "CBC", "type": "block" };
const require$$2$1 = {
  "aes-128-ecb": { "cipher": "AES", "key": 128, "iv": 0, "mode": "ECB", "type": "block" },
  "aes-192-ecb": { "cipher": "AES", "key": 192, "iv": 0, "mode": "ECB", "type": "block" },
  "aes-256-ecb": { "cipher": "AES", "key": 256, "iv": 0, "mode": "ECB", "type": "block" },
  "aes-128-cbc": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CBC", "type": "block" },
  "aes-192-cbc": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CBC", "type": "block" },
  "aes-256-cbc": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CBC", "type": "block" },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB", "type": "stream" },
  "aes-192-cfb": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB", "type": "stream" },
  "aes-256-cfb": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB", "type": "stream" },
  "aes-128-cfb8": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB8", "type": "stream" },
  "aes-192-cfb8": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB8", "type": "stream" },
  "aes-256-cfb8": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB8", "type": "stream" },
  "aes-128-cfb1": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB1", "type": "stream" },
  "aes-192-cfb1": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB1", "type": "stream" },
  "aes-256-cfb1": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB1", "type": "stream" },
  "aes-128-ofb": { "cipher": "AES", "key": 128, "iv": 16, "mode": "OFB", "type": "stream" },
  "aes-192-ofb": { "cipher": "AES", "key": 192, "iv": 16, "mode": "OFB", "type": "stream" },
  "aes-256-ofb": { "cipher": "AES", "key": 256, "iv": 16, "mode": "OFB", "type": "stream" },
  "aes-128-ctr": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CTR", "type": "stream" },
  "aes-192-ctr": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CTR", "type": "stream" },
  "aes-256-ctr": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CTR", "type": "stream" },
  "aes-128-gcm": { "cipher": "AES", "key": 128, "iv": 12, "mode": "GCM", "type": "auth" },
  "aes-192-gcm": { "cipher": "AES", "key": 192, "iv": 12, "mode": "GCM", "type": "auth" },
  "aes-256-gcm": { "cipher": "AES", "key": 256, "iv": 12, "mode": "GCM", "type": "auth" }
};
var modes_1;
var hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var modeModules = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  };
  var modes2 = require$$2$1;
  for (var key2 in modes2) {
    modes2[key2].module = modeModules[modes2[key2].mode];
  }
  modes_1 = modes2;
  return modes_1;
}
var aes = {};
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  function asUInt32Array(buf) {
    if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
    var len2 = buf.length / 4 | 0;
    var out = new Array(len2);
    for (var i2 = 0; i2 < len2; i2++) {
      out[i2] = buf.readUInt32BE(i2 * 4);
    }
    return out;
  }
  function scrubVec(v) {
    for (var i2 = 0; i2 < v.length; v++) {
      v[i2] = 0;
    }
  }
  function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for (var round2 = 1; round2 < nRounds; round2++) {
      t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
      t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
      t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
      t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
      s0 = t0;
      s1 = t1;
      s2 = t2;
      s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [t0, t1, t2, t3];
  }
  var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var G = function() {
    var d = new Array(256);
    for (var j = 0; j < 256; j++) {
      if (j < 128) {
        d[j] = j << 1;
      } else {
        d[j] = j << 1 ^ 283;
      }
    }
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [[], [], [], []];
    var INV_SUB_MIX = [[], [], [], []];
    var x = 0;
    var xi = 0;
    for (var i2 = 0; i2 < 256; ++i2) {
      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 255 ^ 99;
      SBOX[x] = sx;
      INV_SBOX[sx] = x;
      var x2 = d[x];
      var x4 = d[x2];
      var x8 = d[x4];
      var t2 = d[sx] * 257 ^ sx * 16843008;
      SUB_MIX[0][x] = t2 << 24 | t2 >>> 8;
      SUB_MIX[1][x] = t2 << 16 | t2 >>> 16;
      SUB_MIX[2][x] = t2 << 8 | t2 >>> 24;
      SUB_MIX[3][x] = t2;
      t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      INV_SUB_MIX[0][sx] = t2 << 24 | t2 >>> 8;
      INV_SUB_MIX[1][sx] = t2 << 16 | t2 >>> 16;
      INV_SUB_MIX[2][sx] = t2 << 8 | t2 >>> 24;
      INV_SUB_MIX[3][sx] = t2;
      if (x === 0) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }
    return {
      SBOX,
      INV_SBOX,
      SUB_MIX,
      INV_SUB_MIX
    };
  }();
  function AES(key2) {
    this._key = asUInt32Array(key2);
    this._reset();
  }
  AES.blockSize = 4 * 4;
  AES.keySize = 256 / 8;
  AES.prototype.blockSize = AES.blockSize;
  AES.prototype.keySize = AES.keySize;
  AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for (var k = 0; k < keySize; k++) {
      keySchedule[k] = keyWords[k];
    }
    for (k = keySize; k < ksRows; k++) {
      var t2 = keySchedule[k - 1];
      if (k % keySize === 0) {
        t2 = t2 << 8 | t2 >>> 24;
        t2 = G.SBOX[t2 >>> 24] << 24 | G.SBOX[t2 >>> 16 & 255] << 16 | G.SBOX[t2 >>> 8 & 255] << 8 | G.SBOX[t2 & 255];
        t2 ^= RCON[k / keySize | 0] << 24;
      } else if (keySize > 6 && k % keySize === 4) {
        t2 = G.SBOX[t2 >>> 24] << 24 | G.SBOX[t2 >>> 16 & 255] << 16 | G.SBOX[t2 >>> 8 & 255] << 8 | G.SBOX[t2 & 255];
      }
      keySchedule[k] = keySchedule[k - keySize] ^ t2;
    }
    var invKeySchedule = [];
    for (var ik = 0; ik < ksRows; ik++) {
      var ksR = ksRows - ik;
      var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
      if (ik < 4 || ksR <= 4) {
        invKeySchedule[ik] = tt;
      } else {
        invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
      }
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
  };
  AES.prototype.encryptBlockRaw = function(M) {
    M = asUInt32Array(M);
    return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
  };
  AES.prototype.encryptBlock = function(M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer2.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
  };
  AES.prototype.decryptBlock = function(M) {
    M = asUInt32Array(M);
    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
    var buf = Buffer2.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
  };
  AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
  };
  aes.AES = AES;
  return aes;
}
var ghash;
var hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var ZEROES = Buffer2.alloc(16, 0);
  function toArray(buf) {
    return [
      buf.readUInt32BE(0),
      buf.readUInt32BE(4),
      buf.readUInt32BE(8),
      buf.readUInt32BE(12)
    ];
  }
  function fromArray(out) {
    var buf = Buffer2.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
  }
  function GHASH(key2) {
    this.h = key2;
    this.state = Buffer2.alloc(16, 0);
    this.cache = Buffer2.allocUnsafe(0);
  }
  GHASH.prototype.ghash = function(block) {
    var i2 = -1;
    while (++i2 < block.length) {
      this.state[i2] ^= block[i2];
    }
    this._multiply();
  };
  GHASH.prototype._multiply = function() {
    var Vi = toArray(this.h);
    var Zi = [0, 0, 0, 0];
    var j, xi, lsbVi;
    var i2 = -1;
    while (++i2 < 128) {
      xi = (this.state[~~(i2 / 8)] & 1 << 7 - i2 % 8) !== 0;
      if (xi) {
        Zi[0] ^= Vi[0];
        Zi[1] ^= Vi[1];
        Zi[2] ^= Vi[2];
        Zi[3] ^= Vi[3];
      }
      lsbVi = (Vi[3] & 1) !== 0;
      for (j = 3; j > 0; j--) {
        Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
      }
      Vi[0] = Vi[0] >>> 1;
      if (lsbVi) {
        Vi[0] = Vi[0] ^ 225 << 24;
      }
    }
    this.state = fromArray(Zi);
  };
  GHASH.prototype.update = function(buf) {
    this.cache = Buffer2.concat([this.cache, buf]);
    var chunk;
    while (this.cache.length >= 16) {
      chunk = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      this.ghash(chunk);
    }
  };
  GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) {
      this.ghash(Buffer2.concat([this.cache, ZEROES], 16));
    }
    this.ghash(fromArray([0, abl, 0, bl]));
    return this.state;
  };
  ghash = GHASH;
  return ghash;
}
var authCipher;
var hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var aes2 = requireAes();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var Transform = requireCipherBase();
  var inherits = requireInherits_browser$4();
  var GHASH = requireGhash();
  var xor2 = requireBufferXor();
  var incr32 = requireIncr32();
  function xorTest(a, b) {
    var out = 0;
    if (a.length !== b.length) out++;
    var len2 = Math.min(a.length, b.length);
    for (var i2 = 0; i2 < len2; ++i2) {
      out += a[i2] ^ b[i2];
    }
    return out;
  }
  function calcIv(self2, iv, ck) {
    if (iv.length === 12) {
      self2._finID = Buffer2.concat([iv, Buffer2.from([0, 0, 0, 1])]);
      return Buffer2.concat([iv, Buffer2.from([0, 0, 0, 2])]);
    }
    var ghash2 = new GHASH(ck);
    var len2 = iv.length;
    var toPad = len2 % 16;
    ghash2.update(iv);
    if (toPad) {
      toPad = 16 - toPad;
      ghash2.update(Buffer2.alloc(toPad, 0));
    }
    ghash2.update(Buffer2.alloc(8, 0));
    var ivBits = len2 * 8;
    var tail = Buffer2.alloc(8);
    tail.writeUIntBE(ivBits, 0, 8);
    ghash2.update(tail);
    self2._finID = ghash2.state;
    var out = Buffer2.from(self2._finID);
    incr32(out);
    return out;
  }
  function StreamCipher(mode, key2, iv, decrypt) {
    Transform.call(this);
    var h = Buffer2.alloc(4, 0);
    this._cipher = new aes2.AES(key2);
    var ck = this._cipher.encryptBlock(h);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer2.from(iv);
    this._cache = Buffer2.allocUnsafe(0);
    this._secCache = Buffer2.allocUnsafe(0);
    this._decrypt = decrypt;
    this._alen = 0;
    this._len = 0;
    this._mode = mode;
    this._authTag = null;
    this._called = false;
  }
  inherits(StreamCipher, Transform);
  StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
      var rump = 16 - this._alen % 16;
      if (rump < 16) {
        rump = Buffer2.alloc(rump, 0);
        this._ghash.update(rump);
      }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) {
      this._ghash.update(chunk);
    } else {
      this._ghash.update(out);
    }
    this._len += chunk.length;
    return out;
  };
  StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var tag = xor2(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = tag;
    this._cipher.scrub();
  };
  StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer2.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = tag;
  };
  StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(buf);
    this._alen += buf.length;
  };
  authCipher = StreamCipher;
  return authCipher;
}
var streamCipher;
var hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var aes2 = requireAes();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var Transform = requireCipherBase();
  var inherits = requireInherits_browser$4();
  function StreamCipher(mode, key2, iv, decrypt) {
    Transform.call(this);
    this._cipher = new aes2.AES(key2);
    this._prev = Buffer2.from(iv);
    this._cache = Buffer2.allocUnsafe(0);
    this._secCache = Buffer2.allocUnsafe(0);
    this._decrypt = decrypt;
    this._mode = mode;
  }
  inherits(StreamCipher, Transform);
  StreamCipher.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
  };
  StreamCipher.prototype._final = function() {
    this._cipher.scrub();
  };
  streamCipher = StreamCipher;
  return streamCipher;
}
var evp_bytestokey;
var hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var MD5 = requireMd5_js();
  function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer2.isBuffer(password)) password = Buffer2.from(password, "binary");
    if (salt) {
      if (!Buffer2.isBuffer(salt)) salt = Buffer2.from(salt, "binary");
      if (salt.length !== 8) throw new RangeError("salt should be Buffer with 8 byte length");
    }
    var keyLen = keyBits / 8;
    var key2 = Buffer2.alloc(keyLen);
    var iv = Buffer2.alloc(ivLen || 0);
    var tmp = Buffer2.alloc(0);
    while (keyLen > 0 || ivLen > 0) {
      var hash2 = new MD5();
      hash2.update(tmp);
      hash2.update(password);
      if (salt) hash2.update(salt);
      tmp = hash2.digest();
      var used = 0;
      if (keyLen > 0) {
        var keyStart = key2.length - keyLen;
        used = Math.min(keyLen, tmp.length);
        tmp.copy(key2, keyStart, 0, used);
        keyLen -= used;
      }
      if (used < tmp.length && ivLen > 0) {
        var ivStart = iv.length - ivLen;
        var length = Math.min(ivLen, tmp.length - used);
        tmp.copy(iv, ivStart, used, used + length);
        ivLen -= length;
      }
    }
    tmp.fill(0);
    return { key: key2, iv };
  }
  evp_bytestokey = EVP_BytesToKey;
  return evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var MODES = requireModes$1();
  var AuthCipher = requireAuthCipher();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var StreamCipher = requireStreamCipher();
  var Transform = requireCipherBase();
  var aes2 = requireAes();
  var ebtk = requireEvp_bytestokey();
  var inherits = requireInherits_browser$4();
  function Cipher(mode, key2, iv) {
    Transform.call(this);
    this._cache = new Splitter();
    this._cipher = new aes2.AES(key2);
    this._prev = Buffer2.from(iv);
    this._mode = mode;
    this._autopadding = true;
  }
  inherits(Cipher, Transform);
  Cipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while (chunk = this._cache.get()) {
      thing = this._mode.encrypt(this, chunk);
      out.push(thing);
    }
    return Buffer2.concat(out);
  };
  var PADDING = Buffer2.alloc(16, 16);
  Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
      chunk = this._mode.encrypt(this, chunk);
      this._cipher.scrub();
      return chunk;
    }
    if (!chunk.equals(PADDING)) {
      this._cipher.scrub();
      throw new Error("data not multiple of block length");
    }
  };
  Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
  };
  function Splitter() {
    this.cache = Buffer2.allocUnsafe(0);
  }
  Splitter.prototype.add = function(data) {
    this.cache = Buffer2.concat([this.cache, data]);
  };
  Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
      var out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
    return null;
  };
  Splitter.prototype.flush = function() {
    var len2 = 16 - this.cache.length;
    var padBuff = Buffer2.allocUnsafe(len2);
    var i2 = -1;
    while (++i2 < len2) {
      padBuff.writeUInt8(len2, i2);
    }
    return Buffer2.concat([this.cache, padBuff]);
  };
  function createCipheriv(suite, password, iv) {
    var config2 = MODES[suite.toLowerCase()];
    if (!config2) throw new TypeError("invalid suite type");
    if (typeof password === "string") password = Buffer2.from(password);
    if (password.length !== config2.key / 8) throw new TypeError("invalid key length " + password.length);
    if (typeof iv === "string") iv = Buffer2.from(iv);
    if (config2.mode !== "GCM" && iv.length !== config2.iv) throw new TypeError("invalid iv length " + iv.length);
    if (config2.type === "stream") {
      return new StreamCipher(config2.module, password, iv);
    } else if (config2.type === "auth") {
      return new AuthCipher(config2.module, password, iv);
    }
    return new Cipher(config2.module, password, iv);
  }
  function createCipher(suite, password) {
    var config2 = MODES[suite.toLowerCase()];
    if (!config2) throw new TypeError("invalid suite type");
    var keys2 = ebtk(password, false, config2.key, config2.iv);
    return createCipheriv(suite, keys2.key, keys2.iv);
  }
  encrypter.createCipheriv = createCipheriv;
  encrypter.createCipher = createCipher;
  return encrypter;
}
var decrypter = {};
var hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var AuthCipher = requireAuthCipher();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var MODES = requireModes$1();
  var StreamCipher = requireStreamCipher();
  var Transform = requireCipherBase();
  var aes2 = requireAes();
  var ebtk = requireEvp_bytestokey();
  var inherits = requireInherits_browser$4();
  function Decipher(mode, key2, iv) {
    Transform.call(this);
    this._cache = new Splitter();
    this._last = void 0;
    this._cipher = new aes2.AES(key2);
    this._prev = Buffer2.from(iv);
    this._mode = mode;
    this._autopadding = true;
  }
  inherits(Decipher, Transform);
  Decipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while (chunk = this._cache.get(this._autopadding)) {
      thing = this._mode.decrypt(this, chunk);
      out.push(thing);
    }
    return Buffer2.concat(out);
  };
  Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
      return unpad(this._mode.decrypt(this, chunk));
    } else if (chunk) {
      throw new Error("data not multiple of block length");
    }
  };
  Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
  };
  function Splitter() {
    this.cache = Buffer2.allocUnsafe(0);
  }
  Splitter.prototype.add = function(data) {
    this.cache = Buffer2.concat([this.cache, data]);
  };
  Splitter.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
      if (this.cache.length > 16) {
        out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
    } else {
      if (this.cache.length >= 16) {
        out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
    }
    return null;
  };
  Splitter.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function unpad(last) {
    var padded = last[15];
    if (padded < 1 || padded > 16) {
      throw new Error("unable to decrypt data");
    }
    var i2 = -1;
    while (++i2 < padded) {
      if (last[i2 + (16 - padded)] !== padded) {
        throw new Error("unable to decrypt data");
      }
    }
    if (padded === 16) return;
    return last.slice(0, 16 - padded);
  }
  function createDecipheriv(suite, password, iv) {
    var config2 = MODES[suite.toLowerCase()];
    if (!config2) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer2.from(iv);
    if (config2.mode !== "GCM" && iv.length !== config2.iv) throw new TypeError("invalid iv length " + iv.length);
    if (typeof password === "string") password = Buffer2.from(password);
    if (password.length !== config2.key / 8) throw new TypeError("invalid key length " + password.length);
    if (config2.type === "stream") {
      return new StreamCipher(config2.module, password, iv, true);
    } else if (config2.type === "auth") {
      return new AuthCipher(config2.module, password, iv, true);
    }
    return new Decipher(config2.module, password, iv);
  }
  function createDecipher(suite, password) {
    var config2 = MODES[suite.toLowerCase()];
    if (!config2) throw new TypeError("invalid suite type");
    var keys2 = ebtk(password, false, config2.key, config2.iv);
    return createDecipheriv(suite, keys2.key, keys2.iv);
  }
  decrypter.createDecipher = createDecipher;
  decrypter.createDecipheriv = createDecipheriv;
  return decrypter;
}
var hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$7;
  hasRequiredBrowser$8 = 1;
  var ciphers = requireEncrypter();
  var deciphers = requireDecrypter();
  var modes2 = require$$2$1;
  function getCiphers() {
    return Object.keys(modes2);
  }
  browser$7.createCipher = browser$7.Cipher = ciphers.createCipher;
  browser$7.createCipheriv = browser$7.Cipheriv = ciphers.createCipheriv;
  browser$7.createDecipher = browser$7.Decipher = deciphers.createDecipher;
  browser$7.createDecipheriv = browser$7.Decipheriv = deciphers.createDecipheriv;
  browser$7.listCiphers = browser$7.getCiphers = getCiphers;
  return browser$7;
}
var modes = {};
var hasRequiredModes;
function requireModes() {
  if (hasRequiredModes) return modes;
  hasRequiredModes = 1;
  (function(exports2) {
    exports2["des-ecb"] = {
      key: 8,
      iv: 0
    };
    exports2["des-cbc"] = exports2.des = {
      key: 8,
      iv: 8
    };
    exports2["des-ede3-cbc"] = exports2.des3 = {
      key: 24,
      iv: 8
    };
    exports2["des-ede3"] = {
      key: 24,
      iv: 0
    };
    exports2["des-ede-cbc"] = {
      key: 16,
      iv: 8
    };
    exports2["des-ede"] = {
      key: 16,
      iv: 0
    };
  })(modes);
  return modes;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  if (hasRequiredBrowser$7) return browser$8;
  hasRequiredBrowser$7 = 1;
  var DES = requireBrowserifyDes();
  var aes2 = requireBrowser$8();
  var aesModes = requireModes$1();
  var desModes = requireModes();
  var ebtk = requireEvp_bytestokey();
  function createCipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;
    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError("invalid suite type");
    }
    var keys2 = ebtk(password, false, keyLen, ivLen);
    return createCipheriv(suite, keys2.key, keys2.iv);
  }
  function createDecipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;
    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError("invalid suite type");
    }
    var keys2 = ebtk(password, false, keyLen, ivLen);
    return createDecipheriv(suite, keys2.key, keys2.iv);
  }
  function createCipheriv(suite, key2, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes2.createCipheriv(suite, key2, iv);
    if (desModes[suite]) return new DES({ key: key2, iv, mode: suite });
    throw new TypeError("invalid suite type");
  }
  function createDecipheriv(suite, key2, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes2.createDecipheriv(suite, key2, iv);
    if (desModes[suite]) return new DES({ key: key2, iv, mode: suite, decrypt: true });
    throw new TypeError("invalid suite type");
  }
  function getCiphers() {
    return Object.keys(desModes).concat(aes2.getCiphers());
  }
  browser$8.createCipher = browser$8.Cipher = createCipher;
  browser$8.createCipheriv = browser$8.Cipheriv = createCipheriv;
  browser$8.createDecipher = browser$8.Decipher = createDecipher;
  browser$8.createDecipheriv = browser$8.Decipheriv = createDecipheriv;
  browser$8.listCiphers = browser$8.getCiphers = getCiphers;
  return browser$8;
}
var browser$6 = {};
var bn$5 = { exports: {} };
var bn$4 = bn$5.exports;
var hasRequiredBn$2;
function requireBn$2() {
  if (hasRequiredBn$2) return bn$5.exports;
  hasRequiredBn$2 = 1;
  (function(module) {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base2, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = requireDist().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max2(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min2(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init2(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN.prototype._initArray = function _initArray(number, base2, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number.length; i2 += 3) {
            w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string2, index2) {
        var c = string2.charCodeAt(index2);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string2, lowerBound, index2) {
        var r = parseHex4Bits(string2, index2);
        if (index2 - 1 >= lowerBound) {
          r |= parseHex4Bits(string2, index2 - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len2 = Math.min(str.length, end);
        for (var i2 = start; i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow2 = 1;
          word = parseBase(number, i2, number.length, base2);
          for (i2 = 0; i2 < mod; i2++) {
            pow2 *= base2;
          }
          this.imuln(pow2);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy2(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer2(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength2 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i2;
        var q = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q.isZero(); i2++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i2 - 1] = b;
          }
        } else {
          for (i2 = 0; !q.isZero(); i2++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i2] = b;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w;
          var r = 0;
          if (t2 >= 4096) {
            r += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r += 2;
            t2 >>>= 2;
          }
          return r + t2;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t2 = w;
        var r = 0;
        if ((t2 & 8191) === 0) {
          r += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a.words[i2] ^ b.words[i2];
        }
        if (this !== a) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor2(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r = (a.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r = (a.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        if (carry === 0 && i2 < a.length && a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2;
        len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len2; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j;
            var a = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len2 < 63) {
          res = smallMulTo(this, num, out);
        } else if (len2 < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t2 = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i2 = 0; i2 < N; i2++) {
          t2[i2] = this.revBin(i2, l, N);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i2 = 0; i2 < l; i2++) {
          rb |= (x & 1) << l - i2 - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i2 = 0; i2 < N; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform2(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i2 = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i2 = 0; i2 < N / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N - i2 - 1];
          rws[N - i2 - 1] = t2;
          t2 = iws[i2];
          iws[i2] = -iws[N - i2 - 1];
          iws[N - i2 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i2 = 0; i2 < N / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
          ws[i2] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
        var carry = 0;
        for (var i2 = 0; i2 < len2; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len2; i2 < N; ++i2) {
          rws[i2] = 0;
        }
        assert(carry === 0);
        assert((carry & -8192) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i2 = 0; i2 < N; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _23 = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _23, rwst, iwst, N, rbt);
        this.transform(nrws, _23, nrwst, niwst, N, rbt);
        for (var i2 = 0; i2 < N; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _23, N, rbt);
        this.conjugate(rmws, _23, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow2(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0) break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s] = this.words[i2];
          }
          for (i2 = 0; i2 < s; i2++) {
            this.words[i2] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask2;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs2() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift;
        var i2;
        this._expand(len2);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b;
            b = t2;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red2(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output2) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output2.words[i2] = input.words[i2];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask2;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow2 = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow2);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t2 = this.pow(a, q);
        var m = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert(i2 < m);
          var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t2 = t2.redMul(c);
          m = i2;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow2(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont2(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t2 = a.imul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t2 = a.mul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, bn$4);
  })(bn$5);
  return bn$5.exports;
}
var brorand = { exports: {} };
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var r;
  brorand.exports = function rand(len2) {
    if (!r)
      r = new Rand(null);
    return r.generate(len2);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  brorand.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len2) {
    return this._rand(len2);
  };
  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for (var i2 = 0; i2 < res.length; i2++)
      res[i2] = this.rand.getByte();
    return res;
  };
  if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr2 = new Uint8Array(n);
        self.crypto.getRandomValues(arr2);
        return arr2;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr2 = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr2);
        return arr2;
      };
    } else if (typeof window === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      var crypto2 = requireCryptoBrowserify();
      if (typeof crypto2.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n) {
        return crypto2.randomBytes(n);
      };
    } catch (e) {
    }
  }
  return brorand.exports;
}
var mr;
var hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var bn2 = requireBn$2();
  var brorand2 = requireBrorand();
  function MillerRabin(rand) {
    this.rand = rand || new brorand2.Rand();
  }
  mr = MillerRabin;
  MillerRabin.create = function create4(rand) {
    return new MillerRabin(rand);
  };
  MillerRabin.prototype._randbelow = function _randbelow(n) {
    var len2 = n.bitLength();
    var min_bytes = Math.ceil(len2 / 8);
    do
      var a = new bn2(this.rand.generate(min_bytes));
    while (a.cmp(n) >= 0);
    return a;
  };
  MillerRabin.prototype._randrange = function _randrange(start, stop) {
    var size = stop.sub(start);
    return start.add(this._randbelow(size));
  };
  MillerRabin.prototype.test = function test(n, k, cb) {
    var len2 = n.bitLength();
    var red2 = bn2.mont(n);
    var rone = new bn2(1).toRed(red2);
    if (!k)
      k = Math.max(1, len2 / 48 | 0);
    var n1 = n.subn(1);
    for (var s = 0; !n1.testn(s); s++) {
    }
    var d = n.shrn(s);
    var rn1 = n1.toRed(red2);
    var prime = true;
    for (; k > 0; k--) {
      var a = this._randrange(new bn2(2), n1);
      if (cb)
        cb(a);
      var x = a.toRed(red2).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
        continue;
      for (var i2 = 1; i2 < s; i2++) {
        x = x.redSqr();
        if (x.cmp(rone) === 0)
          return false;
        if (x.cmp(rn1) === 0)
          break;
      }
      if (i2 === s)
        return false;
    }
    return prime;
  };
  MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
    var len2 = n.bitLength();
    var red2 = bn2.mont(n);
    var rone = new bn2(1).toRed(red2);
    if (!k)
      k = Math.max(1, len2 / 48 | 0);
    var n1 = n.subn(1);
    for (var s = 0; !n1.testn(s); s++) {
    }
    var d = n.shrn(s);
    var rn1 = n1.toRed(red2);
    for (; k > 0; k--) {
      var a = this._randrange(new bn2(2), n1);
      var g = n.gcd(a);
      if (g.cmpn(1) !== 0)
        return g;
      var x = a.toRed(red2).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
        continue;
      for (var i2 = 1; i2 < s; i2++) {
        x = x.redSqr();
        if (x.cmp(rone) === 0)
          return x.fromRed().subn(1).gcd(n);
        if (x.cmp(rn1) === 0)
          break;
      }
      if (i2 === s) {
        x = x.redSqr();
        return x.fromRed().subn(1).gcd(n);
      }
    }
    return false;
  };
  return mr;
}
var generatePrime;
var hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var randomBytes = requireBrowser$d();
  generatePrime = findPrime;
  findPrime.simpleSieve = simpleSieve;
  findPrime.fermatTest = fermatTest;
  var BN = requireBn$2();
  var TWENTYFOUR = new BN(24);
  var MillerRabin = requireMr();
  var millerRabin = new MillerRabin();
  var ONE = new BN(1);
  var TWO = new BN(2);
  var FIVE = new BN(5);
  new BN(16);
  new BN(8);
  var TEN = new BN(10);
  var THREE = new BN(3);
  new BN(7);
  var ELEVEN = new BN(11);
  var FOUR = new BN(4);
  new BN(12);
  var primes = null;
  function _getPrimes() {
    if (primes !== null)
      return primes;
    var limit = 1048576;
    var res = [];
    res[0] = 2;
    for (var i2 = 1, k = 3; k < limit; k += 2) {
      var sqrt = Math.ceil(Math.sqrt(k));
      for (var j = 0; j < i2 && res[j] <= sqrt; j++)
        if (k % res[j] === 0)
          break;
      if (i2 !== j && res[j] <= sqrt)
        continue;
      res[i2++] = k;
    }
    primes = res;
    return res;
  }
  function simpleSieve(p) {
    var primes2 = _getPrimes();
    for (var i2 = 0; i2 < primes2.length; i2++)
      if (p.modn(primes2[i2]) === 0) {
        if (p.cmpn(primes2[i2]) === 0) {
          return true;
        } else {
          return false;
        }
      }
    return true;
  }
  function fermatTest(p) {
    var red2 = BN.mont(p);
    return TWO.toRed(red2).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
  }
  function findPrime(bits, gen) {
    if (bits < 16) {
      if (gen === 2 || gen === 5) {
        return new BN([140, 123]);
      } else {
        return new BN([140, 39]);
      }
    }
    gen = new BN(gen);
    var num, n2;
    while (true) {
      num = new BN(randomBytes(Math.ceil(bits / 8)));
      while (num.bitLength() > bits) {
        num.ishrn(1);
      }
      if (num.isEven()) {
        num.iadd(ONE);
      }
      if (!num.testn(1)) {
        num.iadd(TWO);
      }
      if (!gen.cmp(TWO)) {
        while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
          num.iadd(FOUR);
        }
      } else if (!gen.cmp(FIVE)) {
        while (num.mod(TEN).cmp(THREE)) {
          num.iadd(FOUR);
        }
      }
      n2 = num.shrn(1);
      if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
        return num;
      }
    }
  }
  return generatePrime;
}
const modp1 = { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" };
const modp2 = { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" };
const modp5 = { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" };
const modp14 = { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" };
const modp15 = { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" };
const modp16 = { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" };
const modp17 = { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" };
const modp18 = { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" };
const require$$1$3 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh;
var hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var BN = requireBn$2();
  var MillerRabin = requireMr();
  var millerRabin = new MillerRabin();
  var TWENTYFOUR = new BN(24);
  var ELEVEN = new BN(11);
  var TEN = new BN(10);
  var THREE = new BN(3);
  var SEVEN = new BN(7);
  var primes = requireGeneratePrime();
  var randomBytes = requireBrowser$d();
  dh = DH;
  function setPublicKey(pub, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(pub)) {
      pub = new Buffer(pub, enc);
    }
    this._pub = new BN(pub);
    return this;
  }
  function setPrivateKey(priv, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(priv)) {
      priv = new Buffer(priv, enc);
    }
    this._priv = new BN(priv);
    return this;
  }
  var primeCache = {};
  function checkPrime(prime, generator) {
    var gen = generator.toString("hex");
    var hex = [gen, prime.toString(16)].join("_");
    if (hex in primeCache) {
      return primeCache[hex];
    }
    var error3 = 0;
    if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
      error3 += 1;
      if (gen === "02" || gen === "05") {
        error3 += 8;
      } else {
        error3 += 4;
      }
      primeCache[hex] = error3;
      return error3;
    }
    if (!millerRabin.test(prime.shrn(1))) {
      error3 += 2;
    }
    var rem;
    switch (gen) {
      case "02":
        if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
          error3 += 8;
        }
        break;
      case "05":
        rem = prime.mod(TEN);
        if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
          error3 += 8;
        }
        break;
      default:
        error3 += 4;
    }
    primeCache[hex] = error3;
    return error3;
  }
  function DH(prime, generator, malleable) {
    this.setGenerator(generator);
    this.__prime = new BN(prime);
    this._prime = BN.mont(this.__prime);
    this._primeLen = prime.length;
    this._pub = void 0;
    this._priv = void 0;
    this._primeCode = void 0;
    if (malleable) {
      this.setPublicKey = setPublicKey;
      this.setPrivateKey = setPrivateKey;
    } else {
      this._primeCode = 8;
    }
  }
  Object.defineProperty(DH.prototype, "verifyError", {
    enumerable: true,
    get: function() {
      if (typeof this._primeCode !== "number") {
        this._primeCode = checkPrime(this.__prime, this.__gen);
      }
      return this._primeCode;
    }
  });
  DH.prototype.generateKeys = function() {
    if (!this._priv) {
      this._priv = new BN(randomBytes(this._primeLen));
    }
    this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
    return this.getPublicKey();
  };
  DH.prototype.computeSecret = function(other) {
    other = new BN(other);
    other = other.toRed(this._prime);
    var secret = other.redPow(this._priv).fromRed();
    var out = new Buffer(secret.toArray());
    var prime = this.getPrime();
    if (out.length < prime.length) {
      var front = new Buffer(prime.length - out.length);
      front.fill(0);
      out = Buffer.concat([front, out]);
    }
    return out;
  };
  DH.prototype.getPublicKey = function getPublicKey(enc) {
    return formatReturnValue(this._pub, enc);
  };
  DH.prototype.getPrivateKey = function getPrivateKey(enc) {
    return formatReturnValue(this._priv, enc);
  };
  DH.prototype.getPrime = function(enc) {
    return formatReturnValue(this.__prime, enc);
  };
  DH.prototype.getGenerator = function(enc) {
    return formatReturnValue(this._gen, enc);
  };
  DH.prototype.setGenerator = function(gen, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(gen)) {
      gen = new Buffer(gen, enc);
    }
    this.__gen = gen;
    this._gen = new BN(gen);
    return this;
  };
  function formatReturnValue(bn2, enc) {
    var buf = new Buffer(bn2.toArray());
    if (!enc) {
      return buf;
    } else {
      return buf.toString(enc);
    }
  }
  return dh;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$6;
  hasRequiredBrowser$6 = 1;
  var generatePrime2 = requireGeneratePrime();
  var primes = require$$1$3;
  var DH = requireDh();
  function getDiffieHellman(mod) {
    var prime = new Buffer(primes[mod].prime, "hex");
    var gen = new Buffer(primes[mod].gen, "hex");
    return new DH(prime, gen);
  }
  var ENCODINGS = {
    "binary": true,
    "hex": true,
    "base64": true
  };
  function createDiffieHellman(prime, enc, generator, genc) {
    if (Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0) {
      return createDiffieHellman(prime, "binary", enc, generator);
    }
    enc = enc || "binary";
    genc = genc || "binary";
    generator = generator || new Buffer([2]);
    if (!Buffer.isBuffer(generator)) {
      generator = new Buffer(generator, genc);
    }
    if (typeof prime === "number") {
      return new DH(generatePrime2(prime, generator), generator, true);
    }
    if (!Buffer.isBuffer(prime)) {
      prime = new Buffer(prime, enc);
    }
    return new DH(prime, generator, true);
  }
  browser$6.DiffieHellmanGroup = browser$6.createDiffieHellmanGroup = browser$6.getDiffieHellman = getDiffieHellman;
  browser$6.createDiffieHellman = browser$6.DiffieHellman = createDiffieHellman;
  return browser$6;
}
var safeBuffer$2 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$2;
function requireSafeBuffer$2() {
  if (hasRequiredSafeBuffer$2) return safeBuffer$2.exports;
  hasRequiredSafeBuffer$2 = 1;
  (function(module, exports2) {
    var buffer2 = requireDist();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer$2, safeBuffer$2.exports);
  return safeBuffer$2.exports;
}
var readableBrowser$1 = { exports: {} };
var processNextickArgs = { exports: {} };
var hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1;
  if (!process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0) {
    processNextickArgs.exports = { nextTick };
  } else {
    processNextickArgs.exports = process$1;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len2 = arguments.length;
    var args, i2;
    switch (len2) {
      case 0:
      case 1:
        return process$1.nextTick(fn);
      case 2:
        return process$1.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process$1.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process$1.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len2 - 1);
        i2 = 0;
        while (i2 < args.length) {
          args[i2++] = arguments[i2];
        }
        return process$1.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var toString2 = {}.toString;
  isarray = Array.isArray || function(arr2) {
    return toString2.call(arr2) == "[object Array]";
  };
  return isarray;
}
var streamBrowser$1;
var hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  if (hasRequiredStreamBrowser$1) return streamBrowser$1;
  hasRequiredStreamBrowser$1 = 1;
  streamBrowser$1 = requireEvents().EventEmitter;
  return streamBrowser$1;
}
var util$1 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$1.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util$1.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  util$1.isNull = isNull;
  function isNullOrUndefined2(arg) {
    return arg == null;
  }
  util$1.isNullOrUndefined = isNullOrUndefined2;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  util$1.isNumber = isNumber;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util$1.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$1.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$1.isUndefined = isUndefined2;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  util$1.isRegExp = isRegExp;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$1.isObject = isObject2;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  util$1.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util$1.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$1.isFunction = isFunction2;
  function isPrimitive2(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$1.isPrimitive = isPrimitive2;
  util$1.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util$1;
}
var BufferList = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList) return BufferList.exports;
  hasRequiredBufferList = 1;
  (function(module) {
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$3().Buffer;
    var util2 = requireUtil$2();
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck2(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join3(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i2 = 0;
        while (p) {
          copyBuffer(p.data, ret, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList);
  return BufferList.exports;
}
var destroy_1$1;
var hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1$1 = {
    destroy,
    undestroy
  };
  return destroy_1$1;
}
var _stream_writable$1;
var hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$1 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits_browser$4();
  var internalUtil = {
    deprecate: requireBrowser$c()
  };
  var Stream = requireStreamBrowser$1();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$1();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options2, stream) {
    Duplex = Duplex || require_stream_duplex$1();
    options2 = options2 || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options2.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options2.writableObjectMode;
    var hwm = options2.highWaterMark;
    var writableHwm = options2.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options2.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_23) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options2) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options2);
    }
    this._writableState = new WritableState(options2, this);
    this.writable = true;
    if (options2) {
      if (typeof options2.write === "function") this._write = options2.write;
      if (typeof options2.writev === "function") this._writev = options2.writev;
      if (typeof options2.destroy === "function") this._destroy = options2.destroy;
      if (typeof options2.final === "function") this._final = options2.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len2 = state2.objectMode ? 1 : chunk.length;
    state2.length += len2;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len2, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
    state2.writelen = len2;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len2 = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len2, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable$1;
}
var _stream_duplex$1;
var hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key2 in obj) {
      keys3.push(key2);
    }
    return keys3;
  };
  _stream_duplex$1 = Duplex;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits_browser$4();
  var Readable = require_stream_readable$1();
  var Writable = require_stream_writable$1();
  util2.inherits(Duplex, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v = 0; v < keys2.length; v++) {
      var method = keys2[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options2) {
    if (!(this instanceof Duplex)) return new Duplex(options2);
    Readable.call(this, options2);
    Writable.call(this, options2);
    if (options2 && options2.readable === false) this.readable = false;
    if (options2 && options2.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options2 && options2.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex$1;
}
var _stream_readable$1;
var hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$1 = Readable;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  requireEvents().EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser$1();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits_browser$4();
  var debugUtil = requireUtil$2();
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList2 = requireBufferList();
  var destroyImpl = requireDestroy$1();
  var StringDecoder;
  util2.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options2, stream) {
    Duplex = Duplex || require_stream_duplex$1();
    options2 = options2 || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options2.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options2.readableObjectMode;
    var hwm = options2.highWaterMark;
    var readableHwm = options2.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options2.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options2.encoding);
      this.encoding = options2.encoding;
    }
  }
  function Readable(options2) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!(this instanceof Readable)) return new Readable(options2);
    this._readableState = new ReadableState(options2, this);
    this.readable = true;
    if (options2) {
      if (typeof options2.read === "function") this._read = options2.read;
      if (typeof options2.destroy === "function") this._destroy = options2.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream);
      else emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    var len2 = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len2 === state2.length)
        break;
      else len2 = state2.length;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len2 = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i2 = 0; i2 < len2; i2++) {
        dests[i2].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    if (!state2.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i2 in stream) {
      if (this[i2] === void 0 && typeof stream[i2] === "function") {
        this[i2] = /* @__PURE__ */ function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i2);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf2(xs, x) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x) return i2;
    }
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1;
var hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1;
  _stream_transform$1 = Transform;
  var Duplex = require_stream_duplex$1();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits_browser$4();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options2) {
    if (!(this instanceof Transform)) return new Transform(options2);
    Duplex.call(this, options2);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options2) {
      if (typeof options2.transform === "function") this._transform = options2.transform;
      if (typeof options2.flush === "function") this._flush = options2.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1;
var hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1;
  _stream_passthrough$1 = PassThrough;
  var Transform = require_stream_transform$1();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits_browser$4();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options2) {
    if (!(this instanceof PassThrough)) return new PassThrough(options2);
    Transform.call(this, options2);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  if (hasRequiredReadableBrowser$1) return readableBrowser$1.exports;
  hasRequiredReadableBrowser$1 = 1;
  (function(module, exports2) {
    exports2 = module.exports = require_stream_readable$1();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable$1();
    exports2.Duplex = require_stream_duplex$1();
    exports2.Transform = require_stream_transform$1();
    exports2.PassThrough = require_stream_passthrough$1();
  })(readableBrowser$1, readableBrowser$1.exports);
  return readableBrowser$1.exports;
}
var inherits_browser$2 = { exports: {} };
var hasRequiredInherits_browser$2;
function requireInherits_browser$2() {
  if (hasRequiredInherits_browser$2) return inherits_browser$2.exports;
  hasRequiredInherits_browser$2 = 1;
  if (typeof Object.create === "function") {
    inherits_browser$2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser$2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser$2.exports;
}
var sign = { exports: {} };
var bn$3 = { exports: {} };
var bn$2 = bn$3.exports;
var hasRequiredBn$1;
function requireBn$1() {
  if (hasRequiredBn$1) return bn$3.exports;
  hasRequiredBn$1 = 1;
  (function(module) {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base2, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = requireDist().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max2(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min2(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init2(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN.prototype._initArray = function _initArray(number, base2, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number.length; i2 += 3) {
            w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index2) {
        var c = string2.charCodeAt(index2);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index2) {
        var r = parseHex4Bits(string2, index2);
        if (index2 - 1 >= lowerBound) {
          r |= parseHex4Bits(string2, index2 - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len2 = Math.min(str.length, end);
        for (var i2 = start; i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow2 = 1;
          word = parseBase(number, i2, number.length, base2);
          for (i2 = 0; i2 < mod; i2++) {
            pow2 *= base2;
          }
          this.imuln(pow2);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy2(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength2 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength2);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position = 0;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position = res.length - 1;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w;
          var r = 0;
          if (t2 >= 4096) {
            r += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r += 2;
            t2 >>>= 2;
          }
          return r + t2;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t2 = w;
        var r = 0;
        if ((t2 & 8191) === 0) {
          r += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a.words[i2] ^ b.words[i2];
        }
        if (this !== a) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor2(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r = (a.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r = (a.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        if (carry === 0 && i2 < a.length && a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2;
        len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len2; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j;
            var a = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len2 < 63) {
          res = smallMulTo(this, num, out);
        } else if (len2 < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow2(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0) break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s] = this.words[i2];
          }
          for (i2 = 0; i2 < s; i2++) {
            this.words[i2] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs2() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift;
        var i2;
        this._expand(len2);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0) return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p * acc + (this.words[i2] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b;
            b = t2;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red2(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output2) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output2.words[i2] = input.words[i2];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask2;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow2 = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow2);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t2 = this.pow(a, q);
        var m = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert(i2 < m);
          var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t2 = t2.redMul(c);
          m = i2;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow2(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont2(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t2 = a.imul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t2 = a.mul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, bn$2);
  })(bn$3);
  return bn$3.exports;
}
var safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  if (hasRequiredSafeBuffer$1) return safeBuffer$1.exports;
  hasRequiredSafeBuffer$1 = 1;
  (function(module, exports2) {
    var buffer2 = requireDist();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer$1, safeBuffer$1.exports);
  return safeBuffer$1.exports;
}
var browserifyRsa;
var hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var BN = requireBn$1();
  var randomBytes = requireBrowser$d();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  function getr(priv) {
    var len2 = priv.modulus.byteLength();
    var r;
    do {
      r = new BN(randomBytes(len2));
    } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
    return r;
  }
  function blind(priv) {
    var r = getr(priv);
    var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
    return { blinder, unblinder: r.invm(priv.modulus) };
  }
  function crt(msg, priv) {
    var blinds = blind(priv);
    var len2 = priv.modulus.byteLength();
    var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
    var c1 = blinded.toRed(BN.mont(priv.prime1));
    var c2 = blinded.toRed(BN.mont(priv.prime2));
    var qinv = priv.coefficient;
    var p = priv.prime1;
    var q = priv.prime2;
    var m1 = c1.redPow(priv.exponent1).fromRed();
    var m2 = c2.redPow(priv.exponent2).fromRed();
    var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
    return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer2, "be", len2);
  }
  crt.getr = getr;
  browserifyRsa = crt;
  return browserifyRsa;
}
var elliptic = {};
const version$2 = "6.6.1";
const require$$0$2 = {
  version: version$2
};
var utils$5 = {};
var utils$4 = {};
var hasRequiredUtils$5;
function requireUtils$5() {
  if (hasRequiredUtils$5) return utils$4;
  hasRequiredUtils$5 = 1;
  (function(exports2) {
    var utils2 = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      } else {
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c = msg.charCodeAt(i2);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils2.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils2.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    utils2.toHex = toHex;
    utils2.encode = function encode(arr2, enc) {
      if (enc === "hex")
        return toHex(arr2);
      else
        return arr2;
    };
  })(utils$4);
  return utils$4;
}
var hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$5;
  hasRequiredUtils$4 = 1;
  (function(exports2) {
    var utils2 = exports2;
    var BN = requireBn$2();
    var minAssert = requireMinimalisticAssert();
    var minUtils = requireUtils$5();
    utils2.assert = minAssert;
    utils2.toArray = minUtils.toArray;
    utils2.zero2 = minUtils.zero2;
    utils2.toHex = minUtils.toHex;
    utils2.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i2;
      for (i2 = 0; i2 < naf.length; i2 += 1) {
        naf[i2] = 0;
      }
      var ws = 1 << w + 1;
      var k = num.clone();
      for (i2 = 0; i2 < naf.length; i2++) {
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z = (ws >> 1) - mod;
          else
            z = mod;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i2] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils2.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils2.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key2 = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils2.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
    }
    utils2.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils2.intFromLE = intFromLE;
  })(utils$5);
  return utils$5;
}
var curve = {};
var base$1;
var hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$1;
  hasRequiredBase$1 = 1;
  var BN = requireBn$2();
  var utils2 = requireUtils$4();
  var getNAF = utils2.getNAF;
  var getJSF = utils2.getJSF;
  var assert = utils2.assert;
  function BaseCurve(type2, conf) {
    this.type = type2;
    this.p = new BN(conf.p, 16);
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  base$1 = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    var j;
    var nafW;
    for (j = 0; j < naf.length; j += doubles.step) {
      nafW = 0;
      for (var l = j + doubles.step - 1; l >= j; l--)
        nafW = (nafW << 1) + naf[l];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i2 = I; i2 > 0; i2--) {
      for (j = 0; j < repr.length; j++) {
        nafW = repr[j];
        if (nafW === i2)
          b = b.mixedAdd(doubles.points[j]);
        else if (nafW === -i2)
          b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k, w, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i2 = naf.length - 1; i2 >= 0; i2--) {
      for (var l = 0; i2 >= 0 && naf[i2] === 0; i2--)
        l++;
      if (i2 >= 0)
        l++;
      acc = acc.dblp(l);
      if (i2 < 0)
        break;
      var z = naf[i2];
      assert(z !== 0);
      if (p.type === "affine") {
        if (z > 0)
          acc = acc.mixedAdd(wnd[z - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
      } else {
        if (z > 0)
          acc = acc.add(wnd[z - 1 >> 1]);
        else
          acc = acc.add(wnd[-z - 1 >> 1].neg());
      }
    }
    return p.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max2 = 0;
    var i2;
    var j;
    var p;
    for (i2 = 0; i2 < len2; i2++) {
      p = points[i2];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i2] = nafPoints.wnd;
      wnd[i2] = nafPoints.points;
    }
    for (i2 = len2 - 1; i2 >= 1; i2 -= 2) {
      var a = i2 - 1;
      var b = i2;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
        max2 = Math.max(naf[a].length, max2);
        max2 = Math.max(naf[b].length, max2);
        continue;
      }
      var comb = [
        points[a],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        points[b]
        /* 7 */
      ];
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
      var index2 = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ];
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max2 = Math.max(jsf[0].length, max2);
      naf[a] = new Array(max2);
      naf[b] = new Array(max2);
      for (j = 0; j < max2; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i2 = max2; i2 >= 0; i2--) {
      var k = 0;
      while (i2 >= 0) {
        var zero = true;
        for (j = 0; j < len2; j++) {
          tmp[j] = naf[j][i2] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k++;
        i2--;
      }
      if (i2 >= 0)
        k++;
      acc = acc.dblp(k);
      if (i2 < 0)
        break;
      for (j = 0; j < len2; j++) {
        var z = tmp[j];
        if (z === 0)
          continue;
        else if (z > 0)
          p = wnd[j][z - 1 >> 1];
        else if (z < 0)
          p = wnd[j][-z - 1 >> 1].neg();
        if (p.type === "affine")
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    for (i2 = 0; i2 < len2; i2++)
      wnd[i2] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve2, type2) {
    this.curve = curve2;
    this.type = type2;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils2.toArray(bytes, enc);
    var len2 = this.p.byteLength();
    if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len2) {
      if (bytes[0] === 6)
        assert(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 7)
        assert(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(
        bytes.slice(1, 1 + len2),
        bytes.slice(1 + len2, 1 + 2 * len2)
      );
      return res;
    } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len2) {
      return this.pointFromX(bytes.slice(1, 1 + len2), bytes[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len2 = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len2);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x);
    return [4].concat(x, this.getY().toArray("be", len2));
  };
  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils2.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i2 = 0; i2 < power; i2 += step) {
      for (var j = 0; j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max2 = (1 << wnd) - 1;
    var dbl = max2 === 1 ? null : this.dbl();
    for (var i2 = 1; i2 < max2; i2++)
      res[i2] = res[i2 - 1].add(dbl);
    return {
      wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i2 = 0; i2 < k; i2++)
      r = r.dbl();
    return r;
  };
  return base$1;
}
var inherits_browser$1 = { exports: {} };
var hasRequiredInherits_browser$1;
function requireInherits_browser$1() {
  if (hasRequiredInherits_browser$1) return inherits_browser$1.exports;
  hasRequiredInherits_browser$1 = 1;
  if (typeof Object.create === "function") {
    inherits_browser$1.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser$1.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser$1.exports;
}
var short;
var hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var utils2 = requireUtils$4();
  var BN = requireBn$2();
  var inherits = requireInherits_browser$1();
  var Base = requireBase$1();
  var assert = utils2.assert;
  function ShortCurve(conf) {
    Base.call(this, "short", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits(ShortCurve, Base);
  short = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN(vec.a, 16),
          b: new BN(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red2 = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red2).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN(3).toRed(red2).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y2 = new BN(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i2 = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i2 === 2) {
        break;
      }
      prevR = r;
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 }
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return { k1, k2 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i2 = 0; i2 < points.length; i2++) {
      var split = this._endoSplit(coeffs[i2]);
      var p = points[i2];
      var beta = p._getBeta();
      if (split.k1.negative) {
        split.k1.ineg();
        p = p.neg(true);
      }
      if (split.k2.negative) {
        split.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i2 * 2] = p;
      npoints[i2 * 2 + 1] = beta;
      ncoeffs[i2 * 2] = split.k1;
      ncoeffs[i2 * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
    for (var j = 0; j < i2 * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  function Point(curve2, x, y, isRed) {
    Base.BasePoint.call(this, curve2, "affine");
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red2) {
    return Point.fromJSON(this, obj, red2);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve2 = this.curve;
      var endoMul = function(p) {
        return curve2.point(p.x.redMul(curve2.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve2, obj, red2) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve2.point(obj[0], obj[1], red2);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve2.point(obj2[0], obj2[1], red2);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add(p) {
    if (this.inf)
      return p;
    if (p.inf)
      return this;
    if (this.eq(p))
      return this.dbl();
    if (this.neg().eq(p))
      return this.curve.point(null, null);
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k]);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve2, x, y, z) {
    Base.BasePoint.call(this, curve2, "jacobian");
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN(0);
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = new BN(z, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    if (this.isInfinity())
      return p.toJ();
    if (p.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow2) {
    if (pow2 === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow2)
      return this.dbl();
    var i2;
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (i2 = 0; i2 < pow2; i2++)
        r = r.dbl();
      return r;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i2 = 0; i2 < pow2; i2++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i2 + 1 < pow2)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t2 = m.redSqr().redISub(s).redISub(s);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t2;
      ny = m.redMul(s.redISub(t2)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = b.redSqr();
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t2 = m.redSqr().redISub(s).redISub(s);
      nx = t2;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t2)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t2 = yyyy.redIAdd(yyyy);
    t2 = t2.redIAdd(t2);
    t2 = t2.redIAdd(t2);
    t2 = t2.redIAdd(t2);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t2);
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u.redMul(t2.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
    return this.curve._wnafMul(this, k);
  };
  JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine")
      return this.eq(p.toJ());
    if (this === p)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t2 = this.curve.redN.redMul(zs);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t2);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  return short;
}
var mont;
var hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var BN = requireBn$2();
  var inherits = requireInherits_browser$1();
  var Base = requireBase$1();
  var utils2 = requireUtils$4();
  function MontCurve(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits(MontCurve, Base);
  mont = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  function Point(curve2, x, z) {
    Base.BasePoint.call(this, curve2, "projective");
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN(x, 16);
      this.z = new BN(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits(Point, Base.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils2.toArray(bytes, enc), 1);
  };
  MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  Point.prototype.precompute = function precompute() {
  };
  Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Point.fromJSON = function fromJSON(curve2, obj) {
    return new Point(curve2, obj[0], obj[1] || curve2.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b = this.x.redSub(this.z);
    var bb = b.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.diffAdd = function diffAdd(p, diff) {
    var a = this.x.redAdd(this.z);
    var b = this.x.redSub(this.z);
    var c = p.x.redAdd(p.z);
    var d = p.x.redSub(p.z);
    var da = d.redMul(a);
    var cb = c.redMul(b);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k) {
    var t2 = k.clone();
    var a = this;
    var b = this.curve.point(null, null);
    var c = this;
    for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
      bits.push(t2.andln(1));
    for (var i2 = bits.length - 1; i2 >= 0; i2--) {
      if (bits[i2] === 0) {
        a = a.diffAdd(b, c);
        b = b.dbl();
      } else {
        b = a.diffAdd(b, c);
        a = a.dbl();
      }
    }
    return b;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  return mont;
}
var edwards;
var hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var utils2 = requireUtils$4();
  var BN = requireBn$2();
  var inherits = requireInherits_browser$1();
  var Base = requireBase$1();
  var assert = utils2.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits(EdwardsCurve, Base);
  edwards = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t2) {
    return this.point(x, y, z, t2);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red)
      y = y.toRed(this.red);
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error("invalid point");
      else
        return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd)
      x = x.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };
  function Point(curve2, x, y, z, t2) {
    Base.BasePoint.call(this, curve2, "projective");
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = z ? new BN(z, 16) : this.curve.one;
      this.t = t2 && new BN(t2, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x, y, z, t2) {
    return new Point(this, x, y, z, t2);
  };
  Point.fromJSON = function fromJSON(curve2, obj) {
    return new Point(curve2, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Point.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    var g = d.redAdd(b);
    var f = g.redSub(c);
    var h = d.redSub(b);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
      e = this.curve._mulA(c);
      var f = e.redAdd(d);
      if (this.zOne) {
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        ny = f.redMul(e.redSub(d));
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        h = this.z.redSqr();
        j = f.redSub(h).redISub(h);
        nx = b.redSub(c).redISub(d).redMul(j);
        ny = f.redMul(e.redSub(d));
        nz = f.redMul(j);
      }
    } else {
      e = c.redAdd(d);
      h = this.curve._mulC(this.z).redSqr();
      j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p) {
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    var d = this.z.redMul(p.z.redAdd(p.z));
    var e = b.redSub(a);
    var f = d.redSub(c);
    var g = d.redAdd(c);
    var h = b.redAdd(a);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p) {
    var a = this.z.redMul(p.z);
    var b = a.redSqr();
    var c = this.x.redMul(p.x);
    var d = this.y.redMul(p.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f = b.redSub(e);
    var g = b.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      nz = f.redMul(g);
    } else {
      ny = a.redMul(g).redMul(d.redSub(c));
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };
  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
  };
  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t2 = this.curve.redN.redMul(this.z);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t2);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
  return edwards;
}
var hasRequiredCurve;
function requireCurve() {
  if (hasRequiredCurve) return curve;
  hasRequiredCurve = 1;
  (function(exports2) {
    var curve2 = exports2;
    curve2.base = requireBase$1();
    curve2.short = requireShort();
    curve2.mont = requireMont();
    curve2.edwards = requireEdwards();
  })(curve);
  return curve;
}
var curves = {};
var hash = {};
var utils$3 = {};
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  var assert = requireMinimalisticAssert();
  var inherits = requireInherits_browser$4();
  utils$3.inherits = inherits;
  function isSurrogatePair(msg, i2) {
    if ((msg.charCodeAt(i2) & 64512) !== 55296) {
      return false;
    }
    if (i2 < 0 || i2 + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p = 0;
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c = msg.charCodeAt(i2);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = c >> 6 | 192;
            res[p++] = c & 63 | 128;
          } else if (isSurrogatePair(msg, i2)) {
            c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
            res[p++] = c >> 18 | 240;
            res[p++] = c >> 12 & 63 | 128;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          } else {
            res[p++] = c >> 12 | 224;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      }
    } else {
      for (i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
    }
    return res;
  }
  utils$3.toArray = toArray;
  function toHex(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils$3.toHex = toHex;
  function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
    return res >>> 0;
  }
  utils$3.htonl = htonl;
  function toHex32(msg, endian) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++) {
      var w = msg[i2];
      if (endian === "little")
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils$3.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils$3.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  }
  utils$3.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len2 = end - start;
    assert(len2 % 4 === 0);
    var res = new Array(len2 / 4);
    for (var i2 = 0, k = start; i2 < res.length; i2++, k += 4) {
      var w;
      if (endian === "big")
        w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
      else
        w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
      res[i2] = w >>> 0;
    }
    return res;
  }
  utils$3.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i2 = 0, k = 0; i2 < msg.length; i2++, k += 4) {
      var m = msg[i2];
      if (endian === "big") {
        res[k] = m >>> 24;
        res[k + 1] = m >>> 16 & 255;
        res[k + 2] = m >>> 8 & 255;
        res[k + 3] = m & 255;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = m >>> 16 & 255;
        res[k + 1] = m >>> 8 & 255;
        res[k] = m & 255;
      }
    }
    return res;
  }
  utils$3.split32 = split32;
  function rotr32(w, b) {
    return w >>> b | w << 32 - b;
  }
  utils$3.rotr32 = rotr32;
  function rotl32(w, b) {
    return w << b | w >>> 32 - b;
  }
  utils$3.rotl32 = rotl32;
  function sum32(a, b) {
    return a + b >>> 0;
  }
  utils$3.sum32 = sum32;
  function sum32_3(a, b, c) {
    return a + b + c >>> 0;
  }
  utils$3.sum32_3 = sum32_3;
  function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
  }
  utils$3.sum32_4 = sum32_4;
  function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
  }
  utils$3.sum32_5 = sum32_5;
  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  utils$3.sum64 = sum64;
  function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  utils$3.sum64_hi = sum64_hi;
  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  utils$3.sum64_lo = sum64_lo;
  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh2, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh2 + carry;
    return hi >>> 0;
  }
  utils$3.sum64_4_hi = sum64_4_hi;
  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh2, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  utils$3.sum64_4_lo = sum64_4_lo;
  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh2, dl, eh, el2) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el2 >>> 0;
    carry += lo < el2 ? 1 : 0;
    var hi = ah + bh + ch + dh2 + eh + carry;
    return hi >>> 0;
  }
  utils$3.sum64_5_hi = sum64_5_hi;
  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh2, dl, eh, el2) {
    var lo = al + bl + cl + dl + el2;
    return lo >>> 0;
  }
  utils$3.sum64_5_lo = sum64_5_lo;
  function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
  }
  utils$3.rotr64_hi = rotr64_hi;
  function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }
  utils$3.rotr64_lo = rotr64_lo;
  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }
  utils$3.shr64_hi = shr64_hi;
  function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }
  utils$3.shr64_lo = shr64_lo;
  return utils$3;
}
var common$2 = {};
var hasRequiredCommon$2;
function requireCommon$2() {
  if (hasRequiredCommon$2) return common$2;
  hasRequiredCommon$2 = 1;
  var utils2 = requireUtils$3();
  var assert = requireMinimalisticAssert();
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$2.BlockHash = BlockHash;
  BlockHash.prototype.update = function update2(msg, enc) {
    msg = utils2.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils2.join32(msg, 0, msg.length - r, this.endian);
      for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
        this._update(msg, i2, i2 + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len2 = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len2 + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 128;
    for (var i2 = 1; i2 < k; i2++)
      res[i2] = 0;
    len2 <<= 3;
    if (this.endian === "big") {
      for (var t2 = 8; t2 < this.padLength; t2++)
        res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = len2 >>> 24 & 255;
      res[i2++] = len2 >>> 16 & 255;
      res[i2++] = len2 >>> 8 & 255;
      res[i2++] = len2 & 255;
    } else {
      res[i2++] = len2 & 255;
      res[i2++] = len2 >>> 8 & 255;
      res[i2++] = len2 >>> 16 & 255;
      res[i2++] = len2 >>> 24 & 255;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      for (t2 = 8; t2 < this.padLength; t2++)
        res[i2++] = 0;
    }
    return res;
  };
  return common$2;
}
var sha = {};
var common$1 = {};
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var utils2 = requireUtils$3();
  var rotr32 = utils2.rotr32;
  function ft_1(s, x, y, z) {
    if (s === 0)
      return ch32(x, y, z);
    if (s === 1 || s === 3)
      return p32(x, y, z);
    if (s === 2)
      return maj32(x, y, z);
  }
  common$1.ft_1 = ft_1;
  function ch32(x, y, z) {
    return x & y ^ ~x & z;
  }
  common$1.ch32 = ch32;
  function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  common$1.maj32 = maj32;
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  common$1.p32 = p32;
  function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  common$1.s0_256 = s0_256;
  function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  common$1.s1_256 = s1_256;
  function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
  }
  common$1.g0_256 = g0_256;
  function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
  }
  common$1.g1_256 = g1_256;
  return common$1;
}
var _1;
var hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var utils2 = requireUtils$3();
  var common2 = requireCommon$2();
  var shaCommon = requireCommon$1();
  var rotl32 = utils2.rotl32;
  var sum32 = utils2.sum32;
  var sum32_5 = utils2.sum32_5;
  var ft_1 = shaCommon.ft_1;
  var BlockHash = common2.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  utils2.inherits(SHA1, BlockHash);
  _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2++)
      W[i2] = rotl32(W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (i2 = 0; i2 < W.length; i2++) {
      var s = ~~(i2 / 20);
      var t2 = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i2], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t2;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  return _1;
}
var _256;
var hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var utils2 = requireUtils$3();
  var common2 = requireCommon$2();
  var shaCommon = requireCommon$1();
  var assert = requireMinimalisticAssert();
  var sum32 = utils2.sum32;
  var sum32_4 = utils2.sum32_4;
  var sum32_5 = utils2.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash = common2.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function SHA256() {
    if (!(this instanceof SHA256))
      return new SHA256();
    BlockHash.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils2.inherits(SHA256, BlockHash);
  _256 = SHA256;
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2++)
      W[i2] = sum32_4(g1_256(W[i2 - 2]), W[i2 - 7], g0_256(W[i2 - 15]), W[i2 - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for (i2 = 0; i2 < W.length; i2++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i2], W[i2]);
      var T2 = sum32(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  return _256;
}
var _224;
var hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var utils2 = requireUtils$3();
  var SHA256 = require_256();
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  utils2.inherits(SHA224, SHA256);
  _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h.slice(0, 7), "big");
    else
      return utils2.split32(this.h.slice(0, 7), "big");
  };
  return _224;
}
var _512;
var hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var utils2 = requireUtils$3();
  var common2 = requireCommon$2();
  var assert = requireMinimalisticAssert();
  var rotr64_hi = utils2.rotr64_hi;
  var rotr64_lo = utils2.rotr64_lo;
  var shr64_hi = utils2.shr64_hi;
  var shr64_lo = utils2.shr64_lo;
  var sum64 = utils2.sum64;
  var sum64_hi = utils2.sum64_hi;
  var sum64_lo = utils2.sum64_lo;
  var sum64_4_hi = utils2.sum64_4_hi;
  var sum64_4_lo = utils2.sum64_4_lo;
  var sum64_5_hi = utils2.sum64_5_hi;
  var sum64_5_lo = utils2.sum64_5_lo;
  var BlockHash = common2.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function SHA512() {
    if (!(this instanceof SHA512))
      return new SHA512();
    BlockHash.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils2.inherits(SHA512, BlockHash);
  _512 = SHA512;
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 32; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2 += 2) {
      var c0_hi = g1_512_hi(W[i2 - 4], W[i2 - 3]);
      var c0_lo = g1_512_lo(W[i2 - 4], W[i2 - 3]);
      var c1_hi = W[i2 - 14];
      var c1_lo = W[i2 - 13];
      var c2_hi = g0_512_hi(W[i2 - 30], W[i2 - 29]);
      var c2_lo = g0_512_lo(W[i2 - 30], W[i2 - 29]);
      var c3_hi = W[i2 - 32];
      var c3_lo = W[i2 - 31];
      W[i2] = sum64_4_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
      W[i2 + 1] = sum64_4_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
    }
  };
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh2 = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el2 = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for (var i2 = 0; i2 < W.length; i2 += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el2);
      var c1_lo = s1_512_lo(eh, el2);
      var c2_hi = ch64_hi(eh, el2, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el2, fh, fl, gh, gl);
      var c3_hi = this.k[i2];
      var c3_lo = this.k[i2 + 1];
      var c4_hi = W[i2];
      var c4_lo = W[i2 + 1];
      var T1_hi = sum64_5_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      var T1_lo = sum64_5_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el2;
      eh = sum64_hi(dh2, dl, T1_hi, T1_lo);
      el2 = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh2 = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh2, dl);
    sum64(this.h, 8, eh, el2);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  return _512;
}
var _384;
var hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var utils2 = requireUtils$3();
  var SHA512 = require_512();
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  utils2.inherits(SHA384, SHA512);
  _384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h.slice(0, 12), "big");
    else
      return utils2.split32(this.h.slice(0, 12), "big");
  };
  return _384;
}
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha;
  hasRequiredSha = 1;
  sha.sha1 = require_1();
  sha.sha224 = require_224();
  sha.sha256 = require_256();
  sha.sha384 = require_384();
  sha.sha512 = require_512();
  return sha;
}
var ripemd = {};
var hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var utils2 = requireUtils$3();
  var common2 = requireCommon$2();
  var rotl32 = utils2.rotl32;
  var sum32 = utils2.sum32;
  var sum32_3 = utils2.sum32_3;
  var sum32_4 = utils2.sum32_4;
  var BlockHash = common2.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  utils2.inherits(RIPEMD160, BlockHash);
  ripemd.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update2(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(
        rotl32(
          sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
          s[j]
        ),
        E
      );
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(
        rotl32(
          sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
          sh[j]
        ),
        Eh
      );
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "little");
    else
      return utils2.split32(this.h, "little");
  };
  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return x & y | ~x & z;
    else if (j <= 47)
      return (x | ~y) ^ z;
    else if (j <= 63)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  function K(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  }
  function Kh(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  }
  var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac;
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var utils2 = requireUtils$3();
  var assert = requireMinimalisticAssert();
  function Hmac(hash2, key2, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash2, key2, enc);
    this.Hash = hash2;
    this.blockSize = hash2.blockSize / 8;
    this.outSize = hash2.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils2.toArray(key2, enc));
  }
  hmac = Hmac;
  Hmac.prototype._init = function init2(key2) {
    if (key2.length > this.blockSize)
      key2 = new this.Hash().update(key2).digest();
    assert(key2.length <= this.blockSize);
    for (var i2 = key2.length; i2 < this.blockSize; i2++)
      key2.push(0);
    for (i2 = 0; i2 < key2.length; i2++)
      key2[i2] ^= 54;
    this.inner = new this.Hash().update(key2);
    for (i2 = 0; i2 < key2.length; i2++)
      key2[i2] ^= 106;
    this.outer = new this.Hash().update(key2);
  };
  Hmac.prototype.update = function update2(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  return hmac;
}
var hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash;
  hasRequiredHash = 1;
  (function(exports2) {
    var hash2 = exports2;
    hash2.utils = requireUtils$3();
    hash2.common = requireCommon$2();
    hash2.sha = requireSha();
    hash2.ripemd = requireRipemd();
    hash2.hmac = requireHmac();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  })(hash);
  return hash;
}
var secp256k1;
var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1) return secp256k1;
  hasRequiredSecp256k1 = 1;
  secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
  return secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  if (hasRequiredCurves) return curves;
  hasRequiredCurves = 1;
  (function(exports2) {
    var curves2 = exports2;
    var hash2 = requireHash();
    var curve2 = requireCurve();
    var utils2 = requireUtils$4();
    var assert = utils2.assert;
    function PresetCurve(options2) {
      if (options2.type === "short")
        this.curve = new curve2.short(options2);
      else if (options2.type === "edwards")
        this.curve = new curve2.edwards(options2);
      else
        this.curve = new curve2.mont(options2);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options2.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves2.PresetCurve = PresetCurve;
    function defineCurve(name, options2) {
      Object.defineProperty(curves2, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve3 = new PresetCurve(options2);
          Object.defineProperty(curves2, name, {
            configurable: true,
            enumerable: true,
            value: curve3
          });
          return curve3;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = requireSecp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  })(curves);
  return curves;
}
var hmacDrbg;
var hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var hash2 = requireHash();
  var utils2 = requireUtils$5();
  var assert = requireMinimalisticAssert();
  function HmacDRBG(options2) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options2);
    this.hash = options2.hash;
    this.predResist = !!options2.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options2.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils2.toArray(options2.entropy, options2.entropyEnc || "hex");
    var nonce = utils2.toArray(options2.nonce, options2.nonceEnc || "hex");
    var pers = utils2.toArray(options2.pers, options2.persEnc || "hex");
    assert(
      entropy.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    );
    this._init(entropy, nonce, pers);
  }
  hmacDrbg = HmacDRBG;
  HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i2 = 0; i2 < this.V.length; i2++) {
      this.K[i2] = 0;
      this.V[i2] = 1;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 281474976710656;
  };
  HmacDRBG.prototype._hmac = function hmac2() {
    return new hash2.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update2(seed) {
    var kmac = this._hmac().update(this.V).update([0]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    if (typeof entropyEnc !== "string") {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils2.toArray(entropy, entropyEnc);
    add = utils2.toArray(add, addEnc);
    assert(
      entropy.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    );
    this._update(entropy.concat(add || []));
    this._reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len2, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    if (typeof enc !== "string") {
      addEnc = add;
      add = enc;
      enc = null;
    }
    if (add) {
      add = utils2.toArray(add, addEnc || "hex");
      this._update(add);
    }
    var temp = [];
    while (temp.length < len2) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len2);
    this._update(add);
    this._reseed++;
    return utils2.encode(res, enc);
  };
  return hmacDrbg;
}
var key$1;
var hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var BN = requireBn$2();
  var utils2 = requireUtils$4();
  var assert = utils2.assert;
  function KeyPair(ec2, options2) {
    this.ec = ec2;
    this.priv = null;
    this.pub = null;
    if (options2.priv)
      this._importPrivate(options2.priv, options2.privEnc);
    if (options2.pub)
      this._importPublic(options2.pub, options2.pubEnc);
  }
  key$1 = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec2, {
      pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec2, {
      priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
    this.priv = new BN(key2, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
    if (key2.x || key2.y) {
      if (this.ec.curve.type === "mont") {
        assert(key2.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert(key2.x && key2.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key2.x, key2.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key2, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert(pub.validate(), "public point not validated");
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign2(msg, enc, options2) {
    return this.ec.sign(msg, this, enc, options2);
  };
  KeyPair.prototype.verify = function verify(msg, signature2, options2) {
    return this.ec.verify(msg, signature2, this, void 0, options2);
  };
  KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
  return key$1;
}
var signature$1;
var hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var BN = requireBn$2();
  var utils2 = requireUtils$4();
  var assert = utils2.assert;
  function Signature(options2, enc) {
    if (options2 instanceof Signature)
      return options2;
    if (this._importDER(options2, enc))
      return;
    assert(options2.r && options2.s, "Signature without r or s");
    this.r = new BN(options2.r, 16);
    this.s = new BN(options2.s, 16);
    if (options2.recoveryParam === void 0)
      this.recoveryParam = null;
    else
      this.recoveryParam = options2.recoveryParam;
  }
  signature$1 = Signature;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p) {
    var initial2 = buf[p.place++];
    if (!(initial2 & 128)) {
      return initial2;
    }
    var octetLen = initial2 & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    if (buf[p.place] === 0) {
      return false;
    }
    var val = 0;
    for (var i2 = 0, off = p.place; i2 < octetLen; i2++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i2 = 0;
    var len2 = buf.length - 1;
    while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2) {
      i2++;
    }
    if (i2 === 0) {
      return buf;
    }
    return buf.slice(i2);
  }
  Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils2.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 48) {
      return false;
    }
    var len2 = getLength(data, p);
    if (len2 === false) {
      return false;
    }
    if (len2 + p.place !== data.length) {
      return false;
    }
    if (data[p.place++] !== 2) {
      return false;
    }
    var rlen = getLength(data, p);
    if (rlen === false) {
      return false;
    }
    if ((data[p.place] & 128) !== 0) {
      return false;
    }
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 2) {
      return false;
    }
    var slen = getLength(data, p);
    if (slen === false) {
      return false;
    }
    if (data.length !== slen + p.place) {
      return false;
    }
    if ((data[p.place] & 128) !== 0) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
      if (r[1] & 128) {
        r = r.slice(1);
      } else {
        return false;
      }
    }
    if (s[0] === 0) {
      if (s[1] & 128) {
        s = s.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr2, len2) {
    if (len2 < 128) {
      arr2.push(len2);
      return;
    }
    var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
    arr2.push(octets | 128);
    while (--octets) {
      arr2.push(len2 >>> (octets << 3) & 255);
    }
    arr2.push(len2);
  }
  Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    if (r[0] & 128)
      r = [0].concat(r);
    if (s[0] & 128)
      s = [0].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while (!s[0] && !(s[1] & 128)) {
      s = s.slice(1);
    }
    var arr2 = [2];
    constructLength(arr2, r.length);
    arr2 = arr2.concat(r);
    arr2.push(2);
    constructLength(arr2, s.length);
    var backHalf = arr2.concat(s);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils2.encode(res, enc);
  };
  return signature$1;
}
var ec;
var hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var BN = requireBn$2();
  var HmacDRBG = requireHmacDrbg();
  var utils2 = requireUtils$4();
  var curves2 = requireCurves();
  var rand = requireBrorand();
  var assert = utils2.assert;
  var KeyPair = requireKey$1();
  var Signature = requireSignature$1();
  function EC(options2) {
    if (!(this instanceof EC))
      return new EC(options2);
    if (typeof options2 === "string") {
      assert(
        Object.prototype.hasOwnProperty.call(curves2, options2),
        "Unknown curve " + options2
      );
      options2 = curves2[options2];
    }
    if (options2 instanceof curves2.PresetCurve)
      options2 = { curve: options2 };
    this.curve = options2.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options2.curve.g;
    this.g.precompute(options2.curve.n.bitLength() + 1);
    this.hash = options2.hash || options2.curve.hash;
  }
  ec = EC;
  EC.prototype.keyPair = function keyPair(options2) {
    return new KeyPair(this, options2);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options2) {
    if (!options2)
      options2 = {};
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options2.pers,
      persEnc: options2.persEnc || "utf8",
      entropy: options2.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options2.entropy && options2.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    for (; ; ) {
      var priv = new BN(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
    var byteLength2;
    if (BN.isBN(msg) || typeof msg === "number") {
      msg = new BN(msg, 16);
      byteLength2 = msg.byteLength();
    } else if (typeof msg === "object") {
      byteLength2 = msg.length;
      msg = new BN(msg, 16);
    } else {
      var str = msg.toString();
      byteLength2 = str.length + 1 >>> 1;
      msg = new BN(str, 16);
    }
    if (typeof bitLength !== "number") {
      bitLength = byteLength2 * 8;
    }
    var delta = bitLength - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign2(msg, key2, enc, options2) {
    if (typeof enc === "object") {
      options2 = enc;
      enc = null;
    }
    if (!options2)
      options2 = {};
    if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
      assert(
        typeof msg === "object" && msg && typeof msg.length === "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      );
      assert(msg.length >>> 0 === msg.length);
      for (var i2 = 0; i2 < msg.length; i2++) assert((msg[i2] & 255) === msg[i2]);
    }
    key2 = this.keyFromPrivate(key2, enc);
    msg = this._truncateToN(msg, false, options2.msgBitLength);
    assert(!msg.isNeg(), "Can not sign a negative message");
    var bytes = this.n.byteLength();
    var bkey = key2.getPrivate().toArray("be", bytes);
    var nonce = msg.toArray("be", bytes);
    assert(new BN(nonce).eq(msg), "Can not sign message");
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options2.pers,
      persEnc: options2.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN(1));
    for (var iter = 0; ; iter++) {
      var k = options2.k ? options2.k(iter) : new BN(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0)
        continue;
      var s = k.invm(this.n).mul(r.mul(key2.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
      if (options2.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }
      return new Signature({ r, s, recoveryParam });
    }
  };
  EC.prototype.verify = function verify(msg, signature2, key2, enc, options2) {
    if (!options2)
      options2 = {};
    msg = this._truncateToN(msg, false, options2.msgBitLength);
    key2 = this.keyFromPublic(key2, enc);
    signature2 = new Signature(signature2, "hex");
    var r = signature2.r;
    var s = signature2.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
      p = this.g.mulAdd(u1, key2.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.getX().umod(this.n).cmp(r) === 0;
    }
    p = this.g.jmulAdd(u1, key2.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.eqXToP(r);
  };
  EC.prototype.recoverPubKey = function(msg, signature2, j, enc) {
    assert((3 & j) === j, "The recovery param is more than two bits");
    signature2 = new Signature(signature2, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature2.r;
    var s = signature2.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else
      r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature2.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    return this.g.mulAdd(s1, r, s2);
  };
  EC.prototype.getKeyRecoveryParam = function(e, signature2, Q, enc) {
    signature2 = new Signature(signature2, enc);
    if (signature2.recoveryParam !== null)
      return signature2.recoveryParam;
    for (var i2 = 0; i2 < 4; i2++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature2, i2);
      } catch (e2) {
        continue;
      }
      if (Qprime.eq(Q))
        return i2;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  return ec;
}
var key;
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var utils2 = requireUtils$4();
  var assert = utils2.assert;
  var parseBytes = utils2.parseBytes;
  var cachedProperty = utils2.cachedProperty;
  function KeyPair(eddsa2, params) {
    this.eddsa = eddsa2;
    this._secret = parseBytes(params.secret);
    if (eddsa2.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes(params.pub);
  }
  KeyPair.fromPublic = function fromPublic(eddsa2, pub) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(eddsa2, { pub });
  };
  KeyPair.fromSecret = function fromSecret(eddsa2, secret) {
    if (secret instanceof KeyPair)
      return secret;
    return new KeyPair(eddsa2, { secret });
  };
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa2 = this.eddsa;
    var hash2 = this.hash();
    var lastIx = eddsa2.encodingLength - 1;
    var a = hash2.slice(0, eddsa2.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty(KeyPair, "hash", function hash2() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair.prototype.sign = function sign2(message) {
    assert(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
  };
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, "KeyPair is public only");
    return utils2.encode(this.secret(), enc);
  };
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils2.encode(this.pubBytes(), enc);
  };
  key = KeyPair;
  return key;
}
var signature;
var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var BN = requireBn$2();
  var utils2 = requireUtils$4();
  var assert = utils2.assert;
  var cachedProperty = utils2.cachedProperty;
  var parseBytes = utils2.parseBytes;
  function Signature(eddsa2, sig) {
    this.eddsa = eddsa2;
    if (typeof sig !== "object")
      sig = parseBytes(sig);
    if (Array.isArray(sig)) {
      assert(sig.length === eddsa2.encodingLength * 2, "Signature has invalid size");
      sig = {
        R: sig.slice(0, eddsa2.encodingLength),
        S: sig.slice(eddsa2.encodingLength)
      };
    }
    assert(sig.R && sig.S, "Signature without R or S");
    if (eddsa2.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty(Signature, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature.prototype.toHex = function toHex() {
    return utils2.encode(this.toBytes(), "hex").toUpperCase();
  };
  signature = Signature;
  return signature;
}
var eddsa;
var hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var hash2 = requireHash();
  var curves2 = requireCurves();
  var utils2 = requireUtils$4();
  var assert = utils2.assert;
  var parseBytes = utils2.parseBytes;
  var KeyPair = requireKey();
  var Signature = requireSignature();
  function EDDSA(curve2) {
    assert(curve2 === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA))
      return new EDDSA(curve2);
    curve2 = curves2[curve2].curve;
    this.curve = curve2;
    this.g = curve2.g;
    this.g.precompute(curve2.n.bitLength() + 1);
    this.pointClass = curve2.point().constructor;
    this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
    this.hash = hash2.sha512;
  }
  eddsa = EDDSA;
  EDDSA.prototype.sign = function sign2(message, secret) {
    message = parseBytes(message);
    var key2 = this.keyFromSecret(secret);
    var r = this.hashInt(key2.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key2.pubBytes(), message).mul(key2.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({ R, S, Rencoded });
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
      return false;
    }
    var key2 = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key2.pub().mul(h));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash3 = this.hash();
    for (var i2 = 0; i2 < arguments.length; i2++)
      hash3.update(arguments[i2]);
    return utils2.intFromLE(hash3.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils2.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
    var xIsOdd = (bytes[lastIx] & 128) !== 0;
    var y = utils2.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils2.intFromLE(bytes);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
  return eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  if (hasRequiredElliptic) return elliptic;
  hasRequiredElliptic = 1;
  (function(exports2) {
    var elliptic2 = exports2;
    elliptic2.version = require$$0$2.version;
    elliptic2.utils = requireUtils$4();
    elliptic2.rand = requireBrorand();
    elliptic2.curve = requireCurve();
    elliptic2.curves = requireCurves();
    elliptic2.ec = requireEc();
    elliptic2.eddsa = requireEddsa();
  })(elliptic);
  return elliptic;
}
var bn$1 = { exports: {} };
var bn = bn$1.exports;
var hasRequiredBn;
function requireBn() {
  if (hasRequiredBn) return bn$1.exports;
  hasRequiredBn = 1;
  (function(module) {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base2, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = requireDist().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max2(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min2(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init2(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN.prototype._initArray = function _initArray(number, base2, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number.length; i2 += 3) {
            w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index2) {
        var c = string2.charCodeAt(index2);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index2) {
        var r = parseHex4Bits(string2, index2);
        if (index2 - 1 >= lowerBound) {
          r |= parseHex4Bits(string2, index2 - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len2 = Math.min(str.length, end);
        for (var i2 = start; i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow2 = 1;
          word = parseBase(number, i2, number.length, base2);
          for (i2 = 0; i2 < mod; i2++) {
            pow2 *= base2;
          }
          this.imuln(pow2);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy2(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength2 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength2);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position = 0;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position = res.length - 1;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w;
          var r = 0;
          if (t2 >= 4096) {
            r += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r += 2;
            t2 >>>= 2;
          }
          return r + t2;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t2 = w;
        var r = 0;
        if ((t2 & 8191) === 0) {
          r += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a.words[i2] ^ b.words[i2];
        }
        if (this !== a) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor2(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r = (a.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r = (a.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        if (carry === 0 && i2 < a.length && a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2;
        len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len2; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j;
            var a = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len2 < 63) {
          res = smallMulTo(this, num, out);
        } else if (len2 < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow2(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0) break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s] = this.words[i2];
          }
          for (i2 = 0; i2 < s; i2++) {
            this.words[i2] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs2() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift;
        var i2;
        this._expand(len2);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0) return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p * acc + (this.words[i2] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b;
            b = t2;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red2(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output2) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output2.words[i2] = input.words[i2];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask2;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow2 = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow2);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t2 = this.pow(a, q);
        var m = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert(i2 < m);
          var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t2 = t2.redMul(c);
          m = i2;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow2(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont2(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t2 = a.imul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t2 = a.mul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, bn);
  })(bn$1);
  return bn$1.exports;
}
var asn1$1 = {};
var asn1 = {};
var api$1 = {};
var vmBrowserify = {};
var hasRequiredVmBrowserify;
function requireVmBrowserify() {
  if (hasRequiredVmBrowserify) return vmBrowserify;
  hasRequiredVmBrowserify = 1;
  (function(exports) {
    var indexOf = function(xs, item) {
      if (xs.indexOf) return xs.indexOf(item);
      else for (var i2 = 0; i2 < xs.length; i2++) {
        if (xs[i2] === item) return i2;
      }
      return -1;
    };
    var Object_keys = function(obj) {
      if (Object.keys) return Object.keys(obj);
      else {
        var res = [];
        for (var key2 in obj) res.push(key2);
        return res;
      }
    };
    var forEach = function(xs, fn) {
      if (xs.forEach) return xs.forEach(fn);
      else for (var i2 = 0; i2 < xs.length; i2++) {
        fn(xs[i2], i2, xs);
      }
    };
    var defineProp = function() {
      try {
        Object.defineProperty({}, "_", {});
        return function(obj, name, value) {
          Object.defineProperty(obj, name, {
            writable: true,
            enumerable: false,
            configurable: true,
            value
          });
        };
      } catch (e) {
        return function(obj, name, value) {
          obj[name] = value;
        };
      }
    }();
    var globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function NodeScript(code2) {
      if (!(this instanceof Script)) return new Script(code2);
      this.code = code2;
    };
    Script.prototype.runInContext = function(context2) {
      if (!(context2 instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
      }
      var iframe = document.createElement("iframe");
      if (!iframe.style) iframe.style = {};
      iframe.style.display = "none";
      document.body.appendChild(iframe);
      var win = iframe.contentWindow;
      var wEval = win.eval, wExecScript = win.execScript;
      if (!wEval && wExecScript) {
        wExecScript.call(win, "null");
        wEval = win.eval;
      }
      forEach(Object_keys(context2), function(key2) {
        win[key2] = context2[key2];
      });
      forEach(globals, function(key2) {
        if (context2[key2]) {
          win[key2] = context2[key2];
        }
      });
      var winKeys = Object_keys(win);
      var res = wEval.call(win, this.code);
      forEach(Object_keys(win), function(key2) {
        if (key2 in context2 || indexOf(winKeys, key2) === -1) {
          context2[key2] = win[key2];
        }
      });
      forEach(globals, function(key2) {
        if (!(key2 in context2)) {
          defineProp(context2, key2, win[key2]);
        }
      });
      document.body.removeChild(iframe);
      return res;
    };
    Script.prototype.runInThisContext = function() {
      return eval(this.code);
    };
    Script.prototype.runInNewContext = function(context2) {
      var ctx = Script.createContext(context2);
      var res = this.runInContext(ctx);
      if (context2) {
        forEach(Object_keys(ctx), function(key2) {
          context2[key2] = ctx[key2];
        });
      }
      return res;
    };
    forEach(Object_keys(Script.prototype), function(name) {
      exports[name] = Script[name] = function(code2) {
        var s = Script(code2);
        return s[name].apply(s, [].slice.call(arguments, 1));
      };
    });
    exports.isContext = function(context2) {
      return context2 instanceof Context;
    };
    exports.createScript = function(code2) {
      return exports.Script(code2);
    };
    exports.createContext = Script.createContext = function(context2) {
      var copy2 = new Context();
      if (typeof context2 === "object") {
        forEach(Object_keys(context2), function(key2) {
          copy2[key2] = context2[key2];
        });
      }
      return copy2;
    };
  })(vmBrowserify);
  return vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api$1;
  hasRequiredApi = 1;
  (function(exports2) {
    var asn12 = requireAsn1$1();
    var inherits = requireInherits_browser$4();
    var api2 = exports2;
    api2.define = function define(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base2) {
      var named;
      try {
        named = requireVmBrowserify().runInThisContext(
          "(function " + this.name + "(entity) {\n  this._initNamed(entity);\n})"
        );
      } catch (e) {
        named = function(entity) {
          this._initNamed(entity);
        };
      }
      inherits(named, base2);
      named.prototype._initNamed = function initnamed(entity) {
        base2.call(this, entity);
      };
      return new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(asn12.decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options2) {
      return this._getDecoder(enc).decode(data, options2);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(asn12.encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter2) {
      return this._getEncoder(enc).encode(data, reporter2);
    };
  })(api$1);
  return api$1;
}
var base = {};
var reporter = {};
var hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var inherits = requireInherits_browser$4();
  function Reporter(options2) {
    this._reporterState = {
      obj: null,
      path: [],
      options: options2 || {},
      errors: []
    };
  }
  reporter.Reporter = Reporter;
  Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
  };
  Reporter.prototype.save = function save() {
    var state2 = this._reporterState;
    return { obj: state2.obj, pathLen: state2.path.length };
  };
  Reporter.prototype.restore = function restore(data) {
    var state2 = this._reporterState;
    state2.obj = data.obj;
    state2.path = state2.path.slice(0, data.pathLen);
  };
  Reporter.prototype.enterKey = function enterKey(key2) {
    return this._reporterState.path.push(key2);
  };
  Reporter.prototype.exitKey = function exitKey(index2) {
    var state2 = this._reporterState;
    state2.path = state2.path.slice(0, index2 - 1);
  };
  Reporter.prototype.leaveKey = function leaveKey(index2, key2, value) {
    var state2 = this._reporterState;
    this.exitKey(index2);
    if (state2.obj !== null)
      state2.obj[key2] = value;
  };
  Reporter.prototype.path = function path2() {
    return this._reporterState.path.join("/");
  };
  Reporter.prototype.enterObject = function enterObject() {
    var state2 = this._reporterState;
    var prev = state2.obj;
    state2.obj = {};
    return prev;
  };
  Reporter.prototype.leaveObject = function leaveObject(prev) {
    var state2 = this._reporterState;
    var now2 = state2.obj;
    state2.obj = prev;
    return now2;
  };
  Reporter.prototype.error = function error3(msg) {
    var err;
    var state2 = this._reporterState;
    var inherited = msg instanceof ReporterError;
    if (inherited) {
      err = msg;
    } else {
      err = new ReporterError(state2.path.map(function(elem) {
        return "[" + JSON.stringify(elem) + "]";
      }).join(""), msg.message || msg, msg.stack);
    }
    if (!state2.options.partial)
      throw err;
    if (!inherited)
      state2.errors.push(err);
    return err;
  };
  Reporter.prototype.wrapResult = function wrapResult(result) {
    var state2 = this._reporterState;
    if (!state2.options.partial)
      return result;
    return {
      result: this.isError(result) ? null : result,
      errors: state2.errors
    };
  };
  function ReporterError(path2, msg) {
    this.path = path2;
    this.rethrow(msg);
  }
  inherits(ReporterError, Error);
  ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, ReporterError);
    if (!this.stack) {
      try {
        throw new Error(this.message);
      } catch (e) {
        this.stack = e.stack;
      }
    }
    return this;
  };
  return reporter;
}
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var inherits = requireInherits_browser$4();
  var Reporter = requireBase().Reporter;
  var Buffer2 = requireDist().Buffer;
  function DecoderBuffer(base2, options2) {
    Reporter.call(this, options2);
    if (!Buffer2.isBuffer(base2)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = base2;
    this.offset = 0;
    this.length = base2.length;
  }
  inherits(DecoderBuffer, Reporter);
  buffer.DecoderBuffer = DecoderBuffer;
  DecoderBuffer.prototype.save = function save() {
    return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
  };
  DecoderBuffer.prototype.restore = function restore(save) {
    var res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
  };
  DecoderBuffer.prototype.isEmpty = function isEmpty2() {
    return this.offset === this.length;
  };
  DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length)
      return this.base.readUInt8(this.offset++, true);
    else
      return this.error(fail || "DecoderBuffer overrun");
  };
  DecoderBuffer.prototype.skip = function skip(bytes, fail) {
    if (!(this.offset + bytes <= this.length))
      return this.error(fail || "DecoderBuffer overrun");
    var res = new DecoderBuffer(this.base);
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
  };
  DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
  };
  function EncoderBuffer(value, reporter2) {
    if (Array.isArray(value)) {
      this.length = 0;
      this.value = value.map(function(item) {
        if (!(item instanceof EncoderBuffer))
          item = new EncoderBuffer(item, reporter2);
        this.length += item.length;
        return item;
      }, this);
    } else if (typeof value === "number") {
      if (!(0 <= value && value <= 255))
        return reporter2.error("non-byte EncoderBuffer value");
      this.value = value;
      this.length = 1;
    } else if (typeof value === "string") {
      this.value = value;
      this.length = Buffer2.byteLength(value);
    } else if (Buffer2.isBuffer(value)) {
      this.value = value;
      this.length = value.length;
    } else {
      return reporter2.error("Unsupported type: " + typeof value);
    }
  }
  buffer.EncoderBuffer = EncoderBuffer;
  EncoderBuffer.prototype.join = function join3(out, offset) {
    if (!out)
      out = new Buffer2(this.length);
    if (!offset)
      offset = 0;
    if (this.length === 0)
      return out;
    if (Array.isArray(this.value)) {
      this.value.forEach(function(item) {
        item.join(out, offset);
        offset += item.length;
      });
    } else {
      if (typeof this.value === "number")
        out[offset] = this.value;
      else if (typeof this.value === "string")
        out.write(this.value, offset);
      else if (Buffer2.isBuffer(this.value))
        this.value.copy(out, offset);
      offset += this.length;
    }
    return out;
  };
  return buffer;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var Reporter = requireBase().Reporter;
  var EncoderBuffer = requireBase().EncoderBuffer;
  var DecoderBuffer = requireBase().DecoderBuffer;
  var assert = requireMinimalisticAssert();
  var tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ];
  var methods = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(tags);
  var overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function Node2(enc, parent2) {
    var state2 = {};
    this._baseState = state2;
    state2.enc = enc;
    state2.parent = parent2 || null;
    state2.children = null;
    state2.tag = null;
    state2.args = null;
    state2.reverseArgs = null;
    state2.choice = null;
    state2.optional = false;
    state2.any = false;
    state2.obj = false;
    state2.use = null;
    state2.useDecoder = null;
    state2.key = null;
    state2["default"] = null;
    state2.explicit = null;
    state2.implicit = null;
    state2.contains = null;
    if (!state2.parent) {
      state2.children = [];
      this._wrap();
    }
  }
  node = Node2;
  var stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  Node2.prototype.clone = function clone() {
    var state2 = this._baseState;
    var cstate = {};
    stateProps.forEach(function(prop) {
      cstate[prop] = state2[prop];
    });
    var res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
  };
  Node2.prototype._wrap = function wrap() {
    var state2 = this._baseState;
    methods.forEach(function(method) {
      this[method] = function _wrappedMethod() {
        var clone = new this.constructor(this);
        state2.children.push(clone);
        return clone[method].apply(clone, arguments);
      };
    }, this);
  };
  Node2.prototype._init = function init2(body) {
    var state2 = this._baseState;
    assert(state2.parent === null);
    body.call(this);
    state2.children = state2.children.filter(function(child) {
      return child._baseState.parent === this;
    }, this);
    assert.equal(state2.children.length, 1, "Root node can have only one child");
  };
  Node2.prototype._useArgs = function useArgs(args) {
    var state2 = this._baseState;
    var children = args.filter(function(arg) {
      return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
      return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
      assert(state2.children === null);
      state2.children = children;
      children.forEach(function(child) {
        child._baseState.parent = this;
      }, this);
    }
    if (args.length !== 0) {
      assert(state2.args === null);
      state2.args = args;
      state2.reverseArgs = args.map(function(arg) {
        if (typeof arg !== "object" || arg.constructor !== Object)
          return arg;
        var res = {};
        Object.keys(arg).forEach(function(key2) {
          if (key2 == (key2 | 0))
            key2 |= 0;
          var value = arg[key2];
          res[value] = key2;
        });
        return res;
      });
    }
  };
  overrided.forEach(function(method) {
    Node2.prototype[method] = function _overrided() {
      var state2 = this._baseState;
      throw new Error(method + " not implemented for encoding: " + state2.enc);
    };
  });
  tags.forEach(function(tag) {
    Node2.prototype[tag] = function _tagMethod() {
      var state2 = this._baseState;
      var args = Array.prototype.slice.call(arguments);
      assert(state2.tag === null);
      state2.tag = tag;
      this._useArgs(args);
      return this;
    };
  });
  Node2.prototype.use = function use(item) {
    assert(item);
    var state2 = this._baseState;
    assert(state2.use === null);
    state2.use = item;
    return this;
  };
  Node2.prototype.optional = function optional() {
    var state2 = this._baseState;
    state2.optional = true;
    return this;
  };
  Node2.prototype.def = function def(val) {
    var state2 = this._baseState;
    assert(state2["default"] === null);
    state2["default"] = val;
    state2.optional = true;
    return this;
  };
  Node2.prototype.explicit = function explicit(num) {
    var state2 = this._baseState;
    assert(state2.explicit === null && state2.implicit === null);
    state2.explicit = num;
    return this;
  };
  Node2.prototype.implicit = function implicit(num) {
    var state2 = this._baseState;
    assert(state2.explicit === null && state2.implicit === null);
    state2.implicit = num;
    return this;
  };
  Node2.prototype.obj = function obj() {
    var state2 = this._baseState;
    var args = Array.prototype.slice.call(arguments);
    state2.obj = true;
    if (args.length !== 0)
      this._useArgs(args);
    return this;
  };
  Node2.prototype.key = function key2(newKey) {
    var state2 = this._baseState;
    assert(state2.key === null);
    state2.key = newKey;
    return this;
  };
  Node2.prototype.any = function any() {
    var state2 = this._baseState;
    state2.any = true;
    return this;
  };
  Node2.prototype.choice = function choice(obj) {
    var state2 = this._baseState;
    assert(state2.choice === null);
    state2.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key2) {
      return obj[key2];
    }));
    return this;
  };
  Node2.prototype.contains = function contains(item) {
    var state2 = this._baseState;
    assert(state2.use === null);
    state2.contains = item;
    return this;
  };
  Node2.prototype._decode = function decode(input, options2) {
    var state2 = this._baseState;
    if (state2.parent === null)
      return input.wrapResult(state2.children[0]._decode(input, options2));
    var result = state2["default"];
    var present = true;
    var prevKey = null;
    if (state2.key !== null)
      prevKey = input.enterKey(state2.key);
    if (state2.optional) {
      var tag = null;
      if (state2.explicit !== null)
        tag = state2.explicit;
      else if (state2.implicit !== null)
        tag = state2.implicit;
      else if (state2.tag !== null)
        tag = state2.tag;
      if (tag === null && !state2.any) {
        var save = input.save();
        try {
          if (state2.choice === null)
            this._decodeGeneric(state2.tag, input, options2);
          else
            this._decodeChoice(input, options2);
          present = true;
        } catch (e) {
          present = false;
        }
        input.restore(save);
      } else {
        present = this._peekTag(input, tag, state2.any);
        if (input.isError(present))
          return present;
      }
    }
    var prevObj;
    if (state2.obj && present)
      prevObj = input.enterObject();
    if (present) {
      if (state2.explicit !== null) {
        var explicit = this._decodeTag(input, state2.explicit);
        if (input.isError(explicit))
          return explicit;
        input = explicit;
      }
      var start = input.offset;
      if (state2.use === null && state2.choice === null) {
        if (state2.any)
          var save = input.save();
        var body = this._decodeTag(
          input,
          state2.implicit !== null ? state2.implicit : state2.tag,
          state2.any
        );
        if (input.isError(body))
          return body;
        if (state2.any)
          result = input.raw(save);
        else
          input = body;
      }
      if (options2 && options2.track && state2.tag !== null)
        options2.track(input.path(), start, input.length, "tagged");
      if (options2 && options2.track && state2.tag !== null)
        options2.track(input.path(), input.offset, input.length, "content");
      if (state2.any)
        result = result;
      else if (state2.choice === null)
        result = this._decodeGeneric(state2.tag, input, options2);
      else
        result = this._decodeChoice(input, options2);
      if (input.isError(result))
        return result;
      if (!state2.any && state2.choice === null && state2.children !== null) {
        state2.children.forEach(function decodeChildren(child) {
          child._decode(input, options2);
        });
      }
      if (state2.contains && (state2.tag === "octstr" || state2.tag === "bitstr")) {
        var data = new DecoderBuffer(result);
        result = this._getUse(state2.contains, input._reporterState.obj)._decode(data, options2);
      }
    }
    if (state2.obj && present)
      result = input.leaveObject(prevObj);
    if (state2.key !== null && (result !== null || present === true))
      input.leaveKey(prevKey, state2.key, result);
    else if (prevKey !== null)
      input.exitKey(prevKey);
    return result;
  };
  Node2.prototype._decodeGeneric = function decodeGeneric(tag, input, options2) {
    var state2 = this._baseState;
    if (tag === "seq" || tag === "set")
      return null;
    if (tag === "seqof" || tag === "setof")
      return this._decodeList(input, tag, state2.args[0], options2);
    else if (/str$/.test(tag))
      return this._decodeStr(input, tag, options2);
    else if (tag === "objid" && state2.args)
      return this._decodeObjid(input, state2.args[0], state2.args[1], options2);
    else if (tag === "objid")
      return this._decodeObjid(input, null, null, options2);
    else if (tag === "gentime" || tag === "utctime")
      return this._decodeTime(input, tag, options2);
    else if (tag === "null_")
      return this._decodeNull(input, options2);
    else if (tag === "bool")
      return this._decodeBool(input, options2);
    else if (tag === "objDesc")
      return this._decodeStr(input, tag, options2);
    else if (tag === "int" || tag === "enum")
      return this._decodeInt(input, state2.args && state2.args[0], options2);
    if (state2.use !== null) {
      return this._getUse(state2.use, input._reporterState.obj)._decode(input, options2);
    } else {
      return input.error("unknown tag: " + tag);
    }
  };
  Node2.prototype._getUse = function _getUse(entity, obj) {
    var state2 = this._baseState;
    state2.useDecoder = this._use(entity, obj);
    assert(state2.useDecoder._baseState.parent === null);
    state2.useDecoder = state2.useDecoder._baseState.children[0];
    if (state2.implicit !== state2.useDecoder._baseState.implicit) {
      state2.useDecoder = state2.useDecoder.clone();
      state2.useDecoder._baseState.implicit = state2.implicit;
    }
    return state2.useDecoder;
  };
  Node2.prototype._decodeChoice = function decodeChoice(input, options2) {
    var state2 = this._baseState;
    var result = null;
    var match = false;
    Object.keys(state2.choice).some(function(key2) {
      var save = input.save();
      var node2 = state2.choice[key2];
      try {
        var value = node2._decode(input, options2);
        if (input.isError(value))
          return false;
        result = { type: key2, value };
        match = true;
      } catch (e) {
        input.restore(save);
        return false;
      }
      return true;
    }, this);
    if (!match)
      return input.error("Choice not matched");
    return result;
  };
  Node2.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
  };
  Node2.prototype._encode = function encode(data, reporter2, parent2) {
    var state2 = this._baseState;
    if (state2["default"] !== null && state2["default"] === data)
      return;
    var result = this._encodeValue(data, reporter2, parent2);
    if (result === void 0)
      return;
    if (this._skipDefault(result, reporter2, parent2))
      return;
    return result;
  };
  Node2.prototype._encodeValue = function encode(data, reporter2, parent2) {
    var state2 = this._baseState;
    if (state2.parent === null)
      return state2.children[0]._encode(data, reporter2 || new Reporter());
    var result = null;
    this.reporter = reporter2;
    if (state2.optional && data === void 0) {
      if (state2["default"] !== null)
        data = state2["default"];
      else
        return;
    }
    var content = null;
    var primitive = false;
    if (state2.any) {
      result = this._createEncoderBuffer(data);
    } else if (state2.choice) {
      result = this._encodeChoice(data, reporter2);
    } else if (state2.contains) {
      content = this._getUse(state2.contains, parent2)._encode(data, reporter2);
      primitive = true;
    } else if (state2.children) {
      content = state2.children.map(function(child2) {
        if (child2._baseState.tag === "null_")
          return child2._encode(null, reporter2, data);
        if (child2._baseState.key === null)
          return reporter2.error("Child should have a key");
        var prevKey = reporter2.enterKey(child2._baseState.key);
        if (typeof data !== "object")
          return reporter2.error("Child expected, but input is not object");
        var res = child2._encode(data[child2._baseState.key], reporter2, data);
        reporter2.leaveKey(prevKey);
        return res;
      }, this).filter(function(child2) {
        return child2;
      });
      content = this._createEncoderBuffer(content);
    } else {
      if (state2.tag === "seqof" || state2.tag === "setof") {
        if (!(state2.args && state2.args.length === 1))
          return reporter2.error("Too many args for : " + state2.tag);
        if (!Array.isArray(data))
          return reporter2.error("seqof/setof, but data is not Array");
        var child = this.clone();
        child._baseState.implicit = null;
        content = this._createEncoderBuffer(data.map(function(item) {
          var state3 = this._baseState;
          return this._getUse(state3.args[0], data)._encode(item, reporter2);
        }, child));
      } else if (state2.use !== null) {
        result = this._getUse(state2.use, parent2)._encode(data, reporter2);
      } else {
        content = this._encodePrimitive(state2.tag, data);
        primitive = true;
      }
    }
    var result;
    if (!state2.any && state2.choice === null) {
      var tag = state2.implicit !== null ? state2.implicit : state2.tag;
      var cls = state2.implicit === null ? "universal" : "context";
      if (tag === null) {
        if (state2.use === null)
          reporter2.error("Tag could be omitted only for .use()");
      } else {
        if (state2.use === null)
          result = this._encodeComposite(tag, primitive, cls, content);
      }
    }
    if (state2.explicit !== null)
      result = this._encodeComposite(state2.explicit, false, "context", result);
    return result;
  };
  Node2.prototype._encodeChoice = function encodeChoice(data, reporter2) {
    var state2 = this._baseState;
    var node2 = state2.choice[data.type];
    if (!node2) {
      assert(
        false,
        data.type + " not found in " + JSON.stringify(Object.keys(state2.choice))
      );
    }
    return node2._encode(data.value, reporter2);
  };
  Node2.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    var state2 = this._baseState;
    if (/str$/.test(tag))
      return this._encodeStr(data, tag);
    else if (tag === "objid" && state2.args)
      return this._encodeObjid(data, state2.reverseArgs[0], state2.args[1]);
    else if (tag === "objid")
      return this._encodeObjid(data, null, null);
    else if (tag === "gentime" || tag === "utctime")
      return this._encodeTime(data, tag);
    else if (tag === "null_")
      return this._encodeNull();
    else if (tag === "int" || tag === "enum")
      return this._encodeInt(data, state2.args && state2.reverseArgs[0]);
    else if (tag === "bool")
      return this._encodeBool(data);
    else if (tag === "objDesc")
      return this._encodeStr(data, tag);
    else
      throw new Error("Unsupported tag: " + tag);
  };
  Node2.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
  };
  Node2.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
  };
  return node;
}
var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  (function(exports2) {
    var base2 = exports2;
    base2.Reporter = requireReporter().Reporter;
    base2.DecoderBuffer = requireBuffer().DecoderBuffer;
    base2.EncoderBuffer = requireBuffer().EncoderBuffer;
    base2.Node = requireNode();
  })(base);
  return base;
}
var constants = {};
var der = {};
var hasRequiredDer$2;
function requireDer$2() {
  if (hasRequiredDer$2) return der;
  hasRequiredDer$2 = 1;
  (function(exports2) {
    var constants2 = requireConstants();
    exports2.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports2.tagClassByName = constants2._reverse(exports2.tagClass);
    exports2.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports2.tagByName = constants2._reverse(exports2.tag);
  })(der);
  return der;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  (function(exports2) {
    var constants2 = exports2;
    constants2._reverse = function reverse(map2) {
      var res = {};
      Object.keys(map2).forEach(function(key2) {
        if ((key2 | 0) == key2)
          key2 = key2 | 0;
        var value = map2[key2];
        res[value] = key2;
      });
      return res;
    };
    constants2.der = requireDer$2();
  })(constants);
  return constants;
}
var decoders = {};
var der_1$1;
var hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var inherits = requireInherits_browser$4();
  var asn12 = requireAsn1$1();
  var base2 = asn12.base;
  var bignum = asn12.bignum;
  var der2 = asn12.constants.der;
  function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
  }
  der_1$1 = DERDecoder;
  DERDecoder.prototype.decode = function decode(data, options2) {
    if (!(data instanceof base2.DecoderBuffer))
      data = new base2.DecoderBuffer(data, options2);
    return this.tree._decode(data, options2);
  };
  function DERNode(parent2) {
    base2.Node.call(this, "der", parent2);
  }
  inherits(DERNode, base2.Node);
  DERNode.prototype._peekTag = function peekTag(buffer2, tag, any) {
    if (buffer2.isEmpty())
      return false;
    var state2 = buffer2.save();
    var decodedTag = derDecodeTag(buffer2, 'Failed to peek tag: "' + tag + '"');
    if (buffer2.isError(decodedTag))
      return decodedTag;
    buffer2.restore(state2);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
  };
  DERNode.prototype._decodeTag = function decodeTag(buffer2, tag, any) {
    var decodedTag = derDecodeTag(
      buffer2,
      'Failed to decode tag of "' + tag + '"'
    );
    if (buffer2.isError(decodedTag))
      return decodedTag;
    var len2 = derDecodeLen(
      buffer2,
      decodedTag.primitive,
      'Failed to get length of "' + tag + '"'
    );
    if (buffer2.isError(len2))
      return len2;
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
      return buffer2.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len2 !== null)
      return buffer2.skip(len2, 'Failed to match body of: "' + tag + '"');
    var state2 = buffer2.save();
    var res = this._skipUntilEnd(
      buffer2,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    if (buffer2.isError(res))
      return res;
    len2 = buffer2.offset - state2.offset;
    buffer2.restore(state2);
    return buffer2.skip(len2, 'Failed to match body of: "' + tag + '"');
  };
  DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail) {
    while (true) {
      var tag = derDecodeTag(buffer2, fail);
      if (buffer2.isError(tag))
        return tag;
      var len2 = derDecodeLen(buffer2, tag.primitive, fail);
      if (buffer2.isError(len2))
        return len2;
      var res;
      if (tag.primitive || len2 !== null)
        res = buffer2.skip(len2);
      else
        res = this._skipUntilEnd(buffer2, fail);
      if (buffer2.isError(res))
        return res;
      if (tag.tagStr === "end")
        break;
    }
  };
  DERNode.prototype._decodeList = function decodeList(buffer2, tag, decoder, options2) {
    var result = [];
    while (!buffer2.isEmpty()) {
      var possibleEnd = this._peekTag(buffer2, "end");
      if (buffer2.isError(possibleEnd))
        return possibleEnd;
      var res = decoder.decode(buffer2, "der", options2);
      if (buffer2.isError(res) && possibleEnd)
        break;
      result.push(res);
    }
    return result;
  };
  DERNode.prototype._decodeStr = function decodeStr(buffer2, tag) {
    if (tag === "bitstr") {
      var unused = buffer2.readUInt8();
      if (buffer2.isError(unused))
        return unused;
      return { unused, data: buffer2.raw() };
    } else if (tag === "bmpstr") {
      var raw = buffer2.raw();
      if (raw.length % 2 === 1)
        return buffer2.error("Decoding of string type: bmpstr length mismatch");
      var str = "";
      for (var i2 = 0; i2 < raw.length / 2; i2++) {
        str += String.fromCharCode(raw.readUInt16BE(i2 * 2));
      }
      return str;
    } else if (tag === "numstr") {
      var numstr = buffer2.raw().toString("ascii");
      if (!this._isNumstr(numstr)) {
        return buffer2.error("Decoding of string type: numstr unsupported characters");
      }
      return numstr;
    } else if (tag === "octstr") {
      return buffer2.raw();
    } else if (tag === "objDesc") {
      return buffer2.raw();
    } else if (tag === "printstr") {
      var printstr = buffer2.raw().toString("ascii");
      if (!this._isPrintstr(printstr)) {
        return buffer2.error("Decoding of string type: printstr unsupported characters");
      }
      return printstr;
    } else if (/str$/.test(tag)) {
      return buffer2.raw().toString();
    } else {
      return buffer2.error("Decoding of string type: " + tag + " unsupported");
    }
  };
  DERNode.prototype._decodeObjid = function decodeObjid(buffer2, values2, relative) {
    var result;
    var identifiers = [];
    var ident = 0;
    while (!buffer2.isEmpty()) {
      var subident = buffer2.readUInt8();
      ident <<= 7;
      ident |= subident & 127;
      if ((subident & 128) === 0) {
        identifiers.push(ident);
        ident = 0;
      }
    }
    if (subident & 128)
      identifiers.push(ident);
    var first = identifiers[0] / 40 | 0;
    var second = identifiers[0] % 40;
    if (relative)
      result = identifiers;
    else
      result = [first, second].concat(identifiers.slice(1));
    if (values2) {
      var tmp = values2[result.join(" ")];
      if (tmp === void 0)
        tmp = values2[result.join(".")];
      if (tmp !== void 0)
        result = tmp;
    }
    return result;
  };
  DERNode.prototype._decodeTime = function decodeTime(buffer2, tag) {
    var str = buffer2.raw().toString();
    if (tag === "gentime") {
      var year = str.slice(0, 4) | 0;
      var mon = str.slice(4, 6) | 0;
      var day = str.slice(6, 8) | 0;
      var hour = str.slice(8, 10) | 0;
      var min2 = str.slice(10, 12) | 0;
      var sec = str.slice(12, 14) | 0;
    } else if (tag === "utctime") {
      var year = str.slice(0, 2) | 0;
      var mon = str.slice(2, 4) | 0;
      var day = str.slice(4, 6) | 0;
      var hour = str.slice(6, 8) | 0;
      var min2 = str.slice(8, 10) | 0;
      var sec = str.slice(10, 12) | 0;
      if (year < 70)
        year = 2e3 + year;
      else
        year = 1900 + year;
    } else {
      return buffer2.error("Decoding " + tag + " time is not supported yet");
    }
    return Date.UTC(year, mon - 1, day, hour, min2, sec, 0);
  };
  DERNode.prototype._decodeNull = function decodeNull(buffer2) {
    return null;
  };
  DERNode.prototype._decodeBool = function decodeBool(buffer2) {
    var res = buffer2.readUInt8();
    if (buffer2.isError(res))
      return res;
    else
      return res !== 0;
  };
  DERNode.prototype._decodeInt = function decodeInt(buffer2, values2) {
    var raw = buffer2.raw();
    var res = new bignum(raw);
    if (values2)
      res = values2[res.toString(10)] || res;
    return res;
  };
  DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function")
      entity = entity(obj);
    return entity._getDecoder("der").tree;
  };
  function derDecodeTag(buf, fail) {
    var tag = buf.readUInt8(fail);
    if (buf.isError(tag))
      return tag;
    var cls = der2.tagClass[tag >> 6];
    var primitive = (tag & 32) === 0;
    if ((tag & 31) === 31) {
      var oct = tag;
      tag = 0;
      while ((oct & 128) === 128) {
        oct = buf.readUInt8(fail);
        if (buf.isError(oct))
          return oct;
        tag <<= 7;
        tag |= oct & 127;
      }
    } else {
      tag &= 31;
    }
    var tagStr = der2.tag[tag];
    return {
      cls,
      primitive,
      tag,
      tagStr
    };
  }
  function derDecodeLen(buf, primitive, fail) {
    var len2 = buf.readUInt8(fail);
    if (buf.isError(len2))
      return len2;
    if (!primitive && len2 === 128)
      return null;
    if ((len2 & 128) === 0) {
      return len2;
    }
    var num = len2 & 127;
    if (num > 4)
      return buf.error("length octect is too long");
    len2 = 0;
    for (var i2 = 0; i2 < num; i2++) {
      len2 <<= 8;
      var j = buf.readUInt8(fail);
      if (buf.isError(j))
        return j;
      len2 |= j;
    }
    return len2;
  }
  return der_1$1;
}
var pem$1;
var hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var inherits = requireInherits_browser$4();
  var Buffer2 = requireDist().Buffer;
  var DERDecoder = requireDer$1();
  function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
  }
  inherits(PEMDecoder, DERDecoder);
  pem$1 = PEMDecoder;
  PEMDecoder.prototype.decode = function decode(data, options2) {
    var lines = data.toString().split(/[\r\n]+/g);
    var label = options2.label.toUpperCase();
    var re = /^-----(BEGIN|END) ([^-]+)-----$/;
    var start = -1;
    var end = -1;
    for (var i2 = 0; i2 < lines.length; i2++) {
      var match = lines[i2].match(re);
      if (match === null)
        continue;
      if (match[2] !== label)
        continue;
      if (start === -1) {
        if (match[1] !== "BEGIN")
          break;
        start = i2;
      } else {
        if (match[1] !== "END")
          break;
        end = i2;
        break;
      }
    }
    if (start === -1 || end === -1)
      throw new Error("PEM section not found for: " + label);
    var base64 = lines.slice(start + 1, end).join("");
    base64.replace(/[^a-z0-9\+\/=]+/gi, "");
    var input = new Buffer2(base64, "base64");
    return DERDecoder.prototype.decode.call(this, input, options2);
  };
  return pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  if (hasRequiredDecoders) return decoders;
  hasRequiredDecoders = 1;
  (function(exports2) {
    var decoders2 = exports2;
    decoders2.der = requireDer$1();
    decoders2.pem = requirePem$1();
  })(decoders);
  return decoders;
}
var encoders = {};
var der_1;
var hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var inherits = requireInherits_browser$4();
  var Buffer2 = requireDist().Buffer;
  var asn12 = requireAsn1$1();
  var base2 = asn12.base;
  var der2 = asn12.constants.der;
  function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
  }
  der_1 = DEREncoder;
  DEREncoder.prototype.encode = function encode(data, reporter2) {
    return this.tree._encode(data, reporter2).join();
  };
  function DERNode(parent2) {
    base2.Node.call(this, "der", parent2);
  }
  inherits(DERNode, base2.Node);
  DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
    if (content.length < 128) {
      var header2 = new Buffer2(2);
      header2[0] = encodedTag;
      header2[1] = content.length;
      return this._createEncoderBuffer([header2, content]);
    }
    var lenOctets = 1;
    for (var i2 = content.length; i2 >= 256; i2 >>= 8)
      lenOctets++;
    var header2 = new Buffer2(1 + 1 + lenOctets);
    header2[0] = encodedTag;
    header2[1] = 128 | lenOctets;
    for (var i2 = 1 + lenOctets, j = content.length; j > 0; i2--, j >>= 8)
      header2[i2] = j & 255;
    return this._createEncoderBuffer([header2, content]);
  };
  DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === "bitstr") {
      return this._createEncoderBuffer([str.unused | 0, str.data]);
    } else if (tag === "bmpstr") {
      var buf = new Buffer2(str.length * 2);
      for (var i2 = 0; i2 < str.length; i2++) {
        buf.writeUInt16BE(str.charCodeAt(i2), i2 * 2);
      }
      return this._createEncoderBuffer(buf);
    } else if (tag === "numstr") {
      if (!this._isNumstr(str)) {
        return this.reporter.error("Encoding of string type: numstr supports only digits and space");
      }
      return this._createEncoderBuffer(str);
    } else if (tag === "printstr") {
      if (!this._isPrintstr(str)) {
        return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
      }
      return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag)) {
      return this._createEncoderBuffer(str);
    } else if (tag === "objDesc") {
      return this._createEncoderBuffer(str);
    } else {
      return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    }
  };
  DERNode.prototype._encodeObjid = function encodeObjid(id, values2, relative) {
    if (typeof id === "string") {
      if (!values2)
        return this.reporter.error("string objid given, but no values map found");
      if (!values2.hasOwnProperty(id))
        return this.reporter.error("objid not found in values map");
      id = values2[id].split(/[\s\.]+/g);
      for (var i2 = 0; i2 < id.length; i2++)
        id[i2] |= 0;
    } else if (Array.isArray(id)) {
      id = id.slice();
      for (var i2 = 0; i2 < id.length; i2++)
        id[i2] |= 0;
    }
    if (!Array.isArray(id)) {
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
    }
    if (!relative) {
      if (id[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      id.splice(0, 2, id[0] * 40 + id[1]);
    }
    var size = 0;
    for (var i2 = 0; i2 < id.length; i2++) {
      var ident = id[i2];
      for (size++; ident >= 128; ident >>= 7)
        size++;
    }
    var objid = new Buffer2(size);
    var offset = objid.length - 1;
    for (var i2 = id.length - 1; i2 >= 0; i2--) {
      var ident = id[i2];
      objid[offset--] = ident & 127;
      while ((ident >>= 7) > 0)
        objid[offset--] = 128 | ident & 127;
    }
    return this._createEncoderBuffer(objid);
  };
  function two(num) {
    if (num < 10)
      return "0" + num;
    else
      return num;
  }
  DERNode.prototype._encodeTime = function encodeTime(time, tag) {
    var str;
    var date = new Date(time);
    if (tag === "gentime") {
      str = [
        two(date.getFullYear()),
        two(date.getUTCMonth() + 1),
        two(date.getUTCDate()),
        two(date.getUTCHours()),
        two(date.getUTCMinutes()),
        two(date.getUTCSeconds()),
        "Z"
      ].join("");
    } else if (tag === "utctime") {
      str = [
        two(date.getFullYear() % 100),
        two(date.getUTCMonth() + 1),
        two(date.getUTCDate()),
        two(date.getUTCHours()),
        two(date.getUTCMinutes()),
        two(date.getUTCSeconds()),
        "Z"
      ].join("");
    } else {
      this.reporter.error("Encoding " + tag + " time is not supported yet");
    }
    return this._encodeStr(str, "octstr");
  };
  DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
  };
  DERNode.prototype._encodeInt = function encodeInt(num, values2) {
    if (typeof num === "string") {
      if (!values2)
        return this.reporter.error("String int or enum given, but no values map");
      if (!values2.hasOwnProperty(num)) {
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
      }
      num = values2[num];
    }
    if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
      var numArray = num.toArray();
      if (!num.sign && numArray[0] & 128) {
        numArray.unshift(0);
      }
      num = new Buffer2(numArray);
    }
    if (Buffer2.isBuffer(num)) {
      var size = num.length;
      if (num.length === 0)
        size++;
      var out = new Buffer2(size);
      num.copy(out);
      if (num.length === 0)
        out[0] = 0;
      return this._createEncoderBuffer(out);
    }
    if (num < 128)
      return this._createEncoderBuffer(num);
    if (num < 256)
      return this._createEncoderBuffer([0, num]);
    var size = 1;
    for (var i2 = num; i2 >= 256; i2 >>= 8)
      size++;
    var out = new Array(size);
    for (var i2 = out.length - 1; i2 >= 0; i2--) {
      out[i2] = num & 255;
      num >>= 8;
    }
    if (out[0] & 128) {
      out.unshift(0);
    }
    return this._createEncoderBuffer(new Buffer2(out));
  };
  DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 255 : 0);
  };
  DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function")
      entity = entity(obj);
    return entity._getEncoder("der").tree;
  };
  DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter2, parent2) {
    var state2 = this._baseState;
    var i2;
    if (state2["default"] === null)
      return false;
    var data = dataBuffer.join();
    if (state2.defaultBuffer === void 0)
      state2.defaultBuffer = this._encodeValue(state2["default"], reporter2, parent2).join();
    if (data.length !== state2.defaultBuffer.length)
      return false;
    for (i2 = 0; i2 < data.length; i2++)
      if (data[i2] !== state2.defaultBuffer[i2])
        return false;
    return true;
  };
  function encodeTag(tag, primitive, cls, reporter2) {
    var res;
    if (tag === "seqof")
      tag = "seq";
    else if (tag === "setof")
      tag = "set";
    if (der2.tagByName.hasOwnProperty(tag))
      res = der2.tagByName[tag];
    else if (typeof tag === "number" && (tag | 0) === tag)
      res = tag;
    else
      return reporter2.error("Unknown tag: " + tag);
    if (res >= 31)
      return reporter2.error("Multi-octet tag encoding unsupported");
    if (!primitive)
      res |= 32;
    res |= der2.tagClassByName[cls || "universal"] << 6;
    return res;
  }
  return der_1;
}
var pem;
var hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var inherits = requireInherits_browser$4();
  var DEREncoder = requireDer();
  function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
  }
  inherits(PEMEncoder, DEREncoder);
  pem = PEMEncoder;
  PEMEncoder.prototype.encode = function encode(data, options2) {
    var buf = DEREncoder.prototype.encode.call(this, data);
    var p = buf.toString("base64");
    var out = ["-----BEGIN " + options2.label + "-----"];
    for (var i2 = 0; i2 < p.length; i2 += 64)
      out.push(p.slice(i2, i2 + 64));
    out.push("-----END " + options2.label + "-----");
    return out.join("\n");
  };
  return pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  if (hasRequiredEncoders) return encoders;
  hasRequiredEncoders = 1;
  (function(exports2) {
    var encoders2 = exports2;
    encoders2.der = requireDer();
    encoders2.pem = requirePem();
  })(encoders);
  return encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  if (hasRequiredAsn1$1) return asn1;
  hasRequiredAsn1$1 = 1;
  (function(exports2) {
    var asn12 = exports2;
    asn12.bignum = requireBn$2();
    asn12.define = requireApi().define;
    asn12.base = requireBase();
    asn12.constants = requireConstants();
    asn12.decoders = requireDecoders();
    asn12.encoders = requireEncoders();
  })(asn1);
  return asn1;
}
var certificate;
var hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var asn = requireAsn1$1();
  var Time = asn.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  });
  var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  });
  var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  });
  var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(AlgorithmIdentifier),
      this.key("subjectPublicKey").bitstr()
    );
  });
  var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
  });
  var RDNSequence = asn.define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
  });
  var Name = asn.define("Name", function() {
    this.choice({
      rdnSequence: this.use(RDNSequence)
    });
  });
  var Validity = asn.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(Time),
      this.key("notAfter").use(Time)
    );
  });
  var Extension = asn.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(false),
      this.key("extnValue").octstr()
    );
  });
  var TBSCertificate = asn.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0)["int"]().optional(),
      this.key("serialNumber")["int"](),
      this.key("signature").use(AlgorithmIdentifier),
      this.key("issuer").use(Name),
      this.key("validity").use(Validity),
      this.key("subject").use(Name),
      this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(Extension).optional()
    );
  });
  var X509Certificate = asn.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(TBSCertificate),
      this.key("signatureAlgorithm").use(AlgorithmIdentifier),
      this.key("signatureValue").bitstr()
    );
  });
  certificate = X509Certificate;
  return certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var asn12 = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var RSAPrivateKey = asn12.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version")["int"](),
      this.key("modulus")["int"](),
      this.key("publicExponent")["int"](),
      this.key("privateExponent")["int"](),
      this.key("prime1")["int"](),
      this.key("prime2")["int"](),
      this.key("exponent1")["int"](),
      this.key("exponent2")["int"](),
      this.key("coefficient")["int"]()
    );
  });
  asn1$1.RSAPrivateKey = RSAPrivateKey;
  var RSAPublicKey = asn12.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus")["int"](),
      this.key("publicExponent")["int"]()
    );
  });
  asn1$1.RSAPublicKey = RSAPublicKey;
  var AlgorithmIdentifier = asn12.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p")["int"](),
        this.key("q")["int"](),
        this.key("g")["int"]()
      ).optional()
    );
  });
  var PublicKey3 = asn12.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(AlgorithmIdentifier),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = PublicKey3;
  var PrivateKeyInfo = asn12.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version")["int"](),
      this.key("algorithm").use(AlgorithmIdentifier),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = PrivateKeyInfo;
  var EncryptedPrivateKeyInfo = asn12.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters")["int"]()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
  var DSAPrivateKey = asn12.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version")["int"](),
      this.key("p")["int"](),
      this.key("q")["int"](),
      this.key("g")["int"](),
      this.key("pub_key")["int"](),
      this.key("priv_key")["int"]()
    );
  });
  asn1$1.DSAPrivateKey = DSAPrivateKey;
  asn1$1.DSAparam = asn12.define("DSAparam", function() {
    this["int"]();
  });
  var ECParameters = asn12.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  var ECPrivateKey = asn12.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version")["int"](),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ECParameters),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  asn1$1.ECPrivateKey = ECPrivateKey;
  asn1$1.signature = asn12.define("signature", function() {
    this.seq().obj(
      this.key("r")["int"](),
      this.key("s")["int"]()
    );
  });
  return asn1$1;
}
const require$$1$2 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports2) {
    var buffer2 = requireDist();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var fixProc;
var hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
  var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
  var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
  var evp = requireEvp_bytestokey();
  var ciphers = requireBrowser$8();
  var Buffer2 = requireSafeBuffer().Buffer;
  fixProc = function(okey, password) {
    var key2 = okey.toString();
    var match = key2.match(findProc);
    var decrypted;
    if (!match) {
      var match2 = key2.match(fullRegex);
      decrypted = Buffer2.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
      var suite = "aes" + match[1];
      var iv = Buffer2.from(match[2], "hex");
      var cipherText = Buffer2.from(match[3].replace(/[\r\n]/g, ""), "base64");
      var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
      var out = [];
      var cipher2 = ciphers.createDecipheriv(suite, cipherKey, iv);
      out.push(cipher2.update(cipherText));
      out.push(cipher2["final"]());
      decrypted = Buffer2.concat(out);
    }
    var tag = key2.match(startRegex)[1];
    return {
      tag,
      data: decrypted
    };
  };
  return fixProc;
}
var parseAsn1;
var hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var asn12 = requireAsn1();
  var aesid = require$$1$2;
  var fixProc2 = requireFixProc();
  var ciphers = requireBrowser$8();
  var compat = requireBrowser$9();
  var Buffer2 = requireSafeBuffer().Buffer;
  function decrypt(data, password) {
    var salt = data.algorithm.decrypt.kde.kdeparams.salt;
    var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
    var iv = data.algorithm.decrypt.cipher.iv;
    var cipherText = data.subjectPrivateKey;
    var keylen = parseInt(algo.split("-")[1], 10) / 8;
    var key2 = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
    var cipher2 = ciphers.createDecipheriv(algo, key2, iv);
    var out = [];
    out.push(cipher2.update(cipherText));
    out.push(cipher2["final"]());
    return Buffer2.concat(out);
  }
  function parseKeys(buffer2) {
    var password;
    if (typeof buffer2 === "object" && !Buffer2.isBuffer(buffer2)) {
      password = buffer2.passphrase;
      buffer2 = buffer2.key;
    }
    if (typeof buffer2 === "string") {
      buffer2 = Buffer2.from(buffer2);
    }
    var stripped = fixProc2(buffer2, password);
    var type2 = stripped.tag;
    var data = stripped.data;
    var subtype, ndata;
    switch (type2) {
      case "CERTIFICATE":
        ndata = asn12.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
      // falls through
      case "PUBLIC KEY":
        if (!ndata) {
          ndata = asn12.PublicKey.decode(data, "der");
        }
        subtype = ndata.algorithm.algorithm.join(".");
        switch (subtype) {
          case "1.2.840.113549.1.1.1":
            return asn12.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            ndata.subjectPrivateKey = ndata.subjectPublicKey;
            return {
              type: "ec",
              data: ndata
            };
          case "1.2.840.10040.4.1":
            ndata.algorithm.params.pub_key = asn12.DSAparam.decode(ndata.subjectPublicKey.data, "der");
            return {
              type: "dsa",
              data: ndata.algorithm.params
            };
          default:
            throw new Error("unknown key id " + subtype);
        }
      // throw new Error('unknown key type ' + type)
      case "ENCRYPTED PRIVATE KEY":
        data = asn12.EncryptedPrivateKey.decode(data, "der");
        data = decrypt(data, password);
      // falls through
      case "PRIVATE KEY":
        ndata = asn12.PrivateKey.decode(data, "der");
        subtype = ndata.algorithm.algorithm.join(".");
        switch (subtype) {
          case "1.2.840.113549.1.1.1":
            return asn12.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: ndata.algorithm.curve,
              privateKey: asn12.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            ndata.algorithm.params.priv_key = asn12.DSAparam.decode(ndata.subjectPrivateKey, "der");
            return {
              type: "dsa",
              params: ndata.algorithm.params
            };
          default:
            throw new Error("unknown key id " + subtype);
        }
      // throw new Error('unknown key type ' + type)
      case "RSA PUBLIC KEY":
        return asn12.RSAPublicKey.decode(data, "der");
      case "RSA PRIVATE KEY":
        return asn12.RSAPrivateKey.decode(data, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: asn12.DSAPrivateKey.decode(data, "der")
        };
      case "EC PRIVATE KEY":
        data = asn12.ECPrivateKey.decode(data, "der");
        return {
          curve: data.parameters.value,
          privateKey: data.privateKey
        };
      default:
        throw new Error("unknown key type " + type2);
    }
  }
  parseKeys.signature = asn12.signature;
  parseAsn1 = parseKeys;
  return parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var createHmac = requireBrowser$a();
  var crt = /* @__PURE__ */ requireBrowserifyRsa();
  var EC = requireElliptic().ec;
  var BN = requireBn();
  var parseKeys = requireParseAsn1();
  var curves2 = require$$4;
  var RSA_PKCS1_PADDING = 1;
  function sign$12(hash2, key2, hashType, signType, tag) {
    var priv = parseKeys(key2);
    if (priv.curve) {
      if (signType !== "ecdsa" && signType !== "ecdsa/rsa") {
        throw new Error("wrong private key type");
      }
      return ecSign(hash2, priv);
    } else if (priv.type === "dsa") {
      if (signType !== "dsa") {
        throw new Error("wrong private key type");
      }
      return dsaSign(hash2, priv, hashType);
    }
    if (signType !== "rsa" && signType !== "ecdsa/rsa") {
      throw new Error("wrong private key type");
    }
    if (key2.padding !== void 0 && key2.padding !== RSA_PKCS1_PADDING) {
      throw new Error("illegal or unsupported padding mode");
    }
    hash2 = Buffer2.concat([tag, hash2]);
    var len2 = priv.modulus.byteLength();
    var pad = [0, 1];
    while (hash2.length + pad.length + 1 < len2) {
      pad.push(255);
    }
    pad.push(0);
    var i2 = -1;
    while (++i2 < hash2.length) {
      pad.push(hash2[i2]);
    }
    var out = crt(pad, priv);
    return out;
  }
  function ecSign(hash2, priv) {
    var curveId = curves2[priv.curve.join(".")];
    if (!curveId) {
      throw new Error("unknown curve " + priv.curve.join("."));
    }
    var curve2 = new EC(curveId);
    var key2 = curve2.keyFromPrivate(priv.privateKey);
    var out = key2.sign(hash2);
    return Buffer2.from(out.toDER());
  }
  function dsaSign(hash2, priv, algo) {
    var x = priv.params.priv_key;
    var p = priv.params.p;
    var q = priv.params.q;
    var g = priv.params.g;
    var r = new BN(0);
    var k;
    var H = bits2int(hash2, q).mod(q);
    var s = false;
    var kv = getKey(x, q, hash2, algo);
    while (s === false) {
      k = makeKey(q, kv, algo);
      r = makeR(g, k, p, q);
      s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
      if (s.cmpn(0) === 0) {
        s = false;
        r = new BN(0);
      }
    }
    return toDER(r, s);
  }
  function toDER(r, s) {
    r = r.toArray();
    s = s.toArray();
    if (r[0] & 128) {
      r = [0].concat(r);
    }
    if (s[0] & 128) {
      s = [0].concat(s);
    }
    var total = r.length + s.length + 4;
    var res = [
      48,
      total,
      2,
      r.length
    ];
    res = res.concat(r, [2, s.length], s);
    return Buffer2.from(res);
  }
  function getKey(x, q, hash2, algo) {
    x = Buffer2.from(x.toArray());
    if (x.length < q.byteLength()) {
      var zeros = Buffer2.alloc(q.byteLength() - x.length);
      x = Buffer2.concat([zeros, x]);
    }
    var hlen = hash2.length;
    var hbits = bits2octets(hash2, q);
    var v = Buffer2.alloc(hlen);
    v.fill(1);
    var k = Buffer2.alloc(hlen);
    k = createHmac(algo, k).update(v).update(Buffer2.from([0])).update(x).update(hbits).digest();
    v = createHmac(algo, k).update(v).digest();
    k = createHmac(algo, k).update(v).update(Buffer2.from([1])).update(x).update(hbits).digest();
    v = createHmac(algo, k).update(v).digest();
    return { k, v };
  }
  function bits2int(obits, q) {
    var bits = new BN(obits);
    var shift = (obits.length << 3) - q.bitLength();
    if (shift > 0) {
      bits.ishrn(shift);
    }
    return bits;
  }
  function bits2octets(bits, q) {
    bits = bits2int(bits, q);
    bits = bits.mod(q);
    var out = Buffer2.from(bits.toArray());
    if (out.length < q.byteLength()) {
      var zeros = Buffer2.alloc(q.byteLength() - out.length);
      out = Buffer2.concat([zeros, out]);
    }
    return out;
  }
  function makeKey(q, kv, algo) {
    var t2;
    var k;
    do {
      t2 = Buffer2.alloc(0);
      while (t2.length * 8 < q.bitLength()) {
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
        t2 = Buffer2.concat([t2, kv.v]);
      }
      k = bits2int(t2, q);
      kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer2.from([0])).digest();
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
    } while (k.cmp(q) !== -1);
    return k;
  }
  function makeR(g, k, p, q) {
    return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
  }
  sign.exports = sign$12;
  sign.exports.getKey = getKey;
  sign.exports.makeKey = makeKey;
  return sign.exports;
}
var verify_1;
var hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var BN = requireBn();
  var EC = requireElliptic().ec;
  var parseKeys = requireParseAsn1();
  var curves2 = require$$4;
  function verify(sig, hash2, key2, signType, tag) {
    var pub = parseKeys(key2);
    if (pub.type === "ec") {
      if (signType !== "ecdsa" && signType !== "ecdsa/rsa") {
        throw new Error("wrong public key type");
      }
      return ecVerify(sig, hash2, pub);
    } else if (pub.type === "dsa") {
      if (signType !== "dsa") {
        throw new Error("wrong public key type");
      }
      return dsaVerify(sig, hash2, pub);
    }
    if (signType !== "rsa" && signType !== "ecdsa/rsa") {
      throw new Error("wrong public key type");
    }
    hash2 = Buffer2.concat([tag, hash2]);
    var len2 = pub.modulus.byteLength();
    var pad = [1];
    var padNum = 0;
    while (hash2.length + pad.length + 2 < len2) {
      pad.push(255);
      padNum += 1;
    }
    pad.push(0);
    var i2 = -1;
    while (++i2 < hash2.length) {
      pad.push(hash2[i2]);
    }
    pad = Buffer2.from(pad);
    var red2 = BN.mont(pub.modulus);
    sig = new BN(sig).toRed(red2);
    sig = sig.redPow(new BN(pub.publicExponent));
    sig = Buffer2.from(sig.fromRed().toArray());
    var out = padNum < 8 ? 1 : 0;
    len2 = Math.min(sig.length, pad.length);
    if (sig.length !== pad.length) {
      out = 1;
    }
    i2 = -1;
    while (++i2 < len2) {
      out |= sig[i2] ^ pad[i2];
    }
    return out === 0;
  }
  function ecVerify(sig, hash2, pub) {
    var curveId = curves2[pub.data.algorithm.curve.join(".")];
    if (!curveId) {
      throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
    }
    var curve2 = new EC(curveId);
    var pubkey = pub.data.subjectPrivateKey.data;
    return curve2.verify(hash2, sig, pubkey);
  }
  function dsaVerify(sig, hash2, pub) {
    var p = pub.data.p;
    var q = pub.data.q;
    var g = pub.data.g;
    var y = pub.data.pub_key;
    var unpacked = parseKeys.signature.decode(sig, "der");
    var s = unpacked.s;
    var r = unpacked.r;
    checkValue(s, q);
    checkValue(r, q);
    var montp = BN.mont(p);
    var w = s.invm(q);
    var v = g.toRed(montp).redPow(new BN(hash2).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
    return v.cmp(r) === 0;
  }
  function checkValue(b, q) {
    if (b.cmpn(0) <= 0) {
      throw new Error("invalid sig");
    }
    if (b.cmp(q) >= 0) {
      throw new Error("invalid sig");
    }
  }
  verify_1 = verify;
  return verify_1;
}
var browser$5;
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$5;
  hasRequiredBrowser$5 = 1;
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var createHash = requireBrowser$b();
  var stream = requireReadableBrowser$1();
  var inherits = requireInherits_browser$2();
  var sign2 = requireSign();
  var verify = requireVerify();
  var algorithms = require$$6;
  Object.keys(algorithms).forEach(function(key2) {
    algorithms[key2].id = Buffer2.from(algorithms[key2].id, "hex");
    algorithms[key2.toLowerCase()] = algorithms[key2];
  });
  function Sign(algorithm) {
    stream.Writable.call(this);
    var data = algorithms[algorithm];
    if (!data) {
      throw new Error("Unknown message digest");
    }
    this._hashType = data.hash;
    this._hash = createHash(data.hash);
    this._tag = data.id;
    this._signType = data.sign;
  }
  inherits(Sign, stream.Writable);
  Sign.prototype._write = function _write(data, _23, done) {
    this._hash.update(data);
    done();
  };
  Sign.prototype.update = function update2(data, enc) {
    this._hash.update(typeof data === "string" ? Buffer2.from(data, enc) : data);
    return this;
  };
  Sign.prototype.sign = function signMethod(key2, enc) {
    this.end();
    var hash2 = this._hash.digest();
    var sig = sign2(hash2, key2, this._hashType, this._signType, this._tag);
    return enc ? sig.toString(enc) : sig;
  };
  function Verify(algorithm) {
    stream.Writable.call(this);
    var data = algorithms[algorithm];
    if (!data) {
      throw new Error("Unknown message digest");
    }
    this._hash = createHash(data.hash);
    this._tag = data.id;
    this._signType = data.sign;
  }
  inherits(Verify, stream.Writable);
  Verify.prototype._write = function _write(data, _23, done) {
    this._hash.update(data);
    done();
  };
  Verify.prototype.update = function update2(data, enc) {
    this._hash.update(typeof data === "string" ? Buffer2.from(data, enc) : data);
    return this;
  };
  Verify.prototype.verify = function verifyMethod(key2, sig, enc) {
    var sigBuffer = typeof sig === "string" ? Buffer2.from(sig, enc) : sig;
    this.end();
    var hash2 = this._hash.digest();
    return verify(sigBuffer, hash2, key2, this._signType, this._tag);
  };
  function createSign(algorithm) {
    return new Sign(algorithm);
  }
  function createVerify(algorithm) {
    return new Verify(algorithm);
  }
  browser$5 = {
    Sign: createSign,
    Verify: createVerify,
    createSign,
    createVerify
  };
  return browser$5;
}
var browser$4;
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var elliptic2 = requireElliptic();
  var BN = requireBn$2();
  browser$4 = function createECDH(curve2) {
    return new ECDH(curve2);
  };
  var aliases = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  aliases.p224 = aliases.secp224r1;
  aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
  aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
  aliases.p384 = aliases.secp384r1;
  aliases.p521 = aliases.secp521r1;
  function ECDH(curve2) {
    this.curveType = aliases[curve2];
    if (!this.curveType) {
      this.curveType = {
        name: curve2
      };
    }
    this.curve = new elliptic2.ec(this.curveType.name);
    this.keys = void 0;
  }
  ECDH.prototype.generateKeys = function(enc, format2) {
    this.keys = this.curve.genKeyPair();
    return this.getPublicKey(enc, format2);
  };
  ECDH.prototype.computeSecret = function(other, inenc, enc) {
    inenc = inenc || "utf8";
    if (!Buffer.isBuffer(other)) {
      other = new Buffer(other, inenc);
    }
    var otherPub = this.curve.keyFromPublic(other).getPublic();
    var out = otherPub.mul(this.keys.getPrivate()).getX();
    return formatReturnValue(out, enc, this.curveType.byteLength);
  };
  ECDH.prototype.getPublicKey = function(enc, format2) {
    var key2 = this.keys.getPublic(format2 === "compressed", true);
    if (format2 === "hybrid") {
      if (key2[key2.length - 1] % 2) {
        key2[0] = 7;
      } else {
        key2[0] = 6;
      }
    }
    return formatReturnValue(key2, enc);
  };
  ECDH.prototype.getPrivateKey = function(enc) {
    return formatReturnValue(this.keys.getPrivate(), enc);
  };
  ECDH.prototype.setPublicKey = function(pub, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(pub)) {
      pub = new Buffer(pub, enc);
    }
    this.keys._importPublic(pub);
    return this;
  };
  ECDH.prototype.setPrivateKey = function(priv, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(priv)) {
      priv = new Buffer(priv, enc);
    }
    var _priv = new BN(priv);
    _priv = _priv.toString(16);
    this.keys = this.curve.genKeyPair();
    this.keys._importPrivate(_priv);
    return this;
  };
  function formatReturnValue(bn2, enc, len2) {
    if (!Array.isArray(bn2)) {
      bn2 = bn2.toArray();
    }
    var buf = new Buffer(bn2);
    if (len2 && buf.length < len2) {
      var zeros = new Buffer(len2 - buf.length);
      zeros.fill(0);
      buf = Buffer.concat([zeros, buf]);
    }
    if (!enc) {
      return buf;
    } else {
      return buf.toString(enc);
    }
  }
  return browser$4;
}
var browser$3 = {};
var mgf;
var hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var createHash = requireBrowser$b();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  mgf = function(seed, len2) {
    var t2 = Buffer2.alloc(0);
    var i2 = 0;
    var c;
    while (t2.length < len2) {
      c = i2ops(i2++);
      t2 = Buffer2.concat([t2, createHash("sha1").update(seed).update(c).digest()]);
    }
    return t2.slice(0, len2);
  };
  function i2ops(c) {
    var out = Buffer2.allocUnsafe(4);
    out.writeUInt32BE(c, 0);
    return out;
  }
  return mgf;
}
var xor;
var hasRequiredXor;
function requireXor() {
  if (hasRequiredXor) return xor;
  hasRequiredXor = 1;
  xor = function xor2(a, b) {
    var len2 = a.length;
    var i2 = -1;
    while (++i2 < len2) {
      a[i2] ^= b[i2];
    }
    return a;
  };
  return xor;
}
var withPublic_1;
var hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var BN = requireBn$2();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  function withPublic(paddedMsg, key2) {
    return Buffer2.from(paddedMsg.toRed(BN.mont(key2.modulus)).redPow(new BN(key2.publicExponent)).fromRed().toArray());
  }
  withPublic_1 = withPublic;
  return withPublic_1;
}
var publicEncrypt;
var hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var parseKeys = requireParseAsn1();
  var randomBytes = requireBrowser$d();
  var createHash = requireBrowser$b();
  var mgf2 = requireMgf();
  var xor2 = requireXor();
  var BN = requireBn$2();
  var withPublic = requireWithPublic();
  var crt = /* @__PURE__ */ requireBrowserifyRsa();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  publicEncrypt = function publicEncrypt2(publicKey, msg, reverse) {
    var padding;
    if (publicKey.padding) {
      padding = publicKey.padding;
    } else if (reverse) {
      padding = 1;
    } else {
      padding = 4;
    }
    var key2 = parseKeys(publicKey);
    var paddedMsg;
    if (padding === 4) {
      paddedMsg = oaep(key2, msg);
    } else if (padding === 1) {
      paddedMsg = pkcs1(key2, msg, reverse);
    } else if (padding === 3) {
      paddedMsg = new BN(msg);
      if (paddedMsg.cmp(key2.modulus) >= 0) {
        throw new Error("data too long for modulus");
      }
    } else {
      throw new Error("unknown padding");
    }
    if (reverse) {
      return crt(paddedMsg, key2);
    } else {
      return withPublic(paddedMsg, key2);
    }
  };
  function oaep(key2, msg) {
    var k = key2.modulus.byteLength();
    var mLen = msg.length;
    var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
    var hLen = iHash.length;
    var hLen2 = 2 * hLen;
    if (mLen > k - hLen2 - 2) {
      throw new Error("message too long");
    }
    var ps = Buffer2.alloc(k - mLen - hLen2 - 2);
    var dblen = k - hLen - 1;
    var seed = randomBytes(hLen);
    var maskedDb = xor2(Buffer2.concat([iHash, ps, Buffer2.alloc(1, 1), msg], dblen), mgf2(seed, dblen));
    var maskedSeed = xor2(seed, mgf2(maskedDb, hLen));
    return new BN(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k));
  }
  function pkcs1(key2, msg, reverse) {
    var mLen = msg.length;
    var k = key2.modulus.byteLength();
    if (mLen > k - 11) {
      throw new Error("message too long");
    }
    var ps;
    if (reverse) {
      ps = Buffer2.alloc(k - mLen - 3, 255);
    } else {
      ps = nonZero(k - mLen - 3);
    }
    return new BN(Buffer2.concat([Buffer2.from([0, reverse ? 1 : 2]), ps, Buffer2.alloc(1), msg], k));
  }
  function nonZero(len2) {
    var out = Buffer2.allocUnsafe(len2);
    var i2 = 0;
    var cache2 = randomBytes(len2 * 2);
    var cur = 0;
    var num;
    while (i2 < len2) {
      if (cur === cache2.length) {
        cache2 = randomBytes(len2 * 2);
        cur = 0;
      }
      num = cache2[cur++];
      if (num) {
        out[i2++] = num;
      }
    }
    return out;
  }
  return publicEncrypt;
}
var privateDecrypt;
var hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var parseKeys = requireParseAsn1();
  var mgf2 = requireMgf();
  var xor2 = requireXor();
  var BN = requireBn$2();
  var crt = /* @__PURE__ */ requireBrowserifyRsa();
  var createHash = requireBrowser$b();
  var withPublic = requireWithPublic();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  privateDecrypt = function privateDecrypt2(privateKey, enc, reverse) {
    var padding;
    if (privateKey.padding) {
      padding = privateKey.padding;
    } else if (reverse) {
      padding = 1;
    } else {
      padding = 4;
    }
    var key2 = parseKeys(privateKey);
    var k = key2.modulus.byteLength();
    if (enc.length > k || new BN(enc).cmp(key2.modulus) >= 0) {
      throw new Error("decryption error");
    }
    var msg;
    if (reverse) {
      msg = withPublic(new BN(enc), key2);
    } else {
      msg = crt(enc, key2);
    }
    var zBuffer = Buffer2.alloc(k - msg.length);
    msg = Buffer2.concat([zBuffer, msg], k);
    if (padding === 4) {
      return oaep(key2, msg);
    } else if (padding === 1) {
      return pkcs1(key2, msg, reverse);
    } else if (padding === 3) {
      return msg;
    } else {
      throw new Error("unknown padding");
    }
  };
  function oaep(key2, msg) {
    var k = key2.modulus.byteLength();
    var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
    var hLen = iHash.length;
    if (msg[0] !== 0) {
      throw new Error("decryption error");
    }
    var maskedSeed = msg.slice(1, hLen + 1);
    var maskedDb = msg.slice(hLen + 1);
    var seed = xor2(maskedSeed, mgf2(maskedDb, hLen));
    var db = xor2(maskedDb, mgf2(seed, k - hLen - 1));
    if (compare(iHash, db.slice(0, hLen))) {
      throw new Error("decryption error");
    }
    var i2 = hLen;
    while (db[i2] === 0) {
      i2++;
    }
    if (db[i2++] !== 1) {
      throw new Error("decryption error");
    }
    return db.slice(i2);
  }
  function pkcs1(key2, msg, reverse) {
    var p1 = msg.slice(0, 2);
    var i2 = 2;
    var status = 0;
    while (msg[i2++] !== 0) {
      if (i2 >= msg.length) {
        status++;
        break;
      }
    }
    var ps = msg.slice(2, i2 - 1);
    if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
      status++;
    }
    if (ps.length < 8) {
      status++;
    }
    if (status) {
      throw new Error("decryption error");
    }
    return msg.slice(i2);
  }
  function compare(a, b) {
    a = Buffer2.from(a);
    b = Buffer2.from(b);
    var dif = 0;
    var len2 = a.length;
    if (a.length !== b.length) {
      dif++;
      len2 = Math.min(a.length, b.length);
    }
    var i2 = -1;
    while (++i2 < len2) {
      dif += a[i2] ^ b[i2];
    }
    return dif;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  (function(exports2) {
    exports2.publicEncrypt = requirePublicEncrypt();
    exports2.privateDecrypt = requirePrivateDecrypt();
    exports2.privateEncrypt = function privateEncrypt(key2, buf) {
      return exports2.publicEncrypt(key2, buf, true);
    };
    exports2.publicDecrypt = function publicDecrypt(key2, buf) {
      return exports2.privateDecrypt(key2, buf, true);
    };
  })(browser$3);
  return browser$3;
}
var browser$2 = {};
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  function oldBrowser() {
    throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
  }
  var safeBuffer2 = requireSafeBuffer$3();
  var randombytes = requireBrowser$d();
  var Buffer2 = safeBuffer2.Buffer;
  var kBufferMaxLength = safeBuffer2.kMaxLength;
  var crypto2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  var kMaxUint32 = Math.pow(2, 32) - 1;
  function assertOffset(offset, length) {
    if (typeof offset !== "number" || offset !== offset) {
      throw new TypeError("offset must be a number");
    }
    if (offset > kMaxUint32 || offset < 0) {
      throw new TypeError("offset must be a uint32");
    }
    if (offset > kBufferMaxLength || offset > length) {
      throw new RangeError("offset out of range");
    }
  }
  function assertSize(size, offset, length) {
    if (typeof size !== "number" || size !== size) {
      throw new TypeError("size must be a number");
    }
    if (size > kMaxUint32 || size < 0) {
      throw new TypeError("size must be a uint32");
    }
    if (size + offset > length || size > kBufferMaxLength) {
      throw new RangeError("buffer too small");
    }
  }
  if (crypto2 && crypto2.getRandomValues || !process$1.browser) {
    browser$2.randomFill = randomFill;
    browser$2.randomFillSync = randomFillSync;
  } else {
    browser$2.randomFill = oldBrowser;
    browser$2.randomFillSync = oldBrowser;
  }
  function randomFill(buf, offset, size, cb) {
    if (!Buffer2.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    }
    if (typeof offset === "function") {
      cb = offset;
      offset = 0;
      size = buf.length;
    } else if (typeof size === "function") {
      cb = size;
      size = buf.length - offset;
    } else if (typeof cb !== "function") {
      throw new TypeError('"cb" argument must be a function');
    }
    assertOffset(offset, buf.length);
    assertSize(size, offset, buf.length);
    return actualFill(buf, offset, size, cb);
  }
  function actualFill(buf, offset, size, cb) {
    if (process$1.browser) {
      var ourBuf = buf.buffer;
      var uint = new Uint8Array(ourBuf, offset, size);
      crypto2.getRandomValues(uint);
      if (cb) {
        process$1.nextTick(function() {
          cb(null, buf);
        });
        return;
      }
      return buf;
    }
    if (cb) {
      randombytes(size, function(err, bytes2) {
        if (err) {
          return cb(err);
        }
        bytes2.copy(buf, offset);
        cb(null, buf);
      });
      return;
    }
    var bytes = randombytes(size);
    bytes.copy(buf, offset);
    return buf;
  }
  function randomFillSync(buf, offset, size) {
    if (typeof offset === "undefined") {
      offset = 0;
    }
    if (!Buffer2.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    }
    assertOffset(offset, buf.length);
    if (size === void 0) size = buf.length - offset;
    assertSize(size, offset, buf.length);
    return actualFill(buf, offset, size);
  }
  return browser$2;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1;
  cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$d();
  cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$b();
  cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$a();
  var algos2 = requireAlgos();
  var algoKeys = Object.keys(algos2);
  var hashes = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(algoKeys);
  cryptoBrowserify.getHashes = function() {
    return hashes;
  };
  var p = requireBrowser$9();
  cryptoBrowserify.pbkdf2 = p.pbkdf2;
  cryptoBrowserify.pbkdf2Sync = p.pbkdf2Sync;
  var aes2 = requireBrowser$7();
  cryptoBrowserify.Cipher = aes2.Cipher;
  cryptoBrowserify.createCipher = aes2.createCipher;
  cryptoBrowserify.Cipheriv = aes2.Cipheriv;
  cryptoBrowserify.createCipheriv = aes2.createCipheriv;
  cryptoBrowserify.Decipher = aes2.Decipher;
  cryptoBrowserify.createDecipher = aes2.createDecipher;
  cryptoBrowserify.Decipheriv = aes2.Decipheriv;
  cryptoBrowserify.createDecipheriv = aes2.createDecipheriv;
  cryptoBrowserify.getCiphers = aes2.getCiphers;
  cryptoBrowserify.listCiphers = aes2.listCiphers;
  var dh2 = requireBrowser$6();
  cryptoBrowserify.DiffieHellmanGroup = dh2.DiffieHellmanGroup;
  cryptoBrowserify.createDiffieHellmanGroup = dh2.createDiffieHellmanGroup;
  cryptoBrowserify.getDiffieHellman = dh2.getDiffieHellman;
  cryptoBrowserify.createDiffieHellman = dh2.createDiffieHellman;
  cryptoBrowserify.DiffieHellman = dh2.DiffieHellman;
  var sign2 = requireBrowser$5();
  cryptoBrowserify.createSign = sign2.createSign;
  cryptoBrowserify.Sign = sign2.Sign;
  cryptoBrowserify.createVerify = sign2.createVerify;
  cryptoBrowserify.Verify = sign2.Verify;
  cryptoBrowserify.createECDH = requireBrowser$4();
  var publicEncrypt2 = requireBrowser$3();
  cryptoBrowserify.publicEncrypt = publicEncrypt2.publicEncrypt;
  cryptoBrowserify.privateEncrypt = publicEncrypt2.privateEncrypt;
  cryptoBrowserify.publicDecrypt = publicEncrypt2.publicDecrypt;
  cryptoBrowserify.privateDecrypt = publicEncrypt2.privateDecrypt;
  var rf = requireBrowser$2();
  cryptoBrowserify.randomFill = rf.randomFill;
  cryptoBrowserify.randomFillSync = rf.randomFillSync;
  cryptoBrowserify.createCredentials = function() {
    throw new Error("sorry, createCredentials is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify");
  };
  cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  };
  return cryptoBrowserify;
}
var hasRequiredNaclFast;
function requireNaclFast() {
  if (hasRequiredNaclFast) return naclFast.exports;
  hasRequiredNaclFast = 1;
  (function(module) {
    (function(nacl) {
      var gf = function(init2) {
        var i2, r = new Float64Array(16);
        if (init2) for (i2 = 0; i2 < init2.length; i2++) r[i2] = init2[i2];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _92 = new Uint8Array(32);
      _92[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i2, h, l) {
        x[i2] = h >> 24 & 255;
        x[i2 + 1] = h >> 16 & 255;
        x[i2 + 2] = h >> 8 & 255;
        x[i2 + 3] = h & 255;
        x[i2 + 4] = l >> 24 & 255;
        x[i2 + 5] = l >> 16 & 255;
        x[i2 + 6] = l >> 8 & 255;
        x[i2 + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i2, d = 0;
        for (i2 = 0; i2 < n; i2++) d |= x[xi + i2] ^ y[yi + i2];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = m[mpos + i2] ^ x[i2];
          u = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u = u + (z[i2] & 255) | 0;
            z[i2] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = m[mpos + i2] ^ x[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = x[i2];
          u = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u = u + (z[i2] & 255) | 0;
            z[i2] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = x[i2];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key2) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key2[0] & 255 | (key2[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key2[2] & 255 | (key2[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key2[4] & 255 | (key2[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key2[6] & 255 | (key2[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key2[8] & 255 | (key2[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key2[10] & 255 | (key2[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key2[12] & 255 | (key2[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key2[14] & 255 | (key2[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key2[16] & 255 | (key2[17] & 255) << 8;
        this.pad[1] = key2[18] & 255 | (key2[19] & 255) << 8;
        this.pad[2] = key2[20] & 255 | (key2[21] & 255) << 8;
        this.pad[3] = key2[22] & 255 | (key2[23] & 255) << 8;
        this.pad[4] = key2[24] & 255 | (key2[25] & 255) << 8;
        this.pad[5] = key2[26] & 255 | (key2[27] & 255) << 8;
        this.pad[6] = key2[28] & 255 | (key2[29] & 255) << 8;
        this.pad[7] = key2[30] & 255 | (key2[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask2, f, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++) this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c;
          c = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g[i2] = this.h[i2] + c;
          c = g[i2] >>> 13;
          g[i2] &= 8191;
        }
        g[9] -= 1 << 13;
        mask2 = (c ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) g[i2] &= mask2;
        mask2 = ~mask2;
        for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask2 | g[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f = (this.h[i2] + this.pad[i2] | 0) + (f >>> 16) | 0;
          this.h[i2] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i2;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i2 = 0; i2 < 16; i2++) c[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i2;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i2 = 0; i2 < 32; i2++) m[i2] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) r[i2] = a[i2] | 0;
      }
      function car25519(o) {
        var i2, v, c = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v = o[i2] + c + 65535;
          c = Math.floor(v / 65536);
          o[i2] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t2, c = ~(b - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t2 = c & (p[i2] ^ q[i2]);
          p[i2] ^= t2;
          q[i2] ^= t2;
        }
      }
      function pack25519(o, n) {
        var i2, j, b;
        var m = gf(), t2 = gf();
        for (i2 = 0; i2 < 16; i2++) t2[i2] = n[i2];
        car25519(t2);
        car25519(t2);
        car25519(t2);
        for (j = 0; j < 2; j++) {
          m[0] = t2[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m[i2] = t2[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
            m[i2 - 1] &= 65535;
          }
          m[15] = t2[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t2, m, 1 - b);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o[2 * i2] = t2[i2] & 255;
          o[2 * i2 + 1] = t2[i2] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) o[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i2 = 0; i2 < 16; i2++) o[i2] = a[i2] + b[i2];
      }
      function Z(o, a, b) {
        for (var i2 = 0; i2 < 16; i2++) o[i2] = a[i2] - b[i2];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i2[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4) M(c, c, i2);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function pow2523(o, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i2[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1) M(c, c, i2);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i2;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i2 = 0; i2 < 31; i2++) z[i2] = n[i2];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i2 = 0; i2 < 16; i2++) {
          b[i2] = x[i2];
          d[i2] = a[i2] = c[i2] = 0;
        }
        a[0] = d[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r = z[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x[i2 + 16] = a[i2];
          x[i2 + 32] = c[i2];
          x[i2 + 48] = b[i2];
          x[i2 + 64] = d[i2];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _92);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh[i2] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i2] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i2 * 2];
            l = K[i2 * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i2 % 16];
            l = wl[i2 % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i2, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i2 = 0; i2 < n; i2++) x[i2] = m[b - n + i2];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t2 = gf();
        Z(a, p[1], p[0]);
        Z(t2, q[1], q[0]);
        M(a, a, t2);
        A(b, p[0], p[1]);
        A(t2, q[0], q[1]);
        M(b, b, t2);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p[i2], q[i2], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i2;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b = s[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i2, j, k;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i2] * L[j - (i2 - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i2 = 0; i2 < 32; i2++) {
          x[i2 + 1] += x[i2] >> 8;
          r[i2] = x[i2] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++) x[i2] = r[i2];
        for (i2 = 0; i2 < 64; i2++) r[i2] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i2, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i2 = 0; i2 < n; i2++) sm[64 + i2] = m[i2];
        for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d[32 + i2];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i2 = 0; i2 < 64; i2++) x[i2] = 0;
        for (i2 = 0; i2 < 32; i2++) x[i2] = r[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x[i2 + j] += h[i2] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t2, den6, num);
        M(t2, t2, den);
        pow2523(t2, t2);
        M(t2, t2, num);
        M(t2, t2, den);
        M(t2, t2, den);
        M(r[0], t2, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i2;
        var t2 = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i2 = 0; i2 < n; i2++) m[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++) m[i2 + 32] = pk[i2];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t2, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t2, 0)) {
          for (i2 = 0; i2 < n; i2++) m[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n; i2++) m[i2] = sm[i2 + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr2) {
        for (var i2 = 0; i2 < arr2.length; i2++) arr2[i2] = 0;
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key2) {
        checkArrayTypes(msg, nonce, key2);
        checkLengths(key2, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i2 = 0; i2 < msg.length; i2++) m[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c, m, m.length, nonce, key2);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key2) {
        checkArrayTypes(box, nonce, key2);
        checkLengths(key2, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i2 = 0; i2 < box.length; i2++) c[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key2) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m.length; i2++) m[i2] = tmp[i2];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i2, v = new Uint8Array(n);
            for (i2 = 0; i2 < n; i2 += QUOTA) {
              crypto2.getRandomValues(v.subarray(i2, i2 + Math.min(n - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n; i2++) x[i2] = v[i2];
            cleanup(v);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto2 = requireCryptoBrowserify();
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i2, v = crypto2.randomBytes(n);
              for (i2 = 0; i2 < n; i2++) x[i2] = v[i2];
              cleanup(v);
            });
          }
        }
      })();
    })(module.exports ? module.exports : self.nacl = self.nacl || {});
  })(naclFast);
  return naclFast.exports;
}
var hasRequiredSigning;
function requireSigning() {
  if (hasRequiredSigning) return signing;
  hasRequiredSigning = 1;
  Object.defineProperty(signing, "__esModule", {
    value: true
  });
  signing.sign = sign2;
  signing.verify = verify;
  signing.generate = generate;
  var actualMethods = {};
  signing.FastSigning = checkFastSigning();
  function sign2(data, secretKey) {
    return actualMethods.sign(data, secretKey);
  }
  function verify(data, signature2, publicKey) {
    return actualMethods.verify(data, signature2, publicKey);
  }
  function generate(secretKey) {
    return actualMethods.generate(secretKey);
  }
  function checkFastSigning() {
    return typeof window === "undefined" ? checkFastSigningNode() : checkFastSigningBrowser();
  }
  function checkFastSigningNode() {
    var sodium = void 0;
    try {
      sodium = require$$0$3;
    } catch (err) {
      return checkFastSigningBrowser();
    }
    actualMethods.generate = function(secretKey) {
      var pk = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
      var sk = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);
      sodium.crypto_sign_seed_keypair(pk, sk, secretKey);
      return pk;
    };
    actualMethods.sign = function(data, secretKey) {
      data = Buffer.from(data);
      var signature2 = Buffer.alloc(sodium.crypto_sign_BYTES);
      sodium.crypto_sign_detached(signature2, data, secretKey);
      return signature2;
    };
    actualMethods.verify = function(data, signature2, publicKey) {
      data = Buffer.from(data);
      try {
        return sodium.crypto_sign_verify_detached(signature2, data, publicKey);
      } catch (e) {
        return false;
      }
    };
    return true;
  }
  function checkFastSigningBrowser() {
    var nacl = requireNaclFast();
    actualMethods.generate = function(secretKey) {
      var secretKeyUint8 = new Uint8Array(secretKey);
      var naclKeys = nacl.sign.keyPair.fromSeed(secretKeyUint8);
      return Buffer.from(naclKeys.publicKey);
    };
    actualMethods.sign = function(data, secretKey) {
      data = Buffer.from(data);
      data = new Uint8Array(data.toJSON().data);
      secretKey = new Uint8Array(secretKey.toJSON().data);
      var signature2 = nacl.sign.detached(data, secretKey);
      return Buffer.from(signature2);
    };
    actualMethods.verify = function(data, signature2, publicKey) {
      data = Buffer.from(data);
      data = new Uint8Array(data.toJSON().data);
      signature2 = new Uint8Array(signature2.toJSON().data);
      publicKey = new Uint8Array(publicKey.toJSON().data);
      return nacl.sign.detached.verify(data, signature2, publicKey);
    };
    return false;
  }
  return signing;
}
var get_liquidity_pool_id = {};
var stellarXdr_generated = {};
var lib$1 = {};
var types = {};
var int = {};
var isNumber_1;
var hasRequiredIsNumber;
function requireIsNumber() {
  if (hasRequiredIsNumber) return isNumber_1;
  hasRequiredIsNumber = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var numberTag = "[object Number]";
  function isNumber(value) {
    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
  }
  isNumber_1 = isNumber;
  return isNumber_1;
}
var ioMixin = {};
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData) return _coreJsData;
  hasRequired_coreJsData = 1;
  var root = require_root();
  var coreJsData = root["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked) return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked = isMasked;
  return _isMasked;
}
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource) return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  _toSource = toSource;
  return _toSource;
}
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative) return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction2 = requireIsFunction(), isMasked = require_isMasked(), isObject2 = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue) return _getValue;
  hasRequired_getValue = 1;
  function getValue2(object, key2) {
    return object == null ? void 0 : object[key2];
  }
  _getValue = getValue2;
  return _getValue;
}
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative) return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue2 = require_getValue();
  function getNative(object, key2) {
    var value = getValue2(object, key2);
    return baseIsNative(value) ? value : void 0;
  }
  _getNative = getNative;
  return _getNative;
}
var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty) return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative = require_getNative();
  var defineProperty2 = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  _defineProperty = defineProperty2;
  return _defineProperty;
}
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue) return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty2 = require_defineProperty();
  function baseAssignValue(object, key2, value) {
    if (key2 == "__proto__" && defineProperty2) {
      defineProperty2(object, key2, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key2] = value;
    }
  }
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq;
  return eq_1;
}
var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue) return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq = requireEq();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function assignValue(object, key2, value) {
    var objValue = object[key2];
    if (!(hasOwnProperty.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
      baseAssignValue(object, key2, value);
    }
  }
  _assignValue = assignValue;
  return _assignValue;
}
var _copyObject;
var hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject) return _copyObject;
  hasRequired_copyObject = 1;
  var assignValue = require_assignValue(), baseAssignValue = require_baseAssignValue();
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key2 = props[index2];
      var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key2];
      }
      if (isNew) {
        baseAssignValue(object, key2, newValue);
      } else {
        assignValue(object, key2, newValue);
      }
    }
    return object;
  }
  _copyObject = copyObject;
  return _copyObject;
}
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply) return _apply;
  hasRequired_apply = 1;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply;
  return _apply;
}
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest) return _overRest;
  hasRequired_overRest = 1;
  var apply = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start, transform2) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
      while (++index2 < length) {
        array2[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform2(array2);
      return apply(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant) return constant_1;
  hasRequiredConstant = 1;
  function constant(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant;
  return constant_1;
}
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString) return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant = requireConstant(), defineProperty2 = require_defineProperty(), identity = requireIdentity();
  var baseSetToString = !defineProperty2 ? identity : function(func, string2) {
    return defineProperty2(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string2),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut) return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString) return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest) return _baseRest;
  hasRequired_baseRest = 1;
  var identity = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall) return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq = requireEq(), isArrayLike = requireIsArrayLike(), isIndex = require_isIndex(), isObject2 = requireIsObject();
  function isIterateeCall(value, index2, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
      return eq(object[index2], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var _createAssigner;
var hasRequired_createAssigner;
function require_createAssigner() {
  if (hasRequired_createAssigner) return _createAssigner;
  hasRequired_createAssigner = 1;
  var baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  _createAssigner = createAssigner;
  return _createAssigner;
}
var assignIn_1;
var hasRequiredAssignIn;
function requireAssignIn() {
  if (hasRequiredAssignIn) return assignIn_1;
  hasRequiredAssignIn = 1;
  var copyObject = require_copyObject(), createAssigner = require_createAssigner(), keysIn = requireKeysIn();
  var assignIn = createAssigner(function(object, source) {
    copyObject(source, keysIn(source), object);
  });
  assignIn_1 = assignIn;
  return assignIn_1;
}
var extend;
var hasRequiredExtend;
function requireExtend() {
  if (hasRequiredExtend) return extend;
  hasRequiredExtend = 1;
  extend = requireAssignIn();
  return extend;
}
var cursor = {};
var util = {};
var _arrayEvery;
var hasRequired_arrayEvery;
function require_arrayEvery() {
  if (hasRequired_arrayEvery) return _arrayEvery;
  hasRequired_arrayEvery = 1;
  function arrayEvery(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length;
    while (++index2 < length) {
      if (!predicate(array2[index2], index2, array2)) {
        return false;
      }
    }
    return true;
  }
  _arrayEvery = arrayEvery;
  return _arrayEvery;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg) return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  _overArg = overArg;
  return _overArg;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys) return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys) return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key2 in Object(object)) {
      if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
  function keys2(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  keys_1 = keys2;
  return keys_1;
}
var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn) return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor = require_baseFor(), keys2 = requireKeys();
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys2);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}
var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach) return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}
var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach) return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}
var _baseEvery;
var hasRequired_baseEvery;
function require_baseEvery() {
  if (hasRequired_baseEvery) return _baseEvery;
  hasRequired_baseEvery = 1;
  var baseEach = require_baseEach();
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index2, collection2) {
      result = !!predicate(value, index2, collection2);
      return result;
    });
    return result;
  }
  _baseEvery = baseEvery;
  return _baseEvery;
}
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear) return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear = listCacheClear;
  return _listCacheClear;
}
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf) return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq = requireEq();
  function assocIndexOf(array2, key2) {
    var length = array2.length;
    while (length--) {
      if (eq(array2[length][0], key2)) {
        return length;
      }
    }
    return -1;
  }
  _assocIndexOf = assocIndexOf;
  return _assocIndexOf;
}
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete) return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf = require_assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete = listCacheDelete;
  return _listCacheDelete;
}
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet) return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  _listCacheGet = listCacheGet;
  return _listCacheGet;
}
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas) return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  _listCacheHas = listCacheHas;
  return _listCacheHas;
}
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet) return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key2, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      ++this.size;
      data.push([key2, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  _listCacheSet = listCacheSet;
  return _listCacheSet;
}
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache) return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  _ListCache = ListCache;
  return _ListCache;
}
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear) return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete) return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key2) {
    var data = this.__data__, result = data["delete"](key2);
    this.size = data.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet) return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  _stackGet = stackGet;
  return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas) return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  _stackHas = stackHas;
  return _stackHas;
}
var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map) return _Map;
  hasRequired_Map = 1;
  var getNative = require_getNative(), root = require_root();
  var Map2 = getNative(root, "Map");
  _Map = Map2;
  return _Map;
}
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate) return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative = require_getNative();
  var nativeCreate = getNative(Object, "create");
  _nativeCreate = nativeCreate;
  return _nativeCreate;
}
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear) return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  _hashClear = hashClear;
  return _hashClear;
}
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete) return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete = hashDelete;
  return _hashDelete;
}
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet) return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key2) ? data[key2] : void 0;
  }
  _hashGet = hashGet;
  return _hashGet;
}
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas) return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate = require_nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty.call(data, key2);
  }
  _hashHas = hashHas;
  return _hashHas;
}
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet) return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key2, value) {
    var data = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  _hashSet = hashSet;
  return _hashSet;
}
var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash) return _Hash;
  hasRequired_Hash = 1;
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  _Hash = Hash;
  return _Hash;
}
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear) return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  _mapCacheClear = mapCacheClear;
  return _mapCacheClear;
}
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable) return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable = isKeyable;
  return _isKeyable;
}
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData) return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable = require_isKeyable();
  function getMapData(map2, key2) {
    var data = map2.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  _getMapData = getMapData;
  return _getMapData;
}
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete) return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData = require_getMapData();
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete = mapCacheDelete;
  return _mapCacheDelete;
}
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet) return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData = require_getMapData();
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  _mapCacheGet = mapCacheGet;
  return _mapCacheGet;
}
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas) return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData = require_getMapData();
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  _mapCacheHas = mapCacheHas;
  return _mapCacheHas;
}
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet) return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData = require_getMapData();
  function mapCacheSet(key2, value) {
    var data = getMapData(this, key2), size = data.size;
    data.set(key2, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet = mapCacheSet;
  return _mapCacheSet;
}
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache) return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  _MapCache = MapCache;
  return _MapCache;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet) return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key2, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key2, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key2, value);
    this.size = data.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack) return _Stack;
  hasRequired_Stack = 1;
  var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  _Stack = Stack;
  return _Stack;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd) return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas) return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache) return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values2) {
    var index2 = -1, length = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values2[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome) return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length;
    while (++index2 < length) {
      if (predicate(array2[index2], index2, array2)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas) return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache2, key2) {
    return cache2.has(key2);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays) return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array2);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array2;
    }
    var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while (++index2 < arrLength) {
      var arrValue = array2[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen2) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen2.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array) return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root = require_root();
  var Uint8Array2 = root.Uint8Array;
  _Uint8Array = Uint8Array2;
  return _Uint8Array;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray) return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key2) {
      result[++index2] = [key2, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray) return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set3) {
    var index2 = -1, result = Array(set3.size);
    set3.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag) return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq = requireEq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush) return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush(array2, values2) {
    var index2 = -1, length = values2.length, offset = array2.length;
    while (++index2 < length) {
      array2[offset + index2] = values2[index2];
    }
    return array2;
  }
  _arrayPush = arrayPush;
  return _arrayPush;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush = require_arrayPush(), isArray2 = requireIsArray();
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter) return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array2[index2];
      if (predicate(value, index2, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray) return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols) return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys) return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys2 = requireKeys();
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys2, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects) return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key2 = objProps[index2];
      if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key2 = objProps[index2];
      var objValue = object[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView) return _DataView;
  hasRequired_DataView = 1;
  var getNative = require_getNative(), root = require_root();
  var DataView2 = getNative(root, "DataView");
  _DataView = DataView2;
  return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise) return _Promise;
  hasRequired_Promise = 1;
  var getNative = require_getNative(), root = require_root();
  var Promise2 = getNative(root, "Promise");
  _Promise = Promise2;
  return _Promise;
}
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set) return _Set;
  hasRequired_Set = 1;
  var getNative = require_getNative(), root = require_root();
  var Set2 = getNative(root, "Set");
  _Set = Set2;
  return _Set;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap) return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative = require_getNative(), root = require_root();
  var WeakMap2 = getNative(root, "WeakMap");
  _WeakMap = WeakMap2;
  return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag) return _getTag;
  hasRequired_getTag = 1;
  var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag;
  return _getTag;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray2 = requireIsTypedArray$1();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual) return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = requireIsObjectLike();
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch) return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index2 = matchData.length, length = index2, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index2--) {
      var data = matchData[index2];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index2 < length) {
      data = matchData[index2];
      var key2 = data[0], objValue = object[key2], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key2 in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key2, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable) return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject2 = requireIsObject();
  function isStrictComparable(value) {
    return value === value && !isObject2(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData) return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys2 = requireKeys();
  function getMatchData(object) {
    var result = keys2(object), length = result.length;
    while (length--) {
      var key2 = result[length], value = object[key2];
      result[length] = [key2, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key2, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches) return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey) return _isKey;
  hasRequired_isKey = 1;
  var isArray2 = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey2(value, object) {
    if (isArray2(value)) {
      return false;
    }
    var type2 = typeof value;
    if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  _isKey = isKey2;
  return _isKey;
}
var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize) return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache = require_MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize3(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key2)) {
        return cache2.get(key2);
      }
      var result = func.apply(this, args);
      memoized.cache = cache2.set(key2, result) || cache2;
      return result;
    };
    memoized.cache = new (memoize3.Cache || MapCache)();
    return memoized;
  }
  memoize3.Cache = MapCache;
  memoize_1 = memoize3;
  return memoize_1;
}
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped) return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize3 = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize3(func, function(key2) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key2;
    });
    var cache2 = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath) return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath2 = memoizeCapped(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
      result.push("");
    }
    string2.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  _stringToPath = stringToPath2;
  return _stringToPath;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array2, iteratee) {
    var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
    while (++index2 < length) {
      result[index2] = iteratee(array2[index2], index2, array2);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString) return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray2 = requireIsArray(), isSymbol = requireIsSymbol();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray2(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString2(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString2;
  return toString_1;
}
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath) return _castPath;
  hasRequired_castPath = 1;
  var isArray2 = requireIsArray(), isKey2 = require_isKey(), stringToPath2 = require_stringToPath(), toString2 = requireToString();
  function castPath2(value, object) {
    if (isArray2(value)) {
      return value;
    }
    return isKey2(value, object) ? [value] : stringToPath2(toString2(value));
  }
  _castPath = castPath2;
  return _castPath;
}
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey) return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet) return _baseGet;
  hasRequired_baseGet = 1;
  var castPath2 = require_castPath(), toKey = require_toKey();
  function baseGet2(object, path2) {
    path2 = castPath2(path2, object);
    var index2 = 0, length = path2.length;
    while (object != null && index2 < length) {
      object = object[toKey(path2[index2++])];
    }
    return index2 && index2 == length ? object : void 0;
  }
  _baseGet = baseGet2;
  return _baseGet;
}
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get_1;
  hasRequiredGet = 1;
  var baseGet2 = require_baseGet();
  function get3(object, path2, defaultValue) {
    var result = object == null ? void 0 : baseGet2(object, path2);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get3;
  return get_1;
}
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn) return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object, key2) {
    return object != null && key2 in Object(object);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath) return _hasPath;
  hasRequired_hasPath = 1;
  var castPath2 = require_castPath(), isArguments2 = requireIsArguments$1(), isArray2 = requireIsArray(), isIndex = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
  function hasPath(object, path2, hasFunc) {
    path2 = castPath2(path2, object);
    var index2 = -1, length = path2.length, result = false;
    while (++index2 < length) {
      var key2 = toKey(path2[index2]);
      if (!(result = object != null && hasFunc(object, key2))) {
        break;
      }
      object = object[key2];
    }
    if (result || ++index2 != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key2, length) && (isArray2(object) || isArguments2(object));
  }
  _hasPath = hasPath;
  return _hasPath;
}
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn) return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object, path2) {
    return object != null && hasPath(object, path2, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get3 = requireGet(), hasIn = requireHasIn(), isKey2 = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path2, srcValue) {
    if (isKey2(path2) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path2), srcValue);
    }
    return function(object) {
      var objValue = get3(object, path2);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty) return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key2) {
    return function(object) {
      return object == null ? void 0 : object[key2];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep) return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet2 = require_baseGet();
  function basePropertyDeep(path2) {
    return function(object) {
      return baseGet2(object, path2);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty) return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey2 = require_isKey(), toKey = require_toKey();
  function property(path2) {
    return isKey2(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
  }
  property_1 = property;
  return property_1;
}
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee) return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity = requireIdentity(), isArray2 = requireIsArray(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}
var every_1;
var hasRequiredEvery;
function requireEvery() {
  if (hasRequiredEvery) return every_1;
  hasRequiredEvery = 1;
  var arrayEvery = require_arrayEvery(), baseEvery = require_baseEvery(), baseIteratee = require_baseIteratee(), isArray2 = requireIsArray(), isIterateeCall = require_isIterateeCall();
  function every(collection, predicate, guard) {
    var func = isArray2(collection) ? arrayEvery : baseEvery;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = void 0;
    }
    return func(collection, baseIteratee(predicate, 3));
  }
  every_1 = every;
  return every_1;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", {
    value: true
  });
  util.calculatePadding = calculatePadding;
  util.slicePadding = slicePadding;
  var _every = requireEvery();
  var _every2 = _interopRequireDefault(_every);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function calculatePadding(length) {
    switch (length % 4) {
      case 0:
        return 0;
      case 1:
        return 3;
      case 2:
        return 2;
      case 3:
        return 1;
      default:
        return null;
    }
  }
  function slicePadding(io, length) {
    var padding = io.slice(length);
    var allZero = (0, _every2.default)(padding.buffer(), function(byte) {
      return byte === 0;
    });
    if (allZero !== true) {
      throw new Error("XDR Read Error: invalid padding");
    }
  }
  return util;
}
var hasRequiredCursor;
function requireCursor() {
  if (hasRequiredCursor) return cursor;
  hasRequiredCursor = 1;
  Object.defineProperty(cursor, "__esModule", {
    value: true
  });
  cursor.Cursor = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _util = requireUtil();
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Cursor = function() {
    function Cursor2(buffer2) {
      _classCallCheck2(this, Cursor2);
      if (!(buffer2 instanceof Buffer)) {
        buffer2 = typeof buffer2 === "number" ? Buffer.alloc(buffer2) : Buffer.from(buffer2);
      }
      this._setBuffer(buffer2);
      this.rewind();
    }
    _createClass2(Cursor2, [{
      key: "_setBuffer",
      value: function _setBuffer(buffer2) {
        this._buffer = buffer2;
        this.length = buffer2.length;
      }
    }, {
      key: "buffer",
      value: function buffer2() {
        return this._buffer;
      }
    }, {
      key: "tap",
      value: function tap(cb) {
        cb(this);
        return this;
      }
    }, {
      key: "clone",
      value: function clone(newIndex) {
        var c = new this.constructor(this.buffer());
        c.seek(arguments.length === 0 ? this.tell() : newIndex);
        return c;
      }
    }, {
      key: "tell",
      value: function tell() {
        return this._index;
      }
    }, {
      key: "seek",
      value: function seek(op, index2) {
        if (arguments.length === 1) {
          index2 = op;
          op = "=";
        }
        if (op === "+") {
          this._index += index2;
        } else if (op === "-") {
          this._index -= index2;
        } else {
          this._index = index2;
        }
        return this;
      }
    }, {
      key: "rewind",
      value: function rewind() {
        return this.seek(0);
      }
    }, {
      key: "eof",
      value: function eof() {
        return this.tell() === this.buffer().length;
      }
    }, {
      key: "write",
      value: function write(string2, length, encoding) {
        return this.seek("+", this.buffer().write(string2, this.tell(), length, encoding));
      }
    }, {
      key: "fill",
      value: function fill(value, length) {
        if (arguments.length === 1) {
          length = this.buffer().length - this.tell();
        }
        this.buffer().fill(value, this.tell(), this.tell() + length);
        this.seek("+", length);
        return this;
      }
    }, {
      key: "slice",
      value: function slice2(length) {
        if (arguments.length === 0) {
          length = this.length - this.tell();
        }
        var c = new this.constructor(this.buffer().slice(this.tell(), this.tell() + length));
        this.seek("+", length);
        return c;
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(source) {
        var buf = source instanceof Buffer ? source : source.buffer();
        buf.copy(this.buffer(), this.tell(), 0, buf.length);
        this.seek("+", buf.length);
        return this;
      }
    }, {
      key: "concat",
      value: function concat(list) {
        list.forEach(function(item, i2) {
          if (item instanceof Cursor2) {
            list[i2] = item.buffer();
          }
        });
        list.unshift(this.buffer());
        var b = Buffer.concat(list);
        this._setBuffer(b);
        return this;
      }
    }, {
      key: "toString",
      value: function toString2(encoding, length) {
        if (arguments.length === 0) {
          encoding = "utf8";
          length = this.buffer().length - this.tell();
        } else if (arguments.length === 1) {
          length = this.buffer().length - this.tell();
        }
        var val = this.buffer().toString(encoding, this.tell(), this.tell() + length);
        this.seek("+", length);
        return val;
      }
    }, {
      key: "writeBufferPadded",
      value: function writeBufferPadded(buffer2) {
        var padding = (0, _util.calculatePadding)(buffer2.length);
        var paddingBuffer = Buffer.alloc(padding);
        return this.copyFrom(new Cursor2(buffer2)).copyFrom(new Cursor2(paddingBuffer));
      }
    }]);
    return Cursor2;
  }();
  [[1, ["readInt8", "readUInt8"]], [2, ["readInt16BE", "readInt16LE", "readUInt16BE", "readUInt16LE"]], [4, ["readInt32BE", "readInt32LE", "readUInt32BE", "readUInt32LE", "readFloatBE", "readFloatLE"]], [8, ["readDoubleBE", "readDoubleLE"]]].forEach(function(arr2) {
    arr2[1].forEach(function(method) {
      Cursor.prototype[method] = function read2() {
        var val = this.buffer()[method](this.tell());
        this.seek("+", arr2[0]);
        return val;
      };
    });
  });
  [[1, ["writeInt8", "writeUInt8"]], [2, ["writeInt16BE", "writeInt16LE", "writeUInt16BE", "writeUInt16LE"]], [4, ["writeInt32BE", "writeInt32LE", "writeUInt32BE", "writeUInt32LE", "writeFloatBE", "writeFloatLE"]], [8, ["writeDoubleBE", "writeDoubleLE"]]].forEach(function(arr2) {
    arr2[1].forEach(function(method) {
      Cursor.prototype[method] = function write(val) {
        this.buffer()[method](val, this.tell());
        this.seek("+", arr2[0]);
        return this;
      };
    });
  });
  cursor.Cursor = Cursor;
  return cursor;
}
var hasRequiredIoMixin;
function requireIoMixin() {
  if (hasRequiredIoMixin) return ioMixin;
  hasRequiredIoMixin = 1;
  Object.defineProperty(ioMixin, "__esModule", {
    value: true
  });
  ioMixin.default = includeIoMixin;
  var _extend = requireExtend();
  var _extend2 = _interopRequireDefault(_extend);
  var _isFunction = requireIsFunction();
  var _isFunction2 = _interopRequireDefault(_isFunction);
  var _cursor = requireCursor();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var BUFFER_SIZE = Math.pow(2, 16);
  var staticMethods = {
    toXDR: function toXDR(val) {
      var cursor2 = new _cursor.Cursor(BUFFER_SIZE);
      this.write(val, cursor2);
      var bytesWritten = cursor2.tell();
      cursor2.rewind();
      return cursor2.slice(bytesWritten).buffer();
    },
    fromXDR: function fromXDR(input) {
      var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "raw";
      var buffer2 = void 0;
      switch (format2) {
        case "raw":
          buffer2 = input;
          break;
        case "hex":
          buffer2 = Buffer.from(input, "hex");
          break;
        case "base64":
          buffer2 = Buffer.from(input, "base64");
          break;
        default:
          throw new Error("Invalid format " + format2 + ', must be "raw", "hex", "base64"');
      }
      var cursor2 = new _cursor.Cursor(buffer2);
      var result = this.read(cursor2);
      return result;
    },
    validateXDR: function validateXDR(input) {
      var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "raw";
      try {
        this.fromXDR(input, format2);
        return true;
      } catch (e) {
        return false;
      }
    }
  };
  var instanceMethods = {
    toXDR: function toXDR() {
      var format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "raw";
      var buffer2 = this.constructor.toXDR(this);
      switch (format2) {
        case "raw":
          return buffer2;
        case "hex":
          return buffer2.toString("hex");
        case "base64":
          return buffer2.toString("base64");
        default:
          throw new Error("Invalid format " + format2 + ', must be "raw", "hex", "base64"');
      }
    }
  };
  function includeIoMixin(obj) {
    (0, _extend2.default)(obj, staticMethods);
    if ((0, _isFunction2.default)(obj)) {
      (0, _extend2.default)(obj.prototype, instanceMethods);
    }
  }
  return ioMixin;
}
var hasRequiredInt;
function requireInt() {
  if (hasRequiredInt) return int;
  hasRequiredInt = 1;
  Object.defineProperty(int, "__esModule", {
    value: true
  });
  int.Int = void 0;
  var _isNumber = requireIsNumber();
  var _isNumber2 = _interopRequireDefault(_isNumber);
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Int = int.Int = {
    read: function read2(io) {
      return io.readInt32BE();
    },
    write: function write(value, io) {
      if (!(0, _isNumber2.default)(value)) {
        throw new Error("XDR Write Error: not a number");
      }
      if (Math.floor(value) !== value) {
        throw new Error("XDR Write Error: not an integer");
      }
      io.writeInt32BE(value);
    },
    isValid: function isValid(value) {
      if (!(0, _isNumber2.default)(value)) {
        return false;
      }
      if (Math.floor(value) !== value) {
        return false;
      }
      return value >= Int.MIN_VALUE && value <= Int.MAX_VALUE;
    }
  };
  Int.MAX_VALUE = Math.pow(2, 31) - 1;
  Int.MIN_VALUE = -Math.pow(2, 31);
  (0, _ioMixin2.default)(Int);
  return int;
}
var hyper = {};
var Long$1 = { exports: {} };
var Long = Long$1.exports;
var hasRequiredLong;
function requireLong() {
  if (hasRequiredLong) return Long$1.exports;
  hasRequiredLong = 1;
  (function(module) {
    /**
     * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/Long.js for details
     */
    (function(global2, factory) {
      if (typeof commonjsRequire === "function" && true && module && module["exports"])
        module["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["Long"] = factory();
    })(Long, function() {
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
      });
      Long2.isLong = function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      };
      var INT_CACHE = {};
      var UINT_CACHE = {};
      Long2.fromInt = function fromInt(value, unsigned) {
        var obj, cachedObj;
        if (!unsigned) {
          value = value | 0;
          if (-128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = new Long2(value, value < 0 ? -1 : 0, false);
          if (-128 <= value && value < 128)
            INT_CACHE[value] = obj;
          return obj;
        } else {
          value = value >>> 0;
          if (0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = new Long2(value, (value | 0) < 0 ? -1 : 0, true);
          if (0 <= value && value < 256)
            UINT_CACHE[value] = obj;
          return obj;
        }
      };
      Long2.fromNumber = function fromNumber(value, unsigned) {
        unsigned = !!unsigned;
        if (isNaN(value) || !isFinite(value))
          return Long2.ZERO;
        if (!unsigned && value <= -TWO_PWR_63_DBL)
          return Long2.MIN_VALUE;
        if (!unsigned && value + 1 >= TWO_PWR_63_DBL)
          return Long2.MAX_VALUE;
        if (unsigned && value >= TWO_PWR_64_DBL)
          return Long2.MAX_UNSIGNED_VALUE;
        if (value < 0)
          return Long2.fromNumber(-value, unsigned).negate();
        return new Long2(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      };
      Long2.fromBits = function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      };
      Long2.fromString = function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("number format error: empty string");
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return Long2.ZERO;
        if (typeof unsigned === "number")
          radix = unsigned, unsigned = false;
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw Error("radix out of range: " + radix);
        var p;
        if ((p = str.indexOf("-")) > 0)
          throw Error('number format error: interior "-" character: ' + str);
        else if (p === 0)
          return Long2.fromString(str.substring(1), unsigned, radix).negate();
        var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
        var result = Long2.ZERO;
        for (var i2 = 0; i2 < str.length; i2 += 8) {
          var size = Math.min(8, str.length - i2);
          var value = parseInt(str.substring(i2, i2 + size), radix);
          if (size < 8) {
            var power = Long2.fromNumber(Math.pow(radix, size));
            result = result.multiply(power).add(Long2.fromNumber(value));
          } else {
            result = result.multiply(radixToPower);
            result = result.add(Long2.fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      };
      Long2.fromValue = function fromValue(val) {
        if (val instanceof Long2)
          return val;
        if (typeof val === "number")
          return Long2.fromNumber(val);
        if (typeof val === "string")
          return Long2.fromString(val);
        return new Long2(val.low, val.high, val.unsigned);
      };
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = Long2.fromInt(TWO_PWR_24_DBL);
      Long2.ZERO = Long2.fromInt(0);
      Long2.UZERO = Long2.fromInt(0, true);
      Long2.ONE = Long2.fromInt(1);
      Long2.UONE = Long2.fromInt(1, true);
      Long2.NEG_ONE = Long2.fromInt(-1);
      Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_UNSIGNED_VALUE = Long2.fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0, false);
      Long2.prototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      Long2.prototype.toNumber = function toNumber() {
        if (this.unsigned) {
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        }
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      Long2.prototype.toString = function toString2(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix out of range: " + radix);
        if (this.isZero())
          return "0";
        var rem;
        if (this.isNegative()) {
          if (this.equals(Long2.MIN_VALUE)) {
            var radixLong = Long2.fromNumber(radix);
            var div = this.divide(radixLong);
            rem = div.multiply(radixLong).subtract(this);
            return div.toString(radix) + rem.toInt().toString(radix);
          } else
            return "-" + this.negate().toString(radix);
        }
        var radixToPower = Long2.fromNumber(Math.pow(radix, 6), this.unsigned);
        rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.divide(radixToPower), intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      Long2.prototype.getHighBits = function getHighBits() {
        return this.high;
      };
      Long2.prototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      Long2.prototype.getLowBits = function getLowBits() {
        return this.low;
      };
      Long2.prototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      Long2.prototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.equals(Long2.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      Long2.prototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      Long2.prototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      Long2.prototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      Long2.prototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      Long2.prototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      Long2.prototype.equals = function equals(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      Long2.eq = Long2.prototype.equals;
      Long2.prototype.notEquals = function notEquals(other) {
        return !this.equals(
          /* validates */
          other
        );
      };
      Long2.neq = Long2.prototype.notEquals;
      Long2.prototype.lessThan = function lessThan(other) {
        return this.compare(
          /* validates */
          other
        ) < 0;
      };
      Long2.prototype.lt = Long2.prototype.lessThan;
      Long2.prototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.compare(
          /* validates */
          other
        ) <= 0;
      };
      Long2.prototype.lte = Long2.prototype.lessThanOrEqual;
      Long2.prototype.greaterThan = function greaterThan(other) {
        return this.compare(
          /* validates */
          other
        ) > 0;
      };
      Long2.prototype.gt = Long2.prototype.greaterThan;
      Long2.prototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.compare(
          /* validates */
          other
        ) >= 0;
      };
      Long2.prototype.gte = Long2.prototype.greaterThanOrEqual;
      Long2.prototype.compare = function compare(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        if (this.equals(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.subtract(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      Long2.prototype.negate = function negate() {
        if (!this.unsigned && this.equals(Long2.MIN_VALUE))
          return Long2.MIN_VALUE;
        return this.not().add(Long2.ONE);
      };
      Long2.prototype.neg = Long2.prototype.negate;
      Long2.prototype.add = function add(addend) {
        if (!Long2.isLong(addend))
          addend = Long2.fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      Long2.prototype.subtract = function subtract(subtrahend) {
        if (!Long2.isLong(subtrahend))
          subtrahend = Long2.fromValue(subtrahend);
        return this.add(subtrahend.negate());
      };
      Long2.prototype.sub = Long2.prototype.subtract;
      Long2.prototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return Long2.ZERO;
        if (!Long2.isLong(multiplier))
          multiplier = Long2.fromValue(multiplier);
        if (multiplier.isZero())
          return Long2.ZERO;
        if (this.equals(Long2.MIN_VALUE))
          return multiplier.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
        if (multiplier.equals(Long2.MIN_VALUE))
          return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.negate().multiply(multiplier.negate());
          else
            return this.negate().multiply(multiplier).negate();
        } else if (multiplier.isNegative())
          return this.multiply(multiplier.negate()).negate();
        if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24))
          return Long2.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      Long2.prototype.mul = Long2.prototype.multiply;
      Long2.prototype.divide = function divide(divisor) {
        if (!Long2.isLong(divisor))
          divisor = Long2.fromValue(divisor);
        if (divisor.isZero())
          throw new Error("division by zero");
        if (this.isZero())
          return this.unsigned ? Long2.UZERO : Long2.ZERO;
        var approx, rem, res;
        if (this.equals(Long2.MIN_VALUE)) {
          if (divisor.equals(Long2.ONE) || divisor.equals(Long2.NEG_ONE))
            return Long2.MIN_VALUE;
          else if (divisor.equals(Long2.MIN_VALUE))
            return Long2.ONE;
          else {
            var halfThis = this.shiftRight(1);
            approx = halfThis.divide(divisor).shiftLeft(1);
            if (approx.equals(Long2.ZERO)) {
              return divisor.isNegative() ? Long2.ONE : Long2.NEG_ONE;
            } else {
              rem = this.subtract(divisor.multiply(approx));
              res = approx.add(rem.divide(divisor));
              return res;
            }
          }
        } else if (divisor.equals(Long2.MIN_VALUE))
          return this.unsigned ? Long2.UZERO : Long2.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.negate().divide(divisor.negate());
          return this.negate().divide(divisor).negate();
        } else if (divisor.isNegative())
          return this.divide(divisor.negate()).negate();
        res = Long2.ZERO;
        rem = this;
        while (rem.greaterThanOrEqual(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48), approxRes = Long2.fromNumber(approx), approxRem = approxRes.multiply(divisor);
          while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
            approx -= delta;
            approxRes = Long2.fromNumber(approx, this.unsigned);
            approxRem = approxRes.multiply(divisor);
          }
          if (approxRes.isZero())
            approxRes = Long2.ONE;
          res = res.add(approxRes);
          rem = rem.subtract(approxRem);
        }
        return res;
      };
      Long2.prototype.div = Long2.prototype.divide;
      Long2.prototype.modulo = function modulo(divisor) {
        if (!Long2.isLong(divisor))
          divisor = Long2.fromValue(divisor);
        return this.subtract(this.divide(divisor).multiply(divisor));
      };
      Long2.prototype.mod = Long2.prototype.modulo;
      Long2.prototype.not = function not() {
        return Long2.fromBits(~this.low, ~this.high, this.unsigned);
      };
      Long2.prototype.and = function and(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        return Long2.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      Long2.prototype.or = function or(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        return Long2.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      Long2.prototype.xor = function xor2(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        return Long2.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      Long2.prototype.shiftLeft = function shiftLeft(numBits) {
        if (Long2.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return Long2.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return Long2.fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      Long2.prototype.shl = Long2.prototype.shiftLeft;
      Long2.prototype.shiftRight = function shiftRight(numBits) {
        if (Long2.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return Long2.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return Long2.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      Long2.prototype.shr = Long2.prototype.shiftRight;
      Long2.prototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (Long2.isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return Long2.fromBits(high, 0, this.unsigned);
          else
            return Long2.fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      Long2.prototype.shru = Long2.prototype.shiftRightUnsigned;
      Long2.prototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return new Long2(this.low, this.high, false);
      };
      Long2.prototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return new Long2(this.low, this.high, true);
      };
      return Long2;
    });
  })(Long$1);
  return Long$1.exports;
}
var hasRequiredHyper;
function requireHyper() {
  if (hasRequiredHyper) return hyper;
  hasRequiredHyper = 1;
  Object.defineProperty(hyper, "__esModule", {
    value: true
  });
  hyper.Hyper = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _get = function get3(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === void 0) {
      var parent2 = Object.getPrototypeOf(object);
      if (parent2 === null) {
        return void 0;
      } else {
        return get3(parent2, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;
      if (getter === void 0) {
        return void 0;
      }
      return getter.call(receiver);
    }
  };
  var _long = requireLong();
  var _long2 = _interopRequireDefault(_long);
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn2(self2, call2) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var Hyper = hyper.Hyper = function(_Long) {
    _inherits2(Hyper2, _Long);
    _createClass2(Hyper2, null, [{
      key: "read",
      value: function read2(io) {
        var high = io.readInt32BE();
        var low = io.readInt32BE();
        return this.fromBits(low, high);
      }
    }, {
      key: "write",
      value: function write(value, io) {
        if (!(value instanceof this)) {
          throw new Error("XDR Write Error: " + value + " is not a Hyper");
        }
        io.writeInt32BE(value.high);
        io.writeInt32BE(value.low);
      }
    }, {
      key: "fromString",
      value: function fromString(string2) {
        if (!/^-?\d+$/.test(string2)) {
          throw new Error("Invalid hyper string: " + string2);
        }
        var result = _get(Hyper2.__proto__ || Object.getPrototypeOf(Hyper2), "fromString", this).call(this, string2, false);
        return new this(result.low, result.high);
      }
    }, {
      key: "fromBits",
      value: function fromBits(low, high) {
        var result = _get(Hyper2.__proto__ || Object.getPrototypeOf(Hyper2), "fromBits", this).call(this, low, high, false);
        return new this(result.low, result.high);
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        return value instanceof this;
      }
    }]);
    function Hyper2(low, high) {
      _classCallCheck2(this, Hyper2);
      return _possibleConstructorReturn2(this, (Hyper2.__proto__ || Object.getPrototypeOf(Hyper2)).call(this, low, high, false));
    }
    return Hyper2;
  }(_long2.default);
  (0, _ioMixin2.default)(Hyper);
  Hyper.MAX_VALUE = new Hyper(_long2.default.MAX_VALUE.low, _long2.default.MAX_VALUE.high);
  Hyper.MIN_VALUE = new Hyper(_long2.default.MIN_VALUE.low, _long2.default.MIN_VALUE.high);
  return hyper;
}
var unsignedInt = {};
var hasRequiredUnsignedInt;
function requireUnsignedInt() {
  if (hasRequiredUnsignedInt) return unsignedInt;
  hasRequiredUnsignedInt = 1;
  Object.defineProperty(unsignedInt, "__esModule", {
    value: true
  });
  unsignedInt.UnsignedInt = void 0;
  var _isNumber = requireIsNumber();
  var _isNumber2 = _interopRequireDefault(_isNumber);
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var UnsignedInt = unsignedInt.UnsignedInt = {
    read: function read2(io) {
      return io.readUInt32BE();
    },
    write: function write(value, io) {
      if (!(0, _isNumber2.default)(value)) {
        throw new Error("XDR Write Error: not a number");
      }
      if (Math.floor(value) !== value) {
        throw new Error("XDR Write Error: not an integer");
      }
      if (value < 0) {
        throw new Error("XDR Write Error: negative number " + value);
      }
      io.writeUInt32BE(value);
    },
    isValid: function isValid(value) {
      if (!(0, _isNumber2.default)(value)) {
        return false;
      }
      if (Math.floor(value) !== value) {
        return false;
      }
      return value >= UnsignedInt.MIN_VALUE && value <= UnsignedInt.MAX_VALUE;
    }
  };
  UnsignedInt.MAX_VALUE = Math.pow(2, 32) - 1;
  UnsignedInt.MIN_VALUE = 0;
  (0, _ioMixin2.default)(UnsignedInt);
  return unsignedInt;
}
var unsignedHyper = {};
var hasRequiredUnsignedHyper;
function requireUnsignedHyper() {
  if (hasRequiredUnsignedHyper) return unsignedHyper;
  hasRequiredUnsignedHyper = 1;
  Object.defineProperty(unsignedHyper, "__esModule", {
    value: true
  });
  unsignedHyper.UnsignedHyper = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _get = function get3(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === void 0) {
      var parent2 = Object.getPrototypeOf(object);
      if (parent2 === null) {
        return void 0;
      } else {
        return get3(parent2, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;
      if (getter === void 0) {
        return void 0;
      }
      return getter.call(receiver);
    }
  };
  var _long = requireLong();
  var _long2 = _interopRequireDefault(_long);
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn2(self2, call2) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var UnsignedHyper = unsignedHyper.UnsignedHyper = function(_Long) {
    _inherits2(UnsignedHyper2, _Long);
    _createClass2(UnsignedHyper2, null, [{
      key: "read",
      value: function read2(io) {
        var high = io.readInt32BE();
        var low = io.readInt32BE();
        return this.fromBits(low, high);
      }
    }, {
      key: "write",
      value: function write(value, io) {
        if (!(value instanceof this)) {
          throw new Error("XDR Write Error: " + value + " is not an UnsignedHyper");
        }
        io.writeInt32BE(value.high);
        io.writeInt32BE(value.low);
      }
    }, {
      key: "fromString",
      value: function fromString(string2) {
        if (!/^\d+$/.test(string2)) {
          throw new Error("Invalid hyper string: " + string2);
        }
        var result = _get(UnsignedHyper2.__proto__ || Object.getPrototypeOf(UnsignedHyper2), "fromString", this).call(this, string2, true);
        return new this(result.low, result.high);
      }
    }, {
      key: "fromBits",
      value: function fromBits(low, high) {
        var result = _get(UnsignedHyper2.__proto__ || Object.getPrototypeOf(UnsignedHyper2), "fromBits", this).call(this, low, high, true);
        return new this(result.low, result.high);
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        return value instanceof this;
      }
    }]);
    function UnsignedHyper2(low, high) {
      _classCallCheck2(this, UnsignedHyper2);
      return _possibleConstructorReturn2(this, (UnsignedHyper2.__proto__ || Object.getPrototypeOf(UnsignedHyper2)).call(this, low, high, true));
    }
    return UnsignedHyper2;
  }(_long2.default);
  (0, _ioMixin2.default)(UnsignedHyper);
  UnsignedHyper.MAX_VALUE = new UnsignedHyper(_long2.default.MAX_UNSIGNED_VALUE.low, _long2.default.MAX_UNSIGNED_VALUE.high);
  UnsignedHyper.MIN_VALUE = new UnsignedHyper(_long2.default.MIN_VALUE.low, _long2.default.MIN_VALUE.high);
  return unsignedHyper;
}
var float = {};
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  hasRequiredFloat = 1;
  Object.defineProperty(float, "__esModule", {
    value: true
  });
  float.Float = void 0;
  var _isNumber = requireIsNumber();
  var _isNumber2 = _interopRequireDefault(_isNumber);
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Float = float.Float = {
    read: function read2(io) {
      return io.readFloatBE();
    },
    write: function write(value, io) {
      if (!(0, _isNumber2.default)(value)) {
        throw new Error("XDR Write Error: not a number");
      }
      io.writeFloatBE(value);
    },
    isValid: function isValid(value) {
      return (0, _isNumber2.default)(value);
    }
  };
  (0, _ioMixin2.default)(Float);
  return float;
}
var double = {};
var hasRequiredDouble;
function requireDouble() {
  if (hasRequiredDouble) return double;
  hasRequiredDouble = 1;
  Object.defineProperty(double, "__esModule", {
    value: true
  });
  double.Double = void 0;
  var _isNumber = requireIsNumber();
  var _isNumber2 = _interopRequireDefault(_isNumber);
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Double = double.Double = {
    read: function read2(io) {
      return io.readDoubleBE();
    },
    write: function write(value, io) {
      if (!(0, _isNumber2.default)(value)) {
        throw new Error("XDR Write Error: not a number");
      }
      io.writeDoubleBE(value);
    },
    isValid: function isValid(value) {
      return (0, _isNumber2.default)(value);
    }
  };
  (0, _ioMixin2.default)(Double);
  return double;
}
var quadruple = {};
var hasRequiredQuadruple;
function requireQuadruple() {
  if (hasRequiredQuadruple) return quadruple;
  hasRequiredQuadruple = 1;
  Object.defineProperty(quadruple, "__esModule", {
    value: true
  });
  quadruple.Quadruple = void 0;
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Quadruple = quadruple.Quadruple = {
    /* jshint unused: false */
    read: function read2() {
      throw new Error("XDR Read Error: quadruple not supported");
    },
    write: function write() {
      throw new Error("XDR Write Error: quadruple not supported");
    },
    isValid: function isValid() {
      return false;
    }
  };
  (0, _ioMixin2.default)(Quadruple);
  return quadruple;
}
var bool = {};
var isBoolean_1;
var hasRequiredIsBoolean;
function requireIsBoolean() {
  if (hasRequiredIsBoolean) return isBoolean_1;
  hasRequiredIsBoolean = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var boolTag = "[object Boolean]";
  function isBoolean2(value) {
    return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
  }
  isBoolean_1 = isBoolean2;
  return isBoolean_1;
}
var hasRequiredBool;
function requireBool() {
  if (hasRequiredBool) return bool;
  hasRequiredBool = 1;
  Object.defineProperty(bool, "__esModule", {
    value: true
  });
  bool.Bool = void 0;
  var _isBoolean = requireIsBoolean();
  var _isBoolean2 = _interopRequireDefault(_isBoolean);
  var _int = requireInt();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Bool = bool.Bool = {
    read: function read2(io) {
      var value = _int.Int.read(io);
      switch (value) {
        case 0:
          return false;
        case 1:
          return true;
        default:
          throw new Error("XDR Read Error: Got " + value + " when trying to read a bool");
      }
    },
    write: function write(value, io) {
      var intVal = value ? 1 : 0;
      return _int.Int.write(intVal, io);
    },
    isValid: function isValid(value) {
      return (0, _isBoolean2.default)(value);
    }
  };
  (0, _ioMixin2.default)(Bool);
  return bool;
}
var string = {};
var isString_1;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString) return isString_1;
  hasRequiredIsString = 1;
  var baseGetTag = require_baseGetTag(), isArray2 = requireIsArray(), isObjectLike = requireIsObjectLike();
  var stringTag = "[object String]";
  function isString2(value) {
    return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  isString_1 = isString2;
  return isString_1;
}
var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  Object.defineProperty(string, "__esModule", {
    value: true
  });
  string.String = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _isArray = requireIsArray();
  var _isArray2 = _interopRequireDefault(_isArray);
  var _int = requireInt();
  var _unsignedInt = requireUnsignedInt();
  var _util = requireUtil();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var String2 = string.String = function() {
    function String3() {
      var maxLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _unsignedInt.UnsignedInt.MAX_VALUE;
      _classCallCheck2(this, String3);
      this._maxLength = maxLength;
    }
    _createClass2(String3, [{
      key: "read",
      value: function read2(io) {
        var length = _int.Int.read(io);
        if (length > this._maxLength) {
          throw new Error("XDR Read Error: Saw " + length + " length String," + ("max allowed is " + this._maxLength));
        }
        var padding = (0, _util.calculatePadding)(length);
        var result = io.slice(length);
        (0, _util.slicePadding)(io, padding);
        return result.buffer();
      }
    }, {
      key: "readString",
      value: function readString(io) {
        return this.read(io).toString("utf8");
      }
    }, {
      key: "write",
      value: function write(value, io) {
        if (value.length > this._maxLength) {
          throw new Error("XDR Write Error: Got " + value.length + " bytes," + ("max allows is " + this._maxLength));
        }
        var buffer2 = void 0;
        if ((0, _isString2.default)(value)) {
          buffer2 = Buffer.from(value, "utf8");
        } else {
          buffer2 = Buffer.from(value);
        }
        _int.Int.write(buffer2.length, io);
        io.writeBufferPadded(buffer2);
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        var buffer2 = void 0;
        if ((0, _isString2.default)(value)) {
          buffer2 = Buffer.from(value, "utf8");
        } else if ((0, _isArray2.default)(value) || Buffer.isBuffer(value)) {
          buffer2 = Buffer.from(value);
        } else {
          return false;
        }
        return buffer2.length <= this._maxLength;
      }
    }]);
    return String3;
  }();
  (0, _ioMixin2.default)(String2.prototype);
  return string;
}
var opaque = {};
var hasRequiredOpaque;
function requireOpaque() {
  if (hasRequiredOpaque) return opaque;
  hasRequiredOpaque = 1;
  Object.defineProperty(opaque, "__esModule", {
    value: true
  });
  opaque.Opaque = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _util = requireUtil();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Opaque = opaque.Opaque = function() {
    function Opaque2(length) {
      _classCallCheck2(this, Opaque2);
      this._length = length;
      this._padding = (0, _util.calculatePadding)(length);
    }
    _createClass2(Opaque2, [{
      key: "read",
      value: function read2(io) {
        var result = io.slice(this._length);
        (0, _util.slicePadding)(io, this._padding);
        return result.buffer();
      }
    }, {
      key: "write",
      value: function write(value, io) {
        if (value.length !== this._length) {
          throw new Error("XDR Write Error: Got " + value.length + " bytes, expected " + this._length);
        }
        io.writeBufferPadded(value);
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        return Buffer.isBuffer(value) && value.length === this._length;
      }
    }]);
    return Opaque2;
  }();
  (0, _ioMixin2.default)(Opaque.prototype);
  return opaque;
}
var varOpaque = {};
var hasRequiredVarOpaque;
function requireVarOpaque() {
  if (hasRequiredVarOpaque) return varOpaque;
  hasRequiredVarOpaque = 1;
  Object.defineProperty(varOpaque, "__esModule", {
    value: true
  });
  varOpaque.VarOpaque = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _int = requireInt();
  var _unsignedInt = requireUnsignedInt();
  var _util = requireUtil();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var VarOpaque = varOpaque.VarOpaque = function() {
    function VarOpaque2() {
      var maxLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _unsignedInt.UnsignedInt.MAX_VALUE;
      _classCallCheck2(this, VarOpaque2);
      this._maxLength = maxLength;
    }
    _createClass2(VarOpaque2, [{
      key: "read",
      value: function read2(io) {
        var length = _int.Int.read(io);
        if (length > this._maxLength) {
          throw new Error("XDR Read Error: Saw " + length + " length VarOpaque," + ("max allowed is " + this._maxLength));
        }
        var padding = (0, _util.calculatePadding)(length);
        var result = io.slice(length);
        (0, _util.slicePadding)(io, padding);
        return result.buffer();
      }
    }, {
      key: "write",
      value: function write(value, io) {
        if (value.length > this._maxLength) {
          throw new Error("XDR Write Error: Got " + value.length + " bytes," + ("max allows is " + this._maxLength));
        }
        _int.Int.write(value.length, io);
        io.writeBufferPadded(value);
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        return Buffer.isBuffer(value) && value.length <= this._maxLength;
      }
    }]);
    return VarOpaque2;
  }();
  (0, _ioMixin2.default)(VarOpaque.prototype);
  return varOpaque;
}
var array = {};
var _arrayEach;
var hasRequired_arrayEach;
function require_arrayEach() {
  if (hasRequired_arrayEach) return _arrayEach;
  hasRequired_arrayEach = 1;
  function arrayEach(array2, iteratee) {
    var index2 = -1, length = array2 == null ? 0 : array2.length;
    while (++index2 < length) {
      if (iteratee(array2[index2], index2, array2) === false) {
        break;
      }
    }
    return array2;
  }
  _arrayEach = arrayEach;
  return _arrayEach;
}
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var arrayEach = require_arrayEach(), baseEach = require_baseEach(), castFunction = require_castFunction(), isArray2 = requireIsArray();
  function forEach2(collection, iteratee) {
    var func = isArray2(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1 = forEach2;
  return forEach_1;
}
var each;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach) return each;
  hasRequiredEach = 1;
  each = requireForEach();
  return each;
}
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string2) {
    var index2 = string2.length;
    while (index2-- && reWhitespace.test(string2.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject2 = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite) return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -Infinity) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger) return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite();
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}
var times_1;
var hasRequiredTimes;
function requireTimes() {
  if (hasRequiredTimes) return times_1;
  hasRequiredTimes = 1;
  var baseTimes = require_baseTimes(), castFunction = require_castFunction(), toInteger = requireToInteger();
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_ARRAY_LENGTH = 4294967295;
  var nativeMin = Math.min;
  function times(n, iteratee) {
    n = toInteger(n);
    if (n < 1 || n > MAX_SAFE_INTEGER) {
      return [];
    }
    var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
    iteratee = castFunction(iteratee);
    n -= MAX_ARRAY_LENGTH;
    var result = baseTimes(length, iteratee);
    while (++index2 < n) {
      iteratee(index2);
    }
    return result;
  }
  times_1 = times;
  return times_1;
}
var hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array;
  hasRequiredArray = 1;
  Object.defineProperty(array, "__esModule", {
    value: true
  });
  array.Array = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _every = requireEvery();
  var _every2 = _interopRequireDefault(_every);
  var _each = requireEach();
  var _each2 = _interopRequireDefault(_each);
  var _times = requireTimes();
  var _times2 = _interopRequireDefault(_times);
  var _isArray = requireIsArray();
  var _isArray2 = _interopRequireDefault(_isArray);
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Array2 = array.Array = function() {
    function Array3(childType, length) {
      _classCallCheck2(this, Array3);
      this._childType = childType;
      this._length = length;
    }
    _createClass2(Array3, [{
      key: "read",
      value: function read2(io) {
        var _this = this;
        return (0, _times2.default)(this._length, function() {
          return _this._childType.read(io);
        });
      }
    }, {
      key: "write",
      value: function write(value, io) {
        var _this2 = this;
        if (!(0, _isArray2.default)(value)) {
          throw new Error("XDR Write Error: value is not array");
        }
        if (value.length !== this._length) {
          throw new Error("XDR Write Error: Got array of size " + value.length + "," + ("expected " + this._length));
        }
        (0, _each2.default)(value, function(child) {
          return _this2._childType.write(child, io);
        });
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        var _this3 = this;
        if (!(0, _isArray2.default)(value)) {
          return false;
        }
        if (value.length !== this._length) {
          return false;
        }
        return (0, _every2.default)(value, function(child) {
          return _this3._childType.isValid(child);
        });
      }
    }]);
    return Array3;
  }();
  (0, _ioMixin2.default)(Array2.prototype);
  return array;
}
var varArray = {};
var hasRequiredVarArray;
function requireVarArray() {
  if (hasRequiredVarArray) return varArray;
  hasRequiredVarArray = 1;
  Object.defineProperty(varArray, "__esModule", {
    value: true
  });
  varArray.VarArray = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _every = requireEvery();
  var _every2 = _interopRequireDefault(_every);
  var _each = requireEach();
  var _each2 = _interopRequireDefault(_each);
  var _times = requireTimes();
  var _times2 = _interopRequireDefault(_times);
  var _isArray = requireIsArray();
  var _isArray2 = _interopRequireDefault(_isArray);
  var _unsignedInt = requireUnsignedInt();
  var _int = requireInt();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var VarArray = varArray.VarArray = function() {
    function VarArray2(childType) {
      var maxLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _unsignedInt.UnsignedInt.MAX_VALUE;
      _classCallCheck2(this, VarArray2);
      this._childType = childType;
      this._maxLength = maxLength;
    }
    _createClass2(VarArray2, [{
      key: "read",
      value: function read2(io) {
        var _this = this;
        var length = _int.Int.read(io);
        if (length > this._maxLength) {
          throw new Error("XDR Read Error: Saw " + length + " length VarArray," + ("max allowed is " + this._maxLength));
        }
        return (0, _times2.default)(length, function() {
          return _this._childType.read(io);
        });
      }
    }, {
      key: "write",
      value: function write(value, io) {
        var _this2 = this;
        if (!(0, _isArray2.default)(value)) {
          throw new Error("XDR Write Error: value is not array");
        }
        if (value.length > this._maxLength) {
          throw new Error("XDR Write Error: Got array of size " + value.length + "," + ("max allowed is " + this._maxLength));
        }
        _int.Int.write(value.length, io);
        (0, _each2.default)(value, function(child) {
          return _this2._childType.write(child, io);
        });
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        var _this3 = this;
        if (!(0, _isArray2.default)(value)) {
          return false;
        }
        if (value.length > this._maxLength) {
          return false;
        }
        return (0, _every2.default)(value, function(child) {
          return _this3._childType.isValid(child);
        });
      }
    }]);
    return VarArray2;
  }();
  (0, _ioMixin2.default)(VarArray.prototype);
  return varArray;
}
var option = {};
var isNull_1;
var hasRequiredIsNull;
function requireIsNull() {
  if (hasRequiredIsNull) return isNull_1;
  hasRequiredIsNull = 1;
  function isNull(value) {
    return value === null;
  }
  isNull_1 = isNull;
  return isNull_1;
}
var isUndefined_1;
var hasRequiredIsUndefined;
function requireIsUndefined() {
  if (hasRequiredIsUndefined) return isUndefined_1;
  hasRequiredIsUndefined = 1;
  function isUndefined2(value) {
    return value === void 0;
  }
  isUndefined_1 = isUndefined2;
  return isUndefined_1;
}
var hasRequiredOption;
function requireOption() {
  if (hasRequiredOption) return option;
  hasRequiredOption = 1;
  Object.defineProperty(option, "__esModule", {
    value: true
  });
  option.Option = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _isNull = requireIsNull();
  var _isNull2 = _interopRequireDefault(_isNull);
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _bool = requireBool();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Option = option.Option = function() {
    function Option2(childType) {
      _classCallCheck2(this, Option2);
      this._childType = childType;
    }
    _createClass2(Option2, [{
      key: "read",
      value: function read2(io) {
        if (_bool.Bool.read(io)) {
          return this._childType.read(io);
        }
        return void 0;
      }
    }, {
      key: "write",
      value: function write(value, io) {
        var isPresent = !((0, _isNull2.default)(value) || (0, _isUndefined2.default)(value));
        _bool.Bool.write(isPresent, io);
        if (isPresent) {
          this._childType.write(value, io);
        }
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        if ((0, _isNull2.default)(value)) {
          return true;
        }
        if ((0, _isUndefined2.default)(value)) {
          return true;
        }
        return this._childType.isValid(value);
      }
    }]);
    return Option2;
  }();
  (0, _ioMixin2.default)(Option.prototype);
  return option;
}
var _void = {};
var hasRequired_void;
function require_void() {
  if (hasRequired_void) return _void;
  hasRequired_void = 1;
  Object.defineProperty(_void, "__esModule", {
    value: true
  });
  _void.Void = void 0;
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Void = _void.Void = {
    /* jshint unused: false */
    read: function read2() {
      return void 0;
    },
    write: function write(value) {
      if (!(0, _isUndefined2.default)(value)) {
        throw new Error("XDR Write Error: trying to write value to a void slot");
      }
    },
    isValid: function isValid(value) {
      return (0, _isUndefined2.default)(value);
    }
  };
  (0, _ioMixin2.default)(Void);
  return _void;
}
var _enum = {};
var _baseValues;
var hasRequired_baseValues;
function require_baseValues() {
  if (hasRequired_baseValues) return _baseValues;
  hasRequired_baseValues = 1;
  var arrayMap = require_arrayMap();
  function baseValues(object, props) {
    return arrayMap(props, function(key2) {
      return object[key2];
    });
  }
  _baseValues = baseValues;
  return _baseValues;
}
var values_1;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues) return values_1;
  hasRequiredValues = 1;
  var baseValues = require_baseValues(), keys2 = requireKeys();
  function values2(object) {
    return object == null ? [] : baseValues(object, keys2(object));
  }
  values_1 = values2;
  return values_1;
}
var hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum;
  hasRequired_enum = 1;
  Object.defineProperty(_enum, "__esModule", {
    value: true
  });
  _enum.Enum = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _each = requireEach();
  var _each2 = _interopRequireDefault(_each);
  var _values = requireValues();
  var _values2 = _interopRequireDefault(_values);
  var _int = requireInt();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _possibleConstructorReturn2(self2, call2) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Enum = _enum.Enum = function() {
    function Enum2(name, value) {
      _classCallCheck2(this, Enum2);
      this.name = name;
      this.value = value;
    }
    _createClass2(Enum2, null, [{
      key: "read",
      value: function read2(io) {
        var intVal = _int.Int.read(io);
        if (!this._byValue.has(intVal)) {
          throw new Error("XDR Read Error: Unknown " + this.enumName + " member for value " + intVal);
        }
        return this._byValue.get(intVal);
      }
    }, {
      key: "write",
      value: function write(value, io) {
        if (!(value instanceof this)) {
          throw new Error("XDR Write Error: Unknown " + value + " is not a " + this.enumName);
        }
        _int.Int.write(value.value, io);
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        return value instanceof this;
      }
    }, {
      key: "members",
      value: function members() {
        return this._members;
      }
    }, {
      key: "values",
      value: function values2() {
        return (0, _values2.default)(this._members);
      }
    }, {
      key: "fromName",
      value: function fromName(name) {
        var result = this._members[name];
        if (!result) {
          throw new Error(name + " is not a member of " + this.enumName);
        }
        return result;
      }
    }, {
      key: "fromValue",
      value: function fromValue(value) {
        var result = this._byValue.get(value);
        if (!result) {
          throw new Error(value + " is not a value of any member of " + this.enumName);
        }
        return result;
      }
    }, {
      key: "create",
      value: function create4(context2, name, members) {
        var ChildEnum = function(_Enum) {
          _inherits2(ChildEnum2, _Enum);
          function ChildEnum2() {
            _classCallCheck2(this, ChildEnum2);
            return _possibleConstructorReturn2(this, (ChildEnum2.__proto__ || Object.getPrototypeOf(ChildEnum2)).apply(this, arguments));
          }
          return ChildEnum2;
        }(Enum2);
        ChildEnum.enumName = name;
        context2.results[name] = ChildEnum;
        ChildEnum._members = {};
        ChildEnum._byValue = /* @__PURE__ */ new Map();
        (0, _each2.default)(members, function(value, key2) {
          var inst = new ChildEnum(key2, value);
          ChildEnum._members[key2] = inst;
          ChildEnum._byValue.set(value, inst);
          ChildEnum[key2] = function() {
            return inst;
          };
        });
        return ChildEnum;
      }
    }]);
    return Enum2;
  }();
  (0, _ioMixin2.default)(Enum);
  return _enum;
}
var struct = {};
var _baseMap;
var hasRequired_baseMap;
function require_baseMap() {
  if (hasRequired_baseMap) return _baseMap;
  hasRequired_baseMap = 1;
  var baseEach = require_baseEach(), isArrayLike = requireIsArrayLike();
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key2, collection2) {
      result[++index2] = iteratee(value, key2, collection2);
    });
    return result;
  }
  _baseMap = baseMap;
  return _baseMap;
}
var map_1;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map_1;
  hasRequiredMap = 1;
  var arrayMap = require_arrayMap(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), isArray2 = requireIsArray();
  function map2(collection, iteratee) {
    var func = isArray2(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
  }
  map_1 = map2;
  return map_1;
}
var fromPairs_1;
var hasRequiredFromPairs;
function requireFromPairs() {
  if (hasRequiredFromPairs) return fromPairs_1;
  hasRequiredFromPairs = 1;
  function fromPairs(pairs) {
    var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
    while (++index2 < length) {
      var pair = pairs[index2];
      result[pair[0]] = pair[1];
    }
    return result;
  }
  fromPairs_1 = fromPairs;
  return fromPairs_1;
}
var reference = {};
var hasRequiredReference;
function requireReference() {
  if (hasRequiredReference) return reference;
  hasRequiredReference = 1;
  Object.defineProperty(reference, "__esModule", {
    value: true
  });
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  reference.Reference = function() {
    function Reference() {
      _classCallCheck2(this, Reference);
    }
    _createClass2(Reference, [{
      key: "resolve",
      /* jshint unused: false */
      value: function resolve2() {
        throw new Error("implement resolve in child class");
      }
    }]);
    return Reference;
  }();
  return reference;
}
var hasRequiredStruct;
function requireStruct() {
  if (hasRequiredStruct) return struct;
  hasRequiredStruct = 1;
  Object.defineProperty(struct, "__esModule", {
    value: true
  });
  struct.Struct = void 0;
  var _slicedToArray2 = /* @__PURE__ */ function() {
    function sliceIterator(arr2, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr2[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    return function(arr2, i2) {
      if (Array.isArray(arr2)) {
        return arr2;
      } else if (Symbol.iterator in Object(arr2)) {
        return sliceIterator(arr2, i2);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _each = requireEach();
  var _each2 = _interopRequireDefault(_each);
  var _map = requireMap();
  var _map2 = _interopRequireDefault(_map);
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _fromPairs = requireFromPairs();
  var _fromPairs2 = _interopRequireDefault(_fromPairs);
  var _reference = requireReference();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _possibleConstructorReturn2(self2, call2) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Struct = struct.Struct = function() {
    function Struct2(attributes) {
      _classCallCheck2(this, Struct2);
      this._attributes = attributes || {};
    }
    _createClass2(Struct2, null, [{
      key: "read",
      value: function read2(io) {
        var fields = (0, _map2.default)(this._fields, function(field) {
          var _field = _slicedToArray2(field, 2), name = _field[0], type2 = _field[1];
          var value = type2.read(io);
          return [name, value];
        });
        return new this((0, _fromPairs2.default)(fields));
      }
    }, {
      key: "write",
      value: function write(value, io) {
        if (!(value instanceof this)) {
          throw new Error("XDR Write Error: " + value + " is not a " + this.structName);
        }
        (0, _each2.default)(this._fields, function(field) {
          var _field2 = _slicedToArray2(field, 2), name = _field2[0], type2 = _field2[1];
          var attribute = value._attributes[name];
          type2.write(attribute, io);
        });
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        return value instanceof this;
      }
    }, {
      key: "create",
      value: function create4(context2, name, fields) {
        var ChildStruct = function(_Struct) {
          _inherits2(ChildStruct2, _Struct);
          function ChildStruct2() {
            _classCallCheck2(this, ChildStruct2);
            return _possibleConstructorReturn2(this, (ChildStruct2.__proto__ || Object.getPrototypeOf(ChildStruct2)).apply(this, arguments));
          }
          return ChildStruct2;
        }(Struct2);
        ChildStruct.structName = name;
        context2.results[name] = ChildStruct;
        ChildStruct._fields = fields.map(function(_ref3) {
          var _ref22 = _slicedToArray2(_ref3, 2), fieldName = _ref22[0], field = _ref22[1];
          if (field instanceof _reference.Reference) {
            field = field.resolve(context2);
          }
          return [fieldName, field];
        });
        (0, _each2.default)(ChildStruct._fields, function(field) {
          var _field3 = _slicedToArray2(field, 1), fieldName = _field3[0];
          ChildStruct.prototype[fieldName] = getReadOrWriteAttribute(fieldName);
        });
        return ChildStruct;
      }
    }]);
    return Struct2;
  }();
  (0, _ioMixin2.default)(Struct);
  function getReadOrWriteAttribute(name) {
    return function readOrWriteAttribute(value) {
      if (!(0, _isUndefined2.default)(value)) {
        this._attributes[name] = value;
      }
      return this._attributes[name];
    };
  }
  return struct;
}
var union = {};
var hasRequiredUnion;
function requireUnion() {
  if (hasRequiredUnion) return union;
  hasRequiredUnion = 1;
  Object.defineProperty(union, "__esModule", {
    value: true
  });
  union.Union = void 0;
  var _slicedToArray2 = /* @__PURE__ */ function() {
    function sliceIterator(arr2, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr2[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    return function(arr2, i2) {
      if (Array.isArray(arr2)) {
        return arr2;
      } else if (Symbol.iterator in Object(arr2)) {
        return sliceIterator(arr2, i2);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _each = requireEach();
  var _each2 = _interopRequireDefault(_each);
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _void2 = require_void();
  var _reference = requireReference();
  var _ioMixin = requireIoMixin();
  var _ioMixin2 = _interopRequireDefault(_ioMixin);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _possibleConstructorReturn2(self2, call2) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Union = union.Union = function() {
    function Union2(aSwitch, value) {
      _classCallCheck2(this, Union2);
      this.set(aSwitch, value);
    }
    _createClass2(Union2, [{
      key: "set",
      value: function set3(aSwitch, value) {
        if ((0, _isString2.default)(aSwitch)) {
          aSwitch = this.constructor._switchOn.fromName(aSwitch);
        }
        this._switch = aSwitch;
        this._arm = this.constructor.armForSwitch(this._switch);
        this._armType = this.constructor.armTypeForArm(this._arm);
        this._value = value;
      }
    }, {
      key: "get",
      value: function get3() {
        var armName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._arm;
        if (this._arm !== _void2.Void && this._arm !== armName) {
          throw new Error(armName + " not set");
        }
        return this._value;
      }
    }, {
      key: "switch",
      value: function _switch() {
        return this._switch;
      }
    }, {
      key: "arm",
      value: function arm() {
        return this._arm;
      }
    }, {
      key: "armType",
      value: function armType() {
        return this._armType;
      }
    }, {
      key: "value",
      value: function value() {
        return this._value;
      }
    }], [{
      key: "armForSwitch",
      value: function armForSwitch(aSwitch) {
        if (this._switches.has(aSwitch)) {
          return this._switches.get(aSwitch);
        }
        if (this._defaultArm) {
          return this._defaultArm;
        }
        throw new Error("Bad union switch: " + aSwitch);
      }
    }, {
      key: "armTypeForArm",
      value: function armTypeForArm(arm) {
        if (arm === _void2.Void) {
          return _void2.Void;
        }
        return this._arms[arm];
      }
    }, {
      key: "read",
      value: function read2(io) {
        var aSwitch = this._switchOn.read(io);
        var arm = this.armForSwitch(aSwitch);
        var armType = this.armTypeForArm(arm);
        var value = void 0;
        if (!(0, _isUndefined2.default)(armType)) {
          value = armType.read(io);
        } else {
          value = arm.read(io);
        }
        return new this(aSwitch, value);
      }
    }, {
      key: "write",
      value: function write(value, io) {
        if (!(value instanceof this)) {
          throw new Error("XDR Write Error: " + value + " is not a " + this.unionName);
        }
        this._switchOn.write(value.switch(), io);
        value.armType().write(value.value(), io);
      }
    }, {
      key: "isValid",
      value: function isValid(value) {
        return value instanceof this;
      }
    }, {
      key: "create",
      value: function create4(context2, name, config2) {
        var ChildUnion = function(_Union) {
          _inherits2(ChildUnion2, _Union);
          function ChildUnion2() {
            _classCallCheck2(this, ChildUnion2);
            return _possibleConstructorReturn2(this, (ChildUnion2.__proto__ || Object.getPrototypeOf(ChildUnion2)).apply(this, arguments));
          }
          return ChildUnion2;
        }(Union2);
        ChildUnion.unionName = name;
        context2.results[name] = ChildUnion;
        if (config2.switchOn instanceof _reference.Reference) {
          ChildUnion._switchOn = config2.switchOn.resolve(context2);
        } else {
          ChildUnion._switchOn = config2.switchOn;
        }
        ChildUnion._switches = /* @__PURE__ */ new Map();
        ChildUnion._arms = {};
        (0, _each2.default)(config2.arms, function(value, armsName) {
          if (value instanceof _reference.Reference) {
            value = value.resolve(context2);
          }
          ChildUnion._arms[armsName] = value;
        });
        var defaultArm = config2.defaultArm;
        if (defaultArm instanceof _reference.Reference) {
          defaultArm = defaultArm.resolve(context2);
        }
        ChildUnion._defaultArm = defaultArm;
        (0, _each2.default)(config2.switches, function(_ref3) {
          var _ref22 = _slicedToArray2(_ref3, 2), aSwitch = _ref22[0], armName = _ref22[1];
          if ((0, _isString2.default)(aSwitch)) {
            aSwitch = ChildUnion._switchOn.fromName(aSwitch);
          }
          ChildUnion._switches.set(aSwitch, armName);
        });
        if (!(0, _isUndefined2.default)(ChildUnion._switchOn.values)) {
          (0, _each2.default)(ChildUnion._switchOn.values(), function(aSwitch) {
            ChildUnion[aSwitch.name] = function(value) {
              return new ChildUnion(aSwitch, value);
            };
            ChildUnion.prototype[aSwitch.name] = function set3(value) {
              return this.set(aSwitch, value);
            };
          });
        }
        (0, _each2.default)(ChildUnion._arms, function(type2, armsName) {
          if (type2 === _void2.Void) {
            return;
          }
          ChildUnion.prototype[armsName] = function get3() {
            return this.get(armsName);
          };
        });
        return ChildUnion;
      }
    }]);
    return Union2;
  }();
  (0, _ioMixin2.default)(Union);
  return union;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _int = requireInt();
    Object.keys(_int).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _int[key2];
        }
      });
    });
    var _hyper = requireHyper();
    Object.keys(_hyper).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _hyper[key2];
        }
      });
    });
    var _unsignedInt = requireUnsignedInt();
    Object.keys(_unsignedInt).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _unsignedInt[key2];
        }
      });
    });
    var _unsignedHyper = requireUnsignedHyper();
    Object.keys(_unsignedHyper).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _unsignedHyper[key2];
        }
      });
    });
    var _float = requireFloat();
    Object.keys(_float).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _float[key2];
        }
      });
    });
    var _double = requireDouble();
    Object.keys(_double).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _double[key2];
        }
      });
    });
    var _quadruple = requireQuadruple();
    Object.keys(_quadruple).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _quadruple[key2];
        }
      });
    });
    var _bool = requireBool();
    Object.keys(_bool).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _bool[key2];
        }
      });
    });
    var _string = requireString();
    Object.keys(_string).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _string[key2];
        }
      });
    });
    var _opaque = requireOpaque();
    Object.keys(_opaque).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _opaque[key2];
        }
      });
    });
    var _varOpaque = requireVarOpaque();
    Object.keys(_varOpaque).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _varOpaque[key2];
        }
      });
    });
    var _array = requireArray();
    Object.keys(_array).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _array[key2];
        }
      });
    });
    var _varArray = requireVarArray();
    Object.keys(_varArray).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _varArray[key2];
        }
      });
    });
    var _option = requireOption();
    Object.keys(_option).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _option[key2];
        }
      });
    });
    var _void2 = require_void();
    Object.keys(_void2).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _void2[key2];
        }
      });
    });
    var _enum2 = require_enum();
    Object.keys(_enum2).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _enum2[key2];
        }
      });
    });
    var _struct = requireStruct();
    Object.keys(_struct).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _struct[key2];
        }
      });
    });
    var _union = requireUnion();
    Object.keys(_union).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _union[key2];
        }
      });
    });
  })(types);
  return types;
}
var config$2 = {};
var hasRequiredConfig$1;
function requireConfig$1() {
  if (hasRequiredConfig$1) return config$2;
  hasRequiredConfig$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _createClass2 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _reference = requireReference();
    Object.keys(_reference).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _reference[key2];
        }
      });
    });
    exports2.config = config2;
    var _isUndefined = requireIsUndefined();
    var _isUndefined2 = _interopRequireDefault(_isUndefined);
    var _each = requireEach();
    var _each2 = _interopRequireDefault(_each);
    var _types = requireTypes();
    var XDRTypes = _interopRequireWildcard(_types);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key2 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key2)) newObj[key2] = obj[key2];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn2(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function config2(fn) {
      var types2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (fn) {
        var builder = new TypeBuilder(types2);
        fn(builder);
        builder.resolve();
      }
      return types2;
    }
    var SimpleReference = function(_Reference) {
      _inherits2(SimpleReference2, _Reference);
      function SimpleReference2(name) {
        _classCallCheck2(this, SimpleReference2);
        var _this = _possibleConstructorReturn2(this, (SimpleReference2.__proto__ || Object.getPrototypeOf(SimpleReference2)).call(this));
        _this.name = name;
        return _this;
      }
      _createClass2(SimpleReference2, [{
        key: "resolve",
        value: function resolve2(context2) {
          var defn = context2.definitions[this.name];
          return defn.resolve(context2);
        }
      }]);
      return SimpleReference2;
    }(_reference.Reference);
    var ArrayReference = function(_Reference2) {
      _inherits2(ArrayReference2, _Reference2);
      function ArrayReference2(childReference, length) {
        var variable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        _classCallCheck2(this, ArrayReference2);
        var _this2 = _possibleConstructorReturn2(this, (ArrayReference2.__proto__ || Object.getPrototypeOf(ArrayReference2)).call(this));
        _this2.childReference = childReference;
        _this2.length = length;
        _this2.variable = variable;
        return _this2;
      }
      _createClass2(ArrayReference2, [{
        key: "resolve",
        value: function resolve2(context2) {
          var resolvedChild = this.childReference;
          var length = this.length;
          if (resolvedChild instanceof _reference.Reference) {
            resolvedChild = resolvedChild.resolve(context2);
          }
          if (length instanceof _reference.Reference) {
            length = length.resolve(context2);
          }
          if (this.variable) {
            return new XDRTypes.VarArray(resolvedChild, length);
          }
          return new XDRTypes.Array(resolvedChild, length);
        }
      }]);
      return ArrayReference2;
    }(_reference.Reference);
    var OptionReference = function(_Reference3) {
      _inherits2(OptionReference2, _Reference3);
      function OptionReference2(childReference) {
        _classCallCheck2(this, OptionReference2);
        var _this3 = _possibleConstructorReturn2(this, (OptionReference2.__proto__ || Object.getPrototypeOf(OptionReference2)).call(this));
        _this3.childReference = childReference;
        _this3.name = childReference.name;
        return _this3;
      }
      _createClass2(OptionReference2, [{
        key: "resolve",
        value: function resolve2(context2) {
          var resolvedChild = this.childReference;
          if (resolvedChild instanceof _reference.Reference) {
            resolvedChild = resolvedChild.resolve(context2);
          }
          return new XDRTypes.Option(resolvedChild);
        }
      }]);
      return OptionReference2;
    }(_reference.Reference);
    var SizedReference = function(_Reference4) {
      _inherits2(SizedReference2, _Reference4);
      function SizedReference2(sizedType, length) {
        _classCallCheck2(this, SizedReference2);
        var _this4 = _possibleConstructorReturn2(this, (SizedReference2.__proto__ || Object.getPrototypeOf(SizedReference2)).call(this));
        _this4.sizedType = sizedType;
        _this4.length = length;
        return _this4;
      }
      _createClass2(SizedReference2, [{
        key: "resolve",
        value: function resolve2(context2) {
          var length = this.length;
          if (length instanceof _reference.Reference) {
            length = length.resolve(context2);
          }
          return new this.sizedType(length);
        }
      }]);
      return SizedReference2;
    }(_reference.Reference);
    var Definition = function() {
      function Definition2(constructor, name, cfg) {
        _classCallCheck2(this, Definition2);
        this.constructor = constructor;
        this.name = name;
        this.config = cfg;
      }
      _createClass2(Definition2, [{
        key: "resolve",
        value: function resolve2(context2) {
          if (this.name in context2.results) {
            return context2.results[this.name];
          }
          return this.constructor(context2, this.name, this.config);
        }
      }]);
      return Definition2;
    }();
    function createTypedef(context2, typeName, value) {
      if (value instanceof _reference.Reference) {
        value = value.resolve(context2);
      }
      context2.results[typeName] = value;
      return value;
    }
    function createConst(context2, name, value) {
      context2.results[name] = value;
      return value;
    }
    var TypeBuilder = function() {
      function TypeBuilder2(destination) {
        _classCallCheck2(this, TypeBuilder2);
        this._destination = destination;
        this._definitions = {};
      }
      _createClass2(TypeBuilder2, [{
        key: "enum",
        value: function _enum2(name, members) {
          var result = new Definition(XDRTypes.Enum.create, name, members);
          this.define(name, result);
        }
      }, {
        key: "struct",
        value: function struct2(name, members) {
          var result = new Definition(XDRTypes.Struct.create, name, members);
          this.define(name, result);
        }
      }, {
        key: "union",
        value: function union2(name, cfg) {
          var result = new Definition(XDRTypes.Union.create, name, cfg);
          this.define(name, result);
        }
      }, {
        key: "typedef",
        value: function typedef(name, cfg) {
          var result = new Definition(createTypedef, name, cfg);
          this.define(name, result);
        }
      }, {
        key: "const",
        value: function _const(name, cfg) {
          var result = new Definition(createConst, name, cfg);
          this.define(name, result);
        }
      }, {
        key: "void",
        value: function _void2() {
          return XDRTypes.Void;
        }
      }, {
        key: "bool",
        value: function bool2() {
          return XDRTypes.Bool;
        }
      }, {
        key: "int",
        value: function int2() {
          return XDRTypes.Int;
        }
      }, {
        key: "hyper",
        value: function hyper2() {
          return XDRTypes.Hyper;
        }
      }, {
        key: "uint",
        value: function uint() {
          return XDRTypes.UnsignedInt;
        }
      }, {
        key: "uhyper",
        value: function uhyper() {
          return XDRTypes.UnsignedHyper;
        }
      }, {
        key: "float",
        value: function float2() {
          return XDRTypes.Float;
        }
      }, {
        key: "double",
        value: function double2() {
          return XDRTypes.Double;
        }
      }, {
        key: "quadruple",
        value: function quadruple2() {
          return XDRTypes.Quadruple;
        }
      }, {
        key: "string",
        value: function string2(length) {
          return new SizedReference(XDRTypes.String, length);
        }
      }, {
        key: "opaque",
        value: function opaque2(length) {
          return new SizedReference(XDRTypes.Opaque, length);
        }
      }, {
        key: "varOpaque",
        value: function varOpaque2(length) {
          return new SizedReference(XDRTypes.VarOpaque, length);
        }
      }, {
        key: "array",
        value: function array2(childType, length) {
          return new ArrayReference(childType, length);
        }
      }, {
        key: "varArray",
        value: function varArray2(childType, maxLength) {
          return new ArrayReference(childType, maxLength, true);
        }
      }, {
        key: "option",
        value: function option2(childType) {
          return new OptionReference(childType);
        }
      }, {
        key: "define",
        value: function define(name, definition) {
          if ((0, _isUndefined2.default)(this._destination[name])) {
            this._definitions[name] = definition;
          } else {
            throw new Error("XDRTypes Error:" + name + " is already defined");
          }
        }
      }, {
        key: "lookup",
        value: function lookup9(name) {
          return new SimpleReference(name);
        }
      }, {
        key: "resolve",
        value: function resolve2() {
          var _this5 = this;
          (0, _each2.default)(this._definitions, function(defn) {
            defn.resolve({
              definitions: _this5._definitions,
              results: _this5._destination
            });
          });
        }
      }]);
      return TypeBuilder2;
    }();
  })(config$2);
  return config$2;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$1;
  hasRequiredLib$3 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _types = requireTypes();
    Object.keys(_types).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _types[key2];
        }
      });
    });
    var _config = requireConfig$1();
    Object.keys(_config).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _config[key2];
        }
      });
    });
  })(lib$1);
  return lib$1;
}
var hasRequiredStellarXdr_generated;
function requireStellarXdr_generated() {
  if (hasRequiredStellarXdr_generated) return stellarXdr_generated;
  hasRequiredStellarXdr_generated = 1;
  Object.defineProperty(stellarXdr_generated, "__esModule", {
    value: true
  });
  var _jsXdr = requireLib$3();
  var XDR = _interopRequireWildcard(_jsXdr);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2)) newObj[key2] = obj[key2];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  var types2 = XDR.config(function(xdr) {
    xdr.typedef("AccountId", xdr.lookup("PublicKey"));
    xdr.typedef("Thresholds", xdr.opaque(4));
    xdr.typedef("String32", xdr.string(32));
    xdr.typedef("String64", xdr.string(64));
    xdr.typedef("SequenceNumber", xdr.lookup("Int64"));
    xdr.typedef("TimePoint", xdr.lookup("Uint64"));
    xdr.typedef("DataValue", xdr.varOpaque(64));
    xdr.typedef("PoolId", xdr.lookup("Hash"));
    xdr.typedef("AssetCode4", xdr.opaque(4));
    xdr.typedef("AssetCode12", xdr.opaque(12));
    xdr.enum("AssetType", {
      assetTypeNative: 0,
      assetTypeCreditAlphanum4: 1,
      assetTypeCreditAlphanum12: 2,
      assetTypePoolShare: 3
    });
    xdr.union("AssetCode", {
      switchOn: xdr.lookup("AssetType"),
      switchName: "type",
      switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]],
      arms: {
        assetCode4: xdr.lookup("AssetCode4"),
        assetCode12: xdr.lookup("AssetCode12")
      }
    });
    xdr.struct("AlphaNum4", [["assetCode", xdr.lookup("AssetCode4")], ["issuer", xdr.lookup("AccountId")]]);
    xdr.struct("AlphaNum12", [["assetCode", xdr.lookup("AssetCode12")], ["issuer", xdr.lookup("AccountId")]]);
    xdr.union("Asset", {
      switchOn: xdr.lookup("AssetType"),
      switchName: "type",
      switches: [["assetTypeNative", xdr.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]],
      arms: {
        alphaNum4: xdr.lookup("AlphaNum4"),
        alphaNum12: xdr.lookup("AlphaNum12")
      }
    });
    xdr.struct("Price", [["n", xdr.lookup("Int32")], ["d", xdr.lookup("Int32")]]);
    xdr.struct("Liabilities", [["buying", xdr.lookup("Int64")], ["selling", xdr.lookup("Int64")]]);
    xdr.enum("ThresholdIndices", {
      thresholdMasterWeight: 0,
      thresholdLow: 1,
      thresholdMed: 2,
      thresholdHigh: 3
    });
    xdr.enum("LedgerEntryType", {
      account: 0,
      trustline: 1,
      offer: 2,
      data: 3,
      claimableBalance: 4,
      liquidityPool: 5
    });
    xdr.struct("Signer", [["key", xdr.lookup("SignerKey")], ["weight", xdr.lookup("Uint32")]]);
    xdr.enum("AccountFlags", {
      authRequiredFlag: 1,
      authRevocableFlag: 2,
      authImmutableFlag: 4,
      authClawbackEnabledFlag: 8
    });
    xdr.const("MASK_ACCOUNT_FLAGS", 7);
    xdr.const("MASK_ACCOUNT_FLAGS_V17", 15);
    xdr.const("MAX_SIGNERS", 20);
    xdr.typedef("SponsorshipDescriptor", xdr.option(xdr.lookup("AccountId")));
    xdr.union("AccountEntryExtensionV2Ext", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("AccountEntryExtensionV2", [["numSponsored", xdr.lookup("Uint32")], ["numSponsoring", xdr.lookup("Uint32")], ["signerSponsoringIDs", xdr.varArray(xdr.lookup("SponsorshipDescriptor"), xdr.lookup("MAX_SIGNERS"))], ["ext", xdr.lookup("AccountEntryExtensionV2Ext")]]);
    xdr.union("AccountEntryExtensionV1Ext", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()], [2, "v2"]],
      arms: {
        v2: xdr.lookup("AccountEntryExtensionV2")
      }
    });
    xdr.struct("AccountEntryExtensionV1", [["liabilities", xdr.lookup("Liabilities")], ["ext", xdr.lookup("AccountEntryExtensionV1Ext")]]);
    xdr.union("AccountEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()], [1, "v1"]],
      arms: {
        v1: xdr.lookup("AccountEntryExtensionV1")
      }
    });
    xdr.struct("AccountEntry", [["accountId", xdr.lookup("AccountId")], ["balance", xdr.lookup("Int64")], ["seqNum", xdr.lookup("SequenceNumber")], ["numSubEntries", xdr.lookup("Uint32")], ["inflationDest", xdr.option(xdr.lookup("AccountId"))], ["flags", xdr.lookup("Uint32")], ["homeDomain", xdr.lookup("String32")], ["thresholds", xdr.lookup("Thresholds")], ["signers", xdr.varArray(xdr.lookup("Signer"), xdr.lookup("MAX_SIGNERS"))], ["ext", xdr.lookup("AccountEntryExt")]]);
    xdr.enum("TrustLineFlags", {
      authorizedFlag: 1,
      authorizedToMaintainLiabilitiesFlag: 2,
      trustlineClawbackEnabledFlag: 4
    });
    xdr.const("MASK_TRUSTLINE_FLAGS", 1);
    xdr.const("MASK_TRUSTLINE_FLAGS_V13", 3);
    xdr.const("MASK_TRUSTLINE_FLAGS_V17", 7);
    xdr.enum("LiquidityPoolType", {
      liquidityPoolConstantProduct: 0
    });
    xdr.union("TrustLineAsset", {
      switchOn: xdr.lookup("AssetType"),
      switchName: "type",
      switches: [["assetTypeNative", xdr.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]],
      arms: {
        alphaNum4: xdr.lookup("AlphaNum4"),
        alphaNum12: xdr.lookup("AlphaNum12"),
        liquidityPoolId: xdr.lookup("PoolId")
      }
    });
    xdr.union("TrustLineEntryExtensionV2Ext", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", xdr.lookup("Int32")], ["ext", xdr.lookup("TrustLineEntryExtensionV2Ext")]]);
    xdr.union("TrustLineEntryV1Ext", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()], [2, "v2"]],
      arms: {
        v2: xdr.lookup("TrustLineEntryExtensionV2")
      }
    });
    xdr.struct("TrustLineEntryV1", [["liabilities", xdr.lookup("Liabilities")], ["ext", xdr.lookup("TrustLineEntryV1Ext")]]);
    xdr.union("TrustLineEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()], [1, "v1"]],
      arms: {
        v1: xdr.lookup("TrustLineEntryV1")
      }
    });
    xdr.struct("TrustLineEntry", [["accountId", xdr.lookup("AccountId")], ["asset", xdr.lookup("TrustLineAsset")], ["balance", xdr.lookup("Int64")], ["limit", xdr.lookup("Int64")], ["flags", xdr.lookup("Uint32")], ["ext", xdr.lookup("TrustLineEntryExt")]]);
    xdr.enum("OfferEntryFlags", {
      passiveFlag: 1
    });
    xdr.const("MASK_OFFERENTRY_FLAGS", 1);
    xdr.union("OfferEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("OfferEntry", [["sellerId", xdr.lookup("AccountId")], ["offerId", xdr.lookup("Int64")], ["selling", xdr.lookup("Asset")], ["buying", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["price", xdr.lookup("Price")], ["flags", xdr.lookup("Uint32")], ["ext", xdr.lookup("OfferEntryExt")]]);
    xdr.union("DataEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("DataEntry", [["accountId", xdr.lookup("AccountId")], ["dataName", xdr.lookup("String64")], ["dataValue", xdr.lookup("DataValue")], ["ext", xdr.lookup("DataEntryExt")]]);
    xdr.enum("ClaimPredicateType", {
      claimPredicateUnconditional: 0,
      claimPredicateAnd: 1,
      claimPredicateOr: 2,
      claimPredicateNot: 3,
      claimPredicateBeforeAbsoluteTime: 4,
      claimPredicateBeforeRelativeTime: 5
    });
    xdr.union("ClaimPredicate", {
      switchOn: xdr.lookup("ClaimPredicateType"),
      switchName: "type",
      switches: [["claimPredicateUnconditional", xdr.void()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]],
      arms: {
        andPredicates: xdr.varArray(xdr.lookup("ClaimPredicate"), 2),
        orPredicates: xdr.varArray(xdr.lookup("ClaimPredicate"), 2),
        notPredicate: xdr.option(xdr.lookup("ClaimPredicate")),
        absBefore: xdr.lookup("Int64"),
        relBefore: xdr.lookup("Int64")
      }
    });
    xdr.enum("ClaimantType", {
      claimantTypeV0: 0
    });
    xdr.struct("ClaimantV0", [["destination", xdr.lookup("AccountId")], ["predicate", xdr.lookup("ClaimPredicate")]]);
    xdr.union("Claimant", {
      switchOn: xdr.lookup("ClaimantType"),
      switchName: "type",
      switches: [["claimantTypeV0", "v0"]],
      arms: {
        v0: xdr.lookup("ClaimantV0")
      }
    });
    xdr.enum("ClaimableBalanceIdType", {
      claimableBalanceIdTypeV0: 0,
      claimableBalanceIdTypeFromPoolRevoke: 1
    });
    xdr.union("ClaimableBalanceId", {
      switchOn: xdr.lookup("ClaimableBalanceIdType"),
      switchName: "type",
      switches: [["claimableBalanceIdTypeV0", "v0"], ["claimableBalanceIdTypeFromPoolRevoke", "fromPoolRevoke"]],
      arms: {
        v0: xdr.lookup("Hash"),
        fromPoolRevoke: xdr.lookup("Hash")
      }
    });
    xdr.enum("ClaimableBalanceFlags", {
      claimableBalanceClawbackEnabledFlag: 1
    });
    xdr.const("MASK_CLAIMABLE_BALANCE_FLAGS", 1);
    xdr.union("ClaimableBalanceEntryExtensionV1Ext", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("ClaimableBalanceEntryExtensionV1", [["ext", xdr.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", xdr.lookup("Uint32")]]);
    xdr.union("ClaimableBalanceEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()], [1, "v1"]],
      arms: {
        v1: xdr.lookup("ClaimableBalanceEntryExtensionV1")
      }
    });
    xdr.struct("ClaimableBalanceEntry", [["balanceId", xdr.lookup("ClaimableBalanceId")], ["claimants", xdr.varArray(xdr.lookup("Claimant"), 10)], ["asset", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["ext", xdr.lookup("ClaimableBalanceEntryExt")]]);
    xdr.struct("LiquidityPoolConstantProductParameters", [["assetA", xdr.lookup("Asset")], ["assetB", xdr.lookup("Asset")], ["fee", xdr.lookup("Int32")]]);
    xdr.struct("LiquidityPoolEntryConstantProduct", [["params", xdr.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", xdr.lookup("Int64")], ["reserveB", xdr.lookup("Int64")], ["totalPoolShares", xdr.lookup("Int64")], ["poolSharesTrustLineCount", xdr.lookup("Int64")]]);
    xdr.union("LiquidityPoolEntryBody", {
      switchOn: xdr.lookup("LiquidityPoolType"),
      switchName: "type",
      switches: [["liquidityPoolConstantProduct", "constantProduct"]],
      arms: {
        constantProduct: xdr.lookup("LiquidityPoolEntryConstantProduct")
      }
    });
    xdr.struct("LiquidityPoolEntry", [["liquidityPoolId", xdr.lookup("PoolId")], ["body", xdr.lookup("LiquidityPoolEntryBody")]]);
    xdr.union("LedgerEntryExtensionV1Ext", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("LedgerEntryExtensionV1", [["sponsoringId", xdr.lookup("SponsorshipDescriptor")], ["ext", xdr.lookup("LedgerEntryExtensionV1Ext")]]);
    xdr.union("LedgerEntryData", {
      switchOn: xdr.lookup("LedgerEntryType"),
      switchName: "type",
      switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"]],
      arms: {
        account: xdr.lookup("AccountEntry"),
        trustLine: xdr.lookup("TrustLineEntry"),
        offer: xdr.lookup("OfferEntry"),
        data: xdr.lookup("DataEntry"),
        claimableBalance: xdr.lookup("ClaimableBalanceEntry"),
        liquidityPool: xdr.lookup("LiquidityPoolEntry")
      }
    });
    xdr.union("LedgerEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()], [1, "v1"]],
      arms: {
        v1: xdr.lookup("LedgerEntryExtensionV1")
      }
    });
    xdr.struct("LedgerEntry", [["lastModifiedLedgerSeq", xdr.lookup("Uint32")], ["data", xdr.lookup("LedgerEntryData")], ["ext", xdr.lookup("LedgerEntryExt")]]);
    xdr.struct("LedgerKeyAccount", [["accountId", xdr.lookup("AccountId")]]);
    xdr.struct("LedgerKeyTrustLine", [["accountId", xdr.lookup("AccountId")], ["asset", xdr.lookup("TrustLineAsset")]]);
    xdr.struct("LedgerKeyOffer", [["sellerId", xdr.lookup("AccountId")], ["offerId", xdr.lookup("Int64")]]);
    xdr.struct("LedgerKeyData", [["accountId", xdr.lookup("AccountId")], ["dataName", xdr.lookup("String64")]]);
    xdr.struct("LedgerKeyClaimableBalance", [["balanceId", xdr.lookup("ClaimableBalanceId")]]);
    xdr.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", xdr.lookup("PoolId")]]);
    xdr.union("LedgerKey", {
      switchOn: xdr.lookup("LedgerEntryType"),
      switchName: "type",
      switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"]],
      arms: {
        account: xdr.lookup("LedgerKeyAccount"),
        trustLine: xdr.lookup("LedgerKeyTrustLine"),
        offer: xdr.lookup("LedgerKeyOffer"),
        data: xdr.lookup("LedgerKeyData"),
        claimableBalance: xdr.lookup("LedgerKeyClaimableBalance"),
        liquidityPool: xdr.lookup("LedgerKeyLiquidityPool")
      }
    });
    xdr.enum("EnvelopeType", {
      envelopeTypeTxV0: 0,
      envelopeTypeScp: 1,
      envelopeTypeTx: 2,
      envelopeTypeAuth: 3,
      envelopeTypeScpvalue: 4,
      envelopeTypeTxFeeBump: 5,
      envelopeTypeOpId: 6,
      envelopeTypePoolRevokeOpId: 7
    });
    xdr.typedef("UpgradeType", xdr.varOpaque(128));
    xdr.enum("StellarValueType", {
      stellarValueBasic: 0,
      stellarValueSigned: 1
    });
    xdr.struct("LedgerCloseValueSignature", [["nodeId", xdr.lookup("NodeId")], ["signature", xdr.lookup("Signature")]]);
    xdr.union("StellarValueExt", {
      switchOn: xdr.lookup("StellarValueType"),
      switchName: "v",
      switches: [["stellarValueBasic", xdr.void()], ["stellarValueSigned", "lcValueSignature"]],
      arms: {
        lcValueSignature: xdr.lookup("LedgerCloseValueSignature")
      }
    });
    xdr.struct("StellarValue", [["txSetHash", xdr.lookup("Hash")], ["closeTime", xdr.lookup("TimePoint")], ["upgrades", xdr.varArray(xdr.lookup("UpgradeType"), 6)], ["ext", xdr.lookup("StellarValueExt")]]);
    xdr.const("MASK_LEDGERHEADER_FLAGS", 7);
    xdr.enum("LedgerHeaderFlags", {
      disableLiquidityPoolTradingFlag: 1,
      disableLiquidityPoolDepositFlag: 2,
      disableLiquidityPoolWithdrawalFlag: 4
    });
    xdr.union("LedgerHeaderExtensionV1Ext", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("LedgerHeaderExtensionV1", [["flags", xdr.lookup("Uint32")], ["ext", xdr.lookup("LedgerHeaderExtensionV1Ext")]]);
    xdr.union("LedgerHeaderExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()], [1, "v1"]],
      arms: {
        v1: xdr.lookup("LedgerHeaderExtensionV1")
      }
    });
    xdr.struct("LedgerHeader", [["ledgerVersion", xdr.lookup("Uint32")], ["previousLedgerHash", xdr.lookup("Hash")], ["scpValue", xdr.lookup("StellarValue")], ["txSetResultHash", xdr.lookup("Hash")], ["bucketListHash", xdr.lookup("Hash")], ["ledgerSeq", xdr.lookup("Uint32")], ["totalCoins", xdr.lookup("Int64")], ["feePool", xdr.lookup("Int64")], ["inflationSeq", xdr.lookup("Uint32")], ["idPool", xdr.lookup("Uint64")], ["baseFee", xdr.lookup("Uint32")], ["baseReserve", xdr.lookup("Uint32")], ["maxTxSetSize", xdr.lookup("Uint32")], ["skipList", xdr.array(xdr.lookup("Hash"), 4)], ["ext", xdr.lookup("LedgerHeaderExt")]]);
    xdr.enum("LedgerUpgradeType", {
      ledgerUpgradeVersion: 1,
      ledgerUpgradeBaseFee: 2,
      ledgerUpgradeMaxTxSetSize: 3,
      ledgerUpgradeBaseReserve: 4,
      ledgerUpgradeFlags: 5
    });
    xdr.union("LedgerUpgrade", {
      switchOn: xdr.lookup("LedgerUpgradeType"),
      switchName: "type",
      switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"]],
      arms: {
        newLedgerVersion: xdr.lookup("Uint32"),
        newBaseFee: xdr.lookup("Uint32"),
        newMaxTxSetSize: xdr.lookup("Uint32"),
        newBaseReserve: xdr.lookup("Uint32"),
        newFlags: xdr.lookup("Uint32")
      }
    });
    xdr.enum("BucketEntryType", {
      metaentry: -1,
      liveentry: 0,
      deadentry: 1,
      initentry: 2
    });
    xdr.union("BucketMetadataExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("BucketMetadata", [["ledgerVersion", xdr.lookup("Uint32")], ["ext", xdr.lookup("BucketMetadataExt")]]);
    xdr.union("BucketEntry", {
      switchOn: xdr.lookup("BucketEntryType"),
      switchName: "type",
      switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]],
      arms: {
        liveEntry: xdr.lookup("LedgerEntry"),
        deadEntry: xdr.lookup("LedgerKey"),
        metaEntry: xdr.lookup("BucketMetadata")
      }
    });
    xdr.struct("TransactionSet", [["previousLedgerHash", xdr.lookup("Hash")], ["txes", xdr.varArray(xdr.lookup("TransactionEnvelope"), 2147483647)]]);
    xdr.struct("TransactionResultPair", [["transactionHash", xdr.lookup("Hash")], ["result", xdr.lookup("TransactionResult")]]);
    xdr.struct("TransactionResultSet", [["results", xdr.varArray(xdr.lookup("TransactionResultPair"), 2147483647)]]);
    xdr.union("TransactionHistoryEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("TransactionHistoryEntry", [["ledgerSeq", xdr.lookup("Uint32")], ["txSet", xdr.lookup("TransactionSet")], ["ext", xdr.lookup("TransactionHistoryEntryExt")]]);
    xdr.union("TransactionHistoryResultEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("TransactionHistoryResultEntry", [["ledgerSeq", xdr.lookup("Uint32")], ["txResultSet", xdr.lookup("TransactionResultSet")], ["ext", xdr.lookup("TransactionHistoryResultEntryExt")]]);
    xdr.union("LedgerHeaderHistoryEntryExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("LedgerHeaderHistoryEntry", [["hash", xdr.lookup("Hash")], ["header", xdr.lookup("LedgerHeader")], ["ext", xdr.lookup("LedgerHeaderHistoryEntryExt")]]);
    xdr.struct("LedgerScpMessages", [["ledgerSeq", xdr.lookup("Uint32")], ["messages", xdr.varArray(xdr.lookup("ScpEnvelope"), 2147483647)]]);
    xdr.struct("ScpHistoryEntryV0", [["quorumSets", xdr.varArray(xdr.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", xdr.lookup("LedgerScpMessages")]]);
    xdr.union("ScpHistoryEntry", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, "v0"]],
      arms: {
        v0: xdr.lookup("ScpHistoryEntryV0")
      }
    });
    xdr.enum("LedgerEntryChangeType", {
      ledgerEntryCreated: 0,
      ledgerEntryUpdated: 1,
      ledgerEntryRemoved: 2,
      ledgerEntryState: 3
    });
    xdr.union("LedgerEntryChange", {
      switchOn: xdr.lookup("LedgerEntryChangeType"),
      switchName: "type",
      switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]],
      arms: {
        created: xdr.lookup("LedgerEntry"),
        updated: xdr.lookup("LedgerEntry"),
        removed: xdr.lookup("LedgerKey"),
        state: xdr.lookup("LedgerEntry")
      }
    });
    xdr.typedef("LedgerEntryChanges", xdr.varArray(xdr.lookup("LedgerEntryChange"), 2147483647));
    xdr.struct("OperationMeta", [["changes", xdr.lookup("LedgerEntryChanges")]]);
    xdr.struct("TransactionMetaV1", [["txChanges", xdr.lookup("LedgerEntryChanges")], ["operations", xdr.varArray(xdr.lookup("OperationMeta"), 2147483647)]]);
    xdr.struct("TransactionMetaV2", [["txChangesBefore", xdr.lookup("LedgerEntryChanges")], ["operations", xdr.varArray(xdr.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr.lookup("LedgerEntryChanges")]]);
    xdr.union("TransactionMeta", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, "operations"], [1, "v1"], [2, "v2"]],
      arms: {
        operations: xdr.varArray(xdr.lookup("OperationMeta"), 2147483647),
        v1: xdr.lookup("TransactionMetaV1"),
        v2: xdr.lookup("TransactionMetaV2")
      }
    });
    xdr.struct("TransactionResultMeta", [["result", xdr.lookup("TransactionResultPair")], ["feeProcessing", xdr.lookup("LedgerEntryChanges")], ["txApplyProcessing", xdr.lookup("TransactionMeta")]]);
    xdr.struct("UpgradeEntryMeta", [["upgrade", xdr.lookup("LedgerUpgrade")], ["changes", xdr.lookup("LedgerEntryChanges")]]);
    xdr.struct("LedgerCloseMetaV0", [["ledgerHeader", xdr.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr.lookup("TransactionSet")], ["txProcessing", xdr.varArray(xdr.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr.varArray(xdr.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr.varArray(xdr.lookup("ScpHistoryEntry"), 2147483647)]]);
    xdr.union("LedgerCloseMeta", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, "v0"]],
      arms: {
        v0: xdr.lookup("LedgerCloseMetaV0")
      }
    });
    xdr.enum("ErrorCode", {
      errMisc: 0,
      errData: 1,
      errConf: 2,
      errAuth: 3,
      errLoad: 4
    });
    xdr.struct("Error", [["code", xdr.lookup("ErrorCode")], ["msg", xdr.string(100)]]);
    xdr.struct("AuthCert", [["pubkey", xdr.lookup("Curve25519Public")], ["expiration", xdr.lookup("Uint64")], ["sig", xdr.lookup("Signature")]]);
    xdr.struct("Hello", [["ledgerVersion", xdr.lookup("Uint32")], ["overlayVersion", xdr.lookup("Uint32")], ["overlayMinVersion", xdr.lookup("Uint32")], ["networkId", xdr.lookup("Hash")], ["versionStr", xdr.string(100)], ["listeningPort", xdr.int()], ["peerId", xdr.lookup("NodeId")], ["cert", xdr.lookup("AuthCert")], ["nonce", xdr.lookup("Uint256")]]);
    xdr.struct("Auth", [["unused", xdr.int()]]);
    xdr.enum("IpAddrType", {
      iPv4: 0,
      iPv6: 1
    });
    xdr.union("PeerAddressIp", {
      switchOn: xdr.lookup("IpAddrType"),
      switchName: "type",
      switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]],
      arms: {
        ipv4: xdr.opaque(4),
        ipv6: xdr.opaque(16)
      }
    });
    xdr.struct("PeerAddress", [["ip", xdr.lookup("PeerAddressIp")], ["port", xdr.lookup("Uint32")], ["numFailures", xdr.lookup("Uint32")]]);
    xdr.enum("MessageType", {
      errorMsg: 0,
      auth: 2,
      dontHave: 3,
      getPeers: 4,
      peers: 5,
      getTxSet: 6,
      txSet: 7,
      transaction: 8,
      getScpQuorumset: 9,
      scpQuorumset: 10,
      scpMessage: 11,
      getScpState: 12,
      hello: 13,
      surveyRequest: 14,
      surveyResponse: 15
    });
    xdr.struct("DontHave", [["type", xdr.lookup("MessageType")], ["reqHash", xdr.lookup("Uint256")]]);
    xdr.enum("SurveyMessageCommandType", {
      surveyTopology: 0
    });
    xdr.struct("SurveyRequestMessage", [["surveyorPeerId", xdr.lookup("NodeId")], ["surveyedPeerId", xdr.lookup("NodeId")], ["ledgerNum", xdr.lookup("Uint32")], ["encryptionKey", xdr.lookup("Curve25519Public")], ["commandType", xdr.lookup("SurveyMessageCommandType")]]);
    xdr.struct("SignedSurveyRequestMessage", [["requestSignature", xdr.lookup("Signature")], ["request", xdr.lookup("SurveyRequestMessage")]]);
    xdr.typedef("EncryptedBody", xdr.varOpaque(64e3));
    xdr.struct("SurveyResponseMessage", [["surveyorPeerId", xdr.lookup("NodeId")], ["surveyedPeerId", xdr.lookup("NodeId")], ["ledgerNum", xdr.lookup("Uint32")], ["commandType", xdr.lookup("SurveyMessageCommandType")], ["encryptedBody", xdr.lookup("EncryptedBody")]]);
    xdr.struct("SignedSurveyResponseMessage", [["responseSignature", xdr.lookup("Signature")], ["response", xdr.lookup("SurveyResponseMessage")]]);
    xdr.struct("PeerStats", [["id", xdr.lookup("NodeId")], ["versionStr", xdr.string(100)], ["messagesRead", xdr.lookup("Uint64")], ["messagesWritten", xdr.lookup("Uint64")], ["bytesRead", xdr.lookup("Uint64")], ["bytesWritten", xdr.lookup("Uint64")], ["secondsConnected", xdr.lookup("Uint64")], ["uniqueFloodBytesRecv", xdr.lookup("Uint64")], ["duplicateFloodBytesRecv", xdr.lookup("Uint64")], ["uniqueFetchBytesRecv", xdr.lookup("Uint64")], ["duplicateFetchBytesRecv", xdr.lookup("Uint64")], ["uniqueFloodMessageRecv", xdr.lookup("Uint64")], ["duplicateFloodMessageRecv", xdr.lookup("Uint64")], ["uniqueFetchMessageRecv", xdr.lookup("Uint64")], ["duplicateFetchMessageRecv", xdr.lookup("Uint64")]]);
    xdr.typedef("PeerStatList", xdr.varArray(xdr.lookup("PeerStats"), 25));
    xdr.struct("TopologyResponseBody", [["inboundPeers", xdr.lookup("PeerStatList")], ["outboundPeers", xdr.lookup("PeerStatList")], ["totalInboundPeerCount", xdr.lookup("Uint32")], ["totalOutboundPeerCount", xdr.lookup("Uint32")]]);
    xdr.union("SurveyResponseBody", {
      switchOn: xdr.lookup("SurveyMessageCommandType"),
      switchName: "type",
      switches: [["surveyTopology", "topologyResponseBody"]],
      arms: {
        topologyResponseBody: xdr.lookup("TopologyResponseBody")
      }
    });
    xdr.union("StellarMessage", {
      switchOn: xdr.lookup("MessageType"),
      switchName: "type",
      switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", xdr.void()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"]],
      arms: {
        error: xdr.lookup("Error"),
        hello: xdr.lookup("Hello"),
        auth: xdr.lookup("Auth"),
        dontHave: xdr.lookup("DontHave"),
        peers: xdr.varArray(xdr.lookup("PeerAddress"), 100),
        txSetHash: xdr.lookup("Uint256"),
        txSet: xdr.lookup("TransactionSet"),
        transaction: xdr.lookup("TransactionEnvelope"),
        signedSurveyRequestMessage: xdr.lookup("SignedSurveyRequestMessage"),
        signedSurveyResponseMessage: xdr.lookup("SignedSurveyResponseMessage"),
        qSetHash: xdr.lookup("Uint256"),
        qSet: xdr.lookup("ScpQuorumSet"),
        envelope: xdr.lookup("ScpEnvelope"),
        getScpLedgerSeq: xdr.lookup("Uint32")
      }
    });
    xdr.struct("AuthenticatedMessageV0", [["sequence", xdr.lookup("Uint64")], ["message", xdr.lookup("StellarMessage")], ["mac", xdr.lookup("HmacSha256Mac")]]);
    xdr.union("AuthenticatedMessage", {
      switchOn: xdr.lookup("Uint32"),
      switchName: "v",
      switches: [[0, "v0"]],
      arms: {
        v0: xdr.lookup("AuthenticatedMessageV0")
      }
    });
    xdr.typedef("Value", xdr.varOpaque());
    xdr.struct("ScpBallot", [["counter", xdr.lookup("Uint32")], ["value", xdr.lookup("Value")]]);
    xdr.enum("ScpStatementType", {
      scpStPrepare: 0,
      scpStConfirm: 1,
      scpStExternalize: 2,
      scpStNominate: 3
    });
    xdr.struct("ScpNomination", [["quorumSetHash", xdr.lookup("Hash")], ["votes", xdr.varArray(xdr.lookup("Value"), 2147483647)], ["accepted", xdr.varArray(xdr.lookup("Value"), 2147483647)]]);
    xdr.struct("ScpStatementPrepare", [["quorumSetHash", xdr.lookup("Hash")], ["ballot", xdr.lookup("ScpBallot")], ["prepared", xdr.option(xdr.lookup("ScpBallot"))], ["preparedPrime", xdr.option(xdr.lookup("ScpBallot"))], ["nC", xdr.lookup("Uint32")], ["nH", xdr.lookup("Uint32")]]);
    xdr.struct("ScpStatementConfirm", [["ballot", xdr.lookup("ScpBallot")], ["nPrepared", xdr.lookup("Uint32")], ["nCommit", xdr.lookup("Uint32")], ["nH", xdr.lookup("Uint32")], ["quorumSetHash", xdr.lookup("Hash")]]);
    xdr.struct("ScpStatementExternalize", [["commit", xdr.lookup("ScpBallot")], ["nH", xdr.lookup("Uint32")], ["commitQuorumSetHash", xdr.lookup("Hash")]]);
    xdr.union("ScpStatementPledges", {
      switchOn: xdr.lookup("ScpStatementType"),
      switchName: "type",
      switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]],
      arms: {
        prepare: xdr.lookup("ScpStatementPrepare"),
        confirm: xdr.lookup("ScpStatementConfirm"),
        externalize: xdr.lookup("ScpStatementExternalize"),
        nominate: xdr.lookup("ScpNomination")
      }
    });
    xdr.struct("ScpStatement", [["nodeId", xdr.lookup("NodeId")], ["slotIndex", xdr.lookup("Uint64")], ["pledges", xdr.lookup("ScpStatementPledges")]]);
    xdr.struct("ScpEnvelope", [["statement", xdr.lookup("ScpStatement")], ["signature", xdr.lookup("Signature")]]);
    xdr.struct("ScpQuorumSet", [["threshold", xdr.lookup("Uint32")], ["validators", xdr.varArray(xdr.lookup("NodeId"), 2147483647)], ["innerSets", xdr.varArray(xdr.lookup("ScpQuorumSet"), 2147483647)]]);
    xdr.union("LiquidityPoolParameters", {
      switchOn: xdr.lookup("LiquidityPoolType"),
      switchName: "type",
      switches: [["liquidityPoolConstantProduct", "constantProduct"]],
      arms: {
        constantProduct: xdr.lookup("LiquidityPoolConstantProductParameters")
      }
    });
    xdr.struct("MuxedAccountMed25519", [["id", xdr.lookup("Uint64")], ["ed25519", xdr.lookup("Uint256")]]);
    xdr.union("MuxedAccount", {
      switchOn: xdr.lookup("CryptoKeyType"),
      switchName: "type",
      switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]],
      arms: {
        ed25519: xdr.lookup("Uint256"),
        med25519: xdr.lookup("MuxedAccountMed25519")
      }
    });
    xdr.struct("DecoratedSignature", [["hint", xdr.lookup("SignatureHint")], ["signature", xdr.lookup("Signature")]]);
    xdr.enum("OperationType", {
      createAccount: 0,
      payment: 1,
      pathPaymentStrictReceive: 2,
      manageSellOffer: 3,
      createPassiveSellOffer: 4,
      setOptions: 5,
      changeTrust: 6,
      allowTrust: 7,
      accountMerge: 8,
      inflation: 9,
      manageData: 10,
      bumpSequence: 11,
      manageBuyOffer: 12,
      pathPaymentStrictSend: 13,
      createClaimableBalance: 14,
      claimClaimableBalance: 15,
      beginSponsoringFutureReserves: 16,
      endSponsoringFutureReserves: 17,
      revokeSponsorship: 18,
      clawback: 19,
      clawbackClaimableBalance: 20,
      setTrustLineFlags: 21,
      liquidityPoolDeposit: 22,
      liquidityPoolWithdraw: 23
    });
    xdr.struct("CreateAccountOp", [["destination", xdr.lookup("AccountId")], ["startingBalance", xdr.lookup("Int64")]]);
    xdr.struct("PaymentOp", [["destination", xdr.lookup("MuxedAccount")], ["asset", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")]]);
    xdr.struct("PathPaymentStrictReceiveOp", [["sendAsset", xdr.lookup("Asset")], ["sendMax", xdr.lookup("Int64")], ["destination", xdr.lookup("MuxedAccount")], ["destAsset", xdr.lookup("Asset")], ["destAmount", xdr.lookup("Int64")], ["path", xdr.varArray(xdr.lookup("Asset"), 5)]]);
    xdr.struct("PathPaymentStrictSendOp", [["sendAsset", xdr.lookup("Asset")], ["sendAmount", xdr.lookup("Int64")], ["destination", xdr.lookup("MuxedAccount")], ["destAsset", xdr.lookup("Asset")], ["destMin", xdr.lookup("Int64")], ["path", xdr.varArray(xdr.lookup("Asset"), 5)]]);
    xdr.struct("ManageSellOfferOp", [["selling", xdr.lookup("Asset")], ["buying", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["price", xdr.lookup("Price")], ["offerId", xdr.lookup("Int64")]]);
    xdr.struct("ManageBuyOfferOp", [["selling", xdr.lookup("Asset")], ["buying", xdr.lookup("Asset")], ["buyAmount", xdr.lookup("Int64")], ["price", xdr.lookup("Price")], ["offerId", xdr.lookup("Int64")]]);
    xdr.struct("CreatePassiveSellOfferOp", [["selling", xdr.lookup("Asset")], ["buying", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["price", xdr.lookup("Price")]]);
    xdr.struct("SetOptionsOp", [["inflationDest", xdr.option(xdr.lookup("AccountId"))], ["clearFlags", xdr.option(xdr.lookup("Uint32"))], ["setFlags", xdr.option(xdr.lookup("Uint32"))], ["masterWeight", xdr.option(xdr.lookup("Uint32"))], ["lowThreshold", xdr.option(xdr.lookup("Uint32"))], ["medThreshold", xdr.option(xdr.lookup("Uint32"))], ["highThreshold", xdr.option(xdr.lookup("Uint32"))], ["homeDomain", xdr.option(xdr.lookup("String32"))], ["signer", xdr.option(xdr.lookup("Signer"))]]);
    xdr.union("ChangeTrustAsset", {
      switchOn: xdr.lookup("AssetType"),
      switchName: "type",
      switches: [["assetTypeNative", xdr.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]],
      arms: {
        alphaNum4: xdr.lookup("AlphaNum4"),
        alphaNum12: xdr.lookup("AlphaNum12"),
        liquidityPool: xdr.lookup("LiquidityPoolParameters")
      }
    });
    xdr.struct("ChangeTrustOp", [["line", xdr.lookup("ChangeTrustAsset")], ["limit", xdr.lookup("Int64")]]);
    xdr.struct("AllowTrustOp", [["trustor", xdr.lookup("AccountId")], ["asset", xdr.lookup("AssetCode")], ["authorize", xdr.lookup("Uint32")]]);
    xdr.struct("ManageDataOp", [["dataName", xdr.lookup("String64")], ["dataValue", xdr.option(xdr.lookup("DataValue"))]]);
    xdr.struct("BumpSequenceOp", [["bumpTo", xdr.lookup("SequenceNumber")]]);
    xdr.struct("CreateClaimableBalanceOp", [["asset", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["claimants", xdr.varArray(xdr.lookup("Claimant"), 10)]]);
    xdr.struct("ClaimClaimableBalanceOp", [["balanceId", xdr.lookup("ClaimableBalanceId")]]);
    xdr.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", xdr.lookup("AccountId")]]);
    xdr.enum("RevokeSponsorshipType", {
      revokeSponsorshipLedgerEntry: 0,
      revokeSponsorshipSigner: 1
    });
    xdr.struct("RevokeSponsorshipOpSigner", [["accountId", xdr.lookup("AccountId")], ["signerKey", xdr.lookup("SignerKey")]]);
    xdr.union("RevokeSponsorshipOp", {
      switchOn: xdr.lookup("RevokeSponsorshipType"),
      switchName: "type",
      switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]],
      arms: {
        ledgerKey: xdr.lookup("LedgerKey"),
        signer: xdr.lookup("RevokeSponsorshipOpSigner")
      }
    });
    xdr.struct("ClawbackOp", [["asset", xdr.lookup("Asset")], ["from", xdr.lookup("MuxedAccount")], ["amount", xdr.lookup("Int64")]]);
    xdr.struct("ClawbackClaimableBalanceOp", [["balanceId", xdr.lookup("ClaimableBalanceId")]]);
    xdr.struct("SetTrustLineFlagsOp", [["trustor", xdr.lookup("AccountId")], ["asset", xdr.lookup("Asset")], ["clearFlags", xdr.lookup("Uint32")], ["setFlags", xdr.lookup("Uint32")]]);
    xdr.const("LIQUIDITY_POOL_FEE_V18", 30);
    xdr.struct("LiquidityPoolDepositOp", [["liquidityPoolId", xdr.lookup("PoolId")], ["maxAmountA", xdr.lookup("Int64")], ["maxAmountB", xdr.lookup("Int64")], ["minPrice", xdr.lookup("Price")], ["maxPrice", xdr.lookup("Price")]]);
    xdr.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", xdr.lookup("PoolId")], ["amount", xdr.lookup("Int64")], ["minAmountA", xdr.lookup("Int64")], ["minAmountB", xdr.lookup("Int64")]]);
    xdr.union("OperationBody", {
      switchOn: xdr.lookup("OperationType"),
      switchName: "type",
      switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", xdr.void()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", xdr.void()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"]],
      arms: {
        createAccountOp: xdr.lookup("CreateAccountOp"),
        paymentOp: xdr.lookup("PaymentOp"),
        pathPaymentStrictReceiveOp: xdr.lookup("PathPaymentStrictReceiveOp"),
        manageSellOfferOp: xdr.lookup("ManageSellOfferOp"),
        createPassiveSellOfferOp: xdr.lookup("CreatePassiveSellOfferOp"),
        setOptionsOp: xdr.lookup("SetOptionsOp"),
        changeTrustOp: xdr.lookup("ChangeTrustOp"),
        allowTrustOp: xdr.lookup("AllowTrustOp"),
        destination: xdr.lookup("MuxedAccount"),
        manageDataOp: xdr.lookup("ManageDataOp"),
        bumpSequenceOp: xdr.lookup("BumpSequenceOp"),
        manageBuyOfferOp: xdr.lookup("ManageBuyOfferOp"),
        pathPaymentStrictSendOp: xdr.lookup("PathPaymentStrictSendOp"),
        createClaimableBalanceOp: xdr.lookup("CreateClaimableBalanceOp"),
        claimClaimableBalanceOp: xdr.lookup("ClaimClaimableBalanceOp"),
        beginSponsoringFutureReservesOp: xdr.lookup("BeginSponsoringFutureReservesOp"),
        revokeSponsorshipOp: xdr.lookup("RevokeSponsorshipOp"),
        clawbackOp: xdr.lookup("ClawbackOp"),
        clawbackClaimableBalanceOp: xdr.lookup("ClawbackClaimableBalanceOp"),
        setTrustLineFlagsOp: xdr.lookup("SetTrustLineFlagsOp"),
        liquidityPoolDepositOp: xdr.lookup("LiquidityPoolDepositOp"),
        liquidityPoolWithdrawOp: xdr.lookup("LiquidityPoolWithdrawOp")
      }
    });
    xdr.struct("Operation", [["sourceAccount", xdr.option(xdr.lookup("MuxedAccount"))], ["body", xdr.lookup("OperationBody")]]);
    xdr.struct("OperationIdId", [["sourceAccount", xdr.lookup("AccountId")], ["seqNum", xdr.lookup("SequenceNumber")], ["opNum", xdr.lookup("Uint32")]]);
    xdr.struct("OperationIdRevokeId", [["sourceAccount", xdr.lookup("AccountId")], ["seqNum", xdr.lookup("SequenceNumber")], ["opNum", xdr.lookup("Uint32")], ["liquidityPoolId", xdr.lookup("PoolId")], ["asset", xdr.lookup("Asset")]]);
    xdr.union("OperationId", {
      switchOn: xdr.lookup("EnvelopeType"),
      switchName: "type",
      switches: [["envelopeTypeOpId", "id"], ["envelopeTypePoolRevokeOpId", "revokeId"]],
      arms: {
        id: xdr.lookup("OperationIdId"),
        revokeId: xdr.lookup("OperationIdRevokeId")
      }
    });
    xdr.enum("MemoType", {
      memoNone: 0,
      memoText: 1,
      memoId: 2,
      memoHash: 3,
      memoReturn: 4
    });
    xdr.union("Memo", {
      switchOn: xdr.lookup("MemoType"),
      switchName: "type",
      switches: [["memoNone", xdr.void()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]],
      arms: {
        text: xdr.string(28),
        id: xdr.lookup("Uint64"),
        hash: xdr.lookup("Hash"),
        retHash: xdr.lookup("Hash")
      }
    });
    xdr.struct("TimeBounds", [["minTime", xdr.lookup("TimePoint")], ["maxTime", xdr.lookup("TimePoint")]]);
    xdr.const("MAX_OPS_PER_TX", 100);
    xdr.union("TransactionV0Ext", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("TransactionV0", [["sourceAccountEd25519", xdr.lookup("Uint256")], ["fee", xdr.lookup("Uint32")], ["seqNum", xdr.lookup("SequenceNumber")], ["timeBounds", xdr.option(xdr.lookup("TimeBounds"))], ["memo", xdr.lookup("Memo")], ["operations", xdr.varArray(xdr.lookup("Operation"), xdr.lookup("MAX_OPS_PER_TX"))], ["ext", xdr.lookup("TransactionV0Ext")]]);
    xdr.struct("TransactionV0Envelope", [["tx", xdr.lookup("TransactionV0")], ["signatures", xdr.varArray(xdr.lookup("DecoratedSignature"), 20)]]);
    xdr.union("TransactionExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("Transaction", [["sourceAccount", xdr.lookup("MuxedAccount")], ["fee", xdr.lookup("Uint32")], ["seqNum", xdr.lookup("SequenceNumber")], ["timeBounds", xdr.option(xdr.lookup("TimeBounds"))], ["memo", xdr.lookup("Memo")], ["operations", xdr.varArray(xdr.lookup("Operation"), xdr.lookup("MAX_OPS_PER_TX"))], ["ext", xdr.lookup("TransactionExt")]]);
    xdr.struct("TransactionV1Envelope", [["tx", xdr.lookup("Transaction")], ["signatures", xdr.varArray(xdr.lookup("DecoratedSignature"), 20)]]);
    xdr.union("FeeBumpTransactionInnerTx", {
      switchOn: xdr.lookup("EnvelopeType"),
      switchName: "type",
      switches: [["envelopeTypeTx", "v1"]],
      arms: {
        v1: xdr.lookup("TransactionV1Envelope")
      }
    });
    xdr.union("FeeBumpTransactionExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("FeeBumpTransaction", [["feeSource", xdr.lookup("MuxedAccount")], ["fee", xdr.lookup("Int64")], ["innerTx", xdr.lookup("FeeBumpTransactionInnerTx")], ["ext", xdr.lookup("FeeBumpTransactionExt")]]);
    xdr.struct("FeeBumpTransactionEnvelope", [["tx", xdr.lookup("FeeBumpTransaction")], ["signatures", xdr.varArray(xdr.lookup("DecoratedSignature"), 20)]]);
    xdr.union("TransactionEnvelope", {
      switchOn: xdr.lookup("EnvelopeType"),
      switchName: "type",
      switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]],
      arms: {
        v0: xdr.lookup("TransactionV0Envelope"),
        v1: xdr.lookup("TransactionV1Envelope"),
        feeBump: xdr.lookup("FeeBumpTransactionEnvelope")
      }
    });
    xdr.union("TransactionSignaturePayloadTaggedTransaction", {
      switchOn: xdr.lookup("EnvelopeType"),
      switchName: "type",
      switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]],
      arms: {
        tx: xdr.lookup("Transaction"),
        feeBump: xdr.lookup("FeeBumpTransaction")
      }
    });
    xdr.struct("TransactionSignaturePayload", [["networkId", xdr.lookup("Hash")], ["taggedTransaction", xdr.lookup("TransactionSignaturePayloadTaggedTransaction")]]);
    xdr.enum("ClaimAtomType", {
      claimAtomTypeV0: 0,
      claimAtomTypeOrderBook: 1,
      claimAtomTypeLiquidityPool: 2
    });
    xdr.struct("ClaimOfferAtomV0", [["sellerEd25519", xdr.lookup("Uint256")], ["offerId", xdr.lookup("Int64")], ["assetSold", xdr.lookup("Asset")], ["amountSold", xdr.lookup("Int64")], ["assetBought", xdr.lookup("Asset")], ["amountBought", xdr.lookup("Int64")]]);
    xdr.struct("ClaimOfferAtom", [["sellerId", xdr.lookup("AccountId")], ["offerId", xdr.lookup("Int64")], ["assetSold", xdr.lookup("Asset")], ["amountSold", xdr.lookup("Int64")], ["assetBought", xdr.lookup("Asset")], ["amountBought", xdr.lookup("Int64")]]);
    xdr.struct("ClaimLiquidityAtom", [["liquidityPoolId", xdr.lookup("PoolId")], ["assetSold", xdr.lookup("Asset")], ["amountSold", xdr.lookup("Int64")], ["assetBought", xdr.lookup("Asset")], ["amountBought", xdr.lookup("Int64")]]);
    xdr.union("ClaimAtom", {
      switchOn: xdr.lookup("ClaimAtomType"),
      switchName: "type",
      switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]],
      arms: {
        v0: xdr.lookup("ClaimOfferAtomV0"),
        orderBook: xdr.lookup("ClaimOfferAtom"),
        liquidityPool: xdr.lookup("ClaimLiquidityAtom")
      }
    });
    xdr.enum("CreateAccountResultCode", {
      createAccountSuccess: 0,
      createAccountMalformed: -1,
      createAccountUnderfunded: -2,
      createAccountLowReserve: -3,
      createAccountAlreadyExist: -4
    });
    xdr.union("CreateAccountResult", {
      switchOn: xdr.lookup("CreateAccountResultCode"),
      switchName: "code",
      switches: [["createAccountSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("PaymentResultCode", {
      paymentSuccess: 0,
      paymentMalformed: -1,
      paymentUnderfunded: -2,
      paymentSrcNoTrust: -3,
      paymentSrcNotAuthorized: -4,
      paymentNoDestination: -5,
      paymentNoTrust: -6,
      paymentNotAuthorized: -7,
      paymentLineFull: -8,
      paymentNoIssuer: -9
    });
    xdr.union("PaymentResult", {
      switchOn: xdr.lookup("PaymentResultCode"),
      switchName: "code",
      switches: [["paymentSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("PathPaymentStrictReceiveResultCode", {
      pathPaymentStrictReceiveSuccess: 0,
      pathPaymentStrictReceiveMalformed: -1,
      pathPaymentStrictReceiveUnderfunded: -2,
      pathPaymentStrictReceiveSrcNoTrust: -3,
      pathPaymentStrictReceiveSrcNotAuthorized: -4,
      pathPaymentStrictReceiveNoDestination: -5,
      pathPaymentStrictReceiveNoTrust: -6,
      pathPaymentStrictReceiveNotAuthorized: -7,
      pathPaymentStrictReceiveLineFull: -8,
      pathPaymentStrictReceiveNoIssuer: -9,
      pathPaymentStrictReceiveTooFewOffers: -10,
      pathPaymentStrictReceiveOfferCrossSelf: -11,
      pathPaymentStrictReceiveOverSendmax: -12
    });
    xdr.struct("SimplePaymentResult", [["destination", xdr.lookup("AccountId")], ["asset", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")]]);
    xdr.struct("PathPaymentStrictReceiveResultSuccess", [["offers", xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)], ["last", xdr.lookup("SimplePaymentResult")]]);
    xdr.union("PathPaymentStrictReceiveResult", {
      switchOn: xdr.lookup("PathPaymentStrictReceiveResultCode"),
      switchName: "code",
      switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"]],
      arms: {
        success: xdr.lookup("PathPaymentStrictReceiveResultSuccess"),
        noIssuer: xdr.lookup("Asset")
      },
      defaultArm: xdr.void()
    });
    xdr.enum("PathPaymentStrictSendResultCode", {
      pathPaymentStrictSendSuccess: 0,
      pathPaymentStrictSendMalformed: -1,
      pathPaymentStrictSendUnderfunded: -2,
      pathPaymentStrictSendSrcNoTrust: -3,
      pathPaymentStrictSendSrcNotAuthorized: -4,
      pathPaymentStrictSendNoDestination: -5,
      pathPaymentStrictSendNoTrust: -6,
      pathPaymentStrictSendNotAuthorized: -7,
      pathPaymentStrictSendLineFull: -8,
      pathPaymentStrictSendNoIssuer: -9,
      pathPaymentStrictSendTooFewOffers: -10,
      pathPaymentStrictSendOfferCrossSelf: -11,
      pathPaymentStrictSendUnderDestmin: -12
    });
    xdr.struct("PathPaymentStrictSendResultSuccess", [["offers", xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)], ["last", xdr.lookup("SimplePaymentResult")]]);
    xdr.union("PathPaymentStrictSendResult", {
      switchOn: xdr.lookup("PathPaymentStrictSendResultCode"),
      switchName: "code",
      switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendNoIssuer", "noIssuer"]],
      arms: {
        success: xdr.lookup("PathPaymentStrictSendResultSuccess"),
        noIssuer: xdr.lookup("Asset")
      },
      defaultArm: xdr.void()
    });
    xdr.enum("ManageSellOfferResultCode", {
      manageSellOfferSuccess: 0,
      manageSellOfferMalformed: -1,
      manageSellOfferSellNoTrust: -2,
      manageSellOfferBuyNoTrust: -3,
      manageSellOfferSellNotAuthorized: -4,
      manageSellOfferBuyNotAuthorized: -5,
      manageSellOfferLineFull: -6,
      manageSellOfferUnderfunded: -7,
      manageSellOfferCrossSelf: -8,
      manageSellOfferSellNoIssuer: -9,
      manageSellOfferBuyNoIssuer: -10,
      manageSellOfferNotFound: -11,
      manageSellOfferLowReserve: -12
    });
    xdr.enum("ManageOfferEffect", {
      manageOfferCreated: 0,
      manageOfferUpdated: 1,
      manageOfferDeleted: 2
    });
    xdr.union("ManageOfferSuccessResultOffer", {
      switchOn: xdr.lookup("ManageOfferEffect"),
      switchName: "effect",
      switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"]],
      arms: {
        offer: xdr.lookup("OfferEntry")
      },
      defaultArm: xdr.void()
    });
    xdr.struct("ManageOfferSuccessResult", [["offersClaimed", xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)], ["offer", xdr.lookup("ManageOfferSuccessResultOffer")]]);
    xdr.union("ManageSellOfferResult", {
      switchOn: xdr.lookup("ManageSellOfferResultCode"),
      switchName: "code",
      switches: [["manageSellOfferSuccess", "success"]],
      arms: {
        success: xdr.lookup("ManageOfferSuccessResult")
      },
      defaultArm: xdr.void()
    });
    xdr.enum("ManageBuyOfferResultCode", {
      manageBuyOfferSuccess: 0,
      manageBuyOfferMalformed: -1,
      manageBuyOfferSellNoTrust: -2,
      manageBuyOfferBuyNoTrust: -3,
      manageBuyOfferSellNotAuthorized: -4,
      manageBuyOfferBuyNotAuthorized: -5,
      manageBuyOfferLineFull: -6,
      manageBuyOfferUnderfunded: -7,
      manageBuyOfferCrossSelf: -8,
      manageBuyOfferSellNoIssuer: -9,
      manageBuyOfferBuyNoIssuer: -10,
      manageBuyOfferNotFound: -11,
      manageBuyOfferLowReserve: -12
    });
    xdr.union("ManageBuyOfferResult", {
      switchOn: xdr.lookup("ManageBuyOfferResultCode"),
      switchName: "code",
      switches: [["manageBuyOfferSuccess", "success"]],
      arms: {
        success: xdr.lookup("ManageOfferSuccessResult")
      },
      defaultArm: xdr.void()
    });
    xdr.enum("SetOptionsResultCode", {
      setOptionsSuccess: 0,
      setOptionsLowReserve: -1,
      setOptionsTooManySigners: -2,
      setOptionsBadFlags: -3,
      setOptionsInvalidInflation: -4,
      setOptionsCantChange: -5,
      setOptionsUnknownFlag: -6,
      setOptionsThresholdOutOfRange: -7,
      setOptionsBadSigner: -8,
      setOptionsInvalidHomeDomain: -9,
      setOptionsAuthRevocableRequired: -10
    });
    xdr.union("SetOptionsResult", {
      switchOn: xdr.lookup("SetOptionsResultCode"),
      switchName: "code",
      switches: [["setOptionsSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("ChangeTrustResultCode", {
      changeTrustSuccess: 0,
      changeTrustMalformed: -1,
      changeTrustNoIssuer: -2,
      changeTrustInvalidLimit: -3,
      changeTrustLowReserve: -4,
      changeTrustSelfNotAllowed: -5,
      changeTrustTrustLineMissing: -6,
      changeTrustCannotDelete: -7,
      changeTrustNotAuthMaintainLiabilities: -8
    });
    xdr.union("ChangeTrustResult", {
      switchOn: xdr.lookup("ChangeTrustResultCode"),
      switchName: "code",
      switches: [["changeTrustSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("AllowTrustResultCode", {
      allowTrustSuccess: 0,
      allowTrustMalformed: -1,
      allowTrustNoTrustLine: -2,
      allowTrustTrustNotRequired: -3,
      allowTrustCantRevoke: -4,
      allowTrustSelfNotAllowed: -5,
      allowTrustLowReserve: -6
    });
    xdr.union("AllowTrustResult", {
      switchOn: xdr.lookup("AllowTrustResultCode"),
      switchName: "code",
      switches: [["allowTrustSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("AccountMergeResultCode", {
      accountMergeSuccess: 0,
      accountMergeMalformed: -1,
      accountMergeNoAccount: -2,
      accountMergeImmutableSet: -3,
      accountMergeHasSubEntries: -4,
      accountMergeSeqnumTooFar: -5,
      accountMergeDestFull: -6,
      accountMergeIsSponsor: -7
    });
    xdr.union("AccountMergeResult", {
      switchOn: xdr.lookup("AccountMergeResultCode"),
      switchName: "code",
      switches: [["accountMergeSuccess", "sourceAccountBalance"]],
      arms: {
        sourceAccountBalance: xdr.lookup("Int64")
      },
      defaultArm: xdr.void()
    });
    xdr.enum("InflationResultCode", {
      inflationSuccess: 0,
      inflationNotTime: -1
    });
    xdr.struct("InflationPayout", [["destination", xdr.lookup("AccountId")], ["amount", xdr.lookup("Int64")]]);
    xdr.union("InflationResult", {
      switchOn: xdr.lookup("InflationResultCode"),
      switchName: "code",
      switches: [["inflationSuccess", "payouts"]],
      arms: {
        payouts: xdr.varArray(xdr.lookup("InflationPayout"), 2147483647)
      },
      defaultArm: xdr.void()
    });
    xdr.enum("ManageDataResultCode", {
      manageDataSuccess: 0,
      manageDataNotSupportedYet: -1,
      manageDataNameNotFound: -2,
      manageDataLowReserve: -3,
      manageDataInvalidName: -4
    });
    xdr.union("ManageDataResult", {
      switchOn: xdr.lookup("ManageDataResultCode"),
      switchName: "code",
      switches: [["manageDataSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("BumpSequenceResultCode", {
      bumpSequenceSuccess: 0,
      bumpSequenceBadSeq: -1
    });
    xdr.union("BumpSequenceResult", {
      switchOn: xdr.lookup("BumpSequenceResultCode"),
      switchName: "code",
      switches: [["bumpSequenceSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("CreateClaimableBalanceResultCode", {
      createClaimableBalanceSuccess: 0,
      createClaimableBalanceMalformed: -1,
      createClaimableBalanceLowReserve: -2,
      createClaimableBalanceNoTrust: -3,
      createClaimableBalanceNotAuthorized: -4,
      createClaimableBalanceUnderfunded: -5
    });
    xdr.union("CreateClaimableBalanceResult", {
      switchOn: xdr.lookup("CreateClaimableBalanceResultCode"),
      switchName: "code",
      switches: [["createClaimableBalanceSuccess", "balanceId"]],
      arms: {
        balanceId: xdr.lookup("ClaimableBalanceId")
      },
      defaultArm: xdr.void()
    });
    xdr.enum("ClaimClaimableBalanceResultCode", {
      claimClaimableBalanceSuccess: 0,
      claimClaimableBalanceDoesNotExist: -1,
      claimClaimableBalanceCannotClaim: -2,
      claimClaimableBalanceLineFull: -3,
      claimClaimableBalanceNoTrust: -4,
      claimClaimableBalanceNotAuthorized: -5
    });
    xdr.union("ClaimClaimableBalanceResult", {
      switchOn: xdr.lookup("ClaimClaimableBalanceResultCode"),
      switchName: "code",
      switches: [["claimClaimableBalanceSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("BeginSponsoringFutureReservesResultCode", {
      beginSponsoringFutureReservesSuccess: 0,
      beginSponsoringFutureReservesMalformed: -1,
      beginSponsoringFutureReservesAlreadySponsored: -2,
      beginSponsoringFutureReservesRecursive: -3
    });
    xdr.union("BeginSponsoringFutureReservesResult", {
      switchOn: xdr.lookup("BeginSponsoringFutureReservesResultCode"),
      switchName: "code",
      switches: [["beginSponsoringFutureReservesSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("EndSponsoringFutureReservesResultCode", {
      endSponsoringFutureReservesSuccess: 0,
      endSponsoringFutureReservesNotSponsored: -1
    });
    xdr.union("EndSponsoringFutureReservesResult", {
      switchOn: xdr.lookup("EndSponsoringFutureReservesResultCode"),
      switchName: "code",
      switches: [["endSponsoringFutureReservesSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("RevokeSponsorshipResultCode", {
      revokeSponsorshipSuccess: 0,
      revokeSponsorshipDoesNotExist: -1,
      revokeSponsorshipNotSponsor: -2,
      revokeSponsorshipLowReserve: -3,
      revokeSponsorshipOnlyTransferable: -4,
      revokeSponsorshipMalformed: -5
    });
    xdr.union("RevokeSponsorshipResult", {
      switchOn: xdr.lookup("RevokeSponsorshipResultCode"),
      switchName: "code",
      switches: [["revokeSponsorshipSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("ClawbackResultCode", {
      clawbackSuccess: 0,
      clawbackMalformed: -1,
      clawbackNotClawbackEnabled: -2,
      clawbackNoTrust: -3,
      clawbackUnderfunded: -4
    });
    xdr.union("ClawbackResult", {
      switchOn: xdr.lookup("ClawbackResultCode"),
      switchName: "code",
      switches: [["clawbackSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("ClawbackClaimableBalanceResultCode", {
      clawbackClaimableBalanceSuccess: 0,
      clawbackClaimableBalanceDoesNotExist: -1,
      clawbackClaimableBalanceNotIssuer: -2,
      clawbackClaimableBalanceNotClawbackEnabled: -3
    });
    xdr.union("ClawbackClaimableBalanceResult", {
      switchOn: xdr.lookup("ClawbackClaimableBalanceResultCode"),
      switchName: "code",
      switches: [["clawbackClaimableBalanceSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("SetTrustLineFlagsResultCode", {
      setTrustLineFlagsSuccess: 0,
      setTrustLineFlagsMalformed: -1,
      setTrustLineFlagsNoTrustLine: -2,
      setTrustLineFlagsCantRevoke: -3,
      setTrustLineFlagsInvalidState: -4,
      setTrustLineFlagsLowReserve: -5
    });
    xdr.union("SetTrustLineFlagsResult", {
      switchOn: xdr.lookup("SetTrustLineFlagsResultCode"),
      switchName: "code",
      switches: [["setTrustLineFlagsSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("LiquidityPoolDepositResultCode", {
      liquidityPoolDepositSuccess: 0,
      liquidityPoolDepositMalformed: -1,
      liquidityPoolDepositNoTrust: -2,
      liquidityPoolDepositNotAuthorized: -3,
      liquidityPoolDepositUnderfunded: -4,
      liquidityPoolDepositLineFull: -5,
      liquidityPoolDepositBadPrice: -6,
      liquidityPoolDepositPoolFull: -7
    });
    xdr.union("LiquidityPoolDepositResult", {
      switchOn: xdr.lookup("LiquidityPoolDepositResultCode"),
      switchName: "code",
      switches: [["liquidityPoolDepositSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("LiquidityPoolWithdrawResultCode", {
      liquidityPoolWithdrawSuccess: 0,
      liquidityPoolWithdrawMalformed: -1,
      liquidityPoolWithdrawNoTrust: -2,
      liquidityPoolWithdrawUnderfunded: -3,
      liquidityPoolWithdrawLineFull: -4,
      liquidityPoolWithdrawUnderMinimum: -5
    });
    xdr.union("LiquidityPoolWithdrawResult", {
      switchOn: xdr.lookup("LiquidityPoolWithdrawResultCode"),
      switchName: "code",
      switches: [["liquidityPoolWithdrawSuccess", xdr.void()]],
      arms: {},
      defaultArm: xdr.void()
    });
    xdr.enum("OperationResultCode", {
      opInner: 0,
      opBadAuth: -1,
      opNoAccount: -2,
      opNotSupported: -3,
      opTooManySubentries: -4,
      opExceededWorkLimit: -5,
      opTooManySponsoring: -6
    });
    xdr.union("OperationResultTr", {
      switchOn: xdr.lookup("OperationType"),
      switchName: "type",
      switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"]],
      arms: {
        createAccountResult: xdr.lookup("CreateAccountResult"),
        paymentResult: xdr.lookup("PaymentResult"),
        pathPaymentStrictReceiveResult: xdr.lookup("PathPaymentStrictReceiveResult"),
        manageSellOfferResult: xdr.lookup("ManageSellOfferResult"),
        createPassiveSellOfferResult: xdr.lookup("ManageSellOfferResult"),
        setOptionsResult: xdr.lookup("SetOptionsResult"),
        changeTrustResult: xdr.lookup("ChangeTrustResult"),
        allowTrustResult: xdr.lookup("AllowTrustResult"),
        accountMergeResult: xdr.lookup("AccountMergeResult"),
        inflationResult: xdr.lookup("InflationResult"),
        manageDataResult: xdr.lookup("ManageDataResult"),
        bumpSeqResult: xdr.lookup("BumpSequenceResult"),
        manageBuyOfferResult: xdr.lookup("ManageBuyOfferResult"),
        pathPaymentStrictSendResult: xdr.lookup("PathPaymentStrictSendResult"),
        createClaimableBalanceResult: xdr.lookup("CreateClaimableBalanceResult"),
        claimClaimableBalanceResult: xdr.lookup("ClaimClaimableBalanceResult"),
        beginSponsoringFutureReservesResult: xdr.lookup("BeginSponsoringFutureReservesResult"),
        endSponsoringFutureReservesResult: xdr.lookup("EndSponsoringFutureReservesResult"),
        revokeSponsorshipResult: xdr.lookup("RevokeSponsorshipResult"),
        clawbackResult: xdr.lookup("ClawbackResult"),
        clawbackClaimableBalanceResult: xdr.lookup("ClawbackClaimableBalanceResult"),
        setTrustLineFlagsResult: xdr.lookup("SetTrustLineFlagsResult"),
        liquidityPoolDepositResult: xdr.lookup("LiquidityPoolDepositResult"),
        liquidityPoolWithdrawResult: xdr.lookup("LiquidityPoolWithdrawResult")
      }
    });
    xdr.union("OperationResult", {
      switchOn: xdr.lookup("OperationResultCode"),
      switchName: "code",
      switches: [["opInner", "tr"]],
      arms: {
        tr: xdr.lookup("OperationResultTr")
      },
      defaultArm: xdr.void()
    });
    xdr.enum("TransactionResultCode", {
      txFeeBumpInnerSuccess: 1,
      txSuccess: 0,
      txFailed: -1,
      txTooEarly: -2,
      txTooLate: -3,
      txMissingOperation: -4,
      txBadSeq: -5,
      txBadAuth: -6,
      txInsufficientBalance: -7,
      txNoAccount: -8,
      txInsufficientFee: -9,
      txBadAuthExtra: -10,
      txInternalError: -11,
      txNotSupported: -12,
      txFeeBumpInnerFailed: -13,
      txBadSponsorship: -14
    });
    xdr.union("InnerTransactionResultResult", {
      switchOn: xdr.lookup("TransactionResultCode"),
      switchName: "code",
      switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr.void()], ["txTooLate", xdr.void()], ["txMissingOperation", xdr.void()], ["txBadSeq", xdr.void()], ["txBadAuth", xdr.void()], ["txInsufficientBalance", xdr.void()], ["txNoAccount", xdr.void()], ["txInsufficientFee", xdr.void()], ["txBadAuthExtra", xdr.void()], ["txInternalError", xdr.void()], ["txNotSupported", xdr.void()], ["txBadSponsorship", xdr.void()]],
      arms: {
        results: xdr.varArray(xdr.lookup("OperationResult"), 2147483647)
      }
    });
    xdr.union("InnerTransactionResultExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("InnerTransactionResult", [["feeCharged", xdr.lookup("Int64")], ["result", xdr.lookup("InnerTransactionResultResult")], ["ext", xdr.lookup("InnerTransactionResultExt")]]);
    xdr.struct("InnerTransactionResultPair", [["transactionHash", xdr.lookup("Hash")], ["result", xdr.lookup("InnerTransactionResult")]]);
    xdr.union("TransactionResultResult", {
      switchOn: xdr.lookup("TransactionResultCode"),
      switchName: "code",
      switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"]],
      arms: {
        innerResultPair: xdr.lookup("InnerTransactionResultPair"),
        results: xdr.varArray(xdr.lookup("OperationResult"), 2147483647)
      },
      defaultArm: xdr.void()
    });
    xdr.union("TransactionResultExt", {
      switchOn: xdr.int(),
      switchName: "v",
      switches: [[0, xdr.void()]],
      arms: {}
    });
    xdr.struct("TransactionResult", [["feeCharged", xdr.lookup("Int64")], ["result", xdr.lookup("TransactionResultResult")], ["ext", xdr.lookup("TransactionResultExt")]]);
    xdr.typedef("Hash", xdr.opaque(32));
    xdr.typedef("Uint256", xdr.opaque(32));
    xdr.typedef("Uint32", xdr.uint());
    xdr.typedef("Int32", xdr.int());
    xdr.typedef("Uint64", xdr.uhyper());
    xdr.typedef("Int64", xdr.hyper());
    xdr.enum("CryptoKeyType", {
      keyTypeEd25519: 0,
      keyTypePreAuthTx: 1,
      keyTypeHashX: 2,
      keyTypeMuxedEd25519: 256
    });
    xdr.enum("PublicKeyType", {
      publicKeyTypeEd25519: 0
    });
    xdr.enum("SignerKeyType", {
      signerKeyTypeEd25519: 0,
      signerKeyTypePreAuthTx: 1,
      signerKeyTypeHashX: 2
    });
    xdr.union("PublicKey", {
      switchOn: xdr.lookup("PublicKeyType"),
      switchName: "type",
      switches: [["publicKeyTypeEd25519", "ed25519"]],
      arms: {
        ed25519: xdr.lookup("Uint256")
      }
    });
    xdr.union("SignerKey", {
      switchOn: xdr.lookup("SignerKeyType"),
      switchName: "type",
      switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"]],
      arms: {
        ed25519: xdr.lookup("Uint256"),
        preAuthTx: xdr.lookup("Uint256"),
        hashX: xdr.lookup("Uint256")
      }
    });
    xdr.typedef("Signature", xdr.varOpaque(64));
    xdr.typedef("SignatureHint", xdr.opaque(4));
    xdr.typedef("NodeId", xdr.lookup("PublicKey"));
    xdr.struct("Curve25519Secret", [["key", xdr.opaque(32)]]);
    xdr.struct("Curve25519Public", [["key", xdr.opaque(32)]]);
    xdr.struct("HmacSha256Key", [["key", xdr.opaque(32)]]);
    xdr.struct("HmacSha256Mac", [["mac", xdr.opaque(32)]]);
  });
  stellarXdr_generated.default = types2;
  return stellarXdr_generated;
}
var asset = {};
var _baseAssign;
var hasRequired_baseAssign;
function require_baseAssign() {
  if (hasRequired_baseAssign) return _baseAssign;
  hasRequired_baseAssign = 1;
  var copyObject = require_copyObject(), keys2 = requireKeys();
  function baseAssign(object, source) {
    return object && copyObject(source, keys2(source), object);
  }
  _baseAssign = baseAssign;
  return _baseAssign;
}
var _baseAssignIn;
var hasRequired_baseAssignIn;
function require_baseAssignIn() {
  if (hasRequired_baseAssignIn) return _baseAssignIn;
  hasRequired_baseAssignIn = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn();
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  _baseAssignIn = baseAssignIn;
  return _baseAssignIn;
}
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
  hasRequired_cloneBuffer = 1;
  (function(module, exports2) {
    var root = require_root();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
      buffer2.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  })(_cloneBuffer, _cloneBuffer.exports);
  return _cloneBuffer.exports;
}
var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray) return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray(source, array2) {
    var index2 = -1, length = source.length;
    array2 || (array2 = Array(length));
    while (++index2 < length) {
      array2[index2] = source[index2];
    }
    return array2;
  }
  _copyArray = copyArray;
  return _copyArray;
}
var _copySymbols;
var hasRequired_copySymbols;
function require_copySymbols() {
  if (hasRequired_copySymbols) return _copySymbols;
  hasRequired_copySymbols = 1;
  var copyObject = require_copyObject(), getSymbols = require_getSymbols();
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  _copySymbols = copySymbols;
  return _copySymbols;
}
var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype) return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg = require_overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype;
  return _getPrototype;
}
var _getSymbolsIn;
var hasRequired_getSymbolsIn;
function require_getSymbolsIn() {
  if (hasRequired_getSymbolsIn) return _getSymbolsIn;
  hasRequired_getSymbolsIn = 1;
  var arrayPush = require_arrayPush(), getPrototype = require_getPrototype(), getSymbols = require_getSymbols(), stubArray = requireStubArray();
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };
  _getSymbolsIn = getSymbolsIn;
  return _getSymbolsIn;
}
var _copySymbolsIn;
var hasRequired_copySymbolsIn;
function require_copySymbolsIn() {
  if (hasRequired_copySymbolsIn) return _copySymbolsIn;
  hasRequired_copySymbolsIn = 1;
  var copyObject = require_copyObject(), getSymbolsIn = require_getSymbolsIn();
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }
  _copySymbolsIn = copySymbolsIn;
  return _copySymbolsIn;
}
var _getAllKeysIn;
var hasRequired_getAllKeysIn;
function require_getAllKeysIn() {
  if (hasRequired_getAllKeysIn) return _getAllKeysIn;
  hasRequired_getAllKeysIn = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbolsIn = require_getSymbolsIn(), keysIn = requireKeysIn();
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  _getAllKeysIn = getAllKeysIn;
  return _getAllKeysIn;
}
var _initCloneArray;
var hasRequired_initCloneArray;
function require_initCloneArray() {
  if (hasRequired_initCloneArray) return _initCloneArray;
  hasRequired_initCloneArray = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function initCloneArray(array2) {
    var length = array2.length, result = new array2.constructor(length);
    if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
      result.index = array2.index;
      result.input = array2.input;
    }
    return result;
  }
  _initCloneArray = initCloneArray;
  return _initCloneArray;
}
var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var Uint8Array2 = require_Uint8Array();
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  _cloneArrayBuffer = cloneArrayBuffer;
  return _cloneArrayBuffer;
}
var _cloneDataView;
var hasRequired_cloneDataView;
function require_cloneDataView() {
  if (hasRequired_cloneDataView) return _cloneDataView;
  hasRequired_cloneDataView = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneDataView(dataView, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
  }
  _cloneDataView = cloneDataView;
  return _cloneDataView;
}
var _cloneRegExp;
var hasRequired_cloneRegExp;
function require_cloneRegExp() {
  if (hasRequired_cloneRegExp) return _cloneRegExp;
  hasRequired_cloneRegExp = 1;
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  _cloneRegExp = cloneRegExp;
  return _cloneRegExp;
}
var _cloneSymbol;
var hasRequired_cloneSymbol;
function require_cloneSymbol() {
  if (hasRequired_cloneSymbol) return _cloneSymbol;
  hasRequired_cloneSymbol = 1;
  var Symbol2 = require_Symbol();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  _cloneSymbol = cloneSymbol;
  return _cloneSymbol;
}
var _cloneTypedArray;
var hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray) return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  _cloneTypedArray = cloneTypedArray;
  return _cloneTypedArray;
}
var _initCloneByTag;
var hasRequired_initCloneByTag;
function require_initCloneByTag() {
  if (hasRequired_initCloneByTag) return _initCloneByTag;
  hasRequired_initCloneByTag = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer(), cloneDataView = require_cloneDataView(), cloneRegExp = require_cloneRegExp(), cloneSymbol = require_cloneSymbol(), cloneTypedArray = require_cloneTypedArray();
  var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return new Ctor();
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return new Ctor();
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  _initCloneByTag = initCloneByTag;
  return _initCloneByTag;
}
var _baseCreate;
var hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate) return _baseCreate;
  hasRequired_baseCreate = 1;
  var isObject2 = requireIsObject();
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    return function(proto) {
      if (!isObject2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  _baseCreate = baseCreate;
  return _baseCreate;
}
var _initCloneObject;
var hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject) return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var baseCreate = require_baseCreate(), getPrototype = require_getPrototype(), isPrototype = require_isPrototype();
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  _initCloneObject = initCloneObject;
  return _initCloneObject;
}
var _baseIsMap;
var hasRequired_baseIsMap;
function require_baseIsMap() {
  if (hasRequired_baseIsMap) return _baseIsMap;
  hasRequired_baseIsMap = 1;
  var getTag = require_getTag(), isObjectLike = requireIsObjectLike();
  var mapTag = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }
  _baseIsMap = baseIsMap;
  return _baseIsMap;
}
var isMap_1;
var hasRequiredIsMap;
function requireIsMap() {
  if (hasRequiredIsMap) return isMap_1;
  hasRequiredIsMap = 1;
  var baseIsMap = require_baseIsMap(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  isMap_1 = isMap;
  return isMap_1;
}
var _baseIsSet;
var hasRequired_baseIsSet;
function require_baseIsSet() {
  if (hasRequired_baseIsSet) return _baseIsSet;
  hasRequired_baseIsSet = 1;
  var getTag = require_getTag(), isObjectLike = requireIsObjectLike();
  var setTag = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }
  _baseIsSet = baseIsSet;
  return _baseIsSet;
}
var isSet_1;
var hasRequiredIsSet;
function requireIsSet() {
  if (hasRequiredIsSet) return isSet_1;
  hasRequiredIsSet = 1;
  var baseIsSet = require_baseIsSet(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  isSet_1 = isSet;
  return isSet_1;
}
var _baseClone;
var hasRequired_baseClone;
function require_baseClone() {
  if (hasRequired_baseClone) return _baseClone;
  hasRequired_baseClone = 1;
  var Stack = require_Stack(), arrayEach = require_arrayEach(), assignValue = require_assignValue(), baseAssign = require_baseAssign(), baseAssignIn = require_baseAssignIn(), cloneBuffer = require_cloneBuffer(), copyArray = require_copyArray(), copySymbols = require_copySymbols(), copySymbolsIn = require_copySymbolsIn(), getAllKeys = require_getAllKeys(), getAllKeysIn = require_getAllKeysIn(), getTag = require_getTag(), initCloneArray = require_initCloneArray(), initCloneByTag = require_initCloneByTag(), initCloneObject = require_initCloneObject(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isMap = requireIsMap(), isObject2 = requireIsObject(), isSet = requireIsSet(), keys2 = requireKeys(), keysIn = requireKeysIn();
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key2, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object ? customizer(value, key2, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key3) {
        result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key3) {
      if (props) {
        key3 = subValue;
        subValue = value[key3];
      }
      assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
    });
    return result;
  }
  _baseClone = baseClone;
  return _baseClone;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  var baseClone = require_baseClone();
  var CLONE_SYMBOLS_FLAG = 4;
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }
  clone_1 = clone;
  return clone_1;
}
var _baseRepeat;
var hasRequired_baseRepeat;
function require_baseRepeat() {
  if (hasRequired_baseRepeat) return _baseRepeat;
  hasRequired_baseRepeat = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var nativeFloor = Math.floor;
  function baseRepeat(string2, n) {
    var result = "";
    if (!string2 || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    do {
      if (n % 2) {
        result += string2;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string2 += string2;
      }
    } while (n);
    return result;
  }
  _baseRepeat = baseRepeat;
  return _baseRepeat;
}
var _baseSlice;
var hasRequired_baseSlice;
function require_baseSlice() {
  if (hasRequired_baseSlice) return _baseSlice;
  hasRequired_baseSlice = 1;
  function baseSlice2(array2, start, end) {
    var index2 = -1, length = array2.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index2 < length) {
      result[index2] = array2[index2 + start];
    }
    return result;
  }
  _baseSlice = baseSlice2;
  return _baseSlice;
}
var _castSlice;
var hasRequired_castSlice;
function require_castSlice() {
  if (hasRequired_castSlice) return _castSlice;
  hasRequired_castSlice = 1;
  var baseSlice2 = require_baseSlice();
  function castSlice(array2, start, end) {
    var length = array2.length;
    end = end === void 0 ? length : end;
    return !start && end >= length ? array2 : baseSlice2(array2, start, end);
  }
  _castSlice = castSlice;
  return _castSlice;
}
var _hasUnicode;
var hasRequired_hasUnicode;
function require_hasUnicode() {
  if (hasRequired_hasUnicode) return _hasUnicode;
  hasRequired_hasUnicode = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsZWJ = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
  function hasUnicode(string2) {
    return reHasUnicode.test(string2);
  }
  _hasUnicode = hasUnicode;
  return _hasUnicode;
}
var _asciiSize;
var hasRequired_asciiSize;
function require_asciiSize() {
  if (hasRequired_asciiSize) return _asciiSize;
  hasRequired_asciiSize = 1;
  var baseProperty = require_baseProperty();
  var asciiSize = baseProperty("length");
  _asciiSize = asciiSize;
  return _asciiSize;
}
var _unicodeSize;
var hasRequired_unicodeSize;
function require_unicodeSize() {
  if (hasRequired_unicodeSize) return _unicodeSize;
  hasRequired_unicodeSize = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  function unicodeSize(string2) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string2)) {
      ++result;
    }
    return result;
  }
  _unicodeSize = unicodeSize;
  return _unicodeSize;
}
var _stringSize;
var hasRequired_stringSize;
function require_stringSize() {
  if (hasRequired_stringSize) return _stringSize;
  hasRequired_stringSize = 1;
  var asciiSize = require_asciiSize(), hasUnicode = require_hasUnicode(), unicodeSize = require_unicodeSize();
  function stringSize(string2) {
    return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
  }
  _stringSize = stringSize;
  return _stringSize;
}
var _asciiToArray;
var hasRequired_asciiToArray;
function require_asciiToArray() {
  if (hasRequired_asciiToArray) return _asciiToArray;
  hasRequired_asciiToArray = 1;
  function asciiToArray(string2) {
    return string2.split("");
  }
  _asciiToArray = asciiToArray;
  return _asciiToArray;
}
var _unicodeToArray;
var hasRequired_unicodeToArray;
function require_unicodeToArray() {
  if (hasRequired_unicodeToArray) return _unicodeToArray;
  hasRequired_unicodeToArray = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  function unicodeToArray(string2) {
    return string2.match(reUnicode) || [];
  }
  _unicodeToArray = unicodeToArray;
  return _unicodeToArray;
}
var _stringToArray;
var hasRequired_stringToArray;
function require_stringToArray() {
  if (hasRequired_stringToArray) return _stringToArray;
  hasRequired_stringToArray = 1;
  var asciiToArray = require_asciiToArray(), hasUnicode = require_hasUnicode(), unicodeToArray = require_unicodeToArray();
  function stringToArray(string2) {
    return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
  }
  _stringToArray = stringToArray;
  return _stringToArray;
}
var _createPadding;
var hasRequired_createPadding;
function require_createPadding() {
  if (hasRequired_createPadding) return _createPadding;
  hasRequired_createPadding = 1;
  var baseRepeat = require_baseRepeat(), baseToString = require_baseToString(), castSlice = require_castSlice(), hasUnicode = require_hasUnicode(), stringSize = require_stringSize(), stringToArray = require_stringToArray();
  var nativeCeil = Math.ceil;
  function createPadding(length, chars) {
    chars = chars === void 0 ? " " : baseToString(chars);
    var charsLength = chars.length;
    if (charsLength < 2) {
      return charsLength ? baseRepeat(chars, length) : chars;
    }
    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
    return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
  }
  _createPadding = createPadding;
  return _createPadding;
}
var padEnd_1;
var hasRequiredPadEnd;
function requirePadEnd() {
  if (hasRequiredPadEnd) return padEnd_1;
  hasRequiredPadEnd = 1;
  var createPadding = require_createPadding(), stringSize = require_stringSize(), toInteger = requireToInteger(), toString2 = requireToString();
  function padEnd(string2, length, chars) {
    string2 = toString2(string2);
    length = toInteger(length);
    var strLength = length ? stringSize(string2) : 0;
    return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
  }
  padEnd_1 = padEnd;
  return padEnd_1;
}
var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex) return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array2, predicate, fromIndex, fromRight) {
    var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length) {
      if (predicate(array2[index2], index2, array2)) {
        return index2;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}
var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN) return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}
var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf) return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array2, value, fromIndex) {
    var index2 = fromIndex - 1, length = array2.length;
    while (++index2 < length) {
      if (array2[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}
var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf) return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array2, value, fromIndex) {
    return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}
var _charsEndIndex;
var hasRequired_charsEndIndex;
function require_charsEndIndex() {
  if (hasRequired_charsEndIndex) return _charsEndIndex;
  hasRequired_charsEndIndex = 1;
  var baseIndexOf = require_baseIndexOf();
  function charsEndIndex(strSymbols, chrSymbols) {
    var index2 = strSymbols.length;
    while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
    }
    return index2;
  }
  _charsEndIndex = charsEndIndex;
  return _charsEndIndex;
}
var trimEnd_1;
var hasRequiredTrimEnd;
function requireTrimEnd() {
  if (hasRequiredTrimEnd) return trimEnd_1;
  hasRequiredTrimEnd = 1;
  var baseToString = require_baseToString(), castSlice = require_castSlice(), charsEndIndex = require_charsEndIndex(), stringToArray = require_stringToArray(), toString2 = requireToString(), trimmedEndIndex = require_trimmedEndIndex();
  function trimEnd(string2, chars, guard) {
    string2 = toString2(string2);
    if (string2 && (guard || chars === void 0)) {
      return string2.slice(0, trimmedEndIndex(string2) + 1);
    }
    if (!string2 || !(chars = baseToString(chars))) {
      return string2;
    }
    var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
    return castSlice(strSymbols, 0, end).join("");
  }
  trimEnd_1 = trimEnd;
  return trimEnd_1;
}
var keypair = {};
var strkey = {};
var base32 = {};
var hasRequiredBase32;
function requireBase32() {
  if (hasRequiredBase32) return base32;
  hasRequiredBase32 = 1;
  (function(exports2) {
    var charmap = function(alphabet, mappings) {
      mappings || (mappings = {});
      alphabet.split("").forEach(function(c, i2) {
        if (!(c in mappings)) mappings[c] = i2;
      });
      return mappings;
    };
    var rfc4648 = {
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      charmap: {
        0: 14,
        1: 8
      }
    };
    rfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);
    var crockford = {
      alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
      charmap: {
        O: 0,
        I: 1,
        L: 1
      }
    };
    crockford.charmap = charmap(crockford.alphabet, crockford.charmap);
    var base32hex = {
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      charmap: {}
    };
    base32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);
    function Decoder(options2) {
      this.buf = [];
      this.shift = 8;
      this.carry = 0;
      if (options2) {
        switch (options2.type) {
          case "rfc4648":
            this.charmap = exports2.rfc4648.charmap;
            break;
          case "crockford":
            this.charmap = exports2.crockford.charmap;
            break;
          case "base32hex":
            this.charmap = exports2.base32hex.charmap;
            break;
          default:
            throw new Error("invalid type");
        }
        if (options2.charmap) this.charmap = options2.charmap;
      }
    }
    Decoder.prototype.charmap = rfc4648.charmap;
    Decoder.prototype.write = function(str) {
      var charmap2 = this.charmap;
      var buf = this.buf;
      var shift = this.shift;
      var carry = this.carry;
      str.toUpperCase().split("").forEach(function(char) {
        if (char == "=") return;
        var symbol = charmap2[char] & 255;
        shift -= 5;
        if (shift > 0) {
          carry |= symbol << shift;
        } else if (shift < 0) {
          buf.push(carry | symbol >> -shift);
          shift += 8;
          carry = symbol << shift & 255;
        } else {
          buf.push(carry | symbol);
          shift = 8;
          carry = 0;
        }
      });
      this.shift = shift;
      this.carry = carry;
      return this;
    };
    Decoder.prototype.finalize = function(str) {
      if (str) {
        this.write(str);
      }
      if (this.shift !== 8 && this.carry !== 0) {
        this.buf.push(this.carry);
        this.shift = 8;
        this.carry = 0;
      }
      return this.buf;
    };
    function Encoder(options2) {
      this.buf = "";
      this.shift = 3;
      this.carry = 0;
      if (options2) {
        switch (options2.type) {
          case "rfc4648":
            this.alphabet = exports2.rfc4648.alphabet;
            break;
          case "crockford":
            this.alphabet = exports2.crockford.alphabet;
            break;
          case "base32hex":
            this.alphabet = exports2.base32hex.alphabet;
            break;
          default:
            throw new Error("invalid type");
        }
        if (options2.alphabet) this.alphabet = options2.alphabet;
        else if (options2.lc) this.alphabet = this.alphabet.toLowerCase();
      }
    }
    Encoder.prototype.alphabet = rfc4648.alphabet;
    Encoder.prototype.write = function(buf) {
      var shift = this.shift;
      var carry = this.carry;
      var symbol;
      var byte;
      var i2;
      for (i2 = 0; i2 < buf.length; i2++) {
        byte = buf[i2];
        symbol = carry | byte >> shift;
        this.buf += this.alphabet[symbol & 31];
        if (shift > 5) {
          shift -= 5;
          symbol = byte >> shift;
          this.buf += this.alphabet[symbol & 31];
        }
        shift = 5 - shift;
        carry = byte << shift;
        shift = 8 - shift;
      }
      this.shift = shift;
      this.carry = carry;
      return this;
    };
    Encoder.prototype.finalize = function(buf) {
      if (buf) {
        this.write(buf);
      }
      if (this.shift !== 3) {
        this.buf += this.alphabet[this.carry & 31];
        this.shift = 3;
        this.carry = 0;
      }
      return this.buf;
    };
    exports2.encode = function(buf, options2) {
      return new Encoder(options2).finalize(buf);
    };
    exports2.decode = function(str, options2) {
      return new Decoder(options2).finalize(str);
    };
    exports2.Decoder = Decoder;
    exports2.Encoder = Encoder;
    exports2.charmap = charmap;
    exports2.crockford = crockford;
    exports2.rfc4648 = rfc4648;
    exports2.base32hex = base32hex;
  })(base32);
  return base32;
}
const createBuffer = Buffer$1.from && Buffer$1.alloc && Buffer$1.allocUnsafe && Buffer$1.allocUnsafeSlow ? Buffer$1.from : (
  // support for Node < 5.10
  (val) => new Buffer$1(val)
);
function defineCrc(model, calc) {
  const fn = (buf, previous) => calc(buf, previous) >>> 0;
  fn.signed = calc;
  fn.unsigned = fn;
  fn.model = model;
  return fn;
}
const crc1 = defineCrc("crc1", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = ~~previous;
  let accum = 0;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    accum += byte;
  }
  crc2 += accum % 256;
  return crc2 % 256;
});
let TABLE$8 = [
  0,
  7,
  14,
  9,
  28,
  27,
  18,
  21,
  56,
  63,
  54,
  49,
  36,
  35,
  42,
  45,
  112,
  119,
  126,
  121,
  108,
  107,
  98,
  101,
  72,
  79,
  70,
  65,
  84,
  83,
  90,
  93,
  224,
  231,
  238,
  233,
  252,
  251,
  242,
  245,
  216,
  223,
  214,
  209,
  196,
  195,
  202,
  205,
  144,
  151,
  158,
  153,
  140,
  139,
  130,
  133,
  168,
  175,
  166,
  161,
  180,
  179,
  186,
  189,
  199,
  192,
  201,
  206,
  219,
  220,
  213,
  210,
  255,
  248,
  241,
  246,
  227,
  228,
  237,
  234,
  183,
  176,
  185,
  190,
  171,
  172,
  165,
  162,
  143,
  136,
  129,
  134,
  147,
  148,
  157,
  154,
  39,
  32,
  41,
  46,
  59,
  60,
  53,
  50,
  31,
  24,
  17,
  22,
  3,
  4,
  13,
  10,
  87,
  80,
  89,
  94,
  75,
  76,
  69,
  66,
  111,
  104,
  97,
  102,
  115,
  116,
  125,
  122,
  137,
  142,
  135,
  128,
  149,
  146,
  155,
  156,
  177,
  182,
  191,
  184,
  173,
  170,
  163,
  164,
  249,
  254,
  247,
  240,
  229,
  226,
  235,
  236,
  193,
  198,
  207,
  200,
  221,
  218,
  211,
  212,
  105,
  110,
  103,
  96,
  117,
  114,
  123,
  124,
  81,
  86,
  95,
  88,
  77,
  74,
  67,
  68,
  25,
  30,
  23,
  16,
  5,
  2,
  11,
  12,
  33,
  38,
  47,
  40,
  61,
  58,
  51,
  52,
  78,
  73,
  64,
  71,
  82,
  85,
  92,
  91,
  118,
  113,
  120,
  127,
  106,
  109,
  100,
  99,
  62,
  57,
  48,
  55,
  34,
  37,
  44,
  43,
  6,
  1,
  8,
  15,
  26,
  29,
  20,
  19,
  174,
  169,
  160,
  167,
  178,
  181,
  188,
  187,
  150,
  145,
  152,
  159,
  138,
  141,
  132,
  131,
  222,
  217,
  208,
  215,
  194,
  197,
  204,
  203,
  230,
  225,
  232,
  239,
  250,
  253,
  244,
  243
];
if (typeof Int32Array !== "undefined") TABLE$8 = new Int32Array(TABLE$8);
const crc8 = defineCrc("crc-8", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = ~~previous;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = TABLE$8[(crc2 ^ byte) & 255] & 255;
  }
  return crc2;
});
let TABLE$7 = [
  0,
  94,
  188,
  226,
  97,
  63,
  221,
  131,
  194,
  156,
  126,
  32,
  163,
  253,
  31,
  65,
  157,
  195,
  33,
  127,
  252,
  162,
  64,
  30,
  95,
  1,
  227,
  189,
  62,
  96,
  130,
  220,
  35,
  125,
  159,
  193,
  66,
  28,
  254,
  160,
  225,
  191,
  93,
  3,
  128,
  222,
  60,
  98,
  190,
  224,
  2,
  92,
  223,
  129,
  99,
  61,
  124,
  34,
  192,
  158,
  29,
  67,
  161,
  255,
  70,
  24,
  250,
  164,
  39,
  121,
  155,
  197,
  132,
  218,
  56,
  102,
  229,
  187,
  89,
  7,
  219,
  133,
  103,
  57,
  186,
  228,
  6,
  88,
  25,
  71,
  165,
  251,
  120,
  38,
  196,
  154,
  101,
  59,
  217,
  135,
  4,
  90,
  184,
  230,
  167,
  249,
  27,
  69,
  198,
  152,
  122,
  36,
  248,
  166,
  68,
  26,
  153,
  199,
  37,
  123,
  58,
  100,
  134,
  216,
  91,
  5,
  231,
  185,
  140,
  210,
  48,
  110,
  237,
  179,
  81,
  15,
  78,
  16,
  242,
  172,
  47,
  113,
  147,
  205,
  17,
  79,
  173,
  243,
  112,
  46,
  204,
  146,
  211,
  141,
  111,
  49,
  178,
  236,
  14,
  80,
  175,
  241,
  19,
  77,
  206,
  144,
  114,
  44,
  109,
  51,
  209,
  143,
  12,
  82,
  176,
  238,
  50,
  108,
  142,
  208,
  83,
  13,
  239,
  177,
  240,
  174,
  76,
  18,
  145,
  207,
  45,
  115,
  202,
  148,
  118,
  40,
  171,
  245,
  23,
  73,
  8,
  86,
  180,
  234,
  105,
  55,
  213,
  139,
  87,
  9,
  235,
  181,
  54,
  104,
  138,
  212,
  149,
  203,
  41,
  119,
  244,
  170,
  72,
  22,
  233,
  183,
  85,
  11,
  136,
  214,
  52,
  106,
  43,
  117,
  151,
  201,
  74,
  20,
  246,
  168,
  116,
  42,
  200,
  150,
  21,
  75,
  169,
  247,
  182,
  232,
  10,
  84,
  215,
  137,
  107,
  53
];
if (typeof Int32Array !== "undefined") TABLE$7 = new Int32Array(TABLE$7);
const crc81wire = defineCrc("dallas-1-wire", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = ~~previous;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = TABLE$7[(crc2 ^ byte) & 255] & 255;
  }
  return crc2;
});
let TABLE$6 = [
  0,
  49345,
  49537,
  320,
  49921,
  960,
  640,
  49729,
  50689,
  1728,
  1920,
  51009,
  1280,
  50625,
  50305,
  1088,
  52225,
  3264,
  3456,
  52545,
  3840,
  53185,
  52865,
  3648,
  2560,
  51905,
  52097,
  2880,
  51457,
  2496,
  2176,
  51265,
  55297,
  6336,
  6528,
  55617,
  6912,
  56257,
  55937,
  6720,
  7680,
  57025,
  57217,
  8e3,
  56577,
  7616,
  7296,
  56385,
  5120,
  54465,
  54657,
  5440,
  55041,
  6080,
  5760,
  54849,
  53761,
  4800,
  4992,
  54081,
  4352,
  53697,
  53377,
  4160,
  61441,
  12480,
  12672,
  61761,
  13056,
  62401,
  62081,
  12864,
  13824,
  63169,
  63361,
  14144,
  62721,
  13760,
  13440,
  62529,
  15360,
  64705,
  64897,
  15680,
  65281,
  16320,
  16e3,
  65089,
  64001,
  15040,
  15232,
  64321,
  14592,
  63937,
  63617,
  14400,
  10240,
  59585,
  59777,
  10560,
  60161,
  11200,
  10880,
  59969,
  60929,
  11968,
  12160,
  61249,
  11520,
  60865,
  60545,
  11328,
  58369,
  9408,
  9600,
  58689,
  9984,
  59329,
  59009,
  9792,
  8704,
  58049,
  58241,
  9024,
  57601,
  8640,
  8320,
  57409,
  40961,
  24768,
  24960,
  41281,
  25344,
  41921,
  41601,
  25152,
  26112,
  42689,
  42881,
  26432,
  42241,
  26048,
  25728,
  42049,
  27648,
  44225,
  44417,
  27968,
  44801,
  28608,
  28288,
  44609,
  43521,
  27328,
  27520,
  43841,
  26880,
  43457,
  43137,
  26688,
  30720,
  47297,
  47489,
  31040,
  47873,
  31680,
  31360,
  47681,
  48641,
  32448,
  32640,
  48961,
  32e3,
  48577,
  48257,
  31808,
  46081,
  29888,
  30080,
  46401,
  30464,
  47041,
  46721,
  30272,
  29184,
  45761,
  45953,
  29504,
  45313,
  29120,
  28800,
  45121,
  20480,
  37057,
  37249,
  20800,
  37633,
  21440,
  21120,
  37441,
  38401,
  22208,
  22400,
  38721,
  21760,
  38337,
  38017,
  21568,
  39937,
  23744,
  23936,
  40257,
  24320,
  40897,
  40577,
  24128,
  23040,
  39617,
  39809,
  23360,
  39169,
  22976,
  22656,
  38977,
  34817,
  18624,
  18816,
  35137,
  19200,
  35777,
  35457,
  19008,
  19968,
  36545,
  36737,
  20288,
  36097,
  19904,
  19584,
  35905,
  17408,
  33985,
  34177,
  17728,
  34561,
  18368,
  18048,
  34369,
  33281,
  17088,
  17280,
  33601,
  16640,
  33217,
  32897,
  16448
];
if (typeof Int32Array !== "undefined") TABLE$6 = new Int32Array(TABLE$6);
const crc16 = defineCrc("crc-16", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = ~~previous;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$6[(crc2 ^ byte) & 255] ^ crc2 >> 8) & 65535;
  }
  return crc2;
});
let TABLE$5 = [
  0,
  4129,
  8258,
  12387,
  16516,
  20645,
  24774,
  28903,
  33032,
  37161,
  41290,
  45419,
  49548,
  53677,
  57806,
  61935,
  4657,
  528,
  12915,
  8786,
  21173,
  17044,
  29431,
  25302,
  37689,
  33560,
  45947,
  41818,
  54205,
  50076,
  62463,
  58334,
  9314,
  13379,
  1056,
  5121,
  25830,
  29895,
  17572,
  21637,
  42346,
  46411,
  34088,
  38153,
  58862,
  62927,
  50604,
  54669,
  13907,
  9842,
  5649,
  1584,
  30423,
  26358,
  22165,
  18100,
  46939,
  42874,
  38681,
  34616,
  63455,
  59390,
  55197,
  51132,
  18628,
  22757,
  26758,
  30887,
  2112,
  6241,
  10242,
  14371,
  51660,
  55789,
  59790,
  63919,
  35144,
  39273,
  43274,
  47403,
  23285,
  19156,
  31415,
  27286,
  6769,
  2640,
  14899,
  10770,
  56317,
  52188,
  64447,
  60318,
  39801,
  35672,
  47931,
  43802,
  27814,
  31879,
  19684,
  23749,
  11298,
  15363,
  3168,
  7233,
  60846,
  64911,
  52716,
  56781,
  44330,
  48395,
  36200,
  40265,
  32407,
  28342,
  24277,
  20212,
  15891,
  11826,
  7761,
  3696,
  65439,
  61374,
  57309,
  53244,
  48923,
  44858,
  40793,
  36728,
  37256,
  33193,
  45514,
  41451,
  53516,
  49453,
  61774,
  57711,
  4224,
  161,
  12482,
  8419,
  20484,
  16421,
  28742,
  24679,
  33721,
  37784,
  41979,
  46042,
  49981,
  54044,
  58239,
  62302,
  689,
  4752,
  8947,
  13010,
  16949,
  21012,
  25207,
  29270,
  46570,
  42443,
  38312,
  34185,
  62830,
  58703,
  54572,
  50445,
  13538,
  9411,
  5280,
  1153,
  29798,
  25671,
  21540,
  17413,
  42971,
  47098,
  34713,
  38840,
  59231,
  63358,
  50973,
  55100,
  9939,
  14066,
  1681,
  5808,
  26199,
  30326,
  17941,
  22068,
  55628,
  51565,
  63758,
  59695,
  39368,
  35305,
  47498,
  43435,
  22596,
  18533,
  30726,
  26663,
  6336,
  2273,
  14466,
  10403,
  52093,
  56156,
  60223,
  64286,
  35833,
  39896,
  43963,
  48026,
  19061,
  23124,
  27191,
  31254,
  2801,
  6864,
  10931,
  14994,
  64814,
  60687,
  56684,
  52557,
  48554,
  44427,
  40424,
  36297,
  31782,
  27655,
  23652,
  19525,
  15522,
  11395,
  7392,
  3265,
  61215,
  65342,
  53085,
  57212,
  44955,
  49082,
  36825,
  40952,
  28183,
  32310,
  20053,
  24180,
  11923,
  16050,
  3793,
  7920
];
if (typeof Int32Array !== "undefined") TABLE$5 = new Int32Array(TABLE$5);
const crc16ccitt = defineCrc("ccitt", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 65535;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$5[(crc2 >> 8 ^ byte) & 255] ^ crc2 << 8) & 65535;
  }
  return crc2;
});
let TABLE$4 = [
  0,
  49345,
  49537,
  320,
  49921,
  960,
  640,
  49729,
  50689,
  1728,
  1920,
  51009,
  1280,
  50625,
  50305,
  1088,
  52225,
  3264,
  3456,
  52545,
  3840,
  53185,
  52865,
  3648,
  2560,
  51905,
  52097,
  2880,
  51457,
  2496,
  2176,
  51265,
  55297,
  6336,
  6528,
  55617,
  6912,
  56257,
  55937,
  6720,
  7680,
  57025,
  57217,
  8e3,
  56577,
  7616,
  7296,
  56385,
  5120,
  54465,
  54657,
  5440,
  55041,
  6080,
  5760,
  54849,
  53761,
  4800,
  4992,
  54081,
  4352,
  53697,
  53377,
  4160,
  61441,
  12480,
  12672,
  61761,
  13056,
  62401,
  62081,
  12864,
  13824,
  63169,
  63361,
  14144,
  62721,
  13760,
  13440,
  62529,
  15360,
  64705,
  64897,
  15680,
  65281,
  16320,
  16e3,
  65089,
  64001,
  15040,
  15232,
  64321,
  14592,
  63937,
  63617,
  14400,
  10240,
  59585,
  59777,
  10560,
  60161,
  11200,
  10880,
  59969,
  60929,
  11968,
  12160,
  61249,
  11520,
  60865,
  60545,
  11328,
  58369,
  9408,
  9600,
  58689,
  9984,
  59329,
  59009,
  9792,
  8704,
  58049,
  58241,
  9024,
  57601,
  8640,
  8320,
  57409,
  40961,
  24768,
  24960,
  41281,
  25344,
  41921,
  41601,
  25152,
  26112,
  42689,
  42881,
  26432,
  42241,
  26048,
  25728,
  42049,
  27648,
  44225,
  44417,
  27968,
  44801,
  28608,
  28288,
  44609,
  43521,
  27328,
  27520,
  43841,
  26880,
  43457,
  43137,
  26688,
  30720,
  47297,
  47489,
  31040,
  47873,
  31680,
  31360,
  47681,
  48641,
  32448,
  32640,
  48961,
  32e3,
  48577,
  48257,
  31808,
  46081,
  29888,
  30080,
  46401,
  30464,
  47041,
  46721,
  30272,
  29184,
  45761,
  45953,
  29504,
  45313,
  29120,
  28800,
  45121,
  20480,
  37057,
  37249,
  20800,
  37633,
  21440,
  21120,
  37441,
  38401,
  22208,
  22400,
  38721,
  21760,
  38337,
  38017,
  21568,
  39937,
  23744,
  23936,
  40257,
  24320,
  40897,
  40577,
  24128,
  23040,
  39617,
  39809,
  23360,
  39169,
  22976,
  22656,
  38977,
  34817,
  18624,
  18816,
  35137,
  19200,
  35777,
  35457,
  19008,
  19968,
  36545,
  36737,
  20288,
  36097,
  19904,
  19584,
  35905,
  17408,
  33985,
  34177,
  17728,
  34561,
  18368,
  18048,
  34369,
  33281,
  17088,
  17280,
  33601,
  16640,
  33217,
  32897,
  16448
];
if (typeof Int32Array !== "undefined") TABLE$4 = new Int32Array(TABLE$4);
const crc16modbus = defineCrc("crc-16-modbus", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 65535;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$4[(crc2 ^ byte) & 255] ^ crc2 >> 8) & 65535;
  }
  return crc2;
});
const crc16xmodem = defineCrc("xmodem", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 0;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    let code2 = crc2 >>> 8 & 255;
    code2 ^= byte & 255;
    code2 ^= code2 >>> 4;
    crc2 = crc2 << 8 & 65535;
    crc2 ^= code2;
    code2 = code2 << 5 & 65535;
    crc2 ^= code2;
    code2 = code2 << 7 & 65535;
    crc2 ^= code2;
  }
  return crc2;
});
let TABLE$3 = [
  0,
  4489,
  8978,
  12955,
  17956,
  22445,
  25910,
  29887,
  35912,
  40385,
  44890,
  48851,
  51820,
  56293,
  59774,
  63735,
  4225,
  264,
  13203,
  8730,
  22181,
  18220,
  30135,
  25662,
  40137,
  36160,
  49115,
  44626,
  56045,
  52068,
  63999,
  59510,
  8450,
  12427,
  528,
  5017,
  26406,
  30383,
  17460,
  21949,
  44362,
  48323,
  36440,
  40913,
  60270,
  64231,
  51324,
  55797,
  12675,
  8202,
  4753,
  792,
  30631,
  26158,
  21685,
  17724,
  48587,
  44098,
  40665,
  36688,
  64495,
  60006,
  55549,
  51572,
  16900,
  21389,
  24854,
  28831,
  1056,
  5545,
  10034,
  14011,
  52812,
  57285,
  60766,
  64727,
  34920,
  39393,
  43898,
  47859,
  21125,
  17164,
  29079,
  24606,
  5281,
  1320,
  14259,
  9786,
  57037,
  53060,
  64991,
  60502,
  39145,
  35168,
  48123,
  43634,
  25350,
  29327,
  16404,
  20893,
  9506,
  13483,
  1584,
  6073,
  61262,
  65223,
  52316,
  56789,
  43370,
  47331,
  35448,
  39921,
  29575,
  25102,
  20629,
  16668,
  13731,
  9258,
  5809,
  1848,
  65487,
  60998,
  56541,
  52564,
  47595,
  43106,
  39673,
  35696,
  33800,
  38273,
  42778,
  46739,
  49708,
  54181,
  57662,
  61623,
  2112,
  6601,
  11090,
  15067,
  20068,
  24557,
  28022,
  31999,
  38025,
  34048,
  47003,
  42514,
  53933,
  49956,
  61887,
  57398,
  6337,
  2376,
  15315,
  10842,
  24293,
  20332,
  32247,
  27774,
  42250,
  46211,
  34328,
  38801,
  58158,
  62119,
  49212,
  53685,
  10562,
  14539,
  2640,
  7129,
  28518,
  32495,
  19572,
  24061,
  46475,
  41986,
  38553,
  34576,
  62383,
  57894,
  53437,
  49460,
  14787,
  10314,
  6865,
  2904,
  32743,
  28270,
  23797,
  19836,
  50700,
  55173,
  58654,
  62615,
  32808,
  37281,
  41786,
  45747,
  19012,
  23501,
  26966,
  30943,
  3168,
  7657,
  12146,
  16123,
  54925,
  50948,
  62879,
  58390,
  37033,
  33056,
  46011,
  41522,
  23237,
  19276,
  31191,
  26718,
  7393,
  3432,
  16371,
  11898,
  59150,
  63111,
  50204,
  54677,
  41258,
  45219,
  33336,
  37809,
  27462,
  31439,
  18516,
  23005,
  11618,
  15595,
  3696,
  8185,
  63375,
  58886,
  54429,
  50452,
  45483,
  40994,
  37561,
  33584,
  31687,
  27214,
  22741,
  18780,
  15843,
  11370,
  7921,
  3960
];
if (typeof Int32Array !== "undefined") TABLE$3 = new Int32Array(TABLE$3);
const crc16kermit = defineCrc("kermit", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 0;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$3[(crc2 ^ byte) & 255] ^ crc2 >> 8) & 65535;
  }
  return crc2;
});
let TABLE$2 = [
  0,
  8801531,
  9098509,
  825846,
  9692897,
  1419802,
  1651692,
  10452759,
  10584377,
  2608578,
  2839604,
  11344079,
  3303384,
  11807523,
  12104405,
  4128302,
  12930697,
  4391538,
  5217156,
  13227903,
  5679208,
  13690003,
  14450021,
  5910942,
  6606768,
  14844747,
  15604413,
  6837830,
  16197969,
  7431594,
  8256604,
  16494759,
  840169,
  9084178,
  8783076,
  18463,
  10434312,
  1670131,
  1434117,
  9678590,
  11358416,
  2825259,
  2590173,
  10602790,
  4109873,
  12122826,
  11821884,
  3289031,
  13213536,
  5231515,
  4409965,
  12912278,
  5929345,
  14431610,
  13675660,
  5693559,
  6823513,
  15618722,
  14863188,
  6588335,
  16513208,
  8238147,
  7417269,
  16212302,
  1680338,
  10481449,
  9664223,
  1391140,
  9061683,
  788936,
  36926,
  8838341,
  12067563,
  4091408,
  3340262,
  11844381,
  2868234,
  11372785,
  10555655,
  2579964,
  14478683,
  5939616,
  5650518,
  13661357,
  5180346,
  13190977,
  12967607,
  4428364,
  8219746,
  16457881,
  16234863,
  7468436,
  15633027,
  6866552,
  6578062,
  14816117,
  1405499,
  9649856,
  10463030,
  1698765,
  8819930,
  55329,
  803287,
  9047340,
  11858690,
  3325945,
  4072975,
  12086004,
  2561507,
  10574104,
  11387118,
  2853909,
  13647026,
  5664841,
  5958079,
  14460228,
  4446803,
  12949160,
  13176670,
  5194661,
  7454091,
  16249200,
  16476294,
  8201341,
  14834538,
  6559633,
  6852199,
  15647388,
  3360676,
  11864927,
  12161705,
  4185682,
  10527045,
  2551230,
  2782280,
  11286707,
  9619101,
  1346150,
  1577872,
  10379115,
  73852,
  8875143,
  9172337,
  899466,
  16124205,
  7357910,
  8182816,
  16421083,
  6680524,
  14918455,
  15678145,
  6911546,
  5736468,
  13747439,
  14507289,
  5968354,
  12873461,
  4334094,
  5159928,
  13170435,
  4167245,
  12180150,
  11879232,
  3346363,
  11301036,
  2767959,
  2532769,
  10545498,
  10360692,
  1596303,
  1360505,
  9604738,
  913813,
  9157998,
  8856728,
  92259,
  16439492,
  8164415,
  7343561,
  16138546,
  6897189,
  15692510,
  14936872,
  6662099,
  5986813,
  14488838,
  13733104,
  5750795,
  13156124,
  5174247,
  4352529,
  12855018,
  2810998,
  11315341,
  10498427,
  2522496,
  12124823,
  4148844,
  3397530,
  11901793,
  9135439,
  862644,
  110658,
  8912057,
  1606574,
  10407765,
  9590435,
  1317464,
  15706879,
  6940164,
  6651890,
  14889737,
  8145950,
  16384229,
  16161043,
  7394792,
  5123014,
  13133629,
  12910283,
  4370992,
  14535975,
  5997020,
  5707818,
  13718737,
  2504095,
  10516836,
  11329682,
  2796649,
  11916158,
  3383173,
  4130419,
  12143240,
  8893606,
  129117,
  876971,
  9121104,
  1331783,
  9576124,
  10389322,
  1625009,
  14908182,
  6633453,
  6925851,
  15721184,
  7380471,
  16175372,
  16402682,
  8127489,
  4389423,
  12891860,
  13119266,
  5137369,
  13704398,
  5722165,
  6015427,
  14517560
];
if (typeof Int32Array !== "undefined") TABLE$2 = new Int32Array(TABLE$2);
const crc24 = defineCrc("crc-24", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = typeof previous !== "undefined" ? ~~previous : 11994318;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = (TABLE$2[(crc2 >> 16 ^ byte) & 255] ^ crc2 << 8) & 16777215;
  }
  return crc2;
});
let TABLE$1 = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") TABLE$1 = new Int32Array(TABLE$1);
const crc32 = defineCrc("crc-32", function(buf, previous) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = previous === 0 ? 0 : ~~previous ^ -1;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = TABLE$1[(crc2 ^ byte) & 255] ^ crc2 >>> 8;
  }
  return crc2 ^ -1;
});
let TABLE = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") TABLE = new Int32Array(TABLE);
const crcjam = defineCrc("jam", function(buf, previous = -1) {
  if (!Buffer$1.isBuffer(buf)) buf = createBuffer(buf);
  let crc2 = previous === 0 ? 0 : ~~previous;
  for (let index2 = 0; index2 < buf.length; index2++) {
    const byte = buf[index2];
    crc2 = TABLE[(crc2 ^ byte) & 255] ^ crc2 >>> 8;
  }
  return crc2;
});
const index = {
  crc1,
  crc8,
  crc81wire,
  crc16,
  crc16ccitt,
  crc16modbus,
  crc16xmodem,
  crc16kermit,
  crc24,
  crc32,
  crcjam
};
const crc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  crc1,
  crc16,
  crc16ccitt,
  crc16kermit,
  crc16modbus,
  crc16xmodem,
  crc24,
  crc32,
  crc8,
  crc81wire,
  crcjam,
  default: index
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(crc);
var checksum = {};
var hasRequiredChecksum;
function requireChecksum() {
  if (hasRequiredChecksum) return checksum;
  hasRequiredChecksum = 1;
  Object.defineProperty(checksum, "__esModule", {
    value: true
  });
  checksum.verifyChecksum = verifyChecksum;
  function verifyChecksum(expected, actual) {
    if (expected.length !== actual.length) {
      return false;
    }
    if (expected.length === 0) {
      return true;
    }
    for (var i2 = 0; i2 < expected.length; i2 += 1) {
      if (expected[i2] !== actual[i2]) {
        return false;
      }
    }
    return true;
  }
  return checksum;
}
var hasRequiredStrkey;
function requireStrkey() {
  if (hasRequiredStrkey) return strkey;
  hasRequiredStrkey = 1;
  Object.defineProperty(strkey, "__esModule", {
    value: true
  });
  strkey.StrKey = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  strkey.decodeCheck = decodeCheck;
  strkey.encodeCheck = encodeCheck;
  var _base = requireBase32();
  var _base2 = _interopRequireDefault(_base);
  var _crc = require$$1$1;
  var _crc2 = _interopRequireDefault(_crc);
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _isNull = requireIsNull();
  var _isNull2 = _interopRequireDefault(_isNull);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _checksum = requireChecksum();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var versionBytes = {
    ed25519PublicKey: 6 << 3,
    // G (when encoded in base32)
    ed25519SecretSeed: 18 << 3,
    // S
    med25519PublicKey: 12 << 3,
    // M
    preAuthTx: 19 << 3,
    // T
    sha256Hash: 23 << 3
    // X
  };
  strkey.StrKey = function() {
    function StrKey() {
      _classCallCheck2(this, StrKey);
    }
    _createClass2(StrKey, null, [{
      key: "encodeEd25519PublicKey",
      /**
       * Encodes `data` to strkey ed25519 public key.
       *
       * @param   {Buffer} data   raw data to encode
       * @returns {string}        "G..." representation of the key
       */
      value: function encodeEd25519PublicKey(data) {
        return encodeCheck("ed25519PublicKey", data);
      }
      /**
       * Decodes strkey ed25519 public key to raw data.
       *
       * If the parameter is a muxed account key ("M..."), this will only encode it
       * as a basic Ed25519 key (as if in "G..." format).
       *
       * @param   {string} data   "G..." (or "M...") key representation to decode
       * @returns {Buffer}        raw key
       */
    }, {
      key: "decodeEd25519PublicKey",
      value: function decodeEd25519PublicKey(data) {
        return decodeCheck("ed25519PublicKey", data);
      }
      /**
       * Returns true if the given Stellar public key is a valid ed25519 public key.
       * @param {string} publicKey public key to check
       * @returns {boolean}
       */
    }, {
      key: "isValidEd25519PublicKey",
      value: function isValidEd25519PublicKey(publicKey) {
        return isValid("ed25519PublicKey", publicKey);
      }
      /**
       * Encodes data to strkey ed25519 seed.
       * @param {Buffer} data data to encode
       * @returns {string}
       */
    }, {
      key: "encodeEd25519SecretSeed",
      value: function encodeEd25519SecretSeed(data) {
        return encodeCheck("ed25519SecretSeed", data);
      }
      /**
       * Decodes strkey ed25519 seed to raw data.
       * @param {string} data data to decode
       * @returns {Buffer}
       */
    }, {
      key: "decodeEd25519SecretSeed",
      value: function decodeEd25519SecretSeed(data) {
        return decodeCheck("ed25519SecretSeed", data);
      }
      /**
       * Returns true if the given Stellar secret key is a valid ed25519 secret seed.
       * @param {string} seed seed to check
       * @returns {boolean}
       */
    }, {
      key: "isValidEd25519SecretSeed",
      value: function isValidEd25519SecretSeed(seed) {
        return isValid("ed25519SecretSeed", seed);
      }
      /**
       * Encodes data to strkey med25519 public key.
       * @param {Buffer} data data to encode
       * @returns {string}
       */
    }, {
      key: "encodeMed25519PublicKey",
      value: function encodeMed25519PublicKey(data) {
        return encodeCheck("med25519PublicKey", data);
      }
      /**
       * Decodes strkey med25519 public key to raw data.
       * @param {string} data data to decode
       * @returns {Buffer}
       */
    }, {
      key: "decodeMed25519PublicKey",
      value: function decodeMed25519PublicKey(data) {
        return decodeCheck("med25519PublicKey", data);
      }
      /**
       * Returns true if the given Stellar public key is a valid med25519 public key.
       * @param {string} publicKey public key to check
       * @returns {boolean}
       */
    }, {
      key: "isValidMed25519PublicKey",
      value: function isValidMed25519PublicKey(publicKey) {
        return isValid("med25519PublicKey", publicKey);
      }
      /**
       * Encodes data to strkey preAuthTx.
       * @param {Buffer} data data to encode
       * @returns {string}
       */
    }, {
      key: "encodePreAuthTx",
      value: function encodePreAuthTx(data) {
        return encodeCheck("preAuthTx", data);
      }
      /**
       * Decodes strkey PreAuthTx to raw data.
       * @param {string} data data to decode
       * @returns {Buffer}
       */
    }, {
      key: "decodePreAuthTx",
      value: function decodePreAuthTx(data) {
        return decodeCheck("preAuthTx", data);
      }
      /**
       * Encodes data to strkey sha256 hash.
       * @param {Buffer} data data to encode
       * @returns {string}
       */
    }, {
      key: "encodeSha256Hash",
      value: function encodeSha256Hash(data) {
        return encodeCheck("sha256Hash", data);
      }
      /**
       * Decodes strkey sha256 hash to raw data.
       * @param {string} data data to decode
       * @returns {Buffer}
       */
    }, {
      key: "decodeSha256Hash",
      value: function decodeSha256Hash(data) {
        return decodeCheck("sha256Hash", data);
      }
    }]);
    return StrKey;
  }();
  function isValid(versionByteName, encoded) {
    if (encoded && encoded.length !== 56 && encoded.length !== 69) {
      return false;
    }
    try {
      var decoded = decodeCheck(versionByteName, encoded);
      if (decoded.length !== 32 && decoded.length !== 40) {
        return false;
      }
    } catch (err) {
      return false;
    }
    return true;
  }
  function decodeCheck(versionByteName, encoded) {
    if (!(0, _isString2.default)(encoded)) {
      throw new TypeError("encoded argument must be of type String");
    }
    var decoded = _base2.default.decode(encoded);
    var versionByte = decoded[0];
    var payload = decoded.slice(0, -2);
    var data = payload.slice(1);
    var checksum2 = decoded.slice(-2);
    if (encoded !== _base2.default.encode(decoded)) {
      throw new Error("invalid encoded string");
    }
    var expectedVersion = versionBytes[versionByteName];
    if ((0, _isUndefined2.default)(expectedVersion)) {
      throw new Error(versionByteName + " is not a valid version byte name. " + ("Expected one of " + Object.keys(versionBytes).join(", ")));
    }
    if (versionByte !== expectedVersion) {
      throw new Error("invalid version byte. expected " + expectedVersion + ", got " + versionByte);
    }
    var expectedChecksum = calculateChecksum(payload);
    if (!(0, _checksum.verifyChecksum)(expectedChecksum, checksum2)) {
      throw new Error("invalid checksum");
    }
    return Buffer.from(data);
  }
  function encodeCheck(versionByteName, data) {
    if ((0, _isNull2.default)(data) || (0, _isUndefined2.default)(data)) {
      throw new Error("cannot encode null data");
    }
    var versionByte = versionBytes[versionByteName];
    if ((0, _isUndefined2.default)(versionByte)) {
      throw new Error(versionByteName + " is not a valid version byte name. " + ("Expected one of " + Object.keys(versionBytes).join(", ")));
    }
    data = Buffer.from(data);
    var versionBuffer = Buffer.from([versionByte]);
    var payload = Buffer.concat([versionBuffer, data]);
    var checksum2 = calculateChecksum(payload);
    var unencoded = Buffer.concat([payload, checksum2]);
    return _base2.default.encode(unencoded);
  }
  function calculateChecksum(payload) {
    var checksum2 = Buffer.alloc(2);
    checksum2.writeUInt16LE(_crc2.default.crc16xmodem(payload), 0);
    return checksum2;
  }
  return strkey;
}
var hasRequiredKeypair;
function requireKeypair() {
  if (hasRequiredKeypair) return keypair;
  hasRequiredKeypair = 1;
  Object.defineProperty(keypair, "__esModule", {
    value: true
  });
  keypair.Keypair = void 0;
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _tweetnacl = requireNaclFast();
  var _tweetnacl2 = _interopRequireDefault(_tweetnacl);
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _signing = requireSigning();
  var _strkey = requireStrkey();
  var _hashing = requireHashing();
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  keypair.Keypair = function() {
    function Keypair(keys2) {
      _classCallCheck2(this, Keypair);
      if (keys2.type !== "ed25519") {
        throw new Error("Invalid keys type");
      }
      this.type = keys2.type;
      if (keys2.secretKey) {
        keys2.secretKey = Buffer.from(keys2.secretKey);
        if (keys2.secretKey.length !== 32) {
          throw new Error("secretKey length is invalid");
        }
        this._secretSeed = keys2.secretKey;
        this._publicKey = (0, _signing.generate)(keys2.secretKey);
        this._secretKey = Buffer.concat([keys2.secretKey, this._publicKey]);
        if (keys2.publicKey && !this._publicKey.equals(Buffer.from(keys2.publicKey))) {
          throw new Error("secretKey does not match publicKey");
        }
      } else {
        this._publicKey = Buffer.from(keys2.publicKey);
        if (this._publicKey.length !== 32) {
          throw new Error("publicKey length is invalid");
        }
      }
    }
    _createClass2(Keypair, [{
      key: "xdrAccountId",
      value: function xdrAccountId() {
        return new _stellarXdr_generated2.default.AccountId.publicKeyTypeEd25519(this._publicKey);
      }
    }, {
      key: "xdrPublicKey",
      value: function xdrPublicKey() {
        return new _stellarXdr_generated2.default.PublicKey.publicKeyTypeEd25519(this._publicKey);
      }
      /**
       * Creates a {@link xdr.MuxedAccount} object from the public key.
       *
       * You will get a different type of muxed account depending on whether or not
       * you pass an ID.
       *
       * @param  {string} [id] - stringified integer indicating the underlying muxed
       *     ID of the new account object
       *
       * @return {xdr.MuxedAccount}
       */
    }, {
      key: "xdrMuxedAccount",
      value: function xdrMuxedAccount(id) {
        if (!(0, _isUndefined2.default)(id)) {
          if (!(0, _isString2.default)(id)) {
            throw new TypeError("expected string for ID, got " + (typeof id === "undefined" ? "undefined" : _typeof2(id)));
          }
          return _stellarXdr_generated2.default.MuxedAccount.keyTypeMuxedEd25519(new _stellarXdr_generated2.default.MuxedAccountMed25519({
            id: _stellarXdr_generated2.default.Uint64.fromString(id),
            ed25519: this._publicKey
          }));
        }
        return new _stellarXdr_generated2.default.MuxedAccount.keyTypeEd25519(this._publicKey);
      }
      /**
       * Returns raw public key
       * @returns {Buffer}
       */
    }, {
      key: "rawPublicKey",
      value: function rawPublicKey() {
        return this._publicKey;
      }
    }, {
      key: "signatureHint",
      value: function signatureHint() {
        var a = this.xdrAccountId().toXDR();
        return a.slice(a.length - 4);
      }
      /**
       * Returns public key associated with this `Keypair` object.
       * @returns {string}
       */
    }, {
      key: "publicKey",
      value: function publicKey() {
        return _strkey.StrKey.encodeEd25519PublicKey(this._publicKey);
      }
      /**
       * Returns secret key associated with this `Keypair` object
       * @returns {string}
       */
    }, {
      key: "secret",
      value: function secret() {
        if (!this._secretSeed) {
          throw new Error("no secret key available");
        }
        if (this.type === "ed25519") {
          return _strkey.StrKey.encodeEd25519SecretSeed(this._secretSeed);
        }
        throw new Error("Invalid Keypair type");
      }
      /**
       * Returns raw secret key.
       * @returns {Buffer}
       */
    }, {
      key: "rawSecretKey",
      value: function rawSecretKey() {
        return this._secretSeed;
      }
      /**
       * Returns `true` if this `Keypair` object contains secret key and can sign.
       * @returns {boolean}
       */
    }, {
      key: "canSign",
      value: function canSign() {
        return !!this._secretKey;
      }
      /**
       * Signs data.
       * @param {Buffer} data Data to sign
       * @returns {Buffer}
       */
    }, {
      key: "sign",
      value: function sign2(data) {
        if (!this.canSign()) {
          throw new Error("cannot sign: no secret key available");
        }
        return (0, _signing.sign)(data, this._secretKey);
      }
      /**
       * Verifies if `signature` for `data` is valid.
       * @param {Buffer} data Signed data
       * @param {Buffer} signature Signature
       * @returns {boolean}
       */
    }, {
      key: "verify",
      value: function verify(data, signature2) {
        return (0, _signing.verify)(data, signature2, this._publicKey);
      }
    }, {
      key: "signDecorated",
      value: function signDecorated(data) {
        var signature2 = this.sign(data);
        var hint = this.signatureHint();
        return new _stellarXdr_generated2.default.DecoratedSignature({ hint, signature: signature2 });
      }
    }], [{
      key: "fromSecret",
      value: function fromSecret(secret) {
        var rawSecret = _strkey.StrKey.decodeEd25519SecretSeed(secret);
        return this.fromRawEd25519Seed(rawSecret);
      }
      /**
       * Creates a new `Keypair` object from ed25519 secret key seed raw bytes.
       *
       * @param {Buffer} rawSeed Raw 32-byte ed25519 secret key seed
       * @returns {Keypair}
       */
    }, {
      key: "fromRawEd25519Seed",
      value: function fromRawEd25519Seed(rawSeed) {
        return new this({ type: "ed25519", secretKey: rawSeed });
      }
      /**
       * Returns `Keypair` object representing network master key.
       * @param {string} networkPassphrase passphrase of the target stellar network (e.g. "Public Global Stellar Network ; September 2015").
       * @returns {Keypair}
       */
    }, {
      key: "master",
      value: function master2(networkPassphrase) {
        if (!networkPassphrase) {
          throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
        }
        return this.fromRawEd25519Seed((0, _hashing.hash)(networkPassphrase));
      }
      /**
       * Creates a new `Keypair` object from public key.
       * @param {string} publicKey public key (ex. `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`)
       * @returns {Keypair}
       */
    }, {
      key: "fromPublicKey",
      value: function fromPublicKey(publicKey) {
        publicKey = _strkey.StrKey.decodeEd25519PublicKey(publicKey);
        if (publicKey.length !== 32) {
          throw new Error("Invalid Stellar public key");
        }
        return new this({ type: "ed25519", publicKey });
      }
      /**
       * Create a random `Keypair` object.
       * @returns {Keypair}
       */
    }, {
      key: "random",
      value: function random() {
        var secret = _tweetnacl2.default.randomBytes(32);
        return this.fromRawEd25519Seed(secret);
      }
    }]);
    return Keypair;
  }();
  return keypair;
}
var hasRequiredAsset;
function requireAsset() {
  if (hasRequiredAsset) return asset;
  hasRequiredAsset = 1;
  Object.defineProperty(asset, "__esModule", {
    value: true
  });
  asset.Asset = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _clone = requireClone();
  var _clone2 = _interopRequireDefault(_clone);
  var _padEnd = requirePadEnd();
  var _padEnd2 = _interopRequireDefault(_padEnd);
  var _trimEnd = requireTrimEnd();
  var _trimEnd2 = _interopRequireDefault(_trimEnd);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _keypair = requireKeypair();
  var _strkey = requireStrkey();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  asset.Asset = function() {
    function Asset(code2, issuer) {
      _classCallCheck2(this, Asset);
      if (!/^[a-zA-Z0-9]{1,12}$/.test(code2)) {
        throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
      }
      if (String(code2).toLowerCase() !== "xlm" && !issuer) {
        throw new Error("Issuer cannot be null");
      }
      if (issuer && !_strkey.StrKey.isValidEd25519PublicKey(issuer)) {
        throw new Error("Issuer is invalid");
      }
      this.code = code2;
      this.issuer = issuer;
    }
    _createClass2(Asset, [{
      key: "toXDRObject",
      /**
       * Returns the xdr.Asset object for this asset.
       * @returns {xdr.Asset} XDR asset object
       */
      value: function toXDRObject() {
        return this._toXDRObject(_stellarXdr_generated2.default.Asset);
      }
      /**
       * Returns the xdr.ChangeTrustAsset object for this asset.
       * @returns {xdr.ChangeTrustAsset} XDR asset object
       */
    }, {
      key: "toChangeTrustXDRObject",
      value: function toChangeTrustXDRObject() {
        return this._toXDRObject(_stellarXdr_generated2.default.ChangeTrustAsset);
      }
      /**
       * Returns the xdr.TrustLineAsset object for this asset.
       * @returns {xdr.TrustLineAsset} XDR asset object
       */
    }, {
      key: "toTrustLineXDRObject",
      value: function toTrustLineXDRObject() {
        return this._toXDRObject(_stellarXdr_generated2.default.TrustLineAsset);
      }
      /**
       * Returns the xdr object for this asset.
       * @param {xdr.Asset | xdr.ChangeTrustAsset} xdrAsset - The asset xdr object.
       * @returns {xdr.Asset | xdr.ChangeTrustAsset | xdr.TrustLineAsset} XDR Asset object
       */
    }, {
      key: "_toXDRObject",
      value: function _toXDRObject() {
        var xdrAsset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _stellarXdr_generated2.default.Asset;
        if (this.isNative()) {
          return xdrAsset.assetTypeNative();
        }
        var xdrType = void 0;
        var xdrTypeString = void 0;
        if (this.code.length <= 4) {
          xdrType = _stellarXdr_generated2.default.AlphaNum4;
          xdrTypeString = "assetTypeCreditAlphanum4";
        } else {
          xdrType = _stellarXdr_generated2.default.AlphaNum12;
          xdrTypeString = "assetTypeCreditAlphanum12";
        }
        var padLength = this.code.length <= 4 ? 4 : 12;
        var paddedCode = (0, _padEnd2.default)(this.code, padLength, "\0");
        var assetType = new xdrType({
          assetCode: paddedCode,
          issuer: _keypair.Keypair.fromPublicKey(this.issuer).xdrAccountId()
        });
        return new xdrAsset(xdrTypeString, assetType);
      }
      /**
       * @returns {string} Asset code
       */
    }, {
      key: "getCode",
      value: function getCode() {
        return (0, _clone2.default)(this.code);
      }
      /**
       * @returns {string} Asset issuer
       */
    }, {
      key: "getIssuer",
      value: function getIssuer() {
        return (0, _clone2.default)(this.issuer);
      }
      /**
       * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
       * @returns {string} Asset type. Can be one of following types:
       *
       * * `native`
       * * `credit_alphanum4`
       * * `credit_alphanum12`
       */
    }, {
      key: "getAssetType",
      value: function getAssetType() {
        if (this.isNative()) {
          return "native";
        }
        if (this.code.length >= 1 && this.code.length <= 4) {
          return "credit_alphanum4";
        }
        if (this.code.length >= 5 && this.code.length <= 12) {
          return "credit_alphanum12";
        }
        return null;
      }
      /**
       * @returns {boolean}  true if this asset object is the native asset.
       */
    }, {
      key: "isNative",
      value: function isNative() {
        return !this.issuer;
      }
      /**
       * @param {Asset} asset Asset to compare
       * @returns {boolean} true if this asset equals the given asset.
       */
    }, {
      key: "equals",
      value: function equals(asset2) {
        return this.code === asset2.getCode() && this.issuer === asset2.getIssuer();
      }
    }, {
      key: "toString",
      value: function toString2() {
        if (this.isNative()) {
          return "native";
        }
        return this.getCode() + ":" + this.getIssuer();
      }
      /**
       * Compares if assetA < assetB according with the criteria:
       * 1. First compare the type (eg. native before alphanum4 before alphanum12).
       * 2. If the types are equal, compare the assets codes.
       * 3. If the asset codes are equal, compare the issuers.
       *
       * @static
       * @param {Asset} assetA - The first asset in the lexicographic order.
       * @param {Asset} assetB - The second asset in the lexicographic order.
       * @return {number} `-1` if assetA < assetB, `0` if assetA == assetB, `1` if assetA > assetB.
       * @memberof Asset
       */
    }], [{
      key: "native",
      value: function native() {
        return new Asset("XLM");
      }
      /**
       * Returns an asset object from its XDR object representation.
       * @param {xdr.Asset} assetXdr - The asset xdr object.
       * @returns {Asset}
       */
    }, {
      key: "fromOperation",
      value: function fromOperation(assetXdr) {
        var anum = void 0;
        var code2 = void 0;
        var issuer = void 0;
        switch (assetXdr.switch()) {
          case _stellarXdr_generated2.default.AssetType.assetTypeNative():
            return this.native();
          case _stellarXdr_generated2.default.AssetType.assetTypeCreditAlphanum4():
            anum = assetXdr.alphaNum4();
          /* falls through */
          case _stellarXdr_generated2.default.AssetType.assetTypeCreditAlphanum12():
            anum = anum || assetXdr.alphaNum12();
            issuer = _strkey.StrKey.encodeEd25519PublicKey(anum.issuer().ed25519());
            code2 = (0, _trimEnd2.default)(anum.assetCode(), "\0");
            return new this(code2, issuer);
          default:
            throw new Error("Invalid asset type: " + assetXdr.switch().name);
        }
      }
    }, {
      key: "compare",
      value: function compare(assetA, assetB) {
        if (!assetA || !(assetA instanceof Asset)) {
          throw new Error("assetA is invalid");
        }
        if (!assetB || !(assetB instanceof Asset)) {
          throw new Error("assetB is invalid");
        }
        if (assetA.equals(assetB)) {
          return 0;
        }
        switch (assetA.getAssetType()) {
          case "native":
            return -1;
          case "credit_alphanum4":
            if (assetB.getAssetType() === "native") {
              return 1;
            }
            if (assetB.getAssetType() === "credit_alphanum12") {
              return -1;
            }
            break;
          case "credit_alphanum12":
            if (assetB.getAssetType() !== "credit_alphanum12") {
              return 1;
            }
            break;
          default:
            throw new Error("Unexpected asset type");
        }
        var result = assetA.getCode().localeCompare(assetB.getCode());
        if (result !== 0) {
          return result;
        }
        return assetA.getIssuer().localeCompare(assetB.getIssuer());
      }
    }]);
    return Asset;
  }();
  return asset;
}
var hasRequiredGet_liquidity_pool_id;
function requireGet_liquidity_pool_id() {
  if (hasRequiredGet_liquidity_pool_id) return get_liquidity_pool_id;
  hasRequiredGet_liquidity_pool_id = 1;
  Object.defineProperty(get_liquidity_pool_id, "__esModule", {
    value: true
  });
  get_liquidity_pool_id.LiquidityPoolFeeV18 = void 0;
  get_liquidity_pool_id.getLiquidityPoolId = getLiquidityPoolId;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _asset = requireAsset();
  var _hashing = requireHashing();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var LiquidityPoolFeeV18 = get_liquidity_pool_id.LiquidityPoolFeeV18 = 30;
  function getLiquidityPoolId(liquidityPoolType) {
    var liquidityPoolParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (liquidityPoolType !== "constant_product") {
      throw new Error("liquidityPoolType is invalid");
    }
    var assetA = liquidityPoolParameters.assetA, assetB = liquidityPoolParameters.assetB, fee = liquidityPoolParameters.fee;
    if (!assetA || !(assetA instanceof _asset.Asset)) {
      throw new Error("assetA is invalid");
    }
    if (!assetB || !(assetB instanceof _asset.Asset)) {
      throw new Error("assetB is invalid");
    }
    if (!fee || fee !== LiquidityPoolFeeV18) {
      throw new Error("fee is invalid");
    }
    if (_asset.Asset.compare(assetA, assetB) !== -1) {
      throw new Error("Assets are not in lexicographic order");
    }
    var lpTypeData = _stellarXdr_generated2.default.LiquidityPoolType.liquidityPoolConstantProduct().toXDR();
    var lpParamsData = new _stellarXdr_generated2.default.LiquidityPoolConstantProductParameters({
      assetA: assetA.toXDRObject(),
      assetB: assetB.toXDRObject(),
      fee
    }).toXDR();
    var payload = Buffer.concat([lpTypeData, lpParamsData]);
    return (0, _hashing.hash)(payload);
  }
  return get_liquidity_pool_id;
}
var transaction_base = {};
var hasRequiredTransaction_base;
function requireTransaction_base() {
  if (hasRequiredTransaction_base) return transaction_base;
  hasRequiredTransaction_base = 1;
  Object.defineProperty(transaction_base, "__esModule", {
    value: true
  });
  transaction_base.TransactionBase = void 0;
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _hashing = requireHashing();
  var _keypair = requireKeypair();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  transaction_base.TransactionBase = function() {
    function TransactionBase(tx, signatures, fee, networkPassphrase) {
      _classCallCheck2(this, TransactionBase);
      if (typeof networkPassphrase !== "string") {
        throw new Error("Invalid passphrase provided to Transaction: expected a string but got a " + (typeof networkPassphrase === "undefined" ? "undefined" : _typeof2(networkPassphrase)));
      }
      this._networkPassphrase = networkPassphrase;
      this._tx = tx;
      this._signatures = signatures;
      this._fee = fee;
    }
    _createClass2(TransactionBase, [{
      key: "sign",
      /**
       * Signs the transaction with the given {@link Keypair}.
       * @param {...Keypair} keypairs Keypairs of signers
       * @returns {void}
       */
      value: function sign2() {
        var _this = this;
        var txHash = this.hash();
        for (var _len = arguments.length, keypairs = Array(_len), _key = 0; _key < _len; _key++) {
          keypairs[_key] = arguments[_key];
        }
        keypairs.forEach(function(kp) {
          var sig = kp.signDecorated(txHash);
          _this.signatures.push(sig);
        });
      }
      /**
       * Signs a transaction with the given {@link Keypair}. Useful if someone sends
       * you a transaction XDR for you to sign and return (see
       * [addSignature](#addSignature) for more information).
       *
       * When you get a transaction XDR to sign....
       * - Instantiate a `Transaction` object with the XDR
       * - Use {@link Keypair} to generate a keypair object for your Stellar seed.
       * - Run `getKeypairSignature` with that keypair
       * - Send back the signature along with your publicKey (not your secret seed!)
       *
       * Example:
       * ```javascript
       * // `transactionXDR` is a string from the person generating the transaction
       * const transaction = new Transaction(transactionXDR, networkPassphrase);
       * const keypair = Keypair.fromSecret(myStellarSeed);
       * return transaction.getKeypairSignature(keypair);
       * ```
       *
       * @param {Keypair} keypair Keypair of signer
       * @returns {string} Signature string
       */
    }, {
      key: "getKeypairSignature",
      value: function getKeypairSignature(keypair2) {
        return keypair2.sign(this.hash()).toString("base64");
      }
      /**
       * Add a signature to the transaction. Useful when a party wants to pre-sign
       * a transaction but doesn't want to give access to their secret keys.
       * This will also verify whether the signature is valid.
       *
       * Here's how you would use this feature to solicit multiple signatures.
       * - Use `TransactionBuilder` to build a new transaction.
       * - Make sure to set a long enough timeout on that transaction to give your
       * signers enough time to sign!
       * - Once you build the transaction, use `transaction.toXDR()` to get the
       * base64-encoded XDR string.
       * - _Warning!_ Once you've built this transaction, don't submit any other
       * transactions onto your account! Doing so will invalidate this pre-compiled
       * transaction!
       * - Send this XDR string to your other parties. They can use the instructions
       * for [getKeypairSignature](#getKeypairSignature) to sign the transaction.
       * - They should send you back their `publicKey` and the `signature` string
       * from [getKeypairSignature](#getKeypairSignature), both of which you pass to
       * this function.
       *
       * @param {string} publicKey The public key of the signer
       * @param {string} signature The base64 value of the signature XDR
       * @returns {void}
       */
    }, {
      key: "addSignature",
      value: function addSignature2() {
        var publicKey = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var signature2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        if (!signature2 || typeof signature2 !== "string") {
          throw new Error("Invalid signature");
        }
        if (!publicKey || typeof publicKey !== "string") {
          throw new Error("Invalid publicKey");
        }
        var keypair2 = void 0;
        var hint = void 0;
        var signatureBuffer = Buffer.from(signature2, "base64");
        try {
          keypair2 = _keypair.Keypair.fromPublicKey(publicKey);
          hint = keypair2.signatureHint();
        } catch (e) {
          throw new Error("Invalid publicKey");
        }
        if (!keypair2.verify(this.hash(), signatureBuffer)) {
          throw new Error("Invalid signature");
        }
        this.signatures.push(new _stellarXdr_generated2.default.DecoratedSignature({
          hint,
          signature: signatureBuffer
        }));
      }
      /**
       * Add `hashX` signer preimage as signature.
       * @param {Buffer|String} preimage Preimage of hash used as signer
       * @returns {void}
       */
    }, {
      key: "signHashX",
      value: function signHashX(preimage) {
        if (typeof preimage === "string") {
          preimage = Buffer.from(preimage, "hex");
        }
        if (preimage.length > 64) {
          throw new Error("preimage cannnot be longer than 64 bytes");
        }
        var signature2 = preimage;
        var hashX = (0, _hashing.hash)(preimage);
        var hint = hashX.slice(hashX.length - 4);
        this.signatures.push(new _stellarXdr_generated2.default.DecoratedSignature({ hint, signature: signature2 }));
      }
      /**
       * Returns a hash for this transaction, suitable for signing.
       * @returns {Buffer}
       */
    }, {
      key: "hash",
      value: function hash2() {
        return (0, _hashing.hash)(this.signatureBase());
      }
    }, {
      key: "signatureBase",
      value: function signatureBase() {
        throw new Error("Implement in subclass");
      }
    }, {
      key: "toEnvelope",
      value: function toEnvelope() {
        throw new Error("Implement in subclass");
      }
      /**
       * Get the transaction envelope as a base64-encoded string
       * @returns {string} XDR string
       */
    }, {
      key: "toXDR",
      value: function toXDR() {
        return this.toEnvelope().toXDR().toString("base64");
      }
    }, {
      key: "signatures",
      get: function get3() {
        return this._signatures;
      },
      set: function set3(value) {
        throw new Error("Transaction is immutable");
      }
    }, {
      key: "tx",
      get: function get3() {
        return this._tx;
      },
      set: function set3(value) {
        throw new Error("Transaction is immutable");
      }
      /**
       * @type {string}
       * @readonly
       */
    }, {
      key: "fee",
      get: function get3() {
        return this._fee;
      },
      set: function set3(value) {
        throw new Error("Transaction is immutable");
      }
      /**
       * @type {string}
       * @readonly
       */
    }, {
      key: "networkPassphrase",
      get: function get3() {
        return this._networkPassphrase;
      },
      set: function set3(networkPassphrase) {
        this._networkPassphrase = networkPassphrase;
      }
    }]);
    return TransactionBase;
  }();
  return transaction_base;
}
var transaction = {};
var operation = {};
var bignumber$1 = { exports: {} };
/*! bignumber.js v4.1.0 https://github.com/MikeMcl/bignumber.js/LICENCE */
var bignumber = bignumber$1.exports;
var hasRequiredBignumber;
function requireBignumber() {
  if (hasRequiredBignumber) return bignumber$1.exports;
  hasRequiredBignumber = 1;
  (function(module) {
    (function(globalObj) {
      var BigNumber2, isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, notBool = " not a boolean or binary digit", roundingMode = "rounding mode", tooManyDigits = "number type has more than 15 significant digits", ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function constructorFactory(config2) {
        var div, parseNumeric, id = 0, P2 = BigNumber3.prototype, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, ERRORS = true, isValidInt = intValidatorWithErrors, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          decimalSeparator: ".",
          groupSeparator: ",",
          groupSize: 3,
          secondaryGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          fractionGroupSize: 0
        };
        function BigNumber3(n, b) {
          var c, e, i2, num, len2, str, x = this;
          if (!(x instanceof BigNumber3)) {
            if (ERRORS) raise(26, "constructor call without new", n);
            return new BigNumber3(n, b);
          }
          if (b == null || !isValidInt(b, 2, 64, id, "base")) {
            if (n instanceof BigNumber3) {
              x.s = n.s;
              x.e = n.e;
              x.c = (n = n.c) ? n.slice() : n;
              id = 0;
              return;
            }
            if ((num = typeof n == "number") && n * 0 == 0) {
              x.s = 1 / n < 0 ? (n = -n, -1) : 1;
              if (n === ~~n) {
                for (e = 0, i2 = n; i2 >= 10; i2 /= 10, e++) ;
                x.e = e;
                x.c = [n];
                id = 0;
                return;
              }
              str = n + "";
            } else {
              if (!isNumeric.test(str = n + "")) return parseNumeric(x, str, num);
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
          } else {
            b = b | 0;
            str = n + "";
            if (b == 10) {
              x = new BigNumber3(n instanceof BigNumber3 ? n : str);
              return round2(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            if ((num = typeof n == "number") && n * 0 != 0 || !new RegExp("^-?" + (c = "[" + ALPHABET.slice(0, b) + "]+") + "(?:\\." + c + ")?$", b < 37 ? "i" : "").test(str)) {
              return parseNumeric(x, str, num, b);
            }
            if (num) {
              x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;
              if (ERRORS && str.replace(/^0\.0*|\./, "").length > 15) {
                raise(id, tooManyDigits, n);
              }
              num = false;
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            str = convertBase(str, 10, b, x.s);
          }
          if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
          if ((i2 = str.search(/e/i)) > 0) {
            if (e < 0) e = i2;
            e += +str.slice(i2 + 1);
            str = str.substring(0, i2);
          } else if (e < 0) {
            e = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len2 = str.length; str.charCodeAt(--len2) === 48; ) ;
          str = str.slice(i2, len2 + 1);
          if (str) {
            len2 = str.length;
            if (num && ERRORS && len2 > 15 && (n > MAX_SAFE_INTEGER || n !== mathfloor(n))) {
              raise(id, tooManyDigits, x.s * n);
            }
            e = e - i2 - 1;
            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i2 = (e + 1) % LOG_BASE;
              if (e < 0) i2 += LOG_BASE;
              if (i2 < len2) {
                if (i2) x.c.push(+str.slice(0, i2));
                for (len2 -= LOG_BASE; i2 < len2; ) {
                  x.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                str = str.slice(i2);
                i2 = LOG_BASE - str.length;
              } else {
                i2 -= len2;
              }
              for (; i2--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
          id = 0;
        }
        BigNumber3.another = constructorFactory;
        BigNumber3.ROUND_UP = 0;
        BigNumber3.ROUND_DOWN = 1;
        BigNumber3.ROUND_CEIL = 2;
        BigNumber3.ROUND_FLOOR = 3;
        BigNumber3.ROUND_HALF_UP = 4;
        BigNumber3.ROUND_HALF_DOWN = 5;
        BigNumber3.ROUND_HALF_EVEN = 6;
        BigNumber3.ROUND_HALF_CEIL = 7;
        BigNumber3.ROUND_HALF_FLOOR = 8;
        BigNumber3.EUCLID = 9;
        BigNumber3.config = BigNumber3.set = function() {
          var v, p, i2 = 0, r = {}, a = arguments, o = a[0], has = o && typeof o == "object" ? function() {
            if (o.hasOwnProperty(p)) return (v = o[p]) != null;
          } : function() {
            if (a.length > i2) return (v = a[i2++]) != null;
          };
          if (has(p = "DECIMAL_PLACES") && isValidInt(v, 0, MAX, 2, p)) {
            DECIMAL_PLACES = v | 0;
          }
          r[p] = DECIMAL_PLACES;
          if (has(p = "ROUNDING_MODE") && isValidInt(v, 0, 8, 2, p)) {
            ROUNDING_MODE = v | 0;
          }
          r[p] = ROUNDING_MODE;
          if (has(p = "EXPONENTIAL_AT")) {
            if (isArray2(v)) {
              if (isValidInt(v[0], -1e9, 0, 2, p) && isValidInt(v[1], 0, MAX, 2, p)) {
                TO_EXP_NEG = v[0] | 0;
                TO_EXP_POS = v[1] | 0;
              }
            } else if (isValidInt(v, -1e9, MAX, 2, p)) {
              TO_EXP_NEG = -(TO_EXP_POS = (v < 0 ? -v : v) | 0);
            }
          }
          r[p] = [TO_EXP_NEG, TO_EXP_POS];
          if (has(p = "RANGE")) {
            if (isArray2(v)) {
              if (isValidInt(v[0], -1e9, -1, 2, p) && isValidInt(v[1], 1, MAX, 2, p)) {
                MIN_EXP = v[0] | 0;
                MAX_EXP = v[1] | 0;
              }
            } else if (isValidInt(v, -1e9, MAX, 2, p)) {
              if (v | 0) MIN_EXP = -(MAX_EXP = (v < 0 ? -v : v) | 0);
              else if (ERRORS) raise(2, p + " cannot be zero", v);
            }
          }
          r[p] = [MIN_EXP, MAX_EXP];
          if (has(p = "ERRORS")) {
            if (v === !!v || v === 1 || v === 0) {
              id = 0;
              isValidInt = (ERRORS = !!v) ? intValidatorWithErrors : intValidatorNoErrors;
            } else if (ERRORS) {
              raise(2, p + notBool, v);
            }
          }
          r[p] = ERRORS;
          if (has(p = "CRYPTO")) {
            if (v === true || v === false || v === 1 || v === 0) {
              if (v) {
                v = typeof crypto == "undefined";
                if (!v && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = true;
                } else if (ERRORS) {
                  raise(2, "crypto unavailable", v ? void 0 : crypto);
                } else {
                  CRYPTO = false;
                }
              } else {
                CRYPTO = false;
              }
            } else if (ERRORS) {
              raise(2, p + notBool, v);
            }
          }
          r[p] = CRYPTO;
          if (has(p = "MODULO_MODE") && isValidInt(v, 0, 9, 2, p)) {
            MODULO_MODE = v | 0;
          }
          r[p] = MODULO_MODE;
          if (has(p = "POW_PRECISION") && isValidInt(v, 0, MAX, 2, p)) {
            POW_PRECISION = v | 0;
          }
          r[p] = POW_PRECISION;
          if (has(p = "FORMAT")) {
            if (typeof v == "object") {
              FORMAT = v;
            } else if (ERRORS) {
              raise(2, p + " not an object", v);
            }
          }
          r[p] = FORMAT;
          return r;
        };
        BigNumber3.max = function() {
          return maxOrMin(arguments, P2.lt);
        };
        BigNumber3.min = function() {
          return maxOrMin(arguments, P2.gt);
        };
        BigNumber3.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i2 = 0, c = [], rand = new BigNumber3(ONE);
            dp = dp == null || !isValidInt(dp, 0, MAX, 14) ? DECIMAL_PLACES : dp | 0;
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i2 < k; ) {
                  v = a[i2] * 131072 + (a[i2 + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i2] = b[0];
                    a[i2 + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i2 < k; ) {
                  v = (a[i2] & 31) * 281474976710656 + a[i2 + 1] * 1099511627776 + a[i2 + 2] * 4294967296 + a[i2 + 3] * 16777216 + (a[i2 + 4] << 16) + (a[i2 + 5] << 8) + a[i2 + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i2);
                  } else {
                    c.push(v % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k / 7;
              } else {
                CRYPTO = false;
                if (ERRORS) raise(14, "crypto unavailable", crypto);
              }
            }
            if (!CRYPTO) {
              for (; i2 < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i2++] = v % 1e14;
              }
            }
            k = c[--i2];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i2] = mathfloor(k / v) * v;
            }
            for (; c[i2] === 0; c.pop(), i2--) ;
            if (i2 < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i2 = 1, v = c[0]; v >= 10; v /= 10, i2++) ;
              if (i2 < LOG_BASE) e -= LOG_BASE - i2;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        function convertBase(str, baseOut, baseIn, sign2) {
          var d, e, k, r, x, xc, y, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (baseIn < 37) str = str.toLowerCase();
          if (i2 >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber3(baseIn);
            x = y.pow(str.length - i2);
            POW_PRECISION = k;
            y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e), 10, baseOut);
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut);
          e = k = xc.length;
          for (; xc[--k] == 0; xc.pop()) ;
          if (!xc[0]) return "0";
          if (i2 < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign2;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i2 = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i2 != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i2 > k || i2 == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint("1", -dp) : "0";
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut; ++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length; !xc[--k]; ) ;
            for (i2 = 0, str = ""; i2 <= k; str += ALPHABET.charAt(xc[i2++])) ;
            str = toFixedPoint(str, e);
          }
          return str;
        }
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base2) {
            var m, temp, xlo, xhi, carry = 0, i2 = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i2--; ) {
              xlo = x[i2] % SQRT_BASE;
              xhi = x[i2] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base2 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i2] = temp % base2;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a[i2] != b[i2]) {
                  cmp = a[i2] > b[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base2) {
            var i2 = 0;
            for (; aL--; ) {
              a[aL] -= i2;
              i2 = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i2 * base2 + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base2) {
            var cmp, e, i2, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber3(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber3(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base2) {
              base2 = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
            if (yc[i2] > (xc[i2] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s += 2;
              n = mathfloor(base2 / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base2);
                xc = multiply(xc, n, base2);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base2 / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base2) n = base2 - 1;
                    prod = multiply(yc, n, base2);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base2);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base2);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base2);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i2++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base2 == BASE) {
              for (i2 = 1, s = qc[0]; s >= 10; s /= 10, i2++) ;
              round2(q, dp + (q.e = i2 + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format2(n, i2, rm, caller) {
          var c0, e, ne, len2, str;
          rm = rm != null && isValidInt(rm, 0, 8, caller, roundingMode) ? rm | 0 : ROUNDING_MODE;
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i2 == null) {
            str = coeffToString(n.c);
            str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG ? toExponential(str, ne) : toFixedPoint(str, ne);
          } else {
            n = round2(new BigNumber3(n), i2, rm);
            e = n.e;
            str = coeffToString(n.c);
            len2 = str.length;
            if (caller == 19 || caller == 24 && (i2 <= e || e <= TO_EXP_NEG)) {
              for (; len2 < i2; str += "0", len2++) ;
              str = toExponential(str, e);
            } else {
              i2 -= ne;
              str = toFixedPoint(str, e);
              if (e + 1 > len2) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e - len2;
                if (i2 > 0) {
                  if (e + 1 == len2) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var m, n, i2 = 0;
          if (isArray2(args[0])) args = args[0];
          m = new BigNumber3(args[0]);
          for (; ++i2 < args.length; ) {
            n = new BigNumber3(args[i2]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function intValidatorWithErrors(n, min2, max2, caller, name) {
          if (n < min2 || n > max2 || n != truncate(n)) {
            raise(caller, (name || "decimal places") + (n < min2 || n > max2 ? " out of range" : " not an integer"), n);
          }
          return true;
        }
        function normalise(n, c, e) {
          var i2 = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i2++) ;
          if ((e = i2 + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, num, b) {
            var base2, s = num ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!num) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base2 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base2 ? p1 : m;
                });
                if (b) {
                  base2 = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber3(s, base2);
              }
              if (ERRORS) raise(id, "not a" + (b ? " base " + b : "") + " number", str);
              x.s = null;
            }
            x.c = x.e = null;
            id = 0;
          };
        }();
        function raise(caller, msg, val) {
          var error3 = new Error([
            "new BigNumber",
            // 0
            "cmp",
            // 1
            "config",
            // 2
            "div",
            // 3
            "divToInt",
            // 4
            "eq",
            // 5
            "gt",
            // 6
            "gte",
            // 7
            "lt",
            // 8
            "lte",
            // 9
            "minus",
            // 10
            "mod",
            // 11
            "plus",
            // 12
            "precision",
            // 13
            "random",
            // 14
            "round",
            // 15
            "shift",
            // 16
            "times",
            // 17
            "toDigits",
            // 18
            "toExponential",
            // 19
            "toFixed",
            // 20
            "toFormat",
            // 21
            "toFraction",
            // 22
            "pow",
            // 23
            "toPrecision",
            // 24
            "toString",
            // 25
            "BigNumber"
            // 26
          ][caller] + "() " + msg + ": " + val);
          error3.name = "BigNumber Error";
          id = 0;
          throw error3;
        }
        function round2(x, sd, rm, r) {
          var d, i2, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i2 = sd - d;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i2 %= LOG_BASE;
                    j = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i2 %= LOG_BASE;
                  j = i2 - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i2 == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i2];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j = xc[0]; j >= 10; j /= 10, i2++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i2 != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        P2.absoluteValue = P2.abs = function() {
          var x = new BigNumber3(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P2.ceil = function() {
          return round2(new BigNumber3(this), this.e + 1, 2);
        };
        P2.comparedTo = P2.cmp = function(y, b) {
          id = 1;
          return compare(this, new BigNumber3(y, b));
        };
        P2.decimalPlaces = P2.dp = function() {
          var n, v, c = this.c;
          if (!c) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P2.dividedBy = P2.div = function(y, b) {
          id = 3;
          return div(this, new BigNumber3(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.divToInt = function(y, b) {
          id = 4;
          return div(this, new BigNumber3(y, b), 0, 1);
        };
        P2.equals = P2.eq = function(y, b) {
          id = 5;
          return compare(this, new BigNumber3(y, b)) === 0;
        };
        P2.floor = function() {
          return round2(new BigNumber3(this), this.e + 1, 3);
        };
        P2.greaterThan = P2.gt = function(y, b) {
          id = 6;
          return compare(this, new BigNumber3(y, b)) > 0;
        };
        P2.greaterThanOrEqualTo = P2.gte = function(y, b) {
          id = 7;
          return (b = compare(this, new BigNumber3(y, b))) === 1 || b === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isInteger = P2.isInt = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = P2.isNeg = function() {
          return this.s < 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.lessThan = P2.lt = function(y, b) {
          id = 8;
          return compare(this, new BigNumber3(y, b)) < 0;
        };
        P2.lessThanOrEqualTo = P2.lte = function(y, b) {
          id = 9;
          return (b = compare(this, new BigNumber3(y, b))) === -1 || b === 0;
        };
        P2.minus = P2.sub = function(y, b) {
          var i2, j, t2, xLTy, x = this, a = x.s;
          id = 10;
          y = new BigNumber3(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber3(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber3(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber3(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t2 = xc;
            } else {
              ye = xe;
              t2 = yc;
            }
            t2.reverse();
            for (b = a; b--; t2.push(0)) ;
            t2.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) t2 = xc, xc = yc, yc = t2, y.s = -y.s;
          b = (j = yc.length) - (i2 = xc.length);
          if (b > 0) for (; b--; xc[i2++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i2 = j; i2 && !xc[--i2]; xc[i2] = b) ;
              --xc[i2];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P2.modulo = P2.mod = function(y, b) {
          var q, s, x = this;
          id = 11;
          y = new BigNumber3(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber3(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber3(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          return x.minus(q.times(y));
        };
        P2.negated = P2.neg = function() {
          var x = new BigNumber3(this);
          x.s = -x.s || null;
          return x;
        };
        P2.plus = P2.add = function(y, b) {
          var t2, x = this, a = x.s;
          id = 12;
          y = new BigNumber3(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber3(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber3(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber3(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t2 = yc;
            } else {
              a = -a;
              t2 = xc;
            }
            t2.reverse();
            for (; a--; t2.push(0)) ;
            t2.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) t2 = yc, yc = xc, xc = t2, b = a;
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P2.precision = P2.sd = function(z) {
          var n, v, x = this, c = x.c;
          if (z != null && z !== !!z && z !== 1 && z !== 0) {
            if (ERRORS) raise(13, "argument" + notBool, z);
            if (z != !!z) z = null;
          }
          if (!c) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (z && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P2.round = function(dp, rm) {
          var n = new BigNumber3(this);
          if (dp == null || isValidInt(dp, 0, MAX, 15)) {
            round2(n, ~~dp + this.e + 1, rm == null || !isValidInt(rm, 0, 8, 15, roundingMode) ? ROUNDING_MODE : rm | 0);
          }
          return n;
        };
        P2.shift = function(k) {
          var n = this;
          return isValidInt(k, -9007199254740991, MAX_SAFE_INTEGER, 16, "argument") ? n.times("1e" + truncate(k)) : new BigNumber3(n.c && n.c[0] && (k < -9007199254740991 || k > MAX_SAFE_INTEGER) ? n.s * (k < 0 ? 0 : 1 / 0) : n);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m, n, r, rep, t2, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+x);
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "1e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber3(n);
          } else {
            r = new BigNumber3(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t2 = r;
              r = half.times(t2.plus(div(x, t2, dp, 1)));
              if (coeffToString(t2.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round2(t2, t2.e + DECIMAL_PLACES + 2, 0);
                    if (t2.times(t2).eq(x)) {
                      r = t2;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round2(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round2(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P2.times = P2.mul = function(y, b) {
          var c, e, i2, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base2, sqrtBase, x = this, xc = x.c, yc = (id = 17, y = new BigNumber3(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) zc = xc, xc = yc, yc = zc, i2 = xcL, xcL = ycL, ycL = i2;
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
          base2 = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k = xcL, j = i2 + k; j > i2; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base2 | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base2;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P2.toDigits = function(sd, rm) {
          var n = new BigNumber3(this);
          sd = sd == null || !isValidInt(sd, 1, MAX, 18, "precision") ? null : sd | 0;
          rm = rm == null || !isValidInt(rm, 0, 8, 18, roundingMode) ? ROUNDING_MODE : rm | 0;
          return sd ? round2(n, sd, rm) : n;
        };
        P2.toExponential = function(dp, rm) {
          return format2(
            this,
            dp != null && isValidInt(dp, 0, MAX, 19) ? ~~dp + 1 : null,
            rm,
            19
          );
        };
        P2.toFixed = function(dp, rm) {
          return format2(this, dp != null && isValidInt(dp, 0, MAX, 20) ? ~~dp + this.e + 1 : null, rm, 20);
        };
        P2.toFormat = function(dp, rm) {
          var str = format2(this, dp != null && isValidInt(dp, 0, MAX, 21) ? ~~dp + this.e + 1 : null, rm, 21);
          if (this.c) {
            var i2, arr2 = str.split("."), g1 = +FORMAT.groupSize, g2 = +FORMAT.secondaryGroupSize, groupSeparator = FORMAT.groupSeparator, intPart = arr2[0], fractionPart = arr2[1], isNeg = this.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len2 = intDigits.length;
            if (g2) i2 = g1, g1 = g2, g2 = i2, len2 -= i2;
            if (g1 > 0 && len2 > 0) {
              i2 = len2 % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len2; i2 += g1) {
                intPart += groupSeparator + intDigits.substr(i2, g1);
              }
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + FORMAT.decimalSeparator + ((g2 = +FORMAT.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + FORMAT.fractionGroupSeparator
            ) : fractionPart) : intPart;
          }
          return str;
        };
        P2.toFraction = function(md) {
          var arr2, d0, d2, e, exp, n, n0, q, s, k = ERRORS, x = this, xc = x.c, d = new BigNumber3(ONE), n1 = d0 = new BigNumber3(ONE), d1 = n0 = new BigNumber3(ONE);
          if (md != null) {
            ERRORS = false;
            n = new BigNumber3(md);
            ERRORS = k;
            if (!(k = n.isInt()) || n.lt(ONE)) {
              if (ERRORS) {
                raise(
                  22,
                  "max denominator " + (k ? "out of range" : "not an integer"),
                  md
                );
              }
              md = !k && n.c && round2(n, n.e + 1, 1).gte(ONE) ? n : null;
            }
          }
          if (!xc) return x.toString();
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.cmp(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber3(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.cmp(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e *= 2;
          arr2 = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().cmp(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1.toString(), d1.toString()] : [n0.toString(), d0.toString()];
          MAX_EXP = exp;
          return arr2;
        };
        P2.toNumber = function() {
          return +this;
        };
        P2.toPower = P2.pow = function(n, m) {
          var k, y, z, i2 = mathfloor(n < 0 ? -n : +n), x = this;
          if (m != null) {
            id = 23;
            m = new BigNumber3(m);
          }
          if (!isValidInt(n, -9007199254740991, MAX_SAFE_INTEGER, 23, "exponent") && (!isFinite(n) || i2 > MAX_SAFE_INTEGER && (n /= 0) || parseFloat(n) != n && !(n = NaN)) || n == 0) {
            k = Math.pow(+x, n);
            return new BigNumber3(m ? k % m : k);
          }
          if (m) {
            if (n > 1 && x.gt(ONE) && x.isInt() && m.gt(ONE) && m.isInt()) {
              x = x.mod(m);
            } else {
              z = m;
              m = null;
            }
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          y = new BigNumber3(ONE);
          for (; ; ) {
            if (i2 % 2) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (m) {
                y = y.mod(m);
              }
            }
            i2 = mathfloor(i2 / 2);
            if (!i2) break;
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (m) {
              x = x.mod(m);
            }
          }
          if (m) return y;
          if (n < 0) y = ONE.div(y);
          return z ? y.mod(z) : k ? round2(y, POW_PRECISION, ROUNDING_MODE) : y;
        };
        P2.toPrecision = function(sd, rm) {
          return format2(this, sd != null && isValidInt(sd, 1, MAX, 24, "precision") ? sd | 0 : null, rm, 24);
        };
        P2.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            str = coeffToString(n.c);
            if (b == null || !isValidInt(b, 2, 64, 25, "base")) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e);
            } else {
              str = convertBase(toFixedPoint(str, e), b | 0, 10, s);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P2.truncated = P2.trunc = function() {
          return round2(new BigNumber3(this), this.e + 1, 1);
        };
        P2.valueOf = P2.toJSON = function() {
          var str, n = this, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e);
          return n.s < 0 ? "-" + str : str;
        };
        P2.isBigNumber = true;
        if (config2 != null) BigNumber3.config(config2);
        return BigNumber3;
      }
      function bitFloor(n) {
        var i2 = n | 0;
        return n > 0 || n === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a) {
        var s, z, i2 = 1, j = a.length, r = a[0] + "";
        for (; i2 < j; ) {
          s = a[i2++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i2 = x.s, j = y.s, k = x.e, l = y.e;
        if (!i2 || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i2;
        if (i2 != j) return i2;
        a = i2 < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i2 = 0; i2 < j; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intValidatorNoErrors(n, min2, max2) {
        return (n = truncate(n)) >= min2 && n <= max2;
      }
      function isArray2(obj) {
        return Object.prototype.toString.call(obj) == "[object Array]";
      }
      function toBaseOut(str, baseIn, baseOut) {
        var j, arr2 = [0], arrL, i2 = 0, len2 = str.length;
        for (; i2 < len2; ) {
          for (arrL = arr2.length; arrL--; arr2[arrL] *= baseIn) ;
          arr2[j = 0] += ALPHABET.indexOf(str.charAt(i2++));
          for (; j < arr2.length; j++) {
            if (arr2[j] > baseOut - 1) {
              if (arr2[j + 1] == null) arr2[j + 1] = 0;
              arr2[j + 1] += arr2[j] / baseOut | 0;
              arr2[j] %= baseOut;
            }
          }
        }
        return arr2.reverse();
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e) {
        var len2, z;
        if (e < 0) {
          for (z = "0."; ++e; z += "0") ;
          str = z + str;
        } else {
          len2 = str.length;
          if (++e > len2) {
            for (z = "0", e -= len2; --e; z += "0") ;
            str += z;
          } else if (e < len2) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
      }
      BigNumber2 = constructorFactory();
      BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
      if (module.exports) {
        module.exports = BigNumber2;
      } else {
        if (!globalObj) globalObj = typeof self != "undefined" ? self : Function("return this")();
        globalObj.BigNumber = BigNumber2;
      }
    })(bignumber);
  })(bignumber$1);
  return bignumber$1.exports;
}
var _isFinite;
var hasRequired_isFinite;
function require_isFinite() {
  if (hasRequired_isFinite) return _isFinite;
  hasRequired_isFinite = 1;
  var root = require_root();
  var nativeIsFinite = root.isFinite;
  function isFinite2(value) {
    return typeof value == "number" && nativeIsFinite(value);
  }
  _isFinite = isFinite2;
  return _isFinite;
}
var continued_fraction = {};
var hasRequiredContinued_fraction;
function requireContinued_fraction() {
  if (hasRequiredContinued_fraction) return continued_fraction;
  hasRequiredContinued_fraction = 1;
  Object.defineProperty(continued_fraction, "__esModule", {
    value: true
  });
  var _slicedToArray2 = /* @__PURE__ */ function() {
    function sliceIterator(arr2, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr2[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    return function(arr2, i2) {
      if (Array.isArray(arr2)) {
        return arr2;
      } else if (Symbol.iterator in Object(arr2)) {
        return sliceIterator(arr2, i2);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  continued_fraction.best_r = best_r2;
  var _bignumber = requireBignumber();
  var _bignumber2 = _interopRequireDefault(_bignumber);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var MAX_INT2 = (1 << 31 >>> 0) - 1;
  function best_r2(rawNumber) {
    var number = new _bignumber2.default(rawNumber);
    var a = void 0;
    var f = void 0;
    var fractions = [[new _bignumber2.default(0), new _bignumber2.default(1)], [new _bignumber2.default(1), new _bignumber2.default(0)]];
    var i2 = 2;
    while (true) {
      if (number.gt(MAX_INT2)) {
        break;
      }
      a = number.floor();
      f = number.sub(a);
      var h = a.mul(fractions[i2 - 1][0]).add(fractions[i2 - 2][0]);
      var k = a.mul(fractions[i2 - 1][1]).add(fractions[i2 - 2][1]);
      if (h.gt(MAX_INT2) || k.gt(MAX_INT2)) {
        break;
      }
      fractions.push([h, k]);
      if (f.eq(0)) {
        break;
      }
      number = new _bignumber2.default(1).div(f);
      i2 += 1;
    }
    var _fractions = _slicedToArray2(fractions[fractions.length - 1], 2), n = _fractions[0], d = _fractions[1];
    if (n.isZero() || d.isZero()) {
      throw new Error("Couldn't find approximation");
    }
    return [n.toNumber(), d.toNumber()];
  }
  return continued_fraction;
}
var liquidity_pool_asset = {};
var hasRequiredLiquidity_pool_asset;
function requireLiquidity_pool_asset() {
  if (hasRequiredLiquidity_pool_asset) return liquidity_pool_asset;
  hasRequiredLiquidity_pool_asset = 1;
  Object.defineProperty(liquidity_pool_asset, "__esModule", {
    value: true
  });
  liquidity_pool_asset.LiquidityPoolAsset = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _clone = requireClone();
  var _clone2 = _interopRequireDefault(_clone);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _asset = requireAsset();
  var _get_liquidity_pool_id = requireGet_liquidity_pool_id();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  liquidity_pool_asset.LiquidityPoolAsset = function() {
    function LiquidityPoolAsset(assetA, assetB, fee) {
      _classCallCheck2(this, LiquidityPoolAsset);
      if (!assetA || !(assetA instanceof _asset.Asset)) {
        throw new Error("assetA is invalid");
      }
      if (!assetB || !(assetB instanceof _asset.Asset)) {
        throw new Error("assetB is invalid");
      }
      if (_asset.Asset.compare(assetA, assetB) !== -1) {
        throw new Error("Assets are not in lexicographic order");
      }
      if (!fee || fee !== _get_liquidity_pool_id.LiquidityPoolFeeV18) {
        throw new Error("fee is invalid");
      }
      this.assetA = assetA;
      this.assetB = assetB;
      this.fee = fee;
    }
    _createClass2(LiquidityPoolAsset, [{
      key: "toXDRObject",
      /**
       * Returns the `xdr.ChangeTrustAsset` object for this liquidity pool asset.
       *
       * Note: To convert from an {@link Asset `Asset`} to `xdr.ChangeTrustAsset`
       * please refer to the
       * {@link Asset.toChangeTrustXDRObject `Asset.toChangeTrustXDRObject`} method.
       *
       * @returns {xdr.ChangeTrustAsset} XDR ChangeTrustAsset object.
       */
      value: function toXDRObject() {
        var lpConstantProductParamsXdr = new _stellarXdr_generated2.default.LiquidityPoolConstantProductParameters({
          assetA: this.assetA.toXDRObject(),
          assetB: this.assetB.toXDRObject(),
          fee: this.fee
        });
        var lpParamsXdr = new _stellarXdr_generated2.default.LiquidityPoolParameters("liquidityPoolConstantProduct", lpConstantProductParamsXdr);
        return new _stellarXdr_generated2.default.ChangeTrustAsset("assetTypePoolShare", lpParamsXdr);
      }
      /**
       * @returns {LiquidityPoolParameters} Liquidity pool parameters.
       */
    }, {
      key: "getLiquidityPoolParameters",
      value: function getLiquidityPoolParameters() {
        return (0, _clone2.default)({
          assetA: this.assetA,
          assetB: this.assetB,
          fee: this.fee
        });
      }
      /**
       * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
       * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
       */
    }, {
      key: "getAssetType",
      value: function getAssetType() {
        return "liquidity_pool_shares";
      }
      /**
       * @param {LiquidityPoolAsset} other the LiquidityPoolAsset to compare
       * @returns {boolean} `true` if this asset equals the given asset.
       */
    }, {
      key: "equals",
      value: function equals(other) {
        return this.assetA.equals(other.assetA) && this.assetB.equals(other.assetB) && this.fee === other.fee;
      }
    }, {
      key: "toString",
      value: function toString2() {
        var poolId = (0, _get_liquidity_pool_id.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
        return "liquidity_pool:" + poolId;
      }
    }], [{
      key: "fromOperation",
      value: function fromOperation(ctAssetXdr) {
        var assetType = ctAssetXdr.switch();
        if (assetType === _stellarXdr_generated2.default.AssetType.assetTypePoolShare()) {
          var liquidityPoolParameters = ctAssetXdr.liquidityPool().constantProduct();
          return new this(_asset.Asset.fromOperation(liquidityPoolParameters.assetA()), _asset.Asset.fromOperation(liquidityPoolParameters.assetB()), liquidityPoolParameters.fee());
        }
        throw new Error("Invalid asset type: " + assetType.name);
      }
    }]);
    return LiquidityPoolAsset;
  }();
  return liquidity_pool_asset;
}
var claimant = {};
var hasRequiredClaimant;
function requireClaimant() {
  if (hasRequiredClaimant) return claimant;
  hasRequiredClaimant = 1;
  Object.defineProperty(claimant, "__esModule", {
    value: true
  });
  claimant.Claimant = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _keypair = requireKeypair();
  var _strkey = requireStrkey();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  claimant.Claimant = function() {
    function Claimant(destination, predicate) {
      _classCallCheck2(this, Claimant);
      if (destination && !_strkey.StrKey.isValidEd25519PublicKey(destination)) {
        throw new Error("Destination is invalid");
      }
      this._destination = destination;
      if (!predicate) {
        this._predicate = _stellarXdr_generated2.default.ClaimPredicate.claimPredicateUnconditional();
      } else if (predicate instanceof _stellarXdr_generated2.default.ClaimPredicate) {
        this._predicate = predicate;
      } else {
        throw new Error("Predicate should be an xdr.ClaimPredicate");
      }
    }
    _createClass2(Claimant, [{
      key: "toXDRObject",
      /**
       * Returns the xdr object for this claimant.
       * @returns {xdr.Claimant} XDR Claimant object
       */
      value: function toXDRObject() {
        var claimant2 = new _stellarXdr_generated2.default.ClaimantV0({
          destination: _keypair.Keypair.fromPublicKey(this._destination).xdrAccountId(),
          predicate: this._predicate
        });
        return _stellarXdr_generated2.default.Claimant.claimantTypeV0(claimant2);
      }
      /**
       * @type {string}
       * @readonly
       */
    }, {
      key: "destination",
      get: function get3() {
        return this._destination;
      },
      set: function set3(value) {
        throw new Error("Claimant is immutable");
      }
      /**
       * @type {xdr.ClaimPredicate}
       * @readonly
       */
    }, {
      key: "predicate",
      get: function get3() {
        return this._predicate;
      },
      set: function set3(value) {
        throw new Error("Claimant is immutable");
      }
    }], [{
      key: "predicateUnconditional",
      value: function predicateUnconditional() {
        return _stellarXdr_generated2.default.ClaimPredicate.claimPredicateUnconditional();
      }
      /**
       * Returns an `and` claim predicate
       * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
       * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
       * @Return {xdr.ClaimPredicate}
       */
    }, {
      key: "predicateAnd",
      value: function predicateAnd(left, right) {
        if (!(left instanceof _stellarXdr_generated2.default.ClaimPredicate)) {
          throw new Error("left Predicate should be an xdr.ClaimPredicate");
        }
        if (!(right instanceof _stellarXdr_generated2.default.ClaimPredicate)) {
          throw new Error("right Predicate should be an xdr.ClaimPredicate");
        }
        return _stellarXdr_generated2.default.ClaimPredicate.claimPredicateAnd([left, right]);
      }
      /**
       * Returns an `or` claim predicate
       * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
       * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
       * @Return {xdr.ClaimPredicate}
       */
    }, {
      key: "predicateOr",
      value: function predicateOr(left, right) {
        if (!(left instanceof _stellarXdr_generated2.default.ClaimPredicate)) {
          throw new Error("left Predicate should be an xdr.ClaimPredicate");
        }
        if (!(right instanceof _stellarXdr_generated2.default.ClaimPredicate)) {
          throw new Error("right Predicate should be an xdr.ClaimPredicate");
        }
        return _stellarXdr_generated2.default.ClaimPredicate.claimPredicateOr([left, right]);
      }
      /**
       * Returns a `not` claim predicate
       * @param {xdr.ClaimPredicate} predicate an xdr.ClaimPredicate
       * @Return {xdr.ClaimPredicate}
       */
    }, {
      key: "predicateNot",
      value: function predicateNot(predicate) {
        if (!(predicate instanceof _stellarXdr_generated2.default.ClaimPredicate)) {
          throw new Error("right Predicate should be an xdr.ClaimPredicate");
        }
        return _stellarXdr_generated2.default.ClaimPredicate.claimPredicateNot(predicate);
      }
      /**
       * Returns a `BeforeAbsoluteTime` claim predicate
       *
       * This predicate will be fulfilled if the closing time of the ledger that
       * includes the CreateClaimableBalance operation is less than this (absolute)
       * Unix timestamp (expressed in seconds).
       *
       * @param {string} absBefore Unix epoch (in seconds) as a string
       * @Return {xdr.ClaimPredicate}
       */
    }, {
      key: "predicateBeforeAbsoluteTime",
      value: function predicateBeforeAbsoluteTime(absBefore) {
        return _stellarXdr_generated2.default.ClaimPredicate.claimPredicateBeforeAbsoluteTime(_stellarXdr_generated2.default.Int64.fromString(absBefore));
      }
      /**
       * Returns a `BeforeRelativeTime` claim predicate
       *
       * This predicate will be fulfilled if the closing time of the ledger that
       * includes the CreateClaimableBalance operation plus this relative time delta
       * (in seconds) is less than the current time.
       *
       * @param {strings} seconds seconds since closeTime of the ledger in which the ClaimableBalanceEntry was created (as string)
       * @Return {xdr.ClaimPredicate}
       */
    }, {
      key: "predicateBeforeRelativeTime",
      value: function predicateBeforeRelativeTime(seconds) {
        return _stellarXdr_generated2.default.ClaimPredicate.claimPredicateBeforeRelativeTime(_stellarXdr_generated2.default.Int64.fromString(seconds));
      }
      /**
       * Returns a claimant object from its XDR object representation.
       * @param {xdr.Claimant} claimantXdr - The claimant xdr object.
       * @returns {Claimant}
       */
    }, {
      key: "fromXDR",
      value: function fromXDR(claimantXdr) {
        var value = void 0;
        switch (claimantXdr.switch()) {
          case _stellarXdr_generated2.default.ClaimantType.claimantTypeV0():
            value = claimantXdr.v0();
            return new this(_strkey.StrKey.encodeEd25519PublicKey(value.destination().ed25519()), value.predicate());
          default:
            throw new Error("Invalid claimant type: " + claimantXdr.switch().name);
        }
      }
    }]);
    return Claimant;
  }();
  return claimant;
}
var liquidity_pool_id = {};
var hasRequiredLiquidity_pool_id;
function requireLiquidity_pool_id() {
  if (hasRequiredLiquidity_pool_id) return liquidity_pool_id;
  hasRequiredLiquidity_pool_id = 1;
  Object.defineProperty(liquidity_pool_id, "__esModule", {
    value: true
  });
  liquidity_pool_id.LiquidityPoolId = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _clone = requireClone();
  var _clone2 = _interopRequireDefault(_clone);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  liquidity_pool_id.LiquidityPoolId = function() {
    function LiquidityPoolId(liquidityPoolId) {
      _classCallCheck2(this, LiquidityPoolId);
      if (!liquidityPoolId) {
        throw new Error("liquidityPoolId cannot be empty");
      }
      if (!/^[a-f0-9]{64}$/.test(liquidityPoolId)) {
        throw new Error("Liquidity pool ID is not a valid hash");
      }
      this.liquidityPoolId = liquidityPoolId;
    }
    _createClass2(LiquidityPoolId, [{
      key: "toXDRObject",
      /**
       * Returns the `xdr.TrustLineAsset` object for this liquidity pool ID.
       *
       * Note: To convert from {@link Asset `Asset`} to `xdr.TrustLineAsset` please
       * refer to the
       * {@link Asset.toTrustLineXDRObject `Asset.toTrustLineXDRObject`} method.
       *
       * @returns {xdr.TrustLineAsset} XDR LiquidityPoolId object
       */
      value: function toXDRObject() {
        var xdrPoolId = _stellarXdr_generated2.default.PoolId.fromXDR(this.liquidityPoolId, "hex");
        return new _stellarXdr_generated2.default.TrustLineAsset("assetTypePoolShare", xdrPoolId);
      }
      /**
       * @returns {string} Liquidity pool ID.
       */
    }, {
      key: "getLiquidityPoolId",
      value: function getLiquidityPoolId() {
        return (0, _clone2.default)(this.liquidityPoolId);
      }
      /**
       * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
       * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
       */
    }, {
      key: "getAssetType",
      value: function getAssetType() {
        return "liquidity_pool_shares";
      }
      /**
       * @param {LiquidityPoolId} asset LiquidityPoolId to compare.
       * @returns {boolean} `true` if this asset equals the given asset.
       */
    }, {
      key: "equals",
      value: function equals(asset2) {
        return this.liquidityPoolId === asset2.getLiquidityPoolId();
      }
    }, {
      key: "toString",
      value: function toString2() {
        return "liquidity_pool:" + this.liquidityPoolId;
      }
    }], [{
      key: "fromOperation",
      value: function fromOperation(tlAssetXdr) {
        var assetType = tlAssetXdr.switch();
        if (assetType === _stellarXdr_generated2.default.AssetType.assetTypePoolShare()) {
          var liquidityPoolId = tlAssetXdr.liquidityPoolId().toString("hex");
          return new this(liquidityPoolId);
        }
        throw new Error("Invalid asset type: " + assetType.name);
      }
    }]);
    return LiquidityPoolId;
  }();
  return liquidity_pool_id;
}
var operations = {};
var manage_sell_offer = {};
var hasRequiredManage_sell_offer;
function requireManage_sell_offer() {
  if (hasRequiredManage_sell_offer) return manage_sell_offer;
  hasRequiredManage_sell_offer = 1;
  Object.defineProperty(manage_sell_offer, "__esModule", {
    value: true
  });
  manage_sell_offer.manageSellOffer = manageSellOffer;
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _jsXdr = requireLib$3();
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function manageSellOffer(opts) {
    var attributes = {};
    attributes.selling = opts.selling.toXDRObject();
    attributes.buying = opts.buying.toXDRObject();
    if (!this.isValidAmount(opts.amount, true)) {
      throw new TypeError(this.constructAmountRequirementsError("amount"));
    }
    attributes.amount = this._toXDRAmount(opts.amount);
    if ((0, _isUndefined2.default)(opts.price)) {
      throw new TypeError("price argument is required");
    }
    attributes.price = this._toXDRPrice(opts.price);
    if (!(0, _isUndefined2.default)(opts.offerId)) {
      opts.offerId = opts.offerId.toString();
    } else {
      opts.offerId = "0";
    }
    attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
    var manageSellOfferOp = new _stellarXdr_generated2.default.ManageSellOfferOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.manageSellOffer(manageSellOfferOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return manage_sell_offer;
}
var create_passive_sell_offer = {};
var hasRequiredCreate_passive_sell_offer;
function requireCreate_passive_sell_offer() {
  if (hasRequiredCreate_passive_sell_offer) return create_passive_sell_offer;
  hasRequiredCreate_passive_sell_offer = 1;
  Object.defineProperty(create_passive_sell_offer, "__esModule", {
    value: true
  });
  create_passive_sell_offer.createPassiveSellOffer = createPassiveSellOffer;
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function createPassiveSellOffer(opts) {
    var attributes = {};
    attributes.selling = opts.selling.toXDRObject();
    attributes.buying = opts.buying.toXDRObject();
    if (!this.isValidAmount(opts.amount)) {
      throw new TypeError(this.constructAmountRequirementsError("amount"));
    }
    attributes.amount = this._toXDRAmount(opts.amount);
    if ((0, _isUndefined2.default)(opts.price)) {
      throw new TypeError("price argument is required");
    }
    attributes.price = this._toXDRPrice(opts.price);
    var createPassiveSellOfferOp = new _stellarXdr_generated2.default.CreatePassiveSellOfferOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.createPassiveSellOffer(createPassiveSellOfferOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return create_passive_sell_offer;
}
var account_merge = {};
var decode_encode_muxed_account = {};
var hasRequiredDecode_encode_muxed_account;
function requireDecode_encode_muxed_account() {
  if (hasRequiredDecode_encode_muxed_account) return decode_encode_muxed_account;
  hasRequiredDecode_encode_muxed_account = 1;
  Object.defineProperty(decode_encode_muxed_account, "__esModule", {
    value: true
  });
  decode_encode_muxed_account.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;
  decode_encode_muxed_account.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;
  decode_encode_muxed_account.encodeMuxedAccount = encodeMuxedAccount;
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _strkey = requireStrkey();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function decodeAddressToMuxedAccount(address, supportMuxing) {
    if (supportMuxing && _strkey.StrKey.isValidMed25519PublicKey(address)) {
      return _decodeAddressFullyToMuxedAccount(address);
    }
    return _stellarXdr_generated2.default.MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));
  }
  function encodeMuxedAccountToAddress(muxedAccount, supportMuxing) {
    if (muxedAccount.switch().value === _stellarXdr_generated2.default.CryptoKeyType.keyTypeMuxedEd25519().value) {
      if (supportMuxing) {
        return _encodeMuxedAccountFullyToAddress(muxedAccount);
      }
      muxedAccount = muxedAccount.med25519();
    }
    return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());
  }
  function encodeMuxedAccount(address, id) {
    if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {
      throw new Error("address should be a Stellar account ID (G...)");
    }
    if (!(0, _isString2.default)(id)) {
      throw new Error("id should be a string representing a number (uint64)");
    }
    return _stellarXdr_generated2.default.MuxedAccount.keyTypeMuxedEd25519(new _stellarXdr_generated2.default.MuxedAccountMed25519({
      id: _stellarXdr_generated2.default.Uint64.fromString(id),
      ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)
    }));
  }
  function _decodeAddressFullyToMuxedAccount(address) {
    var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);
    return _stellarXdr_generated2.default.MuxedAccount.keyTypeMuxedEd25519(new _stellarXdr_generated2.default.MuxedAccountMed25519({
      id: _stellarXdr_generated2.default.Uint64.fromXDR(rawBytes.slice(-8)),
      ed25519: rawBytes.slice(0, -8)
    }));
  }
  function _encodeMuxedAccountFullyToAddress(muxedAccount) {
    if (muxedAccount.switch() === _stellarXdr_generated2.default.CryptoKeyType.keyTypeEd25519()) {
      return encodeMuxedAccountToAddress(muxedAccount);
    }
    var muxed = muxedAccount.med25519();
    return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR("raw")]));
  }
  return decode_encode_muxed_account;
}
var hasRequiredAccount_merge;
function requireAccount_merge() {
  if (hasRequiredAccount_merge) return account_merge;
  hasRequiredAccount_merge = 1;
  Object.defineProperty(account_merge, "__esModule", {
    value: true
  });
  account_merge.accountMerge = accountMerge;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function accountMerge(opts) {
    var opAttributes = {};
    try {
      opAttributes.body = _stellarXdr_generated2.default.OperationBody.accountMerge((0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination, opts.withMuxing));
    } catch (e) {
      throw new Error("destination is invalid");
    }
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return account_merge;
}
var allow_trust = {};
var hasRequiredAllow_trust;
function requireAllow_trust() {
  if (hasRequiredAllow_trust) return allow_trust;
  hasRequiredAllow_trust = 1;
  Object.defineProperty(allow_trust, "__esModule", {
    value: true
  });
  allow_trust.allowTrust = allowTrust;
  var _padEnd = requirePadEnd();
  var _padEnd2 = _interopRequireDefault(_padEnd);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _keypair = requireKeypair();
  var _strkey = requireStrkey();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function allowTrust(opts) {
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.trustor)) {
      throw new Error("trustor is invalid");
    }
    var attributes = {};
    attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
    if (opts.assetCode.length <= 4) {
      var code2 = (0, _padEnd2.default)(opts.assetCode, 4, "\0");
      attributes.asset = _stellarXdr_generated2.default.AssetCode.assetTypeCreditAlphanum4(code2);
    } else if (opts.assetCode.length <= 12) {
      var _code = (0, _padEnd2.default)(opts.assetCode, 12, "\0");
      attributes.asset = _stellarXdr_generated2.default.AssetCode.assetTypeCreditAlphanum12(_code);
    } else {
      throw new Error("Asset code must be 12 characters at max.");
    }
    if (typeof opts.authorize === "boolean") {
      if (opts.authorize) {
        attributes.authorize = _stellarXdr_generated2.default.TrustLineFlags.authorizedFlag().value;
      } else {
        attributes.authorize = 0;
      }
    } else {
      attributes.authorize = opts.authorize;
    }
    var allowTrustOp = new _stellarXdr_generated2.default.AllowTrustOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.allowTrust(allowTrustOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return allow_trust;
}
var bump_sequence = {};
var hasRequiredBump_sequence;
function requireBump_sequence() {
  if (hasRequiredBump_sequence) return bump_sequence;
  hasRequiredBump_sequence = 1;
  Object.defineProperty(bump_sequence, "__esModule", {
    value: true
  });
  bump_sequence.bumpSequence = bumpSequence;
  var _jsXdr = requireLib$3();
  var _bignumber = requireBignumber();
  var _bignumber2 = _interopRequireDefault(_bignumber);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function bumpSequence(opts) {
    var attributes = {};
    if (!(0, _isString2.default)(opts.bumpTo)) {
      throw new Error("bumpTo must be a string");
    }
    try {
      new _bignumber2.default(opts.bumpTo);
    } catch (e) {
      throw new Error("bumpTo must be a stringified number");
    }
    attributes.bumpTo = _jsXdr.Hyper.fromString(opts.bumpTo);
    var bumpSequenceOp = new _stellarXdr_generated2.default.BumpSequenceOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.bumpSequence(bumpSequenceOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return bump_sequence;
}
var change_trust = {};
var hasRequiredChange_trust;
function requireChange_trust() {
  if (hasRequiredChange_trust) return change_trust;
  hasRequiredChange_trust = 1;
  Object.defineProperty(change_trust, "__esModule", {
    value: true
  });
  change_trust.changeTrust = changeTrust;
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _jsXdr = requireLib$3();
  var _bignumber = requireBignumber();
  var _bignumber2 = _interopRequireDefault(_bignumber);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _asset = requireAsset();
  var _liquidity_pool_asset = requireLiquidity_pool_asset();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var MAX_INT642 = "9223372036854775807";
  function changeTrust(opts) {
    var attributes = {};
    if (opts.asset instanceof _asset.Asset) {
      attributes.line = opts.asset.toChangeTrustXDRObject();
    } else if (opts.asset instanceof _liquidity_pool_asset.LiquidityPoolAsset) {
      attributes.line = opts.asset.toXDRObject();
    } else {
      throw new TypeError("asset must be Asset or LiquidityPoolAsset");
    }
    if (!(0, _isUndefined2.default)(opts.limit) && !this.isValidAmount(opts.limit, true)) {
      throw new TypeError(this.constructAmountRequirementsError("limit"));
    }
    if (opts.limit) {
      attributes.limit = this._toXDRAmount(opts.limit);
    } else {
      attributes.limit = _jsXdr.Hyper.fromString(new _bignumber2.default(MAX_INT642).toString());
    }
    if (opts.source) {
      attributes.source = opts.source.masterKeypair;
    }
    var changeTrustOP = new _stellarXdr_generated2.default.ChangeTrustOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.changeTrust(changeTrustOP);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return change_trust;
}
var create_account = {};
var hasRequiredCreate_account;
function requireCreate_account() {
  if (hasRequiredCreate_account) return create_account;
  hasRequiredCreate_account = 1;
  Object.defineProperty(create_account, "__esModule", {
    value: true
  });
  create_account.createAccount = createAccount;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _keypair = requireKeypair();
  var _strkey = requireStrkey();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function createAccount(opts) {
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.destination)) {
      throw new Error("destination is invalid");
    }
    if (!this.isValidAmount(opts.startingBalance, true)) {
      throw new TypeError("startingBalance must be of type String, represent a non-negative number and have at most 7 digits after the decimal");
    }
    var attributes = {};
    attributes.destination = _keypair.Keypair.fromPublicKey(opts.destination).xdrAccountId();
    attributes.startingBalance = this._toXDRAmount(opts.startingBalance);
    var createAccountOp = new _stellarXdr_generated2.default.CreateAccountOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.createAccount(createAccountOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return create_account;
}
var create_claimable_balance = {};
var hasRequiredCreate_claimable_balance;
function requireCreate_claimable_balance() {
  if (hasRequiredCreate_claimable_balance) return create_claimable_balance;
  hasRequiredCreate_claimable_balance = 1;
  Object.defineProperty(create_claimable_balance, "__esModule", {
    value: true
  });
  create_claimable_balance.createClaimableBalance = createClaimableBalance;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _asset = requireAsset();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function createClaimableBalance(opts) {
    if (!(opts.asset instanceof _asset.Asset)) {
      throw new Error("must provide an asset for create claimable balance operation");
    }
    if (!this.isValidAmount(opts.amount)) {
      throw new TypeError(this.constructAmountRequirementsError("amount"));
    }
    if (!Array.isArray(opts.claimants) || opts.claimants.length === 0) {
      throw new Error("must provide at least one claimant");
    }
    var attributes = {};
    attributes.asset = opts.asset.toXDRObject();
    attributes.amount = this._toXDRAmount(opts.amount);
    attributes.claimants = opts.claimants.map(function(c) {
      return c.toXDRObject();
    });
    var createClaimableBalanceOp = new _stellarXdr_generated2.default.CreateClaimableBalanceOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.createClaimableBalance(createClaimableBalanceOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return create_claimable_balance;
}
var claim_claimable_balance = {};
var hasRequiredClaim_claimable_balance;
function requireClaim_claimable_balance() {
  if (hasRequiredClaim_claimable_balance) return claim_claimable_balance;
  hasRequiredClaim_claimable_balance = 1;
  Object.defineProperty(claim_claimable_balance, "__esModule", {
    value: true
  });
  claim_claimable_balance.claimClaimableBalance = claimClaimableBalance;
  claim_claimable_balance.validateClaimableBalanceId = validateClaimableBalanceId;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function claimClaimableBalance() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    validateClaimableBalanceId(opts.balanceId);
    var attributes = {};
    attributes.balanceId = _stellarXdr_generated2.default.ClaimableBalanceId.fromXDR(opts.balanceId, "hex");
    var claimClaimableBalanceOp = new _stellarXdr_generated2.default.ClaimClaimableBalanceOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.claimClaimableBalance(claimClaimableBalanceOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  function validateClaimableBalanceId(balanceId) {
    if (typeof balanceId !== "string" || balanceId.length !== 8 + 64) {
      throw new Error("must provide a valid claimable balance id");
    }
  }
  return claim_claimable_balance;
}
var clawback_claimable_balance = {};
var hasRequiredClawback_claimable_balance;
function requireClawback_claimable_balance() {
  if (hasRequiredClawback_claimable_balance) return clawback_claimable_balance;
  hasRequiredClawback_claimable_balance = 1;
  Object.defineProperty(clawback_claimable_balance, "__esModule", {
    value: true
  });
  clawback_claimable_balance.clawbackClaimableBalance = clawbackClaimableBalance;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _claim_claimable_balance = requireClaim_claimable_balance();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function clawbackClaimableBalance() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    (0, _claim_claimable_balance.validateClaimableBalanceId)(opts.balanceId);
    var attributes = {
      balanceId: _stellarXdr_generated2.default.ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
    };
    var opAttributes = {
      body: _stellarXdr_generated2.default.OperationBody.clawbackClaimableBalance(new _stellarXdr_generated2.default.ClawbackClaimableBalanceOp(attributes))
    };
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return clawback_claimable_balance;
}
var inflation = {};
var hasRequiredInflation;
function requireInflation() {
  if (hasRequiredInflation) return inflation;
  hasRequiredInflation = 1;
  Object.defineProperty(inflation, "__esModule", {
    value: true
  });
  inflation.inflation = inflation$1;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function inflation$1() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.inflation();
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return inflation;
}
var manage_data = {};
var hasRequiredManage_data;
function requireManage_data() {
  if (hasRequiredManage_data) return manage_data;
  hasRequiredManage_data = 1;
  Object.defineProperty(manage_data, "__esModule", {
    value: true
  });
  manage_data.manageData = manageData;
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function manageData(opts) {
    var attributes = {};
    if (!((0, _isString2.default)(opts.name) && opts.name.length <= 64)) {
      throw new Error("name must be a string, up to 64 characters");
    }
    attributes.dataName = opts.name;
    if (!(0, _isString2.default)(opts.value) && !Buffer.isBuffer(opts.value) && opts.value !== null) {
      throw new Error("value must be a string, Buffer or null");
    }
    if ((0, _isString2.default)(opts.value)) {
      attributes.dataValue = Buffer.from(opts.value);
    } else {
      attributes.dataValue = opts.value;
    }
    if (attributes.dataValue !== null && attributes.dataValue.length > 64) {
      throw new Error("value cannot be longer that 64 bytes");
    }
    var manageDataOp = new _stellarXdr_generated2.default.ManageDataOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.manageData(manageDataOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return manage_data;
}
var manage_buy_offer = {};
var hasRequiredManage_buy_offer;
function requireManage_buy_offer() {
  if (hasRequiredManage_buy_offer) return manage_buy_offer;
  hasRequiredManage_buy_offer = 1;
  Object.defineProperty(manage_buy_offer, "__esModule", {
    value: true
  });
  manage_buy_offer.manageBuyOffer = manageBuyOffer;
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _jsXdr = requireLib$3();
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function manageBuyOffer(opts) {
    var attributes = {};
    attributes.selling = opts.selling.toXDRObject();
    attributes.buying = opts.buying.toXDRObject();
    if (!this.isValidAmount(opts.buyAmount, true)) {
      throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
    }
    attributes.buyAmount = this._toXDRAmount(opts.buyAmount);
    if ((0, _isUndefined2.default)(opts.price)) {
      throw new TypeError("price argument is required");
    }
    attributes.price = this._toXDRPrice(opts.price);
    if (!(0, _isUndefined2.default)(opts.offerId)) {
      opts.offerId = opts.offerId.toString();
    } else {
      opts.offerId = "0";
    }
    attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
    var manageBuyOfferOp = new _stellarXdr_generated2.default.ManageBuyOfferOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.manageBuyOffer(manageBuyOfferOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return manage_buy_offer;
}
var path_payment_strict_receive = {};
var hasRequiredPath_payment_strict_receive;
function requirePath_payment_strict_receive() {
  if (hasRequiredPath_payment_strict_receive) return path_payment_strict_receive;
  hasRequiredPath_payment_strict_receive = 1;
  Object.defineProperty(path_payment_strict_receive, "__esModule", {
    value: true
  });
  path_payment_strict_receive.pathPaymentStrictReceive = pathPaymentStrictReceive;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function pathPaymentStrictReceive(opts) {
    switch (true) {
      case !opts.sendAsset:
        throw new Error("Must specify a send asset");
      case !this.isValidAmount(opts.sendMax):
        throw new TypeError(this.constructAmountRequirementsError("sendMax"));
      case !opts.destAsset:
        throw new Error("Must provide a destAsset for a payment operation");
      case !this.isValidAmount(opts.destAmount):
        throw new TypeError(this.constructAmountRequirementsError("destAmount"));
    }
    var attributes = {};
    attributes.sendAsset = opts.sendAsset.toXDRObject();
    attributes.sendMax = this._toXDRAmount(opts.sendMax);
    try {
      attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination, opts.withMuxing);
    } catch (e) {
      throw new Error("destination is invalid");
    }
    attributes.destAsset = opts.destAsset.toXDRObject();
    attributes.destAmount = this._toXDRAmount(opts.destAmount);
    var path2 = opts.path ? opts.path : [];
    attributes.path = path2.map(function(x) {
      return x.toXDRObject();
    });
    var payment2 = new _stellarXdr_generated2.default.PathPaymentStrictReceiveOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.pathPaymentStrictReceive(payment2);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return path_payment_strict_receive;
}
var path_payment_strict_send = {};
var hasRequiredPath_payment_strict_send;
function requirePath_payment_strict_send() {
  if (hasRequiredPath_payment_strict_send) return path_payment_strict_send;
  hasRequiredPath_payment_strict_send = 1;
  Object.defineProperty(path_payment_strict_send, "__esModule", {
    value: true
  });
  path_payment_strict_send.pathPaymentStrictSend = pathPaymentStrictSend;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function pathPaymentStrictSend(opts) {
    switch (true) {
      case !opts.sendAsset:
        throw new Error("Must specify a send asset");
      case !this.isValidAmount(opts.sendAmount):
        throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
      case !opts.destAsset:
        throw new Error("Must provide a destAsset for a payment operation");
      case !this.isValidAmount(opts.destMin):
        throw new TypeError(this.constructAmountRequirementsError("destMin"));
    }
    var attributes = {};
    attributes.sendAsset = opts.sendAsset.toXDRObject();
    attributes.sendAmount = this._toXDRAmount(opts.sendAmount);
    try {
      attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination, opts.withMuxing);
    } catch (e) {
      throw new Error("destination is invalid");
    }
    attributes.destAsset = opts.destAsset.toXDRObject();
    attributes.destMin = this._toXDRAmount(opts.destMin);
    var path2 = opts.path ? opts.path : [];
    attributes.path = path2.map(function(x) {
      return x.toXDRObject();
    });
    var payment2 = new _stellarXdr_generated2.default.PathPaymentStrictSendOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.pathPaymentStrictSend(payment2);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return path_payment_strict_send;
}
var payment = {};
var hasRequiredPayment;
function requirePayment() {
  if (hasRequiredPayment) return payment;
  hasRequiredPayment = 1;
  Object.defineProperty(payment, "__esModule", {
    value: true
  });
  payment.payment = payment$12;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function payment$12(opts) {
    if (!opts.asset) {
      throw new Error("Must provide an asset for a payment operation");
    }
    if (!this.isValidAmount(opts.amount)) {
      throw new TypeError(this.constructAmountRequirementsError("amount"));
    }
    var attributes = {};
    try {
      attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination, opts.withMuxing);
    } catch (e) {
      throw new Error("destination is invalid; did you forget to enable muxing?");
    }
    attributes.asset = opts.asset.toXDRObject();
    attributes.amount = this._toXDRAmount(opts.amount);
    var paymentOp = new _stellarXdr_generated2.default.PaymentOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.payment(paymentOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return payment;
}
var set_options = {};
var hasRequiredSet_options;
function requireSet_options() {
  if (hasRequiredSet_options) return set_options;
  hasRequiredSet_options = 1;
  Object.defineProperty(set_options, "__esModule", {
    value: true
  });
  set_options.setOptions = setOptions;
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _keypair = requireKeypair();
  var _strkey = requireStrkey();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function weightCheckFunction(value, name) {
    if (value >= 0 && value <= 255) {
      return true;
    }
    throw new Error(name + " value must be between 0 and 255");
  }
  function setOptions(opts) {
    var attributes = {};
    if (opts.inflationDest) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.inflationDest)) {
        throw new Error("inflationDest is invalid");
      }
      attributes.inflationDest = _keypair.Keypair.fromPublicKey(opts.inflationDest).xdrAccountId();
    }
    attributes.clearFlags = this._checkUnsignedIntValue("clearFlags", opts.clearFlags);
    attributes.setFlags = this._checkUnsignedIntValue("setFlags", opts.setFlags);
    attributes.masterWeight = this._checkUnsignedIntValue("masterWeight", opts.masterWeight, weightCheckFunction);
    attributes.lowThreshold = this._checkUnsignedIntValue("lowThreshold", opts.lowThreshold, weightCheckFunction);
    attributes.medThreshold = this._checkUnsignedIntValue("medThreshold", opts.medThreshold, weightCheckFunction);
    attributes.highThreshold = this._checkUnsignedIntValue("highThreshold", opts.highThreshold, weightCheckFunction);
    if (!(0, _isUndefined2.default)(opts.homeDomain) && !(0, _isString2.default)(opts.homeDomain)) {
      throw new TypeError("homeDomain argument must be of type String");
    }
    attributes.homeDomain = opts.homeDomain;
    if (opts.signer) {
      var weight = this._checkUnsignedIntValue("signer.weight", opts.signer.weight, weightCheckFunction);
      var key2 = void 0;
      var setValues = 0;
      if (opts.signer.ed25519PublicKey) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
          throw new Error("signer.ed25519PublicKey is invalid.");
        }
        var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
        key2 = new _stellarXdr_generated2.default.SignerKey.signerKeyTypeEd25519(rawKey);
        setValues += 1;
      }
      if (opts.signer.preAuthTx) {
        if ((0, _isString2.default)(opts.signer.preAuthTx)) {
          opts.signer.preAuthTx = Buffer.from(opts.signer.preAuthTx, "hex");
        }
        if (!(Buffer.isBuffer(opts.signer.preAuthTx) && opts.signer.preAuthTx.length === 32)) {
          throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
        }
        key2 = new _stellarXdr_generated2.default.SignerKey.signerKeyTypePreAuthTx(opts.signer.preAuthTx);
        setValues += 1;
      }
      if (opts.signer.sha256Hash) {
        if ((0, _isString2.default)(opts.signer.sha256Hash)) {
          opts.signer.sha256Hash = Buffer.from(opts.signer.sha256Hash, "hex");
        }
        if (!(Buffer.isBuffer(opts.signer.sha256Hash) && opts.signer.sha256Hash.length === 32)) {
          throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
        }
        key2 = new _stellarXdr_generated2.default.SignerKey.signerKeyTypeHashX(opts.signer.sha256Hash);
        setValues += 1;
      }
      if (setValues !== 1) {
        throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
      }
      attributes.signer = new _stellarXdr_generated2.default.Signer({ key: key2, weight });
    }
    var setOptionsOp = new _stellarXdr_generated2.default.SetOptionsOp(attributes);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.setOptions(setOptionsOp);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return set_options;
}
var begin_sponsoring_future_reserves = {};
var hasRequiredBegin_sponsoring_future_reserves;
function requireBegin_sponsoring_future_reserves() {
  if (hasRequiredBegin_sponsoring_future_reserves) return begin_sponsoring_future_reserves;
  hasRequiredBegin_sponsoring_future_reserves = 1;
  Object.defineProperty(begin_sponsoring_future_reserves, "__esModule", {
    value: true
  });
  begin_sponsoring_future_reserves.beginSponsoringFutureReserves = beginSponsoringFutureReserves;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _strkey = requireStrkey();
  var _keypair = requireKeypair();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function beginSponsoringFutureReserves() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.sponsoredId)) {
      throw new Error("sponsoredId is invalid");
    }
    var op = new _stellarXdr_generated2.default.BeginSponsoringFutureReservesOp({
      sponsoredId: _keypair.Keypair.fromPublicKey(opts.sponsoredId).xdrAccountId()
    });
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.beginSponsoringFutureReserves(op);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return begin_sponsoring_future_reserves;
}
var end_sponsoring_future_reserves = {};
var hasRequiredEnd_sponsoring_future_reserves;
function requireEnd_sponsoring_future_reserves() {
  if (hasRequiredEnd_sponsoring_future_reserves) return end_sponsoring_future_reserves;
  hasRequiredEnd_sponsoring_future_reserves = 1;
  Object.defineProperty(end_sponsoring_future_reserves, "__esModule", {
    value: true
  });
  end_sponsoring_future_reserves.endSponsoringFutureReserves = endSponsoringFutureReserves;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function endSponsoringFutureReserves() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.endSponsoringFutureReserves();
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return end_sponsoring_future_reserves;
}
var revoke_sponsorship = {};
var hasRequiredRevoke_sponsorship;
function requireRevoke_sponsorship() {
  if (hasRequiredRevoke_sponsorship) return revoke_sponsorship;
  hasRequiredRevoke_sponsorship = 1;
  Object.defineProperty(revoke_sponsorship, "__esModule", {
    value: true
  });
  revoke_sponsorship.revokeAccountSponsorship = revokeAccountSponsorship;
  revoke_sponsorship.revokeTrustlineSponsorship = revokeTrustlineSponsorship;
  revoke_sponsorship.revokeOfferSponsorship = revokeOfferSponsorship;
  revoke_sponsorship.revokeDataSponsorship = revokeDataSponsorship;
  revoke_sponsorship.revokeClaimableBalanceSponsorship = revokeClaimableBalanceSponsorship;
  revoke_sponsorship.revokeLiquidityPoolSponsorship = revokeLiquidityPoolSponsorship;
  revoke_sponsorship.revokeSignerSponsorship = revokeSignerSponsorship;
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _strkey = requireStrkey();
  var _keypair = requireKeypair();
  var _asset = requireAsset();
  var _liquidity_pool_id = requireLiquidity_pool_id();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function revokeAccountSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
      throw new Error("account is invalid");
    }
    var ledgerKey = _stellarXdr_generated2.default.LedgerKey.account(new _stellarXdr_generated2.default.LedgerKeyAccount({
      accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId()
    }));
    var op = _stellarXdr_generated2.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  function revokeTrustlineSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
      throw new Error("account is invalid");
    }
    var asset2 = void 0;
    if (opts.asset instanceof _asset.Asset) {
      asset2 = opts.asset.toTrustLineXDRObject();
    } else if (opts.asset instanceof _liquidity_pool_id.LiquidityPoolId) {
      asset2 = opts.asset.toXDRObject();
    } else {
      throw new TypeError("asset must be an Asset or LiquidityPoolId");
    }
    var ledgerKey = _stellarXdr_generated2.default.LedgerKey.trustline(new _stellarXdr_generated2.default.LedgerKeyTrustLine({
      accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
      asset: asset2
    }));
    var op = _stellarXdr_generated2.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  function revokeOfferSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.seller)) {
      throw new Error("seller is invalid");
    }
    if (!(0, _isString2.default)(opts.offerId)) {
      throw new Error("offerId is invalid");
    }
    var ledgerKey = _stellarXdr_generated2.default.LedgerKey.offer(new _stellarXdr_generated2.default.LedgerKeyOffer({
      sellerId: _keypair.Keypair.fromPublicKey(opts.seller).xdrAccountId(),
      offerId: _stellarXdr_generated2.default.Int64.fromString(opts.offerId)
    }));
    var op = _stellarXdr_generated2.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  function revokeDataSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
      throw new Error("account is invalid");
    }
    if (!(0, _isString2.default)(opts.name) || opts.name.length > 64) {
      throw new Error("name must be a string, up to 64 characters");
    }
    var ledgerKey = _stellarXdr_generated2.default.LedgerKey.data(new _stellarXdr_generated2.default.LedgerKeyData({
      accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
      dataName: opts.name
    }));
    var op = _stellarXdr_generated2.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  function revokeClaimableBalanceSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(0, _isString2.default)(opts.balanceId)) {
      throw new Error("balanceId is invalid");
    }
    var ledgerKey = _stellarXdr_generated2.default.LedgerKey.claimableBalance(new _stellarXdr_generated2.default.LedgerKeyClaimableBalance({
      balanceId: _stellarXdr_generated2.default.ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
    }));
    var op = _stellarXdr_generated2.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  function revokeLiquidityPoolSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(0, _isString2.default)(opts.liquidityPoolId)) {
      throw new Error("liquidityPoolId is invalid");
    }
    var ledgerKey = _stellarXdr_generated2.default.LedgerKey.liquidityPool(new _stellarXdr_generated2.default.LedgerKeyLiquidityPool({
      liquidityPoolId: _stellarXdr_generated2.default.PoolId.fromXDR(opts.liquidityPoolId, "hex")
    }));
    var op = _stellarXdr_generated2.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {
      body: _stellarXdr_generated2.default.OperationBody.revokeSponsorship(op)
    };
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  function revokeSignerSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
      throw new Error("account is invalid");
    }
    var key2 = void 0;
    if (opts.signer.ed25519PublicKey) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
        throw new Error("signer.ed25519PublicKey is invalid.");
      }
      var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
      key2 = new _stellarXdr_generated2.default.SignerKey.signerKeyTypeEd25519(rawKey);
    } else if (opts.signer.preAuthTx) {
      var buffer2 = void 0;
      if ((0, _isString2.default)(opts.signer.preAuthTx)) {
        buffer2 = Buffer.from(opts.signer.preAuthTx, "hex");
      } else {
        buffer2 = opts.signer.preAuthTx;
      }
      if (!(Buffer.isBuffer(buffer2) && buffer2.length === 32)) {
        throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
      }
      key2 = new _stellarXdr_generated2.default.SignerKey.signerKeyTypePreAuthTx(buffer2);
    } else if (opts.signer.sha256Hash) {
      var _buffer = void 0;
      if ((0, _isString2.default)(opts.signer.sha256Hash)) {
        _buffer = Buffer.from(opts.signer.sha256Hash, "hex");
      } else {
        _buffer = opts.signer.sha256Hash;
      }
      if (!(Buffer.isBuffer(_buffer) && _buffer.length === 32)) {
        throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
      }
      key2 = new _stellarXdr_generated2.default.SignerKey.signerKeyTypeHashX(_buffer);
    } else {
      throw new Error("signer is invalid");
    }
    var signer = new _stellarXdr_generated2.default.RevokeSponsorshipOpSigner({
      accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
      signerKey: key2
    });
    var op = _stellarXdr_generated2.default.RevokeSponsorshipOp.revokeSponsorshipSigner(signer);
    var opAttributes = {};
    opAttributes.body = _stellarXdr_generated2.default.OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return revoke_sponsorship;
}
var clawback = {};
var hasRequiredClawback;
function requireClawback() {
  if (hasRequiredClawback) return clawback;
  hasRequiredClawback = 1;
  Object.defineProperty(clawback, "__esModule", {
    value: true
  });
  clawback.clawback = clawback$1;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function clawback$1() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var attributes = {};
    if (!this.isValidAmount(opts.amount)) {
      throw new TypeError(this.constructAmountRequirementsError("amount"));
    }
    attributes.amount = this._toXDRAmount(opts.amount);
    attributes.asset = opts.asset.toXDRObject();
    attributes.from = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.from);
    var opAttributes = {
      body: _stellarXdr_generated2.default.OperationBody.clawback(new _stellarXdr_generated2.default.ClawbackOp(attributes))
    };
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return clawback;
}
var set_trustline_flags = {};
var hasRequiredSet_trustline_flags;
function requireSet_trustline_flags() {
  if (hasRequiredSet_trustline_flags) return set_trustline_flags;
  hasRequiredSet_trustline_flags = 1;
  Object.defineProperty(set_trustline_flags, "__esModule", {
    value: true
  });
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  set_trustline_flags.setTrustLineFlags = setTrustLineFlags;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _keypair = requireKeypair();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function setTrustLineFlags() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var attributes = {};
    if (_typeof2(opts.flags) !== "object" || Object.keys(opts.flags).length === 0) {
      throw new Error("opts.flags must be an map of boolean flags to modify");
    }
    var mapping = {
      authorized: _stellarXdr_generated2.default.TrustLineFlags.authorizedFlag(),
      authorizedToMaintainLiabilities: _stellarXdr_generated2.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
      clawbackEnabled: _stellarXdr_generated2.default.TrustLineFlags.trustlineClawbackEnabledFlag()
    };
    var clearFlag = 0;
    var setFlag = 0;
    Object.keys(opts.flags).forEach(function(flagName) {
      if (!Object.prototype.hasOwnProperty.call(mapping, flagName)) {
        throw new Error("unsupported flag name specified: " + flagName);
      }
      var flagValue = opts.flags[flagName];
      var bit = mapping[flagName].value;
      if (flagValue === true) {
        setFlag |= bit;
      } else if (flagValue === false) {
        clearFlag |= bit;
      }
    });
    attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
    attributes.asset = opts.asset.toXDRObject();
    attributes.clearFlags = clearFlag;
    attributes.setFlags = setFlag;
    var opAttributes = {
      body: _stellarXdr_generated2.default.OperationBody.setTrustLineFlags(new _stellarXdr_generated2.default.SetTrustLineFlagsOp(attributes))
    };
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return set_trustline_flags;
}
var liquidity_pool_deposit = {};
var hasRequiredLiquidity_pool_deposit;
function requireLiquidity_pool_deposit() {
  if (hasRequiredLiquidity_pool_deposit) return liquidity_pool_deposit;
  hasRequiredLiquidity_pool_deposit = 1;
  Object.defineProperty(liquidity_pool_deposit, "__esModule", {
    value: true
  });
  liquidity_pool_deposit.liquidityPoolDeposit = liquidityPoolDeposit;
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function liquidityPoolDeposit() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var liquidityPoolId = opts.liquidityPoolId, maxAmountA = opts.maxAmountA, maxAmountB = opts.maxAmountB, minPrice = opts.minPrice, maxPrice = opts.maxPrice;
    var attributes = {};
    if (!liquidityPoolId) {
      throw new TypeError("liquidityPoolId argument is required");
    }
    attributes.liquidityPoolId = _stellarXdr_generated2.default.PoolId.fromXDR(liquidityPoolId, "hex");
    if (!this.isValidAmount(maxAmountA, true)) {
      throw new TypeError("maxAmountA argument is required");
    }
    attributes.maxAmountA = this._toXDRAmount(maxAmountA);
    if (!this.isValidAmount(maxAmountB, true)) {
      throw new TypeError("maxAmountB argument is required");
    }
    attributes.maxAmountB = this._toXDRAmount(maxAmountB);
    if ((0, _isUndefined2.default)(minPrice)) {
      throw new TypeError("minPrice argument is required");
    }
    attributes.minPrice = this._toXDRPrice(minPrice);
    if ((0, _isUndefined2.default)(maxPrice)) {
      throw new TypeError("maxPrice argument is required");
    }
    attributes.maxPrice = this._toXDRPrice(maxPrice);
    var liquidityPoolDepositOp = new _stellarXdr_generated2.default.LiquidityPoolDepositOp(attributes);
    var opAttributes = {
      body: _stellarXdr_generated2.default.OperationBody.liquidityPoolDeposit(liquidityPoolDepositOp)
    };
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return liquidity_pool_deposit;
}
var liquidity_pool_withdraw = {};
var hasRequiredLiquidity_pool_withdraw;
function requireLiquidity_pool_withdraw() {
  if (hasRequiredLiquidity_pool_withdraw) return liquidity_pool_withdraw;
  hasRequiredLiquidity_pool_withdraw = 1;
  Object.defineProperty(liquidity_pool_withdraw, "__esModule", {
    value: true
  });
  liquidity_pool_withdraw.liquidityPoolWithdraw = liquidityPoolWithdraw;
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function liquidityPoolWithdraw() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var attributes = {};
    if (!opts.liquidityPoolId) {
      throw new TypeError("liquidityPoolId argument is required");
    }
    attributes.liquidityPoolId = _stellarXdr_generated2.default.PoolId.fromXDR(opts.liquidityPoolId, "hex");
    if (!this.isValidAmount(opts.amount)) {
      throw new TypeError("amount argument is required");
    }
    attributes.amount = this._toXDRAmount(opts.amount);
    if (!this.isValidAmount(opts.minAmountA, true)) {
      throw new TypeError("minAmountA argument is required");
    }
    attributes.minAmountA = this._toXDRAmount(opts.minAmountA);
    if (!this.isValidAmount(opts.minAmountB, true)) {
      throw new TypeError("minAmountB argument is required");
    }
    attributes.minAmountB = this._toXDRAmount(opts.minAmountB);
    var liquidityPoolWithdrawOp = new _stellarXdr_generated2.default.LiquidityPoolWithdrawOp(attributes);
    var opAttributes = {
      body: _stellarXdr_generated2.default.OperationBody.liquidityPoolWithdraw(liquidityPoolWithdrawOp)
    };
    this.setSourceAccount(opAttributes, opts);
    return new _stellarXdr_generated2.default.Operation(opAttributes);
  }
  return liquidity_pool_withdraw;
}
var hasRequiredOperations;
function requireOperations() {
  if (hasRequiredOperations) return operations;
  hasRequiredOperations = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _manage_sell_offer = requireManage_sell_offer();
    Object.defineProperty(exports2, "manageSellOffer", {
      enumerable: true,
      get: function get3() {
        return _manage_sell_offer.manageSellOffer;
      }
    });
    var _create_passive_sell_offer = requireCreate_passive_sell_offer();
    Object.defineProperty(exports2, "createPassiveSellOffer", {
      enumerable: true,
      get: function get3() {
        return _create_passive_sell_offer.createPassiveSellOffer;
      }
    });
    var _account_merge = requireAccount_merge();
    Object.defineProperty(exports2, "accountMerge", {
      enumerable: true,
      get: function get3() {
        return _account_merge.accountMerge;
      }
    });
    var _allow_trust = requireAllow_trust();
    Object.defineProperty(exports2, "allowTrust", {
      enumerable: true,
      get: function get3() {
        return _allow_trust.allowTrust;
      }
    });
    var _bump_sequence = requireBump_sequence();
    Object.defineProperty(exports2, "bumpSequence", {
      enumerable: true,
      get: function get3() {
        return _bump_sequence.bumpSequence;
      }
    });
    var _change_trust = requireChange_trust();
    Object.defineProperty(exports2, "changeTrust", {
      enumerable: true,
      get: function get3() {
        return _change_trust.changeTrust;
      }
    });
    var _create_account = requireCreate_account();
    Object.defineProperty(exports2, "createAccount", {
      enumerable: true,
      get: function get3() {
        return _create_account.createAccount;
      }
    });
    var _create_claimable_balance = requireCreate_claimable_balance();
    Object.defineProperty(exports2, "createClaimableBalance", {
      enumerable: true,
      get: function get3() {
        return _create_claimable_balance.createClaimableBalance;
      }
    });
    var _claim_claimable_balance = requireClaim_claimable_balance();
    Object.defineProperty(exports2, "claimClaimableBalance", {
      enumerable: true,
      get: function get3() {
        return _claim_claimable_balance.claimClaimableBalance;
      }
    });
    var _clawback_claimable_balance = requireClawback_claimable_balance();
    Object.defineProperty(exports2, "clawbackClaimableBalance", {
      enumerable: true,
      get: function get3() {
        return _clawback_claimable_balance.clawbackClaimableBalance;
      }
    });
    var _inflation = requireInflation();
    Object.defineProperty(exports2, "inflation", {
      enumerable: true,
      get: function get3() {
        return _inflation.inflation;
      }
    });
    var _manage_data = requireManage_data();
    Object.defineProperty(exports2, "manageData", {
      enumerable: true,
      get: function get3() {
        return _manage_data.manageData;
      }
    });
    var _manage_buy_offer = requireManage_buy_offer();
    Object.defineProperty(exports2, "manageBuyOffer", {
      enumerable: true,
      get: function get3() {
        return _manage_buy_offer.manageBuyOffer;
      }
    });
    var _path_payment_strict_receive = requirePath_payment_strict_receive();
    Object.defineProperty(exports2, "pathPaymentStrictReceive", {
      enumerable: true,
      get: function get3() {
        return _path_payment_strict_receive.pathPaymentStrictReceive;
      }
    });
    var _path_payment_strict_send = requirePath_payment_strict_send();
    Object.defineProperty(exports2, "pathPaymentStrictSend", {
      enumerable: true,
      get: function get3() {
        return _path_payment_strict_send.pathPaymentStrictSend;
      }
    });
    var _payment = requirePayment();
    Object.defineProperty(exports2, "payment", {
      enumerable: true,
      get: function get3() {
        return _payment.payment;
      }
    });
    var _set_options = requireSet_options();
    Object.defineProperty(exports2, "setOptions", {
      enumerable: true,
      get: function get3() {
        return _set_options.setOptions;
      }
    });
    var _begin_sponsoring_future_reserves = requireBegin_sponsoring_future_reserves();
    Object.defineProperty(exports2, "beginSponsoringFutureReserves", {
      enumerable: true,
      get: function get3() {
        return _begin_sponsoring_future_reserves.beginSponsoringFutureReserves;
      }
    });
    var _end_sponsoring_future_reserves = requireEnd_sponsoring_future_reserves();
    Object.defineProperty(exports2, "endSponsoringFutureReserves", {
      enumerable: true,
      get: function get3() {
        return _end_sponsoring_future_reserves.endSponsoringFutureReserves;
      }
    });
    var _revoke_sponsorship = requireRevoke_sponsorship();
    Object.defineProperty(exports2, "revokeAccountSponsorship", {
      enumerable: true,
      get: function get3() {
        return _revoke_sponsorship.revokeAccountSponsorship;
      }
    });
    Object.defineProperty(exports2, "revokeTrustlineSponsorship", {
      enumerable: true,
      get: function get3() {
        return _revoke_sponsorship.revokeTrustlineSponsorship;
      }
    });
    Object.defineProperty(exports2, "revokeOfferSponsorship", {
      enumerable: true,
      get: function get3() {
        return _revoke_sponsorship.revokeOfferSponsorship;
      }
    });
    Object.defineProperty(exports2, "revokeDataSponsorship", {
      enumerable: true,
      get: function get3() {
        return _revoke_sponsorship.revokeDataSponsorship;
      }
    });
    Object.defineProperty(exports2, "revokeClaimableBalanceSponsorship", {
      enumerable: true,
      get: function get3() {
        return _revoke_sponsorship.revokeClaimableBalanceSponsorship;
      }
    });
    Object.defineProperty(exports2, "revokeLiquidityPoolSponsorship", {
      enumerable: true,
      get: function get3() {
        return _revoke_sponsorship.revokeLiquidityPoolSponsorship;
      }
    });
    Object.defineProperty(exports2, "revokeSignerSponsorship", {
      enumerable: true,
      get: function get3() {
        return _revoke_sponsorship.revokeSignerSponsorship;
      }
    });
    var _clawback = requireClawback();
    Object.defineProperty(exports2, "clawback", {
      enumerable: true,
      get: function get3() {
        return _clawback.clawback;
      }
    });
    var _set_trustline_flags = requireSet_trustline_flags();
    Object.defineProperty(exports2, "setTrustLineFlags", {
      enumerable: true,
      get: function get3() {
        return _set_trustline_flags.setTrustLineFlags;
      }
    });
    var _liquidity_pool_deposit = requireLiquidity_pool_deposit();
    Object.defineProperty(exports2, "liquidityPoolDeposit", {
      enumerable: true,
      get: function get3() {
        return _liquidity_pool_deposit.liquidityPoolDeposit;
      }
    });
    var _liquidity_pool_withdraw = requireLiquidity_pool_withdraw();
    Object.defineProperty(exports2, "liquidityPoolWithdraw", {
      enumerable: true,
      get: function get3() {
        return _liquidity_pool_withdraw.liquidityPoolWithdraw;
      }
    });
  })(operations);
  return operations;
}
var hasRequiredOperation;
function requireOperation() {
  if (hasRequiredOperation) return operation;
  hasRequiredOperation = 1;
  Object.defineProperty(operation, "__esModule", {
    value: true
  });
  operation.Operation = operation.AuthClawbackEnabledFlag = operation.AuthImmutableFlag = operation.AuthRevocableFlag = operation.AuthRequiredFlag = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _jsXdr = requireLib$3();
  var _bignumber = requireBignumber();
  var _bignumber2 = _interopRequireDefault(_bignumber);
  var _trimEnd = requireTrimEnd();
  var _trimEnd2 = _interopRequireDefault(_trimEnd);
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _isNumber = requireIsNumber();
  var _isNumber2 = _interopRequireDefault(_isNumber);
  var _isFinite2 = require_isFinite();
  var _isFinite22 = _interopRequireDefault(_isFinite2);
  var _continued_fraction = requireContinued_fraction();
  var _asset = requireAsset();
  var _liquidity_pool_asset = requireLiquidity_pool_asset();
  var _claimant = requireClaimant();
  var _strkey = requireStrkey();
  var _liquidity_pool_id = requireLiquidity_pool_id();
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _index = requireOperations();
  var ops = _interopRequireWildcard(_index);
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2)) newObj[key2] = obj[key2];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var ONE = 1e7;
  var MAX_INT642 = "9223372036854775807";
  operation.AuthRequiredFlag = 1 << 0;
  operation.AuthRevocableFlag = 1 << 1;
  operation.AuthImmutableFlag = 1 << 2;
  operation.AuthClawbackEnabledFlag = 1 << 3;
  var Operation = operation.Operation = function() {
    function Operation2() {
      _classCallCheck2(this, Operation2);
    }
    _createClass2(Operation2, null, [{
      key: "setSourceAccount",
      value: function setSourceAccount(opAttributes, opts) {
        if (opts.source) {
          try {
            opAttributes.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.source, opts.withMuxing);
          } catch (e) {
            throw new Error("Source address is invalid");
          }
        }
      }
      /**
       * Deconstructs the raw XDR operation object into the structured object that
       * was used to create the operation (i.e. the `opts` parameter to most ops).
       *
       * @param {xdr.Operation}   operation - An XDR Operation.
       * @param {boolean}         [withMuxing] - Indicates that if the operation
       *     contains M... addresses, they should be interpreted fully as muxed
       *     accounts. By default, this option is disabled until muxed accounts are
       *     mature.
       *
       * @return {Operation}
       */
    }, {
      key: "fromXDRObject",
      value: function fromXDRObject(operation2, withMuxing) {
        var result = {};
        if (operation2.sourceAccount()) {
          result.source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(operation2.sourceAccount(), withMuxing);
        }
        var attrs = operation2.body().value();
        var operationName = operation2.body().switch().name;
        switch (operationName) {
          case "createAccount": {
            result.type = "createAccount";
            result.destination = accountIdtoAddress(attrs.destination());
            result.startingBalance = this._fromXDRAmount(attrs.startingBalance());
            break;
          }
          case "payment": {
            result.type = "payment";
            result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination(), withMuxing);
            result.asset = _asset.Asset.fromOperation(attrs.asset());
            result.amount = this._fromXDRAmount(attrs.amount());
            break;
          }
          case "pathPaymentStrictReceive": {
            result.type = "pathPaymentStrictReceive";
            result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
            result.sendMax = this._fromXDRAmount(attrs.sendMax());
            result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination(), withMuxing);
            result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
            result.destAmount = this._fromXDRAmount(attrs.destAmount());
            result.path = [];
            var path2 = attrs.path();
            Object.keys(path2).forEach(function(pathKey) {
              result.path.push(_asset.Asset.fromOperation(path2[pathKey]));
            });
            break;
          }
          case "pathPaymentStrictSend": {
            result.type = "pathPaymentStrictSend";
            result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
            result.sendAmount = this._fromXDRAmount(attrs.sendAmount());
            result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination(), withMuxing);
            result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
            result.destMin = this._fromXDRAmount(attrs.destMin());
            result.path = [];
            var _path = attrs.path();
            Object.keys(_path).forEach(function(pathKey) {
              result.path.push(_asset.Asset.fromOperation(_path[pathKey]));
            });
            break;
          }
          case "changeTrust": {
            result.type = "changeTrust";
            switch (attrs.line().switch()) {
              case _stellarXdr_generated2.default.AssetType.assetTypePoolShare():
                result.line = _liquidity_pool_asset.LiquidityPoolAsset.fromOperation(attrs.line());
                break;
              default:
                result.line = _asset.Asset.fromOperation(attrs.line());
                break;
            }
            result.limit = this._fromXDRAmount(attrs.limit());
            break;
          }
          case "allowTrust": {
            result.type = "allowTrust";
            result.trustor = accountIdtoAddress(attrs.trustor());
            result.assetCode = attrs.asset().value().toString();
            result.assetCode = (0, _trimEnd2.default)(result.assetCode, "\0");
            result.authorize = attrs.authorize();
            break;
          }
          case "setOptions": {
            result.type = "setOptions";
            if (attrs.inflationDest()) {
              result.inflationDest = accountIdtoAddress(attrs.inflationDest());
            }
            result.clearFlags = attrs.clearFlags();
            result.setFlags = attrs.setFlags();
            result.masterWeight = attrs.masterWeight();
            result.lowThreshold = attrs.lowThreshold();
            result.medThreshold = attrs.medThreshold();
            result.highThreshold = attrs.highThreshold();
            result.homeDomain = attrs.homeDomain() !== void 0 ? attrs.homeDomain().toString("ascii") : void 0;
            if (attrs.signer()) {
              var signer = {};
              var arm = attrs.signer().key().arm();
              if (arm === "ed25519") {
                signer.ed25519PublicKey = accountIdtoAddress(attrs.signer().key());
              } else if (arm === "preAuthTx") {
                signer.preAuthTx = attrs.signer().key().preAuthTx();
              } else if (arm === "hashX") {
                signer.sha256Hash = attrs.signer().key().hashX();
              }
              signer.weight = attrs.signer().weight();
              result.signer = signer;
            }
            break;
          }
          // the next case intentionally falls through!
          case "manageOffer":
          case "manageSellOffer": {
            result.type = "manageSellOffer";
            result.selling = _asset.Asset.fromOperation(attrs.selling());
            result.buying = _asset.Asset.fromOperation(attrs.buying());
            result.amount = this._fromXDRAmount(attrs.amount());
            result.price = this._fromXDRPrice(attrs.price());
            result.offerId = attrs.offerId().toString();
            break;
          }
          case "manageBuyOffer": {
            result.type = "manageBuyOffer";
            result.selling = _asset.Asset.fromOperation(attrs.selling());
            result.buying = _asset.Asset.fromOperation(attrs.buying());
            result.buyAmount = this._fromXDRAmount(attrs.buyAmount());
            result.price = this._fromXDRPrice(attrs.price());
            result.offerId = attrs.offerId().toString();
            break;
          }
          // the next case intentionally falls through!
          case "createPassiveOffer":
          case "createPassiveSellOffer": {
            result.type = "createPassiveSellOffer";
            result.selling = _asset.Asset.fromOperation(attrs.selling());
            result.buying = _asset.Asset.fromOperation(attrs.buying());
            result.amount = this._fromXDRAmount(attrs.amount());
            result.price = this._fromXDRPrice(attrs.price());
            break;
          }
          case "accountMerge": {
            result.type = "accountMerge";
            result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs, withMuxing);
            break;
          }
          case "manageData": {
            result.type = "manageData";
            result.name = attrs.dataName().toString("ascii");
            result.value = attrs.dataValue();
            break;
          }
          case "inflation": {
            result.type = "inflation";
            break;
          }
          case "bumpSequence": {
            result.type = "bumpSequence";
            result.bumpTo = attrs.bumpTo().toString();
            break;
          }
          case "createClaimableBalance": {
            result.type = "createClaimableBalance";
            result.asset = _asset.Asset.fromOperation(attrs.asset());
            result.amount = this._fromXDRAmount(attrs.amount());
            result.claimants = [];
            attrs.claimants().forEach(function(claimant2) {
              result.claimants.push(_claimant.Claimant.fromXDR(claimant2));
            });
            break;
          }
          case "claimClaimableBalance": {
            result.type = "claimClaimableBalance";
            result.balanceId = attrs.toXDR("hex");
            break;
          }
          case "beginSponsoringFutureReserves": {
            result.type = "beginSponsoringFutureReserves";
            result.sponsoredId = accountIdtoAddress(attrs.sponsoredId());
            break;
          }
          case "endSponsoringFutureReserves": {
            result.type = "endSponsoringFutureReserves";
            break;
          }
          case "revokeSponsorship": {
            extractRevokeSponshipDetails(attrs, result);
            break;
          }
          case "clawback": {
            result.type = "clawback";
            result.amount = this._fromXDRAmount(attrs.amount());
            result.from = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.from());
            result.asset = _asset.Asset.fromOperation(attrs.asset());
            break;
          }
          case "clawbackClaimableBalance": {
            result.type = "clawbackClaimableBalance";
            result.balanceId = attrs.toXDR("hex");
            break;
          }
          case "setTrustLineFlags": {
            result.type = "setTrustLineFlags";
            result.asset = _asset.Asset.fromOperation(attrs.asset());
            result.trustor = accountIdtoAddress(attrs.trustor());
            var clears = attrs.clearFlags();
            var sets2 = attrs.setFlags();
            var mapping = {
              authorized: _stellarXdr_generated2.default.TrustLineFlags.authorizedFlag(),
              authorizedToMaintainLiabilities: _stellarXdr_generated2.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
              clawbackEnabled: _stellarXdr_generated2.default.TrustLineFlags.trustlineClawbackEnabledFlag()
            };
            var getFlagValue = function getFlagValue2(key2) {
              var bit = mapping[key2].value;
              if (sets2 & bit) {
                return true;
              }
              if (clears & bit) {
                return false;
              }
              return void 0;
            };
            result.flags = {};
            Object.keys(mapping).forEach(function(flagName) {
              result.flags[flagName] = getFlagValue(flagName);
            });
            break;
          }
          case "liquidityPoolDeposit": {
            result.type = "liquidityPoolDeposit";
            result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
            result.maxAmountA = this._fromXDRAmount(attrs.maxAmountA());
            result.maxAmountB = this._fromXDRAmount(attrs.maxAmountB());
            result.minPrice = this._fromXDRPrice(attrs.minPrice());
            result.maxPrice = this._fromXDRPrice(attrs.maxPrice());
            break;
          }
          case "liquidityPoolWithdraw": {
            result.type = "liquidityPoolWithdraw";
            result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
            result.amount = this._fromXDRAmount(attrs.amount());
            result.minAmountA = this._fromXDRAmount(attrs.minAmountA());
            result.minAmountB = this._fromXDRAmount(attrs.minAmountB());
            break;
          }
          default: {
            throw new Error("Unknown operation: " + operationName);
          }
        }
        return result;
      }
    }, {
      key: "isValidAmount",
      value: function isValidAmount(value) {
        var allowZero = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!(0, _isString2.default)(value)) {
          return false;
        }
        var amount = void 0;
        try {
          amount = new _bignumber2.default(value);
        } catch (e) {
          return false;
        }
        if (
          // == 0
          !allowZero && amount.isZero() || // < 0
          amount.isNegative() || // > Max value
          amount.times(ONE).greaterThan(new _bignumber2.default(MAX_INT642).toString()) || // Decimal places (max 7)
          amount.decimalPlaces() > 7 || // NaN or Infinity
          amount.isNaN() || !amount.isFinite()
        ) {
          return false;
        }
        return true;
      }
    }, {
      key: "constructAmountRequirementsError",
      value: function constructAmountRequirementsError(arg) {
        return arg + " argument must be of type String, represent a positive number and have at most 7 digits after the decimal";
      }
      /**
       * Returns value converted to uint32 value or undefined.
       * If `value` is not `Number`, `String` or `Undefined` then throws an error.
       * Used in {@link Operation.setOptions}.
       * @private
       * @param {string} name Name of the property (used in error message only)
       * @param {*} value Value to check
       * @param {function(value, name)} isValidFunction Function to check other constraints (the argument will be a `Number`)
       * @returns {undefined|Number}
       */
    }, {
      key: "_checkUnsignedIntValue",
      value: function _checkUnsignedIntValue(name, value) {
        var isValidFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if ((0, _isUndefined2.default)(value)) {
          return void 0;
        }
        if ((0, _isString2.default)(value)) {
          value = parseFloat(value);
        }
        switch (true) {
          case (!(0, _isNumber2.default)(value) || !(0, _isFinite22.default)(value) || value % 1 !== 0):
            throw new Error(name + " value is invalid");
          case value < 0:
            throw new Error(name + " value must be unsigned");
          case (!isValidFunction || isValidFunction && isValidFunction(value, name)):
            return value;
          default:
            throw new Error(name + " value is invalid");
        }
      }
      /**
       * @private
       * @param {string|BigNumber} value Value
       * @returns {Hyper} XDR amount
       */
    }, {
      key: "_toXDRAmount",
      value: function _toXDRAmount(value) {
        var amount = new _bignumber2.default(value).mul(ONE);
        return _jsXdr.Hyper.fromString(amount.toString());
      }
      /**
       * @private
       * @param {string|BigNumber} value XDR amount
       * @returns {BigNumber} Number
       */
    }, {
      key: "_fromXDRAmount",
      value: function _fromXDRAmount(value) {
        return new _bignumber2.default(value).div(ONE).toFixed(7);
      }
      /**
       * @private
       * @param {object} price Price object
       * @param {function} price.n numerator function that returns a value
       * @param {function} price.d denominator function that returns a value
       * @returns {BigNumber} Big string
       */
    }, {
      key: "_fromXDRPrice",
      value: function _fromXDRPrice(price) {
        var n = new _bignumber2.default(price.n());
        return n.div(new _bignumber2.default(price.d())).toString();
      }
      /**
       * @private
       * @param {object} price Price object
       * @param {function} price.n numerator function that returns a value
       * @param {function} price.d denominator function that returns a value
       * @returns {object} XDR price object
       */
    }, {
      key: "_toXDRPrice",
      value: function _toXDRPrice(price) {
        var xdrObject = void 0;
        if (price.n && price.d) {
          xdrObject = new _stellarXdr_generated2.default.Price(price);
        } else {
          price = new _bignumber2.default(price);
          var approx = (0, _continued_fraction.best_r)(price);
          xdrObject = new _stellarXdr_generated2.default.Price({
            n: parseInt(approx[0], 10),
            d: parseInt(approx[1], 10)
          });
        }
        if (xdrObject.n() < 0 || xdrObject.d() < 0) {
          throw new Error("price must be positive");
        }
        return xdrObject;
      }
    }]);
    return Operation2;
  }();
  function extractRevokeSponshipDetails(attrs, result) {
    switch (attrs.switch().name) {
      case "revokeSponsorshipLedgerEntry": {
        var ledgerKey = attrs.ledgerKey();
        switch (ledgerKey.switch().name) {
          case _stellarXdr_generated2.default.LedgerEntryType.account().name: {
            result.type = "revokeAccountSponsorship";
            result.account = accountIdtoAddress(ledgerKey.account().accountId());
            break;
          }
          case _stellarXdr_generated2.default.LedgerEntryType.trustline().name: {
            result.type = "revokeTrustlineSponsorship";
            result.account = accountIdtoAddress(ledgerKey.trustLine().accountId());
            var xdrAsset = ledgerKey.trustLine().asset();
            switch (xdrAsset.switch()) {
              case _stellarXdr_generated2.default.AssetType.assetTypePoolShare():
                result.asset = _liquidity_pool_id.LiquidityPoolId.fromOperation(xdrAsset);
                break;
              default:
                result.asset = _asset.Asset.fromOperation(xdrAsset);
                break;
            }
            break;
          }
          case _stellarXdr_generated2.default.LedgerEntryType.offer().name: {
            result.type = "revokeOfferSponsorship";
            result.seller = accountIdtoAddress(ledgerKey.offer().sellerId());
            result.offerId = ledgerKey.offer().offerId().toString();
            break;
          }
          case _stellarXdr_generated2.default.LedgerEntryType.data().name: {
            result.type = "revokeDataSponsorship";
            result.account = accountIdtoAddress(ledgerKey.data().accountId());
            result.name = ledgerKey.data().dataName().toString("ascii");
            break;
          }
          case _stellarXdr_generated2.default.LedgerEntryType.claimableBalance().name: {
            result.type = "revokeClaimableBalanceSponsorship";
            result.balanceId = ledgerKey.claimableBalance().balanceId().toXDR("hex");
            break;
          }
          case _stellarXdr_generated2.default.LedgerEntryType.liquidityPool().name: {
            result.type = "revokeLiquidityPoolSponsorship";
            result.liquidityPoolId = ledgerKey.liquidityPool().liquidityPoolId().toString("hex");
            break;
          }
          default: {
            throw new Error("Unknown ledgerKey: " + attrs.switch().name);
          }
        }
        break;
      }
      case "revokeSponsorshipSigner": {
        result.type = "revokeSignerSponsorship";
        result.account = accountIdtoAddress(attrs.signer().accountId());
        result.signer = convertXDRSignerKeyToObject(attrs.signer().signerKey());
        break;
      }
      default: {
        throw new Error("Unknown revokeSponsorship: " + attrs.switch().name);
      }
    }
  }
  function convertXDRSignerKeyToObject(signerKey) {
    var attrs = {};
    switch (signerKey.switch().name) {
      case _stellarXdr_generated2.default.SignerKeyType.signerKeyTypeEd25519().name: {
        attrs.ed25519PublicKey = _strkey.StrKey.encodeEd25519PublicKey(signerKey.ed25519());
        break;
      }
      case _stellarXdr_generated2.default.SignerKeyType.signerKeyTypePreAuthTx().name: {
        attrs.preAuthTx = signerKey.preAuthTx().toString("hex");
        break;
      }
      case _stellarXdr_generated2.default.SignerKeyType.signerKeyTypeHashX().name: {
        attrs.sha256Hash = signerKey.hashX().toString("hex");
        break;
      }
      default: {
        throw new Error("Unknown signerKey: " + signerKey.switch().name);
      }
    }
    return attrs;
  }
  function accountIdtoAddress(accountId) {
    return _strkey.StrKey.encodeEd25519PublicKey(accountId.ed25519());
  }
  Operation.accountMerge = ops.accountMerge;
  Operation.allowTrust = ops.allowTrust;
  Operation.bumpSequence = ops.bumpSequence;
  Operation.changeTrust = ops.changeTrust;
  Operation.createAccount = ops.createAccount;
  Operation.createClaimableBalance = ops.createClaimableBalance;
  Operation.claimClaimableBalance = ops.claimClaimableBalance;
  Operation.clawbackClaimableBalance = ops.clawbackClaimableBalance;
  Operation.createPassiveSellOffer = ops.createPassiveSellOffer;
  Operation.inflation = ops.inflation;
  Operation.manageData = ops.manageData;
  Operation.manageSellOffer = ops.manageSellOffer;
  Operation.manageBuyOffer = ops.manageBuyOffer;
  Operation.pathPaymentStrictReceive = ops.pathPaymentStrictReceive;
  Operation.pathPaymentStrictSend = ops.pathPaymentStrictSend;
  Operation.payment = ops.payment;
  Operation.setOptions = ops.setOptions;
  Operation.beginSponsoringFutureReserves = ops.beginSponsoringFutureReserves;
  Operation.endSponsoringFutureReserves = ops.endSponsoringFutureReserves;
  Operation.revokeAccountSponsorship = ops.revokeAccountSponsorship;
  Operation.revokeTrustlineSponsorship = ops.revokeTrustlineSponsorship;
  Operation.revokeOfferSponsorship = ops.revokeOfferSponsorship;
  Operation.revokeDataSponsorship = ops.revokeDataSponsorship;
  Operation.revokeClaimableBalanceSponsorship = ops.revokeClaimableBalanceSponsorship;
  Operation.revokeLiquidityPoolSponsorship = ops.revokeLiquidityPoolSponsorship;
  Operation.revokeSignerSponsorship = ops.revokeSignerSponsorship;
  Operation.clawback = ops.clawback;
  Operation.setTrustLineFlags = ops.setTrustLineFlags;
  Operation.liquidityPoolDeposit = ops.liquidityPoolDeposit;
  Operation.liquidityPoolWithdraw = ops.liquidityPoolWithdraw;
  return operation;
}
var memo = {};
var hasRequiredMemo;
function requireMemo() {
  if (hasRequiredMemo) return memo;
  hasRequiredMemo = 1;
  Object.defineProperty(memo, "__esModule", {
    value: true
  });
  memo.Memo = memo.MemoReturn = memo.MemoHash = memo.MemoText = memo.MemoID = memo.MemoNone = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _clone = requireClone();
  var _clone2 = _interopRequireDefault(_clone);
  var _jsXdr = requireLib$3();
  var _bignumber = requireBignumber();
  var _bignumber2 = _interopRequireDefault(_bignumber);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var MemoNone = memo.MemoNone = "none";
  var MemoID = memo.MemoID = "id";
  var MemoText = memo.MemoText = "text";
  var MemoHash = memo.MemoHash = "hash";
  var MemoReturn = memo.MemoReturn = "return";
  var Memo = function() {
    function Memo2(type2) {
      var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      _classCallCheck2(this, Memo2);
      this._type = type2;
      this._value = value;
      switch (this._type) {
        case MemoNone:
          break;
        case MemoID:
          Memo2._validateIdValue(value);
          break;
        case MemoText:
          Memo2._validateTextValue(value);
          break;
        case MemoHash:
        case MemoReturn:
          Memo2._validateHashValue(value);
          if ((0, _isString2.default)(value)) {
            this._value = Buffer.from(value, "hex");
          }
          break;
        default:
          throw new Error("Invalid memo type");
      }
    }
    _createClass2(Memo2, [{
      key: "toXDRObject",
      /**
       * Returns XDR memo object.
       * @returns {xdr.Memo}
       */
      value: function toXDRObject() {
        switch (this._type) {
          case MemoNone:
            return _stellarXdr_generated2.default.Memo.memoNone();
          case MemoID:
            return _stellarXdr_generated2.default.Memo.memoId(_jsXdr.UnsignedHyper.fromString(this._value));
          case MemoText:
            return _stellarXdr_generated2.default.Memo.memoText(this._value);
          case MemoHash:
            return _stellarXdr_generated2.default.Memo.memoHash(this._value);
          case MemoReturn:
            return _stellarXdr_generated2.default.Memo.memoReturn(this._value);
          default:
            return null;
        }
      }
      /**
       * Returns {@link Memo} from XDR memo object.
       * @param {xdr.Memo} object XDR memo object
       * @returns {Memo}
       */
    }, {
      key: "type",
      get: function get3() {
        return (0, _clone2.default)(this._type);
      },
      set: function set3(type2) {
        throw new Error("Memo is immutable");
      }
      /**
       * Contains memo value:
       * * `null` for `MemoNone`,
       * * `string` for `MemoID`,
       * * `Buffer` for `MemoText` after decoding using `fromXDRObject`, original value otherwise,
       * * `Buffer` for `MemoHash`, `MemoReturn`.
       */
    }, {
      key: "value",
      get: function get3() {
        switch (this._type) {
          case MemoNone:
            return null;
          case MemoID:
          case MemoText:
            return (0, _clone2.default)(this._value);
          case MemoHash:
          case MemoReturn:
            return Buffer.from(this._value);
          default:
            throw new Error("Invalid memo type");
        }
      },
      set: function set3(value) {
        throw new Error("Memo is immutable");
      }
    }], [{
      key: "_validateIdValue",
      value: function _validateIdValue(value) {
        var error3 = new Error("Expects a int64 as a string. Got " + value);
        if (!(0, _isString2.default)(value)) {
          throw error3;
        }
        var number = void 0;
        try {
          number = new _bignumber2.default(value);
        } catch (e) {
          throw error3;
        }
        if (!number.isFinite()) {
          throw error3;
        }
        if (number.isNaN()) {
          throw error3;
        }
      }
    }, {
      key: "_validateTextValue",
      value: function _validateTextValue(value) {
        if (!_stellarXdr_generated2.default.Memo.armTypeForArm("text").isValid(value)) {
          throw new Error("Expects string, array or buffer, max 28 bytes");
        }
      }
    }, {
      key: "_validateHashValue",
      value: function _validateHashValue(value) {
        var error3 = new Error("Expects a 32 byte hash value or hex encoded string. Got " + value);
        if (value === null || (0, _isUndefined2.default)(value)) {
          throw error3;
        }
        var valueBuffer = void 0;
        if ((0, _isString2.default)(value)) {
          if (!/^[0-9A-Fa-f]{64}$/g.test(value)) {
            throw error3;
          }
          valueBuffer = Buffer.from(value, "hex");
        } else if (Buffer.isBuffer(value)) {
          valueBuffer = Buffer.from(value);
        } else {
          throw error3;
        }
        if (!valueBuffer.length || valueBuffer.length !== 32) {
          throw error3;
        }
      }
      /**
       * Returns an empty memo (`MemoNone`).
       * @returns {Memo}
       */
    }, {
      key: "none",
      value: function none() {
        return new Memo2(MemoNone);
      }
      /**
       * Creates and returns a `MemoText` memo.
       * @param {string} text - memo text
       * @returns {Memo}
       */
    }, {
      key: "text",
      value: function text(_text) {
        return new Memo2(MemoText, _text);
      }
      /**
       * Creates and returns a `MemoID` memo.
       * @param {string} id - 64-bit number represented as a string
       * @returns {Memo}
       */
    }, {
      key: "id",
      value: function id(_id) {
        return new Memo2(MemoID, _id);
      }
      /**
       * Creates and returns a `MemoHash` memo.
       * @param {array|string} hash - 32 byte hash or hex encoded string
       * @returns {Memo}
       */
    }, {
      key: "hash",
      value: function hash2(_hash) {
        return new Memo2(MemoHash, _hash);
      }
      /**
       * Creates and returns a `MemoReturn` memo.
       * @param {array|string} hash - 32 byte hash or hex encoded string
       * @returns {Memo}
       */
    }, {
      key: "return",
      value: function _return(hash2) {
        return new Memo2(MemoReturn, hash2);
      }
    }, {
      key: "fromXDRObject",
      value: function fromXDRObject(object) {
        switch (object.arm()) {
          case "id":
            return Memo2.id(object.value().toString());
          case "text":
            return Memo2.text(object.value());
          case "hash":
            return Memo2.hash(object.value());
          case "retHash":
            return Memo2.return(object.value());
        }
        if (typeof object.value() === "undefined") {
          return Memo2.none();
        }
        throw new Error("Unknown type");
      }
    }]);
    return Memo2;
  }();
  memo.Memo = Memo;
  return memo;
}
var hasRequiredTransaction;
function requireTransaction() {
  if (hasRequiredTransaction) return transaction;
  hasRequiredTransaction = 1;
  Object.defineProperty(transaction, "__esModule", {
    value: true
  });
  transaction.Transaction = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _map = requireMap();
  var _map2 = _interopRequireDefault(_map);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _hashing = requireHashing();
  var _strkey = requireStrkey();
  var _operation = requireOperation();
  var _memo = requireMemo();
  var _transaction_base = requireTransaction_base();
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn2(self2, call2) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  transaction.Transaction = function(_TransactionBase) {
    _inherits2(Transaction, _TransactionBase);
    function Transaction(envelope, networkPassphrase, withMuxing) {
      _classCallCheck2(this, Transaction);
      if (typeof envelope === "string") {
        var buffer2 = Buffer.from(envelope, "base64");
        envelope = _stellarXdr_generated2.default.TransactionEnvelope.fromXDR(buffer2);
      }
      var envelopeType = envelope.switch();
      if (!(envelopeType === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxV0() || envelopeType === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTx())) {
        throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an " + envelopeType.name + ".");
      }
      var txEnvelope = envelope.value();
      var tx = txEnvelope.tx();
      var fee = tx.fee().toString();
      var signatures = (txEnvelope.signatures() || []).slice();
      var _this = _possibleConstructorReturn2(this, (Transaction.__proto__ || Object.getPrototypeOf(Transaction)).call(this, tx, signatures, fee, networkPassphrase));
      _this._envelopeType = envelopeType;
      _this._memo = tx.memo();
      _this._sequence = tx.seqNum().toString();
      switch (_this._envelopeType) {
        case _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxV0():
          _this._source = _strkey.StrKey.encodeEd25519PublicKey(_this.tx.sourceAccountEd25519());
          break;
        default:
          _this._source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.sourceAccount(), withMuxing);
          break;
      }
      var timeBounds = tx.timeBounds();
      if (timeBounds) {
        _this._timeBounds = {
          minTime: timeBounds.minTime().toString(),
          maxTime: timeBounds.maxTime().toString()
        };
      }
      var operations2 = tx.operations() || [];
      _this._operations = (0, _map2.default)(operations2, function(op) {
        return _operation.Operation.fromXDRObject(op, withMuxing);
      });
      return _this;
    }
    _createClass2(Transaction, [{
      key: "signatureBase",
      /**
       * Returns the "signature base" of this transaction, which is the value
       * that, when hashed, should be signed to create a signature that
       * validators on the Stellar Network will accept.
       *
       * It is composed of a 4 prefix bytes followed by the xdr-encoded form
       * of this transaction.
       * @returns {Buffer}
       */
      value: function signatureBase() {
        var tx = this.tx;
        if (this._envelopeType === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxV0()) {
          tx = _stellarXdr_generated2.default.Transaction.fromXDR(Buffer.concat([
            // TransactionV0 is a transaction with the AccountID discriminant
            // stripped off, we need to put it back to build a valid transaction
            // which we can use to build a TransactionSignaturePayloadTaggedTransaction
            _stellarXdr_generated2.default.PublicKeyType.publicKeyTypeEd25519().toXDR(),
            tx.toXDR()
          ]));
        }
        var taggedTransaction = new _stellarXdr_generated2.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(tx);
        var txSignature = new _stellarXdr_generated2.default.TransactionSignaturePayload({
          networkId: _stellarXdr_generated2.default.Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
          taggedTransaction
        });
        return txSignature.toXDR();
      }
      /**
       * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
       * @returns {xdr.TransactionEnvelope}
       */
    }, {
      key: "toEnvelope",
      value: function toEnvelope() {
        var rawTx = this.tx.toXDR();
        var signatures = this.signatures.slice();
        var envelope = void 0;
        switch (this._envelopeType) {
          case _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxV0():
            envelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTxV0(new _stellarXdr_generated2.default.TransactionV0Envelope({
              tx: _stellarXdr_generated2.default.TransactionV0.fromXDR(rawTx),
              // make a copy of tx
              signatures
            }));
            break;
          case _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTx():
            envelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTx(new _stellarXdr_generated2.default.TransactionV1Envelope({
              tx: _stellarXdr_generated2.default.Transaction.fromXDR(rawTx),
              // make a copy of tx
              signatures
            }));
            break;
          default:
            throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an " + this._envelopeType.name + ".");
        }
        return envelope;
      }
    }, {
      key: "timeBounds",
      get: function get3() {
        return this._timeBounds;
      },
      set: function set3(value) {
        throw new Error("Transaction is immutable");
      }
      /**
       * @type {string}
       * @readonly
       */
    }, {
      key: "sequence",
      get: function get3() {
        return this._sequence;
      },
      set: function set3(value) {
        throw new Error("Transaction is immutable");
      }
      /**
       * @type {string}
       * @readonly
       */
    }, {
      key: "source",
      get: function get3() {
        return this._source;
      },
      set: function set3(value) {
        throw new Error("Transaction is immutable");
      }
      /**
       * @type {Array.<xdr.Operation>}
       * @readonly
       */
    }, {
      key: "operations",
      get: function get3() {
        return this._operations;
      },
      set: function set3(value) {
        throw new Error("Transaction is immutable");
      }
      /**
       * @type {string}
       * @readonly
       */
    }, {
      key: "memo",
      get: function get3() {
        return _memo.Memo.fromXDRObject(this._memo);
      },
      set: function set3(value) {
        throw new Error("Transaction is immutable");
      }
    }]);
    return Transaction;
  }(_transaction_base.TransactionBase);
  return transaction;
}
var fee_bump_transaction = {};
var hasRequiredFee_bump_transaction;
function requireFee_bump_transaction() {
  if (hasRequiredFee_bump_transaction) return fee_bump_transaction;
  hasRequiredFee_bump_transaction = 1;
  Object.defineProperty(fee_bump_transaction, "__esModule", {
    value: true
  });
  fee_bump_transaction.FeeBumpTransaction = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _hashing = requireHashing();
  var _transaction = requireTransaction();
  var _transaction_base = requireTransaction_base();
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn2(self2, call2) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  fee_bump_transaction.FeeBumpTransaction = function(_TransactionBase) {
    _inherits2(FeeBumpTransaction, _TransactionBase);
    function FeeBumpTransaction(envelope, networkPassphrase, withMuxing) {
      _classCallCheck2(this, FeeBumpTransaction);
      if (typeof envelope === "string") {
        var buffer2 = Buffer.from(envelope, "base64");
        envelope = _stellarXdr_generated2.default.TransactionEnvelope.fromXDR(buffer2);
      }
      var envelopeType = envelope.switch();
      if (envelopeType !== _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxFeeBump()) {
        throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an " + envelopeType.name + ".");
      }
      var txEnvelope = envelope.value();
      var tx = txEnvelope.tx();
      var fee = tx.fee().toString();
      var signatures = (txEnvelope.signatures() || []).slice();
      var _this = _possibleConstructorReturn2(this, (FeeBumpTransaction.__proto__ || Object.getPrototypeOf(FeeBumpTransaction)).call(this, tx, signatures, fee, networkPassphrase));
      var innerTxEnvelope = _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTx(tx.innerTx().v1());
      _this._feeSource = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.feeSource(), withMuxing);
      _this._innerTransaction = new _transaction.Transaction(innerTxEnvelope, networkPassphrase);
      return _this;
    }
    _createClass2(FeeBumpTransaction, [{
      key: "signatureBase",
      /**
       * Returns the "signature base" of this transaction, which is the value
       * that, when hashed, should be signed to create a signature that
       * validators on the Stellar Network will accept.
       *
       * It is composed of a 4 prefix bytes followed by the xdr-encoded form
       * of this transaction.
       * @returns {Buffer}
       */
      value: function signatureBase() {
        var taggedTransaction = new _stellarXdr_generated2.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);
        var txSignature = new _stellarXdr_generated2.default.TransactionSignaturePayload({
          networkId: _stellarXdr_generated2.default.Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
          taggedTransaction
        });
        return txSignature.toXDR();
      }
      /**
       * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
       * @returns {xdr.TransactionEnvelope}
       */
    }, {
      key: "toEnvelope",
      value: function toEnvelope() {
        var envelope = new _stellarXdr_generated2.default.FeeBumpTransactionEnvelope({
          tx: _stellarXdr_generated2.default.FeeBumpTransaction.fromXDR(this.tx.toXDR()),
          // make a copy of the tx
          signatures: this.signatures.slice()
          // make a copy of the signatures
        });
        return new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTxFeeBump(envelope);
      }
    }, {
      key: "innerTransaction",
      get: function get3() {
        return this._innerTransaction;
      }
      /**
       * @type {string}
       * @readonly
       */
    }, {
      key: "feeSource",
      get: function get3() {
        return this._feeSource;
      }
    }]);
    return FeeBumpTransaction;
  }(_transaction_base.TransactionBase);
  return fee_bump_transaction;
}
var transaction_builder = {};
var hasRequiredTransaction_builder;
function requireTransaction_builder() {
  if (hasRequiredTransaction_builder) return transaction_builder;
  hasRequiredTransaction_builder = 1;
  Object.defineProperty(transaction_builder, "__esModule", {
    value: true
  });
  transaction_builder.TransactionBuilder = transaction_builder.TimeoutInfinite = transaction_builder.BASE_FEE = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  transaction_builder.isValidDate = isValidDate;
  var _jsXdr = requireLib$3();
  var _bignumber = requireBignumber();
  var _bignumber2 = _interopRequireDefault(_bignumber);
  var _clone = requireClone();
  var _clone2 = _interopRequireDefault(_clone);
  var _isUndefined = requireIsUndefined();
  var _isUndefined2 = _interopRequireDefault(_isUndefined);
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _transaction = requireTransaction();
  var _fee_bump_transaction = requireFee_bump_transaction();
  var _memo = requireMemo();
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var BASE_FEE = transaction_builder.BASE_FEE = "100";
  transaction_builder.TimeoutInfinite = 0;
  transaction_builder.TransactionBuilder = function() {
    function TransactionBuilder(sourceAccount) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck2(this, TransactionBuilder);
      if (!sourceAccount) {
        throw new Error("must specify source account for the transaction");
      }
      if ((0, _isUndefined2.default)(opts.fee)) {
        throw new Error("must specify fee for the transaction (in stroops)");
      }
      this.source = sourceAccount;
      this.operations = [];
      this.baseFee = (0, _isUndefined2.default)(opts.fee) ? BASE_FEE : opts.fee;
      this.timebounds = (0, _clone2.default)(opts.timebounds) || null;
      this.memo = opts.memo || _memo.Memo.none();
      this.networkPassphrase = opts.networkPassphrase || null;
      this.supportMuxedAccounts = opts.withMuxing || false;
    }
    _createClass2(TransactionBuilder, [{
      key: "addOperation",
      value: function addOperation2(operation2) {
        this.operations.push(operation2);
        return this;
      }
      /**
       * Adds a memo to the transaction.
       * @param {Memo} memo {@link Memo} object
       * @returns {TransactionBuilder}
       */
    }, {
      key: "addMemo",
      value: function addMemo2(memo2) {
        this.memo = memo2;
        return this;
      }
      /**
       * Because of the distributed nature of the Stellar network it is possible that the status of your transaction
       * will be determined after a long time if the network is highly congested.
       * If you want to be sure to receive the status of the transaction within a given period you should set the
       * {@link TimeBounds} with <code>maxTime</code> on the transaction (this is what <code>setTimeout</code> does
       * internally; if there's <code>minTime</code> set but no <code>maxTime</code> it will be added).
       * Call to <code>TransactionBuilder.setTimeout</code> is required if Transaction does not have <code>max_time</code> set.
       * If you don't want to set timeout, use <code>{@link TimeoutInfinite}</code>. In general you should set
       * <code>{@link TimeoutInfinite}</code> only in smart contracts.
       *
       * Please note that Horizon may still return <code>504 Gateway Timeout</code> error, even for short timeouts.
       * In such case you need to resubmit the same transaction again without making any changes to receive a status.
       * This method is using the machine system time (UTC), make sure it is set correctly.
       * @param {number} timeout Number of seconds the transaction is good. Can't be negative.
       * If the value is `0`, the transaction is good indefinitely.
       * @return {TransactionBuilder}
       * @see TimeoutInfinite
       */
    }, {
      key: "setTimeout",
      value: function setTimeout2(timeout) {
        if (this.timebounds !== null && this.timebounds.maxTime > 0) {
          throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
        }
        if (timeout < 0) {
          throw new Error("timeout cannot be negative");
        }
        if (timeout > 0) {
          var timeoutTimestamp = Math.floor(Date.now() / 1e3) + timeout;
          if (this.timebounds === null) {
            this.timebounds = { minTime: 0, maxTime: timeoutTimestamp };
          } else {
            this.timebounds = {
              minTime: this.timebounds.minTime,
              maxTime: timeoutTimestamp
            };
          }
        } else {
          this.timebounds = {
            minTime: 0,
            maxTime: 0
          };
        }
        return this;
      }
      /**
       * Set network nassphrase for the Transaction that will be built.
       *
       * @param {string} [networkPassphrase] passphrase of the target stellar network (e.g. "Public Global Stellar Network ; September 2015").
       * @returns {TransactionBuilder}
       */
    }, {
      key: "setNetworkPassphrase",
      value: function setNetworkPassphrase(networkPassphrase) {
        this.networkPassphrase = networkPassphrase;
        return this;
      }
      /**
       * Enable support for muxed accounts for the Transaction that will be built.
       * @returns {TransactionBuilder}
       */
    }, {
      key: "enableMuxedAccounts",
      value: function enableMuxedAccounts() {
        this.supportMuxedAccounts = true;
        return this;
      }
      /**
       * This will build the transaction.
       * It will also increment the source account's sequence number by 1.
       * @returns {Transaction} This method will return the built {@link Transaction}.
       */
    }, {
      key: "build",
      value: function build() {
        var sequenceNumber = new _bignumber2.default(this.source.sequenceNumber()).add(1);
        var fee = new _bignumber2.default(this.baseFee).mul(this.operations.length).toNumber();
        var attrs = {
          fee,
          seqNum: _stellarXdr_generated2.default.SequenceNumber.fromString(sequenceNumber.toString()),
          memo: this.memo ? this.memo.toXDRObject() : null
        };
        if (this.timebounds === null || typeof this.timebounds.minTime === "undefined" || typeof this.timebounds.maxTime === "undefined") {
          throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
        }
        if (isValidDate(this.timebounds.minTime)) {
          this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3;
        }
        if (isValidDate(this.timebounds.maxTime)) {
          this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3;
        }
        this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());
        this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
        attrs.timeBounds = new _stellarXdr_generated2.default.TimeBounds(this.timebounds);
        attrs.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(this.source.accountId(), this.supportMuxedAccounts);
        attrs.ext = new _stellarXdr_generated2.default.TransactionExt(0);
        var xtx = new _stellarXdr_generated2.default.Transaction(attrs);
        xtx.operations(this.operations);
        var txEnvelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTx(new _stellarXdr_generated2.default.TransactionV1Envelope({ tx: xtx }));
        var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase, this.supportMuxedAccounts);
        this.source.incrementSequenceNumber();
        return tx;
      }
      /**
       * Builds a {@link FeeBumpTransaction}, enabling you to resubmit an existing
       * transaction with a higher fee.
       *
       * @param {Keypair|string}  feeSource - account paying for the transaction,
       *     in the form of either a Keypair (only the public key is used) or
       *     an account ID (in G... or M... form, but refer to `withMuxing`)
       * @param {string}          baseFee   - max fee willing to pay per operation
       *     in inner transaction (**in stroops**)
       * @param {Transaction}     innerTx   - {@link Transaction} to be bumped by
       *     the fee bump transaction
       * @param {string}          networkPassphrase - passphrase of the target
       *     Stellar network (e.g. "Public Global Stellar Network ; September 2015",
       *     see {@link Networks})
       * @param {bool}            [withMuxing] - Indicates any properties in this
       *     transaction or its underlying operations that use fully-muxed accounts
       *     (i.e. come from an M... address) should be interpreted as such. By
       *     default, this option is disabled until muxed accounts are mature.
       *
       * @todo Alongside the next major version bump, this type signature can be
       *       changed to be less awkward: accept a MuxedAccount as the `feeSource`
       *       rather than a keypair or string.
       *
       * @note Your fee-bump amount should be 10x the original fee.
       * @see  https://developers.stellar.org/docs/glossary/fee-bumps/#replace-by-fee
       *
       * @returns {FeeBumpTransaction}
       */
    }], [{
      key: "buildFeeBumpTransaction",
      value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase, withMuxing) {
        var innerOps = innerTx.operations.length;
        var innerBaseFeeRate = new _bignumber2.default(innerTx.fee).div(innerOps);
        var base2 = new _bignumber2.default(baseFee);
        if (base2.lessThan(innerBaseFeeRate)) {
          throw new Error("Invalid baseFee, it should be at least " + innerBaseFeeRate + " stroops.");
        }
        var minBaseFee = new _bignumber2.default(BASE_FEE);
        if (base2.lessThan(minBaseFee)) {
          throw new Error("Invalid baseFee, it should be at least " + minBaseFee + " stroops.");
        }
        var innerTxEnvelope = innerTx.toEnvelope();
        if (innerTxEnvelope.switch() === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxV0()) {
          var v0Tx = innerTxEnvelope.v0().tx();
          var v1Tx = new _stellarXdr_generated2.default.Transaction({
            sourceAccount: new _stellarXdr_generated2.default.MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),
            fee: v0Tx.fee(),
            seqNum: v0Tx.seqNum(),
            timeBounds: v0Tx.timeBounds(),
            memo: v0Tx.memo(),
            operations: v0Tx.operations(),
            ext: new _stellarXdr_generated2.default.TransactionExt(0)
          });
          innerTxEnvelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTx(new _stellarXdr_generated2.default.TransactionV1Envelope({
            tx: v1Tx,
            signatures: innerTxEnvelope.v0().signatures()
          }));
        }
        var feeSourceAccount = void 0;
        if ((0, _isString2.default)(feeSource)) {
          feeSourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(feeSource, withMuxing);
        } else {
          feeSourceAccount = feeSource.xdrMuxedAccount();
        }
        var tx = new _stellarXdr_generated2.default.FeeBumpTransaction({
          feeSource: feeSourceAccount,
          fee: _stellarXdr_generated2.default.Int64.fromString(base2.mul(innerOps + 1).toString()),
          innerTx: _stellarXdr_generated2.default.FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),
          ext: new _stellarXdr_generated2.default.FeeBumpTransactionExt(0)
        });
        var feeBumpTxEnvelope = new _stellarXdr_generated2.default.FeeBumpTransactionEnvelope({
          tx,
          signatures: []
        });
        var envelope = new _stellarXdr_generated2.default.TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);
        return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase, withMuxing);
      }
      /**
       * Build a {@link Transaction} or {@link FeeBumpTransaction} from an
       * xdr.TransactionEnvelope.
       *
       * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope
       *     object or base64 encoded string.
       * @param {string} networkPassphrase - The network passphrase of the target
       *     Stellar network (e.g. "Public Global Stellar Network ; September
       *     2015"), see {@link Networks}.
       * @param {bool} [withMuxing] - Indicates any properties in this transaction
       *     or its underlying operations that use fully-muxed accounts (i.e. come
       *     from an M... address) should be interpreted as such. By default, this
       *     option is disabled until muxed accounts are mature.
       *
       * @returns {Transaction|FeeBumpTransaction}
       */
    }, {
      key: "fromXDR",
      value: function fromXDR(envelope, networkPassphrase, withMuxing) {
        if (typeof envelope === "string") {
          envelope = _stellarXdr_generated2.default.TransactionEnvelope.fromXDR(envelope, "base64");
        }
        if (envelope.switch() === _stellarXdr_generated2.default.EnvelopeType.envelopeTypeTxFeeBump()) {
          return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase, withMuxing);
        }
        return new _transaction.Transaction(envelope, networkPassphrase, withMuxing);
      }
    }]);
    return TransactionBuilder;
  }();
  function isValidDate(d) {
    return d instanceof Date && !isNaN(d);
  }
  return transaction_builder;
}
var account = {};
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount) return account;
  hasRequiredAccount = 1;
  Object.defineProperty(account, "__esModule", {
    value: true
  });
  account.MuxedAccount = account.Account = void 0;
  var _createClass2 = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _isString = requireIsString();
  var _isString2 = _interopRequireDefault(_isString);
  var _bignumber = requireBignumber();
  var _bignumber2 = _interopRequireDefault(_bignumber);
  var _stellarXdr_generated = requireStellarXdr_generated();
  var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
  var _strkey = requireStrkey();
  var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Account2 = account.Account = function() {
    function Account3(accountId, sequence) {
      _classCallCheck2(this, Account3);
      if (_strkey.StrKey.isValidMed25519PublicKey(accountId)) {
        throw new Error("accountId is an M-address; use MuxedAccount instead");
      }
      if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
        throw new Error("accountId is invalid");
      }
      if (!(0, _isString2.default)(sequence)) {
        throw new Error("sequence must be of type string");
      }
      this._accountId = accountId;
      this.sequence = new _bignumber2.default(sequence);
    }
    _createClass2(Account3, [{
      key: "accountId",
      value: function accountId() {
        return this._accountId;
      }
      /**
       * @returns {string}  sequence number for the account as a string
       */
    }, {
      key: "sequenceNumber",
      value: function sequenceNumber() {
        return this.sequence.toString();
      }
      /**
       * Increments sequence number in this object by one.
       * @returns {void}
       */
    }, {
      key: "incrementSequenceNumber",
      value: function incrementSequenceNumber() {
        this.sequence = this.sequence.add(1);
      }
      /**
       * Creates a muxed "sub"account with this base address and an ID set.
       *
       * @param  {string} id - the ID of the new muxed account
       * @return {MuxedAccount} a new instance w/ the specified parameters
       *
       * @see MuxedAccount
       */
    }, {
      key: "createSubaccount",
      value: function createSubaccount(id) {
        return new MuxedAccount(this, id);
      }
    }]);
    return Account3;
  }();
  var MuxedAccount = account.MuxedAccount = function() {
    function MuxedAccount2(baseAccount, id) {
      _classCallCheck2(this, MuxedAccount2);
      var accountId = baseAccount.accountId();
      if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
        throw new Error("accountId is invalid");
      }
      this.account = baseAccount;
      this._muxedXdr = (0, _decode_encode_muxed_account.encodeMuxedAccount)(accountId, id);
      this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr, true);
      this._id = id;
    }
    _createClass2(MuxedAccount2, [{
      key: "baseAccount",
      /**
       * @return {Account} the underlying account object shared among all muxed
       *     accounts with this Stellar address
       */
      value: function baseAccount() {
        return this.account;
      }
      /**
       * @return {string} the M-address representing this account's (G-address, ID)
       */
    }, {
      key: "accountId",
      value: function accountId() {
        return this._mAddress;
      }
    }, {
      key: "id",
      value: function id() {
        return this._id;
      }
    }, {
      key: "setId",
      value: function setId(id) {
        if (!(0, _isString2.default)(id)) {
          throw new Error("id should be a string representing a number (uint64)");
        }
        this._muxedXdr.med25519().id(_stellarXdr_generated2.default.Uint64.fromString(id));
        this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr, true);
        this._id = id;
        return this;
      }
      /**
       * Accesses the underlying account's sequence number.
       * @return {string}  strigified sequence number for the underlying account
       */
    }, {
      key: "sequenceNumber",
      value: function sequenceNumber() {
        return this.account.sequenceNumber();
      }
      /**
       * Increments the underlying account's sequence number by one.
       * @return {void}
       */
    }, {
      key: "incrementSequenceNumber",
      value: function incrementSequenceNumber() {
        return this.account.incrementSequenceNumber();
      }
      /**
       * Creates another muxed "sub"account from the base with a new ID set
       *
       * @param  {string} id - the ID of the new muxed account
       * @return {MuxedAccount} a new instance w/ the specified parameters
       */
    }, {
      key: "createSubaccount",
      value: function createSubaccount(id) {
        return new MuxedAccount2(this.account, id);
      }
      /**
       * @return {xdr.MuxedAccount} the XDR object representing this muxed account's
       *     G-address and uint64 ID
       */
    }, {
      key: "toXDRObject",
      value: function toXDRObject() {
        return this._muxedXdr;
      }
    }, {
      key: "equals",
      value: function equals(otherMuxedAccount) {
        return this.accountId() === otherMuxedAccount.accountId();
      }
    }], [{
      key: "fromAddress",
      value: function fromAddress(mAddress, sequenceNum) {
        var muxedAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(mAddress, true);
        var gAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(muxedAccount, false);
        var id = muxedAccount.med25519().id().toString();
        return new MuxedAccount2(new Account2(gAddress, sequenceNum), id);
      }
    }]);
    return MuxedAccount2;
  }();
  return account;
}
var network = {};
var hasRequiredNetwork;
function requireNetwork() {
  if (hasRequiredNetwork) return network;
  hasRequiredNetwork = 1;
  Object.defineProperty(network, "__esModule", {
    value: true
  });
  network.Networks = {
    PUBLIC: "Public Global Stellar Network ; September 2015",
    TESTNET: "Test SDF Network ; September 2015"
  };
  return network;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2.exports;
  hasRequiredLib$2 = 1;
  (function(module, exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.encodeMuxedAccount = exports2.encodeMuxedAccountToAddress = exports2.decodeAddressToMuxedAccount = exports2.StrKey = exports2.Networks = exports2.Claimant = exports2.MuxedAccount = exports2.Account = exports2.AuthClawbackEnabledFlag = exports2.AuthImmutableFlag = exports2.AuthRevocableFlag = exports2.AuthRequiredFlag = exports2.Operation = exports2.LiquidityPoolId = exports2.LiquidityPoolAsset = exports2.Asset = exports2.BASE_FEE = exports2.TimeoutInfinite = exports2.TransactionBuilder = exports2.FeeBumpTransaction = exports2.Transaction = exports2.TransactionBase = exports2.Hyper = exports2.UnsignedHyper = exports2.Keypair = exports2.LiquidityPoolFeeV18 = exports2.getLiquidityPoolId = exports2.FastSigning = exports2.verify = exports2.sign = exports2.hash = exports2.xdr = void 0;
    var _hashing = requireHashing();
    Object.defineProperty(exports2, "hash", {
      enumerable: true,
      get: function get3() {
        return _hashing.hash;
      }
    });
    var _signing = requireSigning();
    Object.defineProperty(exports2, "sign", {
      enumerable: true,
      get: function get3() {
        return _signing.sign;
      }
    });
    Object.defineProperty(exports2, "verify", {
      enumerable: true,
      get: function get3() {
        return _signing.verify;
      }
    });
    Object.defineProperty(exports2, "FastSigning", {
      enumerable: true,
      get: function get3() {
        return _signing.FastSigning;
      }
    });
    var _get_liquidity_pool_id = requireGet_liquidity_pool_id();
    Object.defineProperty(exports2, "getLiquidityPoolId", {
      enumerable: true,
      get: function get3() {
        return _get_liquidity_pool_id.getLiquidityPoolId;
      }
    });
    Object.defineProperty(exports2, "LiquidityPoolFeeV18", {
      enumerable: true,
      get: function get3() {
        return _get_liquidity_pool_id.LiquidityPoolFeeV18;
      }
    });
    var _keypair = requireKeypair();
    Object.defineProperty(exports2, "Keypair", {
      enumerable: true,
      get: function get3() {
        return _keypair.Keypair;
      }
    });
    var _jsXdr = requireLib$3();
    Object.defineProperty(exports2, "UnsignedHyper", {
      enumerable: true,
      get: function get3() {
        return _jsXdr.UnsignedHyper;
      }
    });
    Object.defineProperty(exports2, "Hyper", {
      enumerable: true,
      get: function get3() {
        return _jsXdr.Hyper;
      }
    });
    var _transaction_base = requireTransaction_base();
    Object.defineProperty(exports2, "TransactionBase", {
      enumerable: true,
      get: function get3() {
        return _transaction_base.TransactionBase;
      }
    });
    var _transaction = requireTransaction();
    Object.defineProperty(exports2, "Transaction", {
      enumerable: true,
      get: function get3() {
        return _transaction.Transaction;
      }
    });
    var _fee_bump_transaction = requireFee_bump_transaction();
    Object.defineProperty(exports2, "FeeBumpTransaction", {
      enumerable: true,
      get: function get3() {
        return _fee_bump_transaction.FeeBumpTransaction;
      }
    });
    var _transaction_builder = requireTransaction_builder();
    Object.defineProperty(exports2, "TransactionBuilder", {
      enumerable: true,
      get: function get3() {
        return _transaction_builder.TransactionBuilder;
      }
    });
    Object.defineProperty(exports2, "TimeoutInfinite", {
      enumerable: true,
      get: function get3() {
        return _transaction_builder.TimeoutInfinite;
      }
    });
    Object.defineProperty(exports2, "BASE_FEE", {
      enumerable: true,
      get: function get3() {
        return _transaction_builder.BASE_FEE;
      }
    });
    var _asset = requireAsset();
    Object.defineProperty(exports2, "Asset", {
      enumerable: true,
      get: function get3() {
        return _asset.Asset;
      }
    });
    var _liquidity_pool_asset = requireLiquidity_pool_asset();
    Object.defineProperty(exports2, "LiquidityPoolAsset", {
      enumerable: true,
      get: function get3() {
        return _liquidity_pool_asset.LiquidityPoolAsset;
      }
    });
    var _liquidity_pool_id = requireLiquidity_pool_id();
    Object.defineProperty(exports2, "LiquidityPoolId", {
      enumerable: true,
      get: function get3() {
        return _liquidity_pool_id.LiquidityPoolId;
      }
    });
    var _operation = requireOperation();
    Object.defineProperty(exports2, "Operation", {
      enumerable: true,
      get: function get3() {
        return _operation.Operation;
      }
    });
    Object.defineProperty(exports2, "AuthRequiredFlag", {
      enumerable: true,
      get: function get3() {
        return _operation.AuthRequiredFlag;
      }
    });
    Object.defineProperty(exports2, "AuthRevocableFlag", {
      enumerable: true,
      get: function get3() {
        return _operation.AuthRevocableFlag;
      }
    });
    Object.defineProperty(exports2, "AuthImmutableFlag", {
      enumerable: true,
      get: function get3() {
        return _operation.AuthImmutableFlag;
      }
    });
    Object.defineProperty(exports2, "AuthClawbackEnabledFlag", {
      enumerable: true,
      get: function get3() {
        return _operation.AuthClawbackEnabledFlag;
      }
    });
    var _memo = requireMemo();
    Object.keys(_memo).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function get3() {
          return _memo[key2];
        }
      });
    });
    var _account = requireAccount();
    Object.defineProperty(exports2, "Account", {
      enumerable: true,
      get: function get3() {
        return _account.Account;
      }
    });
    Object.defineProperty(exports2, "MuxedAccount", {
      enumerable: true,
      get: function get3() {
        return _account.MuxedAccount;
      }
    });
    var _claimant = requireClaimant();
    Object.defineProperty(exports2, "Claimant", {
      enumerable: true,
      get: function get3() {
        return _claimant.Claimant;
      }
    });
    var _network = requireNetwork();
    Object.defineProperty(exports2, "Networks", {
      enumerable: true,
      get: function get3() {
        return _network.Networks;
      }
    });
    var _strkey = requireStrkey();
    Object.defineProperty(exports2, "StrKey", {
      enumerable: true,
      get: function get3() {
        return _strkey.StrKey;
      }
    });
    var _decode_encode_muxed_account = requireDecode_encode_muxed_account();
    Object.defineProperty(exports2, "decodeAddressToMuxedAccount", {
      enumerable: true,
      get: function get3() {
        return _decode_encode_muxed_account.decodeAddressToMuxedAccount;
      }
    });
    Object.defineProperty(exports2, "encodeMuxedAccountToAddress", {
      enumerable: true,
      get: function get3() {
        return _decode_encode_muxed_account.encodeMuxedAccountToAddress;
      }
    });
    Object.defineProperty(exports2, "encodeMuxedAccount", {
      enumerable: true,
      get: function get3() {
        return _decode_encode_muxed_account.encodeMuxedAccount;
      }
    });
    var _stellarXdr_generated = requireStellarXdr_generated();
    var _stellarXdr_generated2 = _interopRequireDefault(_stellarXdr_generated);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.xdr = _stellarXdr_generated2.default;
    exports2.default = module.exports;
  })(lib$2, lib$2.exports);
  return lib$2.exports;
}
var hasRequiredAccount_response;
function requireAccount_response() {
  if (hasRequiredAccount_response) return account_response;
  hasRequiredAccount_response = 1;
  Object.defineProperty(account_response, "__esModule", { value: true });
  account_response.AccountResponse = void 0;
  var tslib_1 = require$$0$4;
  var forIn_12 = tslib_1.__importDefault(requireForIn());
  var stellar_base_1 = requireLib$2();
  var AccountResponse = function() {
    function AccountResponse2(response2) {
      var _this = this;
      this._baseAccount = new stellar_base_1.Account(response2.account_id, response2.sequence);
      forIn_12.default(response2, function(value, key2) {
        _this[key2] = value;
      });
    }
    AccountResponse2.prototype.accountId = function() {
      return this._baseAccount.accountId();
    };
    AccountResponse2.prototype.sequenceNumber = function() {
      return this._baseAccount.sequenceNumber();
    };
    AccountResponse2.prototype.incrementSequenceNumber = function() {
      this._baseAccount.incrementSequenceNumber();
      this.sequence = this._baseAccount.sequenceNumber();
    };
    AccountResponse2.prototype.createSubaccount = function(id) {
      return this._baseAccount.createSubaccount(id);
    };
    return AccountResponse2;
  }();
  account_response.AccountResponse = AccountResponse;
  return account_response;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.AccountRequiresMemoError = errors.InvalidSep10ChallengeError = errors.BadResponseError = errors.BadRequestError = errors.NotFoundError = errors.NetworkError = void 0;
  var tslib_1 = require$$0$4;
  var NetworkError = function(_super) {
    tslib_1.__extends(NetworkError2, _super);
    function NetworkError2(message, response2) {
      var _newTarget = this.constructor;
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, message) || this;
      _this.__proto__ = trueProto;
      _this.constructor = NetworkError2;
      _this.response = response2;
      return _this;
    }
    NetworkError2.prototype.getResponse = function() {
      return this.response;
    };
    return NetworkError2;
  }(Error);
  errors.NetworkError = NetworkError;
  var NotFoundError = function(_super) {
    tslib_1.__extends(NotFoundError2, _super);
    function NotFoundError2(message, response2) {
      var _newTarget = this.constructor;
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, message, response2) || this;
      _this.__proto__ = trueProto;
      _this.constructor = NotFoundError2;
      _this.name = "NotFoundError";
      return _this;
    }
    return NotFoundError2;
  }(NetworkError);
  errors.NotFoundError = NotFoundError;
  var BadRequestError = function(_super) {
    tslib_1.__extends(BadRequestError2, _super);
    function BadRequestError2(message, response2) {
      var _newTarget = this.constructor;
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, message, response2) || this;
      _this.__proto__ = trueProto;
      _this.constructor = BadRequestError2;
      _this.name = "BadRequestError";
      return _this;
    }
    return BadRequestError2;
  }(NetworkError);
  errors.BadRequestError = BadRequestError;
  var BadResponseError = function(_super) {
    tslib_1.__extends(BadResponseError2, _super);
    function BadResponseError2(message, response2) {
      var _newTarget = this.constructor;
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, message, response2) || this;
      _this.__proto__ = trueProto;
      _this.constructor = BadResponseError2;
      _this.name = "BadResponseError";
      return _this;
    }
    return BadResponseError2;
  }(NetworkError);
  errors.BadResponseError = BadResponseError;
  var InvalidSep10ChallengeError = function(_super) {
    tslib_1.__extends(InvalidSep10ChallengeError2, _super);
    function InvalidSep10ChallengeError2(message) {
      var _newTarget = this.constructor;
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, message) || this;
      _this.__proto__ = trueProto;
      _this.constructor = InvalidSep10ChallengeError2;
      _this.name = "InvalidSep10ChallengeError";
      return _this;
    }
    return InvalidSep10ChallengeError2;
  }(Error);
  errors.InvalidSep10ChallengeError = InvalidSep10ChallengeError;
  var AccountRequiresMemoError = function(_super) {
    tslib_1.__extends(AccountRequiresMemoError2, _super);
    function AccountRequiresMemoError2(message, accountId, operationIndex) {
      var _newTarget = this.constructor;
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, message) || this;
      _this.__proto__ = trueProto;
      _this.constructor = AccountRequiresMemoError2;
      _this.name = "AccountRequiresMemoError";
      _this.accountId = accountId;
      _this.operationIndex = operationIndex;
      return _this;
    }
    return AccountRequiresMemoError2;
  }(Error);
  errors.AccountRequiresMemoError = AccountRequiresMemoError;
  return errors;
}
var config$1 = {};
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig) return config$1;
  hasRequiredConfig = 1;
  Object.defineProperty(config$1, "__esModule", { value: true });
  config$1.Config = void 0;
  var tslib_1 = require$$0$4;
  var clone_12 = tslib_1.__importDefault(requireClone());
  var defaultConfig = {
    allowHttp: false,
    timeout: 0
  };
  var config2 = clone_12.default(defaultConfig);
  var Config = function() {
    function Config2() {
    }
    Config2.setAllowHttp = function(value) {
      config2.allowHttp = value;
    };
    Config2.setTimeout = function(value) {
      config2.timeout = value;
    };
    Config2.isAllowHttp = function() {
      return config2.allowHttp;
    };
    Config2.getTimeout = function() {
      return config2.timeout;
    };
    Config2.setDefault = function() {
      config2 = Object.assign({}, defaultConfig);
    };
    return Config2;
  }();
  config$1.Config = Config;
  return config$1;
}
var server = {};
var isEmpty_1;
var hasRequiredIsEmpty;
function requireIsEmpty() {
  if (hasRequiredIsEmpty) return isEmpty_1;
  hasRequiredIsEmpty = 1;
  var baseKeys = require_baseKeys(), getTag = require_getTag(), isArguments2 = requireIsArguments$1(), isArray2 = requireIsArray(), isArrayLike = requireIsArrayLike(), isBuffer2 = requireIsBuffer(), isPrototype = require_isPrototype(), isTypedArray2 = requireIsTypedArray$1();
  var mapTag = "[object Map]", setTag = "[object Set]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function isEmpty2(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key2 in value) {
      if (hasOwnProperty.call(value, key2)) {
        return false;
      }
    }
    return true;
  }
  isEmpty_1 = isEmpty2;
  return isEmpty_1;
}
var _assignMergeValue;
var hasRequired_assignMergeValue;
function require_assignMergeValue() {
  if (hasRequired_assignMergeValue) return _assignMergeValue;
  hasRequired_assignMergeValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq = requireEq();
  function assignMergeValue(object, key2, value) {
    if (value !== void 0 && !eq(object[key2], value) || value === void 0 && !(key2 in object)) {
      baseAssignValue(object, key2, value);
    }
  }
  _assignMergeValue = assignMergeValue;
  return _assignMergeValue;
}
var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject) return isArrayLikeObject_1;
  hasRequiredIsArrayLikeObject = 1;
  var isArrayLike = requireIsArrayLike(), isObjectLike = requireIsObjectLike();
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  isArrayLikeObject_1 = isArrayLikeObject;
  return isArrayLikeObject_1;
}
var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject) return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag = require_baseGetTag(), getPrototype = require_getPrototype(), isObjectLike = requireIsObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject2(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  isPlainObject_1 = isPlainObject2;
  return isPlainObject_1;
}
var _safeGet;
var hasRequired_safeGet;
function require_safeGet() {
  if (hasRequired_safeGet) return _safeGet;
  hasRequired_safeGet = 1;
  function safeGet(object, key2) {
    if (key2 === "constructor" && typeof object[key2] === "function") {
      return;
    }
    if (key2 == "__proto__") {
      return;
    }
    return object[key2];
  }
  _safeGet = safeGet;
  return _safeGet;
}
var toPlainObject_1;
var hasRequiredToPlainObject;
function requireToPlainObject() {
  if (hasRequiredToPlainObject) return toPlainObject_1;
  hasRequiredToPlainObject = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn();
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  toPlainObject_1 = toPlainObject;
  return toPlainObject_1;
}
var _baseMergeDeep;
var hasRequired_baseMergeDeep;
function require_baseMergeDeep() {
  if (hasRequired_baseMergeDeep) return _baseMergeDeep;
  hasRequired_baseMergeDeep = 1;
  var assignMergeValue = require_assignMergeValue(), cloneBuffer = require_cloneBuffer(), cloneTypedArray = require_cloneTypedArray(), copyArray = require_copyArray(), initCloneObject = require_initCloneObject(), isArguments2 = requireIsArguments$1(), isArray2 = requireIsArray(), isArrayLikeObject = requireIsArrayLikeObject(), isBuffer2 = requireIsBuffer(), isFunction2 = requireIsFunction(), isObject2 = requireIsObject(), isPlainObject2 = requireIsPlainObject(), isTypedArray2 = requireIsTypedArray$1(), safeGet = require_safeGet(), toPlainObject = requireToPlainObject();
  function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key2, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
        newValue = objValue;
        if (isArguments2(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key2, newValue);
  }
  _baseMergeDeep = baseMergeDeep;
  return _baseMergeDeep;
}
var _baseMerge;
var hasRequired_baseMerge;
function require_baseMerge() {
  if (hasRequired_baseMerge) return _baseMerge;
  hasRequired_baseMerge = 1;
  var Stack = require_Stack(), assignMergeValue = require_assignMergeValue(), baseFor = require_baseFor(), baseMergeDeep = require_baseMergeDeep(), isObject2 = requireIsObject(), keysIn = requireKeysIn(), safeGet = require_safeGet();
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key2) {
      stack || (stack = new Stack());
      if (isObject2(srcValue)) {
        baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key2, newValue);
      }
    }, keysIn);
  }
  _baseMerge = baseMerge;
  return _baseMerge;
}
var merge_1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge_1;
  hasRequiredMerge = 1;
  var baseMerge = require_baseMerge(), createAssigner = require_createAssigner();
  var merge2 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  merge_1 = merge2;
  return merge_1;
}
var URI$1 = { exports: {} };
var punycode$4 = { exports: {} };
/*! https://mths.be/punycode v1.4.0 by @mathias */
var punycode$3 = punycode$4.exports;
var hasRequiredPunycode$1;
function requirePunycode$1() {
  if (hasRequiredPunycode$1) return punycode$4.exports;
  hasRequiredPunycode$1 = 1;
  (function(module, exports2) {
    (function(root) {
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = module && !module.nodeType && module;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base2 = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors2 = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base2 - tMin, floor2 = Math.floor, stringFromCharCode = String.fromCharCode, key2;
      function error3(type2) {
        throw new RangeError(errors2[type2]);
      }
      function map2(array2, fn) {
        var length = array2.length;
        var result = [];
        while (length--) {
          result[length] = fn(array2[length]);
        }
        return result;
      }
      function mapDomain(string2, fn) {
        var parts = string2.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string2 = parts[1];
        }
        string2 = string2.replace(regexSeparators, ".");
        var labels = string2.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string2) {
        var output2 = [], counter = 0, length = string2.length, value, extra;
        while (counter < length) {
          value = string2.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output2.push(value);
              counter--;
            }
          } else {
            output2.push(value);
          }
        }
        return output2;
      }
      function ucs2encode(array2) {
        return map2(array2, function(value) {
          var output2 = "";
          if (value > 65535) {
            value -= 65536;
            output2 += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output2 += stringFromCharCode(value);
          return output2;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base2;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor2(delta / damp) : delta >> 1;
        delta += floor2(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base2) {
          delta = floor2(delta / baseMinusTMin);
        }
        return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output2 = [], inputLength = input.length, out, i2 = 0, n = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t2, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error3("not-basic");
          }
          output2.push(input.charCodeAt(j));
        }
        for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          for (oldi = i2, w = 1, k = base2; ; k += base2) {
            if (index2 >= inputLength) {
              error3("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base2 || digit > floor2((maxInt - i2) / w)) {
              error3("overflow");
            }
            i2 += digit * w;
            t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t2) {
              break;
            }
            baseMinusT = base2 - t2;
            if (w > floor2(maxInt / baseMinusT)) {
              error3("overflow");
            }
            w *= baseMinusT;
          }
          out = output2.length + 1;
          bias = adapt(i2 - oldi, out, oldi == 0);
          if (floor2(i2 / out) > maxInt - n) {
            error3("overflow");
          }
          n += floor2(i2 / out);
          i2 %= out;
          output2.splice(i2++, 0, n);
        }
        return ucs2encode(output2);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t2, currentValue, output2 = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output2.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output2.length;
        if (basicLength) {
          output2.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor2((maxInt - delta) / handledCPCountPlusOne)) {
            error3("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error3("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base2; ; k += base2) {
                t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                qMinusT = q - t2;
                baseMinusT = base2 - t2;
                output2.push(
                  stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                );
                q = floor2(qMinusT / baseMinusT);
              }
              output2.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output2.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string2) {
          return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string2) {
          return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key2 in punycode2) {
            punycode2.hasOwnProperty(key2) && (freeExports[key2] = punycode2[key2]);
          }
        }
      } else {
        root.punycode = punycode2;
      }
    })(punycode$3);
  })(punycode$4, punycode$4.exports);
  return punycode$4.exports;
}
var IPv6$1 = { exports: {} };
/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var IPv6 = IPv6$1.exports;
var hasRequiredIPv6;
function requireIPv6() {
  if (hasRequiredIPv6) return IPv6$1.exports;
  hasRequiredIPv6 = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        root.IPv6 = factory(root);
      }
    })(IPv6, function(root) {
      var _IPv6 = root && root.IPv6;
      function bestPresentation(address) {
        var _address = address.toLowerCase();
        var segments = _address.split(":");
        var length = segments.length;
        var total = 8;
        if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
          segments.shift();
          segments.shift();
        } else if (segments[0] === "" && segments[1] === "") {
          segments.shift();
        } else if (segments[length - 1] === "" && segments[length - 2] === "") {
          segments.pop();
        }
        length = segments.length;
        if (segments[length - 1].indexOf(".") !== -1) {
          total = 7;
        }
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (segments[pos] === "") {
            break;
          }
        }
        if (pos < total) {
          segments.splice(pos, 1, "0000");
          while (segments.length < total) {
            segments.splice(pos, 0, "0000");
          }
        }
        var _segments;
        for (var i2 = 0; i2 < total; i2++) {
          _segments = segments[i2].split("");
          for (var j = 0; j < 3; j++) {
            if (_segments[0] === "0" && _segments.length > 1) {
              _segments.splice(0, 1);
            } else {
              break;
            }
          }
          segments[i2] = _segments.join("");
        }
        var best = -1;
        var _best = 0;
        var _current = 0;
        var current = -1;
        var inzeroes = false;
        for (i2 = 0; i2 < total; i2++) {
          if (inzeroes) {
            if (segments[i2] === "0") {
              _current += 1;
            } else {
              inzeroes = false;
              if (_current > _best) {
                best = current;
                _best = _current;
              }
            }
          } else {
            if (segments[i2] === "0") {
              inzeroes = true;
              current = i2;
              _current = 1;
            }
          }
        }
        if (_current > _best) {
          best = current;
          _best = _current;
        }
        if (_best > 1) {
          segments.splice(best, _best, "");
        }
        length = segments.length;
        var result = "";
        if (segments[0] === "") {
          result = ":";
        }
        for (i2 = 0; i2 < length; i2++) {
          result += segments[i2];
          if (i2 === length - 1) {
            break;
          }
          result += ":";
        }
        if (segments[length - 1] === "") {
          result += ":";
        }
        return result;
      }
      function noConflict() {
        if (root.IPv6 === this) {
          root.IPv6 = _IPv6;
        }
        return this;
      }
      return {
        best: bestPresentation,
        noConflict
      };
    });
  })(IPv6$1);
  return IPv6$1.exports;
}
var SecondLevelDomains$1 = { exports: {} };
/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var SecondLevelDomains = SecondLevelDomains$1.exports;
var hasRequiredSecondLevelDomains;
function requireSecondLevelDomains() {
  if (hasRequiredSecondLevelDomains) return SecondLevelDomains$1.exports;
  hasRequiredSecondLevelDomains = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        root.SecondLevelDomains = factory(root);
      }
    })(SecondLevelDomains, function(root) {
      var _SecondLevelDomains = root && root.SecondLevelDomains;
      var SLD = {
        // list of known Second Level Domains
        // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
        // ----
        // publicsuffix.org is more current and actually used by a couple of browsers internally.
        // downside is it also contains domains like "dyndns.org" - which is fine for the security
        // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
        // ----
        list: {
          "ac": " com gov mil net org ",
          "ae": " ac co gov mil name net org pro sch ",
          "af": " com edu gov net org ",
          "al": " com edu gov mil net org ",
          "ao": " co ed gv it og pb ",
          "ar": " com edu gob gov int mil net org tur ",
          "at": " ac co gv or ",
          "au": " asn com csiro edu gov id net org ",
          "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          "bb": " biz co com edu gov info net org store tv ",
          "bh": " biz cc com edu gov info net org ",
          "bn": " com edu gov net org ",
          "bo": " com edu gob gov int mil net org tv ",
          "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          "bs": " com edu gov net org ",
          "bz": " du et om ov rg ",
          "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          "ck": " biz co edu gen gov info net org ",
          "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          "co": " com edu gov mil net nom org ",
          "cr": " ac c co ed fi go or sa ",
          "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          "do": " art com edu gob gov mil net org sld web ",
          "dz": " art asso com edu gov net org pol ",
          "ec": " com edu fin gov info med mil net org pro ",
          "eg": " com edu eun gov mil name net org sci ",
          "er": " com edu gov ind mil net org rochest w ",
          "es": " com edu gob nom org ",
          "et": " biz com edu gov info name net org ",
          "fj": " ac biz com info mil name net org pro ",
          "fk": " ac co gov net nom org ",
          "fr": " asso com f gouv nom prd presse tm ",
          "gg": " co net org ",
          "gh": " com edu gov mil org ",
          "gn": " ac com gov net org ",
          "gr": " com edu gov mil net org ",
          "gt": " com edu gob ind mil net org ",
          "gu": " com edu gov net org ",
          "hk": " com edu gov idv net org ",
          "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          "id": " ac co go mil net or sch web ",
          "il": " ac co gov idf k12 muni net org ",
          "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
          "iq": " com edu gov i mil net org ",
          "ir": " ac co dnssec gov i id net org sch ",
          "it": " edu gov ",
          "je": " co net org ",
          "jo": " com edu gov mil name net org sch ",
          "jp": " ac ad co ed go gr lg ne or ",
          "ke": " ac co go info me mobi ne or sc ",
          "kh": " com edu gov mil net org per ",
          "ki": " biz com de edu gov info mob net org tel ",
          "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          "kn": " edu gov net org ",
          "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          "kw": " com edu gov net org ",
          "ky": " com edu gov net org ",
          "kz": " com edu gov mil net org ",
          "lb": " com edu gov net org ",
          "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          "lr": " com edu gov net org ",
          "lv": " asn com conf edu gov id mil net org ",
          "ly": " com edu gov id med net org plc sch ",
          "ma": " ac co gov m net org press ",
          "mc": " asso tm ",
          "me": " ac co edu gov its net org priv ",
          "mg": " com edu gov mil nom org prd tm ",
          "mk": " com edu gov inf name net org pro ",
          "ml": " com edu gov net org presse ",
          "mn": " edu gov org ",
          "mo": " com edu gov net org ",
          "mt": " com edu gov net org ",
          "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
          "mw": " ac co com coop edu gov int museum net org ",
          "mx": " com edu gob net org ",
          "my": " com edu gov mil name net org sch ",
          "nf": " arts com firm info net other per rec store web ",
          "ng": " biz com edu gov mil mobi name net org sch ",
          "ni": " ac co com edu gob mil net nom org ",
          "np": " com edu gov mil net org ",
          "nr": " biz com edu gov info net org ",
          "om": " ac biz co com edu gov med mil museum net org pro sch ",
          "pe": " com edu gob mil net nom org sld ",
          "ph": " com edu gov i mil net ngo org ",
          "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
          "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          "pr": " ac biz com edu est gov info isla name net org pro prof ",
          "ps": " com edu gov net org plo sec ",
          "pw": " belau co ed go ne or ",
          "ro": " arts com firm info nom nt org rec store tm www ",
          "rs": " ac co edu gov in org ",
          "sb": " com edu gov net org ",
          "sc": " com edu gov net org ",
          "sh": " co com edu gov net nom org ",
          "sl": " com edu gov net org ",
          "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
          "sv": " com edu gob org red ",
          "sz": " ac co org ",
          "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          "tw": " club com ebiz edu game gov idv mil net org ",
          "mu": " ac co com gov net or org ",
          "mz": " ac co edu gov org ",
          "na": " co com ",
          "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          "pa": " abo ac com edu gob ing med net nom org sld ",
          "pt": " com edu gov int net nome org publ ",
          "py": " com edu gov mil net org ",
          "qa": " com edu gov mil net org ",
          "re": " asso com nom ",
          "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          "rw": " ac co com edu gouv gov int mil net ",
          "sa": " com edu gov med net org pub sch ",
          "sd": " com edu gov info med net org tv ",
          "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          "sg": " com edu gov idn net org per ",
          "sn": " art com edu gouv org perso univ ",
          "sy": " com edu gov mil net news org ",
          "th": " ac co go in mi net or ",
          "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
          "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          "tz": " ac co go ne or ",
          "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          "ug": " ac co go ne or org sc ",
          "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          "us": " dni fed isa kids nsn ",
          "uy": " com edu gub mil net org ",
          "ve": " co com edu gob info mil net org web ",
          "vi": " co com k12 net org ",
          "vn": " ac biz com edu gov health info int name net org pro ",
          "ye": " co com gov ltd me net org plc ",
          "yu": " ac co edu gov org ",
          "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          "zm": " ac co com edu gov net org sch ",
          // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
          "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          "net": "gb jp se uk ",
          "org": "ae",
          "de": "com "
        },
        // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
        // in both performance and memory footprint. No initialization required.
        // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
        // Following methods use lastIndexOf() rather than array.split() in order
        // to avoid any memory allocations.
        has: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
        },
        is: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset >= 0) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
        },
        get: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return null;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return null;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return null;
          }
          if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
            return null;
          }
          return domain.slice(sldOffset + 1);
        },
        noConflict: function() {
          if (root.SecondLevelDomains === this) {
            root.SecondLevelDomains = _SecondLevelDomains;
          }
          return this;
        }
      };
      return SLD;
    });
  })(SecondLevelDomains$1);
  return SecondLevelDomains$1.exports;
}
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var URI = URI$1.exports;
var hasRequiredURI;
function requireURI() {
  if (hasRequiredURI) return URI$1.exports;
  hasRequiredURI = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory(requirePunycode$1(), requireIPv6(), requireSecondLevelDomains());
      } else {
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
      }
    })(URI, function(punycode2, IPv62, SLD, root) {
      var _URI = root && root.URI;
      function URI2(url2, base2) {
        var _urlSupplied = arguments.length >= 1;
        var _baseSupplied = arguments.length >= 2;
        if (!(this instanceof URI2)) {
          if (_urlSupplied) {
            if (_baseSupplied) {
              return new URI2(url2, base2);
            }
            return new URI2(url2);
          }
          return new URI2();
        }
        if (url2 === void 0) {
          if (_urlSupplied) {
            throw new TypeError("undefined is not a valid argument for URI");
          }
          if (typeof location !== "undefined") {
            url2 = location.href + "";
          } else {
            url2 = "";
          }
        }
        if (url2 === null) {
          if (_urlSupplied) {
            throw new TypeError("null is not a valid argument for URI");
          }
        }
        this.href(url2);
        if (base2 !== void 0) {
          return this.absoluteTo(base2);
        }
        return this;
      }
      function isInteger(value) {
        return /^[0-9]+$/.test(value);
      }
      URI2.version = "1.19.11";
      var p = URI2.prototype;
      var hasOwn = Object.prototype.hasOwnProperty;
      function escapeRegEx(string2) {
        return string2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function getType(value) {
        if (value === void 0) {
          return "Undefined";
        }
        return String(Object.prototype.toString.call(value)).slice(8, -1);
      }
      function isArray2(obj) {
        return getType(obj) === "Array";
      }
      function filterArrayValues(data, value) {
        var lookup9 = {};
        var i2, length;
        if (getType(value) === "RegExp") {
          lookup9 = null;
        } else if (isArray2(value)) {
          for (i2 = 0, length = value.length; i2 < length; i2++) {
            lookup9[value[i2]] = true;
          }
        } else {
          lookup9[value] = true;
        }
        for (i2 = 0, length = data.length; i2 < length; i2++) {
          var _match = lookup9 && lookup9[data[i2]] !== void 0 || !lookup9 && value.test(data[i2]);
          if (_match) {
            data.splice(i2, 1);
            length--;
            i2--;
          }
        }
        return data;
      }
      function arrayContains(list, value) {
        var i2, length;
        if (isArray2(value)) {
          for (i2 = 0, length = value.length; i2 < length; i2++) {
            if (!arrayContains(list, value[i2])) {
              return false;
            }
          }
          return true;
        }
        var _type = getType(value);
        for (i2 = 0, length = list.length; i2 < length; i2++) {
          if (_type === "RegExp") {
            if (typeof list[i2] === "string" && list[i2].match(value)) {
              return true;
            }
          } else if (list[i2] === value) {
            return true;
          }
        }
        return false;
      }
      function arraysEqual(one, two) {
        if (!isArray2(one) || !isArray2(two)) {
          return false;
        }
        if (one.length !== two.length) {
          return false;
        }
        one.sort();
        two.sort();
        for (var i2 = 0, l = one.length; i2 < l; i2++) {
          if (one[i2] !== two[i2]) {
            return false;
          }
        }
        return true;
      }
      function trimSlashes(text) {
        var trim_expression = /^\/+|\/+$/g;
        return text.replace(trim_expression, "");
      }
      URI2._parts = function() {
        return {
          protocol: null,
          username: null,
          password: null,
          hostname: null,
          urn: null,
          port: null,
          path: null,
          query: null,
          fragment: null,
          // state
          preventInvalidHostname: URI2.preventInvalidHostname,
          duplicateQueryParameters: URI2.duplicateQueryParameters,
          escapeQuerySpace: URI2.escapeQuerySpace
        };
      };
      URI2.preventInvalidHostname = false;
      URI2.duplicateQueryParameters = false;
      URI2.escapeQuerySpace = true;
      URI2.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
      URI2.idn_expression = /[^a-z0-9\._-]/i;
      URI2.punycode_expression = /(xn--)/i;
      URI2.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      URI2.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
      URI2.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
      URI2.findUri = {
        // valid "scheme://" or "www."
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        // everything up to the next whitespace
        end: /[\s\r\n]|$/,
        // trim trailing punctuation captured by end RegExp
        trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
        // balanced parens inclusion (), [], {}, <>
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
      };
      URI2.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      URI2.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
      URI2.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
      };
      URI2.hostProtocols = [
        "http",
        "https"
      ];
      URI2.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
      URI2.domAttributes = {
        "a": "href",
        "blockquote": "cite",
        "link": "href",
        "base": "href",
        "script": "src",
        "form": "action",
        "img": "src",
        "area": "href",
        "iframe": "src",
        "embed": "src",
        "source": "src",
        "track": "src",
        "input": "src",
        // but only if type="image"
        "audio": "src",
        "video": "src"
      };
      URI2.getDomAttribute = function(node2) {
        if (!node2 || !node2.nodeName) {
          return void 0;
        }
        var nodeName = node2.nodeName.toLowerCase();
        if (nodeName === "input" && node2.type !== "image") {
          return void 0;
        }
        return URI2.domAttributes[nodeName];
      };
      function escapeForDumbFirefox36(value) {
        return escape(value);
      }
      function strictEncodeURIComponent(string2) {
        return encodeURIComponent(string2).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
      }
      URI2.encode = strictEncodeURIComponent;
      URI2.decode = decodeURIComponent;
      URI2.iso8859 = function() {
        URI2.encode = escape;
        URI2.decode = unescape;
      };
      URI2.unicode = function() {
        URI2.encode = strictEncodeURIComponent;
        URI2.decode = decodeURIComponent;
      };
      URI2.characters = {
        pathname: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
              // -._~!'()*
              "%24": "$",
              "%26": "&",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%3A": ":",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23"
            }
          }
        },
        reserved: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
              // gen-delims
              "%3A": ":",
              "%2F": "/",
              "%3F": "?",
              "%23": "#",
              "%5B": "[",
              "%5D": "]",
              "%40": "@",
              // sub-delims
              "%21": "!",
              "%24": "$",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "="
            }
          }
        },
        urnpath: {
          // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
          // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
          // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
          // note that the colon character is not featured in the encoding map; this is because URI.js
          // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
          // should not appear unencoded in a segment itself.
          // See also the note above about RFC3986 and capitalalized hex digits.
          encode: {
            expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
            map: {
              "%21": "!",
              "%24": "$",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%40": "@"
            }
          },
          // These characters are the characters called out by RFC2141 as "reserved" characters that
          // should never appear in a URN, plus the colon character (see note above).
          decode: {
            expression: /[\/\?#:]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23",
              ":": "%3A"
            }
          }
        }
      };
      URI2.encodeQuery = function(string2, escapeQuerySpace) {
        var escaped = URI2.encode(string2 + "");
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI2.escapeQuerySpace;
        }
        return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
      };
      URI2.decodeQuery = function(string2, escapeQuerySpace) {
        string2 += "";
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI2.escapeQuerySpace;
        }
        try {
          return URI2.decode(escapeQuerySpace ? string2.replace(/\+/g, "%20") : string2);
        } catch (e) {
          return string2;
        }
      };
      var _parts = { "encode": "encode", "decode": "decode" };
      var _part;
      var generateAccessor = function(_group, _part2) {
        return function(string2) {
          try {
            return URI2[_part2](string2 + "").replace(URI2.characters[_group][_part2].expression, function(c) {
              return URI2.characters[_group][_part2].map[c];
            });
          } catch (e) {
            return string2;
          }
        };
      };
      for (_part in _parts) {
        URI2[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
        URI2[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
      }
      var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
        return function(string2) {
          var actualCodingFunc;
          if (!_innerCodingFuncName) {
            actualCodingFunc = URI2[_codingFuncName];
          } else {
            actualCodingFunc = function(string3) {
              return URI2[_codingFuncName](URI2[_innerCodingFuncName](string3));
            };
          }
          var segments = (string2 + "").split(_sep);
          for (var i2 = 0, length = segments.length; i2 < length; i2++) {
            segments[i2] = actualCodingFunc(segments[i2]);
          }
          return segments.join(_sep);
        };
      };
      URI2.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
      URI2.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
      URI2.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
      URI2.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
      URI2.encodeReserved = generateAccessor("reserved", "encode");
      URI2.parse = function(string2, parts) {
        var pos;
        if (!parts) {
          parts = {
            preventInvalidHostname: URI2.preventInvalidHostname
          };
        }
        string2 = string2.replace(URI2.leading_whitespace_expression, "");
        string2 = string2.replace(URI2.ascii_tab_whitespace, "");
        pos = string2.indexOf("#");
        if (pos > -1) {
          parts.fragment = string2.substring(pos + 1) || null;
          string2 = string2.substring(0, pos);
        }
        pos = string2.indexOf("?");
        if (pos > -1) {
          parts.query = string2.substring(pos + 1) || null;
          string2 = string2.substring(0, pos);
        }
        string2 = string2.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://");
        string2 = string2.replace(/^[/\\]{2,}/i, "//");
        if (string2.substring(0, 2) === "//") {
          parts.protocol = null;
          string2 = string2.substring(2);
          string2 = URI2.parseAuthority(string2, parts);
        } else {
          pos = string2.indexOf(":");
          if (pos > -1) {
            parts.protocol = string2.substring(0, pos) || null;
            if (parts.protocol && !parts.protocol.match(URI2.protocol_expression)) {
              parts.protocol = void 0;
            } else if (string2.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
              string2 = string2.substring(pos + 3);
              string2 = URI2.parseAuthority(string2, parts);
            } else {
              string2 = string2.substring(pos + 1);
              parts.urn = true;
            }
          }
        }
        parts.path = string2;
        return parts;
      };
      URI2.parseHost = function(string2, parts) {
        if (!string2) {
          string2 = "";
        }
        string2 = string2.replace(/\\/g, "/");
        var pos = string2.indexOf("/");
        var bracketPos;
        var t2;
        if (pos === -1) {
          pos = string2.length;
        }
        if (string2.charAt(0) === "[") {
          bracketPos = string2.indexOf("]");
          parts.hostname = string2.substring(1, bracketPos) || null;
          parts.port = string2.substring(bracketPos + 2, pos) || null;
          if (parts.port === "/") {
            parts.port = null;
          }
        } else {
          var firstColon = string2.indexOf(":");
          var firstSlash = string2.indexOf("/");
          var nextColon = string2.indexOf(":", firstColon + 1);
          if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
            parts.hostname = string2.substring(0, pos) || null;
            parts.port = null;
          } else {
            t2 = string2.substring(0, pos).split(":");
            parts.hostname = t2[0] || null;
            parts.port = t2[1] || null;
          }
        }
        if (parts.hostname && string2.substring(pos).charAt(0) !== "/") {
          pos++;
          string2 = "/" + string2;
        }
        if (parts.preventInvalidHostname) {
          URI2.ensureValidHostname(parts.hostname, parts.protocol);
        }
        if (parts.port) {
          URI2.ensureValidPort(parts.port);
        }
        return string2.substring(pos) || "/";
      };
      URI2.parseAuthority = function(string2, parts) {
        string2 = URI2.parseUserinfo(string2, parts);
        return URI2.parseHost(string2, parts);
      };
      URI2.parseUserinfo = function(string2, parts) {
        var _string = string2;
        var firstBackSlash = string2.indexOf("\\");
        if (firstBackSlash !== -1) {
          string2 = string2.replace(/\\/g, "/");
        }
        var firstSlash = string2.indexOf("/");
        var pos = string2.lastIndexOf("@", firstSlash > -1 ? firstSlash : string2.length - 1);
        var t2;
        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
          t2 = string2.substring(0, pos).split(":");
          parts.username = t2[0] ? URI2.decode(t2[0]) : null;
          t2.shift();
          parts.password = t2[0] ? URI2.decode(t2.join(":")) : null;
          string2 = _string.substring(pos + 1);
        } else {
          parts.username = null;
          parts.password = null;
        }
        return string2;
      };
      URI2.parseQuery = function(string2, escapeQuerySpace) {
        if (!string2) {
          return {};
        }
        string2 = string2.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
        if (!string2) {
          return {};
        }
        var items = {};
        var splits = string2.split("&");
        var length = splits.length;
        var v, name, value;
        for (var i2 = 0; i2 < length; i2++) {
          v = splits[i2].split("=");
          name = URI2.decodeQuery(v.shift(), escapeQuerySpace);
          value = v.length ? URI2.decodeQuery(v.join("="), escapeQuerySpace) : null;
          if (name === "__proto__") {
            continue;
          } else if (hasOwn.call(items, name)) {
            if (typeof items[name] === "string" || items[name] === null) {
              items[name] = [items[name]];
            }
            items[name].push(value);
          } else {
            items[name] = value;
          }
        }
        return items;
      };
      URI2.build = function(parts) {
        var t2 = "";
        var requireAbsolutePath = false;
        if (parts.protocol) {
          t2 += parts.protocol + ":";
        }
        if (!parts.urn && (t2 || parts.hostname)) {
          t2 += "//";
          requireAbsolutePath = true;
        }
        t2 += URI2.buildAuthority(parts) || "";
        if (typeof parts.path === "string") {
          if (parts.path.charAt(0) !== "/" && requireAbsolutePath) {
            t2 += "/";
          }
          t2 += parts.path;
        }
        if (typeof parts.query === "string" && parts.query) {
          t2 += "?" + parts.query;
        }
        if (typeof parts.fragment === "string" && parts.fragment) {
          t2 += "#" + parts.fragment;
        }
        return t2;
      };
      URI2.buildHost = function(parts) {
        var t2 = "";
        if (!parts.hostname) {
          return "";
        } else if (URI2.ip6_expression.test(parts.hostname)) {
          t2 += "[" + parts.hostname + "]";
        } else {
          t2 += parts.hostname;
        }
        if (parts.port) {
          t2 += ":" + parts.port;
        }
        return t2;
      };
      URI2.buildAuthority = function(parts) {
        return URI2.buildUserinfo(parts) + URI2.buildHost(parts);
      };
      URI2.buildUserinfo = function(parts) {
        var t2 = "";
        if (parts.username) {
          t2 += URI2.encode(parts.username);
        }
        if (parts.password) {
          t2 += ":" + URI2.encode(parts.password);
        }
        if (t2) {
          t2 += "@";
        }
        return t2;
      };
      URI2.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
        var t2 = "";
        var unique, key2, i2, length;
        for (key2 in data) {
          if (key2 === "__proto__") {
            continue;
          } else if (hasOwn.call(data, key2)) {
            if (isArray2(data[key2])) {
              unique = {};
              for (i2 = 0, length = data[key2].length; i2 < length; i2++) {
                if (data[key2][i2] !== void 0 && unique[data[key2][i2] + ""] === void 0) {
                  t2 += "&" + URI2.buildQueryParameter(key2, data[key2][i2], escapeQuerySpace);
                  if (duplicateQueryParameters !== true) {
                    unique[data[key2][i2] + ""] = true;
                  }
                }
              }
            } else if (data[key2] !== void 0) {
              t2 += "&" + URI2.buildQueryParameter(key2, data[key2], escapeQuerySpace);
            }
          }
        }
        return t2.substring(1);
      };
      URI2.buildQueryParameter = function(name, value, escapeQuerySpace) {
        return URI2.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI2.encodeQuery(value, escapeQuerySpace) : "");
      };
      URI2.addQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key2 in name) {
            if (hasOwn.call(name, key2)) {
              URI2.addQuery(data, key2, name[key2]);
            }
          }
        } else if (typeof name === "string") {
          if (data[name] === void 0) {
            data[name] = value;
            return;
          } else if (typeof data[name] === "string") {
            data[name] = [data[name]];
          }
          if (!isArray2(value)) {
            value = [value];
          }
          data[name] = (data[name] || []).concat(value);
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
      };
      URI2.setQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key2 in name) {
            if (hasOwn.call(name, key2)) {
              URI2.setQuery(data, key2, name[key2]);
            }
          }
        } else if (typeof name === "string") {
          data[name] = value === void 0 ? null : value;
        } else {
          throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
        }
      };
      URI2.removeQuery = function(data, name, value) {
        var i2, length, key2;
        if (isArray2(name)) {
          for (i2 = 0, length = name.length; i2 < length; i2++) {
            data[name[i2]] = void 0;
          }
        } else if (getType(name) === "RegExp") {
          for (key2 in data) {
            if (name.test(key2)) {
              data[key2] = void 0;
            }
          }
        } else if (typeof name === "object") {
          for (key2 in name) {
            if (hasOwn.call(name, key2)) {
              URI2.removeQuery(data, key2, name[key2]);
            }
          }
        } else if (typeof name === "string") {
          if (value !== void 0) {
            if (getType(value) === "RegExp") {
              if (!isArray2(data[name]) && value.test(data[name])) {
                data[name] = void 0;
              } else {
                data[name] = filterArrayValues(data[name], value);
              }
            } else if (data[name] === String(value) && (!isArray2(value) || value.length === 1)) {
              data[name] = void 0;
            } else if (isArray2(data[name])) {
              data[name] = filterArrayValues(data[name], value);
            }
          } else {
            data[name] = void 0;
          }
        } else {
          throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
        }
      };
      URI2.hasQuery = function(data, name, value, withinArray) {
        switch (getType(name)) {
          case "String":
            break;
          case "RegExp":
            for (var key2 in data) {
              if (hasOwn.call(data, key2)) {
                if (name.test(key2) && (value === void 0 || URI2.hasQuery(data, key2, value))) {
                  return true;
                }
              }
            }
            return false;
          case "Object":
            for (var _key in name) {
              if (hasOwn.call(name, _key)) {
                if (!URI2.hasQuery(data, _key, name[_key])) {
                  return false;
                }
              }
            }
            return true;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (getType(value)) {
          case "Undefined":
            return name in data;
          // data[name] !== undefined;
          case "Boolean":
            var _booly = Boolean(isArray2(data[name]) ? data[name].length : data[name]);
            return value === _booly;
          case "Function":
            return !!value(data[name], name, data);
          case "Array":
            if (!isArray2(data[name])) {
              return false;
            }
            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);
          case "RegExp":
            if (!isArray2(data[name])) {
              return Boolean(data[name] && data[name].match(value));
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          case "Number":
            value = String(value);
          /* falls through */
          case "String":
            if (!isArray2(data[name])) {
              return data[name] === value;
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      };
      URI2.joinPaths = function() {
        var input = [];
        var segments = [];
        var nonEmptySegments = 0;
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var url2 = new URI2(arguments[i2]);
          input.push(url2);
          var _segments = url2.segment();
          for (var s = 0; s < _segments.length; s++) {
            if (typeof _segments[s] === "string") {
              segments.push(_segments[s]);
            }
            if (_segments[s]) {
              nonEmptySegments++;
            }
          }
        }
        if (!segments.length || !nonEmptySegments) {
          return new URI2("");
        }
        var uri2 = new URI2("").segment(segments);
        if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
          uri2.path("/" + uri2.path());
        }
        return uri2.normalize();
      };
      URI2.commonPath = function(one, two) {
        var length = Math.min(one.length, two.length);
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
          }
        }
        if (pos < 1) {
          return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
        }
        if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
          pos = one.substring(0, pos).lastIndexOf("/");
        }
        return one.substring(0, pos + 1);
      };
      URI2.withinString = function(string2, callback, options2) {
        options2 || (options2 = {});
        var _start = options2.start || URI2.findUri.start;
        var _end = options2.end || URI2.findUri.end;
        var _trim = options2.trim || URI2.findUri.trim;
        var _parens = options2.parens || URI2.findUri.parens;
        var _attributeOpen = /[a-z0-9-]=["']?$/i;
        _start.lastIndex = 0;
        while (true) {
          var match = _start.exec(string2);
          if (!match) {
            break;
          }
          var start = match.index;
          if (options2.ignoreHtml) {
            var attributeOpen = string2.slice(Math.max(start - 3, 0), start);
            if (attributeOpen && _attributeOpen.test(attributeOpen)) {
              continue;
            }
          }
          var end = start + string2.slice(start).search(_end);
          var slice2 = string2.slice(start, end);
          var parensEnd = -1;
          while (true) {
            var parensMatch = _parens.exec(slice2);
            if (!parensMatch) {
              break;
            }
            var parensMatchEnd = parensMatch.index + parensMatch[0].length;
            parensEnd = Math.max(parensEnd, parensMatchEnd);
          }
          if (parensEnd > -1) {
            slice2 = slice2.slice(0, parensEnd) + slice2.slice(parensEnd).replace(_trim, "");
          } else {
            slice2 = slice2.replace(_trim, "");
          }
          if (slice2.length <= match[0].length) {
            continue;
          }
          if (options2.ignore && options2.ignore.test(slice2)) {
            continue;
          }
          end = start + slice2.length;
          var result = callback(slice2, start, end, string2);
          if (result === void 0) {
            _start.lastIndex = end;
            continue;
          }
          result = String(result);
          string2 = string2.slice(0, start) + result + string2.slice(end);
          _start.lastIndex = start + result.length;
        }
        _start.lastIndex = 0;
        return string2;
      };
      URI2.ensureValidHostname = function(v, protocol) {
        var hasHostname = !!v;
        var hasProtocol = !!protocol;
        var rejectEmptyHostname = false;
        if (hasProtocol) {
          rejectEmptyHostname = arrayContains(URI2.hostProtocols, protocol);
        }
        if (rejectEmptyHostname && !hasHostname) {
          throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
        } else if (v && v.match(URI2.invalid_hostname_characters)) {
          if (!punycode2) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          }
          if (punycode2.toASCII(v).match(URI2.invalid_hostname_characters)) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
          }
        }
      };
      URI2.ensureValidPort = function(v) {
        if (!v) {
          return;
        }
        var port = Number(v);
        if (isInteger(port) && port > 0 && port < 65536) {
          return;
        }
        throw new TypeError('Port "' + v + '" is not a valid port');
      };
      URI2.noConflict = function(removeAll) {
        if (removeAll) {
          var unconflicted = {
            URI: this.noConflict()
          };
          if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
            unconflicted.URITemplate = root.URITemplate.noConflict();
          }
          if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
            unconflicted.IPv6 = root.IPv6.noConflict();
          }
          if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
            unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
          }
          return unconflicted;
        } else if (root.URI === this) {
          root.URI = _URI;
        }
        return this;
      };
      p.build = function(deferBuild) {
        if (deferBuild === true) {
          this._deferred_build = true;
        } else if (deferBuild === void 0 || this._deferred_build) {
          this._string = URI2.build(this._parts);
          this._deferred_build = false;
        }
        return this;
      };
      p.clone = function() {
        return new URI2(this);
      };
      p.valueOf = p.toString = function() {
        return this.build(false)._string;
      };
      function generateSimpleAccessor(_part2) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            this._parts[_part2] = v || null;
            this.build(!build);
            return this;
          }
        };
      }
      function generatePrefixAccessor(_part2, _key) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            if (v !== null) {
              v = v + "";
              if (v.charAt(0) === _key) {
                v = v.substring(1);
              }
            }
            this._parts[_part2] = v;
            this.build(!build);
            return this;
          }
        };
      }
      p.protocol = generateSimpleAccessor("protocol");
      p.username = generateSimpleAccessor("username");
      p.password = generateSimpleAccessor("password");
      p.hostname = generateSimpleAccessor("hostname");
      p.port = generateSimpleAccessor("port");
      p.query = generatePrefixAccessor("query", "?");
      p.fragment = generatePrefixAccessor("fragment", "#");
      p.search = function(v, build) {
        var t2 = this.query(v, build);
        return typeof t2 === "string" && t2.length ? "?" + t2 : t2;
      };
      p.hash = function(v, build) {
        var t2 = this.fragment(v, build);
        return typeof t2 === "string" && t2.length ? "#" + t2 : t2;
      };
      p.pathname = function(v, build) {
        if (v === void 0 || v === true) {
          var res = this._parts.path || (this._parts.hostname ? "/" : "");
          return v ? (this._parts.urn ? URI2.decodeUrnPath : URI2.decodePath)(res) : res;
        } else {
          if (this._parts.urn) {
            this._parts.path = v ? URI2.recodeUrnPath(v) : "";
          } else {
            this._parts.path = v ? URI2.recodePath(v) : "/";
          }
          this.build(!build);
          return this;
        }
      };
      p.path = p.pathname;
      p.href = function(href, build) {
        var key2;
        if (href === void 0) {
          return this.toString();
        }
        this._string = "";
        this._parts = URI2._parts();
        var _URI2 = href instanceof URI2;
        var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
        if (href.nodeName) {
          var attribute = URI2.getDomAttribute(href);
          href = href[attribute] || "";
          _object = false;
        }
        if (!_URI2 && _object && href.pathname !== void 0) {
          href = href.toString();
        }
        if (typeof href === "string" || href instanceof String) {
          this._parts = URI2.parse(String(href), this._parts);
        } else if (_URI2 || _object) {
          var src = _URI2 ? href._parts : href;
          for (key2 in src) {
            if (key2 === "query") {
              continue;
            }
            if (hasOwn.call(this._parts, key2)) {
              this._parts[key2] = src[key2];
            }
          }
          if (src.query) {
            this.query(src.query, false);
          }
        } else {
          throw new TypeError("invalid input");
        }
        this.build(!build);
        return this;
      };
      p.is = function(what) {
        var ip = false;
        var ip4 = false;
        var ip6 = false;
        var name = false;
        var sld = false;
        var idn = false;
        var punycode3 = false;
        var relative = !this._parts.urn;
        if (this._parts.hostname) {
          relative = false;
          ip4 = URI2.ip4_expression.test(this._parts.hostname);
          ip6 = URI2.ip6_expression.test(this._parts.hostname);
          ip = ip4 || ip6;
          name = !ip;
          sld = name && SLD && SLD.has(this._parts.hostname);
          idn = name && URI2.idn_expression.test(this._parts.hostname);
          punycode3 = name && URI2.punycode_expression.test(this._parts.hostname);
        }
        switch (what.toLowerCase()) {
          case "relative":
            return relative;
          case "absolute":
            return !relative;
          // hostname identification
          case "domain":
          case "name":
            return name;
          case "sld":
            return sld;
          case "ip":
            return ip;
          case "ip4":
          case "ipv4":
          case "inet4":
            return ip4;
          case "ip6":
          case "ipv6":
          case "inet6":
            return ip6;
          case "idn":
            return idn;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return punycode3;
        }
        return null;
      };
      var _protocol = p.protocol;
      var _port = p.port;
      var _hostname = p.hostname;
      p.protocol = function(v, build) {
        if (v) {
          v = v.replace(/:(\/\/)?$/, "");
          if (!v.match(URI2.protocol_expression)) {
            throw new TypeError('Protocol "' + v + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
          }
        }
        return _protocol.call(this, v, build);
      };
      p.scheme = p.protocol;
      p.port = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          if (v === 0) {
            v = null;
          }
          if (v) {
            v += "";
            if (v.charAt(0) === ":") {
              v = v.substring(1);
            }
            URI2.ensureValidPort(v);
          }
        }
        return _port.call(this, v, build);
      };
      p.hostname = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
          var res = URI2.parseHost(v, x);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          v = x.hostname;
          if (this._parts.preventInvalidHostname) {
            URI2.ensureValidHostname(v, this._parts.protocol);
          }
        }
        return _hostname.call(this, v, build);
      };
      p.origin = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var protocol = this.protocol();
          var authority = this.authority();
          if (!authority) {
            return "";
          }
          return (protocol ? protocol + "://" : "") + this.authority();
        } else {
          var origin = URI2(v);
          this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
          return this;
        }
      };
      p.host = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI2.buildHost(this._parts) : "";
        } else {
          var res = URI2.parseHost(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.authority = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI2.buildAuthority(this._parts) : "";
        } else {
          var res = URI2.parseAuthority(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.userinfo = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var t2 = URI2.buildUserinfo(this._parts);
          return t2 ? t2.substring(0, t2.length - 1) : t2;
        } else {
          if (v[v.length - 1] !== "@") {
            v += "@";
          }
          URI2.parseUserinfo(v, this._parts);
          this.build(!build);
          return this;
        }
      };
      p.resource = function(v, build) {
        var parts;
        if (v === void 0) {
          return this.path() + this.search() + this.hash();
        }
        parts = URI2.parse(v);
        this._parts.path = parts.path;
        this._parts.query = parts.query;
        this._parts.fragment = parts.fragment;
        this.build(!build);
        return this;
      };
      p.subdomain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var end = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, end) || "";
        } else {
          var e = this._parts.hostname.length - this.domain().length;
          var sub = this._parts.hostname.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(sub));
          if (v && v.charAt(v.length - 1) !== ".") {
            v += ".";
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          if (v) {
            URI2.ensureValidHostname(v, this._parts.protocol);
          }
          this._parts.hostname = this._parts.hostname.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.domain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var t2 = this._parts.hostname.match(/\./g);
          if (t2 && t2.length < 2) {
            return this._parts.hostname;
          }
          var end = this._parts.hostname.length - this.tld(build).length - 1;
          end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
          return this._parts.hostname.substring(end) || "";
        } else {
          if (!v) {
            throw new TypeError("cannot set domain empty");
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          URI2.ensureValidHostname(v, this._parts.protocol);
          if (!this._parts.hostname || this.is("IP")) {
            this._parts.hostname = v;
          } else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.tld = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var pos = this._parts.hostname.lastIndexOf(".");
          var tld = this._parts.hostname.substring(pos + 1);
          if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
            return SLD.get(this._parts.hostname) || tld;
          }
          return tld;
        } else {
          var replace;
          if (!v) {
            throw new TypeError("cannot set TLD empty");
          } else if (v.match(/[^a-zA-Z0-9-]/)) {
            if (SLD && SLD.is(v)) {
              replace = new RegExp(escapeRegEx(this.tld()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v);
            } else {
              throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
            }
          } else if (!this._parts.hostname || this.is("IP")) {
            throw new ReferenceError("cannot set TLD on non-domain host");
          } else {
            replace = new RegExp(escapeRegEx(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.directory = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path && !this._parts.hostname) {
            return "";
          }
          if (this._parts.path === "/") {
            return "/";
          }
          var end = this._parts.path.length - this.filename().length - 1;
          var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
          return v ? URI2.decodePath(res) : res;
        } else {
          var e = this._parts.path.length - this.filename().length;
          var directory = this._parts.path.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(directory));
          if (!this.is("relative")) {
            if (!v) {
              v = "/";
            }
            if (v.charAt(0) !== "/") {
              v = "/" + v;
            }
          }
          if (v && v.charAt(v.length - 1) !== "/") {
            v += "/";
          }
          v = URI2.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.filename = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v !== "string") {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var pos = this._parts.path.lastIndexOf("/");
          var res = this._parts.path.substring(pos + 1);
          return v ? URI2.decodePathSegment(res) : res;
        } else {
          var mutatedDirectory = false;
          if (v.charAt(0) === "/") {
            v = v.substring(1);
          }
          if (v.match(/\.?\//)) {
            mutatedDirectory = true;
          }
          var replace = new RegExp(escapeRegEx(this.filename()) + "$");
          v = URI2.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          if (mutatedDirectory) {
            this.normalizePath(build);
          } else {
            this.build(!build);
          }
          return this;
        }
      };
      p.suffix = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var filename = this.filename();
          var pos = filename.lastIndexOf(".");
          var s, res;
          if (pos === -1) {
            return "";
          }
          s = filename.substring(pos + 1);
          res = /^[a-z0-9%]+$/i.test(s) ? s : "";
          return v ? URI2.decodePathSegment(res) : res;
        } else {
          if (v.charAt(0) === ".") {
            v = v.substring(1);
          }
          var suffix = this.suffix();
          var replace;
          if (!suffix) {
            if (!v) {
              return this;
            }
            this._parts.path += "." + URI2.recodePath(v);
          } else if (!v) {
            replace = new RegExp(escapeRegEx("." + suffix) + "$");
          } else {
            replace = new RegExp(escapeRegEx(suffix) + "$");
          }
          if (replace) {
            v = URI2.recodePath(v);
            this._parts.path = this._parts.path.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.segment = function(segment, v, build) {
        var separator = this._parts.urn ? ":" : "/";
        var path2 = this.path();
        var absolute = path2.substring(0, 1) === "/";
        var segments = path2.split(separator);
        if (segment !== void 0 && typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (segment !== void 0 && typeof segment !== "number") {
          throw new Error('Bad segment "' + segment + '", must be 0-based integer');
        }
        if (absolute) {
          segments.shift();
        }
        if (segment < 0) {
          segment = Math.max(segments.length + segment, 0);
        }
        if (v === void 0) {
          return segment === void 0 ? segments : segments[segment];
        } else if (segment === null || segments[segment] === void 0) {
          if (isArray2(v)) {
            segments = [];
            for (var i2 = 0, l = v.length; i2 < l; i2++) {
              if (!v[i2].length && (!segments.length || !segments[segments.length - 1].length)) {
                continue;
              }
              if (segments.length && !segments[segments.length - 1].length) {
                segments.pop();
              }
              segments.push(trimSlashes(v[i2]));
            }
          } else if (v || typeof v === "string") {
            v = trimSlashes(v);
            if (segments[segments.length - 1] === "") {
              segments[segments.length - 1] = v;
            } else {
              segments.push(v);
            }
          }
        } else {
          if (v) {
            segments[segment] = trimSlashes(v);
          } else {
            segments.splice(segment, 1);
          }
        }
        if (absolute) {
          segments.unshift("");
        }
        return this.path(segments.join(separator), build);
      };
      p.segmentCoded = function(segment, v, build) {
        var segments, i2, l;
        if (typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (v === void 0) {
          segments = this.segment(segment, v, build);
          if (!isArray2(segments)) {
            segments = segments !== void 0 ? URI2.decode(segments) : void 0;
          } else {
            for (i2 = 0, l = segments.length; i2 < l; i2++) {
              segments[i2] = URI2.decode(segments[i2]);
            }
          }
          return segments;
        }
        if (!isArray2(v)) {
          v = typeof v === "string" || v instanceof String ? URI2.encode(v) : v;
        } else {
          for (i2 = 0, l = v.length; i2 < l; i2++) {
            v[i2] = URI2.encode(v[i2]);
          }
        }
        return this.segment(segment, v, build);
      };
      var q = p.query;
      p.query = function(v, build) {
        if (v === true) {
          return URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        } else if (typeof v === "function") {
          var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          var result = v.call(this, data);
          this._parts.query = URI2.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else if (v !== void 0 && typeof v !== "string") {
          this._parts.query = URI2.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else {
          return q.call(this, v, build);
        }
      };
      p.setQuery = function(name, value, build) {
        var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof name === "string" || name instanceof String) {
          data[name] = value !== void 0 ? value : null;
        } else if (typeof name === "object") {
          for (var key2 in name) {
            if (hasOwn.call(name, key2)) {
              data[key2] = name[key2];
            }
          }
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
        this._parts.query = URI2.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.addQuery = function(name, value, build) {
        var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI2.addQuery(data, name, value === void 0 ? null : value);
        this._parts.query = URI2.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.removeQuery = function(name, value, build) {
        var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI2.removeQuery(data, name, value);
        this._parts.query = URI2.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.hasQuery = function(name, value, withinArray) {
        var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI2.hasQuery(data, name, value, withinArray);
      };
      p.setSearch = p.setQuery;
      p.addSearch = p.addQuery;
      p.removeSearch = p.removeQuery;
      p.hasSearch = p.hasQuery;
      p.normalize = function() {
        if (this._parts.urn) {
          return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        }
        return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      };
      p.normalizeProtocol = function(build) {
        if (typeof this._parts.protocol === "string") {
          this._parts.protocol = this._parts.protocol.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizeHostname = function(build) {
        if (this._parts.hostname) {
          if (this.is("IDN") && punycode2) {
            this._parts.hostname = punycode2.toASCII(this._parts.hostname);
          } else if (this.is("IPv6") && IPv62) {
            this._parts.hostname = IPv62.best(this._parts.hostname);
          }
          this._parts.hostname = this._parts.hostname.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizePort = function(build) {
        if (typeof this._parts.protocol === "string" && this._parts.port === URI2.defaultPorts[this._parts.protocol]) {
          this._parts.port = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizePath = function(build) {
        var _path = this._parts.path;
        if (!_path) {
          return this;
        }
        if (this._parts.urn) {
          this._parts.path = URI2.recodeUrnPath(this._parts.path);
          this.build(!build);
          return this;
        }
        if (this._parts.path === "/") {
          return this;
        }
        _path = URI2.recodePath(_path);
        var _was_relative;
        var _leadingParents = "";
        var _parent, _pos;
        if (_path.charAt(0) !== "/") {
          _was_relative = true;
          _path = "/" + _path;
        }
        if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
          _path += "/";
        }
        _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
        if (_was_relative) {
          _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
          if (_leadingParents) {
            _leadingParents = _leadingParents[0];
          }
        }
        while (true) {
          _parent = _path.search(/\/\.\.(\/|$)/);
          if (_parent === -1) {
            break;
          } else if (_parent === 0) {
            _path = _path.substring(3);
            continue;
          }
          _pos = _path.substring(0, _parent).lastIndexOf("/");
          if (_pos === -1) {
            _pos = _parent;
          }
          _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
        }
        if (_was_relative && this.is("relative")) {
          _path = _leadingParents + _path.substring(1);
        }
        this._parts.path = _path;
        this.build(!build);
        return this;
      };
      p.normalizePathname = p.normalizePath;
      p.normalizeQuery = function(build) {
        if (typeof this._parts.query === "string") {
          if (!this._parts.query.length) {
            this._parts.query = null;
          } else {
            this.query(URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
          }
          this.build(!build);
        }
        return this;
      };
      p.normalizeFragment = function(build) {
        if (!this._parts.fragment) {
          this._parts.fragment = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizeSearch = p.normalizeQuery;
      p.normalizeHash = p.normalizeFragment;
      p.iso8859 = function() {
        var e = URI2.encode;
        var d = URI2.decode;
        URI2.encode = escape;
        URI2.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          URI2.encode = e;
          URI2.decode = d;
        }
        return this;
      };
      p.unicode = function() {
        var e = URI2.encode;
        var d = URI2.decode;
        URI2.encode = strictEncodeURIComponent;
        URI2.decode = unescape;
        try {
          this.normalize();
        } finally {
          URI2.encode = e;
          URI2.decode = d;
        }
        return this;
      };
      p.readable = function() {
        var uri2 = this.clone();
        uri2.username("").password("").normalize();
        var t2 = "";
        if (uri2._parts.protocol) {
          t2 += uri2._parts.protocol + "://";
        }
        if (uri2._parts.hostname) {
          if (uri2.is("punycode") && punycode2) {
            t2 += punycode2.toUnicode(uri2._parts.hostname);
            if (uri2._parts.port) {
              t2 += ":" + uri2._parts.port;
            }
          } else {
            t2 += uri2.host();
          }
        }
        if (uri2._parts.hostname && uri2._parts.path && uri2._parts.path.charAt(0) !== "/") {
          t2 += "/";
        }
        t2 += uri2.path(true);
        if (uri2._parts.query) {
          var q2 = "";
          for (var i2 = 0, qp = uri2._parts.query.split("&"), l = qp.length; i2 < l; i2++) {
            var kv = (qp[i2] || "").split("=");
            q2 += "&" + URI2.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            if (kv[1] !== void 0) {
              q2 += "=" + URI2.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            }
          }
          t2 += "?" + q2.substring(1);
        }
        t2 += URI2.decodeQuery(uri2.hash(), true);
        return t2;
      };
      p.absoluteTo = function(base2) {
        var resolved = this.clone();
        var properties = ["protocol", "username", "password", "hostname", "port"];
        var basedir, i2, p2;
        if (this._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        if (!(base2 instanceof URI2)) {
          base2 = new URI2(base2);
        }
        if (resolved._parts.protocol) {
          return resolved;
        } else {
          resolved._parts.protocol = base2._parts.protocol;
        }
        if (this._parts.hostname) {
          return resolved;
        }
        for (i2 = 0; p2 = properties[i2]; i2++) {
          resolved._parts[p2] = base2._parts[p2];
        }
        if (!resolved._parts.path) {
          resolved._parts.path = base2._parts.path;
          if (!resolved._parts.query) {
            resolved._parts.query = base2._parts.query;
          }
        } else {
          if (resolved._parts.path.substring(-2) === "..") {
            resolved._parts.path += "/";
          }
          if (resolved.path().charAt(0) !== "/") {
            basedir = base2.directory();
            basedir = basedir ? basedir : base2.path().indexOf("/") === 0 ? "/" : "";
            resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
            resolved.normalizePath();
          }
        }
        resolved.build();
        return resolved;
      };
      p.relativeTo = function(base2) {
        var relative = this.clone().normalize();
        var relativeParts, baseParts, common2, relativePath, basePath;
        if (relative._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        base2 = new URI2(base2).normalize();
        relativeParts = relative._parts;
        baseParts = base2._parts;
        relativePath = relative.path();
        basePath = base2.path();
        if (relativePath.charAt(0) !== "/") {
          throw new Error("URI is already relative");
        }
        if (basePath.charAt(0) !== "/") {
          throw new Error("Cannot calculate a URI relative to another relative URI");
        }
        if (relativeParts.protocol === baseParts.protocol) {
          relativeParts.protocol = null;
        }
        if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
          return relative.build();
        }
        if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
          return relative.build();
        }
        if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
          relativeParts.hostname = null;
          relativeParts.port = null;
        } else {
          return relative.build();
        }
        if (relativePath === basePath) {
          relativeParts.path = "";
          return relative.build();
        }
        common2 = URI2.commonPath(relativePath, basePath);
        if (!common2) {
          return relative.build();
        }
        var parents = baseParts.path.substring(common2.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        relativeParts.path = parents + relativeParts.path.substring(common2.length) || "./";
        return relative.build();
      };
      p.equals = function(uri2) {
        var one = this.clone();
        var two = new URI2(uri2);
        var one_map = {};
        var two_map = {};
        var checked = {};
        var one_query, two_query, key2;
        one.normalize();
        two.normalize();
        if (one.toString() === two.toString()) {
          return true;
        }
        one_query = one.query();
        two_query = two.query();
        one.query("");
        two.query("");
        if (one.toString() !== two.toString()) {
          return false;
        }
        if (one_query.length !== two_query.length) {
          return false;
        }
        one_map = URI2.parseQuery(one_query, this._parts.escapeQuerySpace);
        two_map = URI2.parseQuery(two_query, this._parts.escapeQuerySpace);
        for (key2 in one_map) {
          if (hasOwn.call(one_map, key2)) {
            if (!isArray2(one_map[key2])) {
              if (one_map[key2] !== two_map[key2]) {
                return false;
              }
            } else if (!arraysEqual(one_map[key2], two_map[key2])) {
              return false;
            }
            checked[key2] = true;
          }
        }
        for (key2 in two_map) {
          if (hasOwn.call(two_map, key2)) {
            if (!checked[key2]) {
              return false;
            }
          }
        }
        return true;
      };
      p.preventInvalidHostname = function(v) {
        this._parts.preventInvalidHostname = !!v;
        return this;
      };
      p.duplicateQueryParameters = function(v) {
        this._parts.duplicateQueryParameters = !!v;
        return this;
      };
      p.escapeQuerySpace = function(v) {
        this._parts.escapeQuerySpace = !!v;
        return this;
      };
      return URI2;
    });
  })(URI$1);
  return URI$1.exports;
}
var call_builder = {};
var browser$1;
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1;
  hasRequiredBrowser$1 = 1;
  browser$1 = false;
  return browser$1;
}
var URITemplate$1 = { exports: {} };
/*!
 * URI.js - Mutating URLs
 * URI Template Support - http://tools.ietf.org/html/rfc6570
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var URITemplate = URITemplate$1.exports;
var hasRequiredURITemplate;
function requireURITemplate() {
  if (hasRequiredURITemplate) return URITemplate$1.exports;
  hasRequiredURITemplate = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory(requireURI());
      } else {
        root.URITemplate = factory(root.URI, root);
      }
    })(URITemplate, function(URI2, root) {
      var _URITemplate = root && root.URITemplate;
      var hasOwn = Object.prototype.hasOwnProperty;
      function URITemplate2(expression) {
        if (URITemplate2._cache[expression]) {
          return URITemplate2._cache[expression];
        }
        if (!(this instanceof URITemplate2)) {
          return new URITemplate2(expression);
        }
        this.expression = expression;
        URITemplate2._cache[expression] = this;
        return this;
      }
      function Data(data) {
        this.data = data;
        this.cache = {};
      }
      var p = URITemplate2.prototype;
      var operators = {
        // Simple string expansion
        "": {
          prefix: "",
          separator: ",",
          named: false,
          empty_name_separator: false,
          encode: "encode"
        },
        // Reserved character strings
        "+": {
          prefix: "",
          separator: ",",
          named: false,
          empty_name_separator: false,
          encode: "encodeReserved"
        },
        // Fragment identifiers prefixed by '#'
        "#": {
          prefix: "#",
          separator: ",",
          named: false,
          empty_name_separator: false,
          encode: "encodeReserved"
        },
        // Name labels or extensions prefixed by '.'
        ".": {
          prefix: ".",
          separator: ".",
          named: false,
          empty_name_separator: false,
          encode: "encode"
        },
        // Path segments prefixed by '/'
        "/": {
          prefix: "/",
          separator: "/",
          named: false,
          empty_name_separator: false,
          encode: "encode"
        },
        // Path parameter name or name=value pairs prefixed by ';'
        ";": {
          prefix: ";",
          separator: ";",
          named: true,
          empty_name_separator: false,
          encode: "encode"
        },
        // Query component beginning with '?' and consisting
        // of name=value pairs separated by '&'; an
        "?": {
          prefix: "?",
          separator: "&",
          named: true,
          empty_name_separator: true,
          encode: "encode"
        },
        // Continuation of query-style &name=value pairs
        // within a literal query component.
        "&": {
          prefix: "&",
          separator: "&",
          named: true,
          empty_name_separator: true,
          encode: "encode"
        }
        // The operator characters equals ("="), comma (","), exclamation ("!"),
        // at sign ("@"), and pipe ("|") are reserved for future extensions.
      };
      URITemplate2._cache = {};
      URITemplate2.EXPRESSION_PATTERN = /\{([^a-zA-Z0-9%_]?)([^\}]+)(\}|$)/g;
      URITemplate2.VARIABLE_PATTERN = /^([^*:.](?:\.?[^*:.])*)((\*)|:(\d+))?$/;
      URITemplate2.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/;
      URITemplate2.LITERAL_PATTERN = /[<>{}"`^| \\]/;
      URITemplate2.expand = function(expression, data, opts) {
        var options2 = operators[expression.operator];
        var type2 = options2.named ? "Named" : "Unnamed";
        var variables = expression.variables;
        var buffer2 = [];
        var d, variable, i2;
        for (i2 = 0; variable = variables[i2]; i2++) {
          d = data.get(variable.name);
          if (d.type === 0 && opts && opts.strict) {
            throw new Error('Missing expansion value for variable "' + variable.name + '"');
          }
          if (!d.val.length) {
            if (d.type) {
              buffer2.push("");
            }
            continue;
          }
          if (d.type > 1 && variable.maxlength) {
            throw new Error('Invalid expression: Prefix modifier not applicable to variable "' + variable.name + '"');
          }
          buffer2.push(URITemplate2["expand" + type2](
            d,
            options2,
            variable.explode,
            variable.explode && options2.separator || ",",
            variable.maxlength,
            variable.name
          ));
        }
        if (buffer2.length) {
          return options2.prefix + buffer2.join(options2.separator);
        } else {
          return "";
        }
      };
      URITemplate2.expandNamed = function(d, options2, explode, separator, length, name) {
        var result = "";
        var encode = options2.encode;
        var empty_name_separator = options2.empty_name_separator;
        var _encode = !d[encode].length;
        var _name = d.type === 2 ? "" : URI2[encode](name);
        var _value, i2, l;
        for (i2 = 0, l = d.val.length; i2 < l; i2++) {
          if (length) {
            _value = URI2[encode](d.val[i2][1].substring(0, length));
            if (d.type === 2) {
              _name = URI2[encode](d.val[i2][0].substring(0, length));
            }
          } else if (_encode) {
            _value = URI2[encode](d.val[i2][1]);
            if (d.type === 2) {
              _name = URI2[encode](d.val[i2][0]);
              d[encode].push([_name, _value]);
            } else {
              d[encode].push([void 0, _value]);
            }
          } else {
            _value = d[encode][i2][1];
            if (d.type === 2) {
              _name = d[encode][i2][0];
            }
          }
          if (result) {
            result += separator;
          }
          if (!explode) {
            if (!i2) {
              result += URI2[encode](name) + (empty_name_separator || _value ? "=" : "");
            }
            if (d.type === 2) {
              result += _name + ",";
            }
            result += _value;
          } else {
            result += _name + (empty_name_separator || _value ? "=" : "") + _value;
          }
        }
        return result;
      };
      URITemplate2.expandUnnamed = function(d, options2, explode, separator, length) {
        var result = "";
        var encode = options2.encode;
        var empty_name_separator = options2.empty_name_separator;
        var _encode = !d[encode].length;
        var _name, _value, i2, l;
        for (i2 = 0, l = d.val.length; i2 < l; i2++) {
          if (length) {
            _value = URI2[encode](d.val[i2][1].substring(0, length));
          } else if (_encode) {
            _value = URI2[encode](d.val[i2][1]);
            d[encode].push([
              d.type === 2 ? URI2[encode](d.val[i2][0]) : void 0,
              _value
            ]);
          } else {
            _value = d[encode][i2][1];
          }
          if (result) {
            result += separator;
          }
          if (d.type === 2) {
            if (length) {
              _name = URI2[encode](d.val[i2][0].substring(0, length));
            } else {
              _name = d[encode][i2][0];
            }
            result += _name;
            if (explode) {
              result += empty_name_separator || _value ? "=" : "";
            } else {
              result += ",";
            }
          }
          result += _value;
        }
        return result;
      };
      URITemplate2.noConflict = function() {
        if (root.URITemplate === URITemplate2) {
          root.URITemplate = _URITemplate;
        }
        return URITemplate2;
      };
      p.expand = function(data, opts) {
        var result = "";
        if (!this.parts || !this.parts.length) {
          this.parse();
        }
        if (!(data instanceof Data)) {
          data = new Data(data);
        }
        for (var i2 = 0, l = this.parts.length; i2 < l; i2++) {
          result += typeof this.parts[i2] === "string" ? this.parts[i2] : URITemplate2.expand(this.parts[i2], data, opts);
        }
        return result;
      };
      p.parse = function() {
        var expression = this.expression;
        var ePattern = URITemplate2.EXPRESSION_PATTERN;
        var vPattern = URITemplate2.VARIABLE_PATTERN;
        var nPattern = URITemplate2.VARIABLE_NAME_PATTERN;
        var lPattern = URITemplate2.LITERAL_PATTERN;
        var parts = [];
        var pos = 0;
        var variables, eMatch, vMatch;
        var checkLiteral = function(literal) {
          if (literal.match(lPattern)) {
            throw new Error('Invalid Literal "' + literal + '"');
          }
          return literal;
        };
        ePattern.lastIndex = 0;
        while (true) {
          eMatch = ePattern.exec(expression);
          if (eMatch === null) {
            parts.push(checkLiteral(expression.substring(pos)));
            break;
          } else {
            parts.push(checkLiteral(expression.substring(pos, eMatch.index)));
            pos = eMatch.index + eMatch[0].length;
          }
          if (!operators[eMatch[1]]) {
            throw new Error('Unknown Operator "' + eMatch[1] + '" in "' + eMatch[0] + '"');
          } else if (!eMatch[3]) {
            throw new Error('Unclosed Expression "' + eMatch[0] + '"');
          }
          variables = eMatch[2].split(",");
          for (var i2 = 0, l = variables.length; i2 < l; i2++) {
            vMatch = variables[i2].match(vPattern);
            if (vMatch === null) {
              throw new Error('Invalid Variable "' + variables[i2] + '" in "' + eMatch[0] + '"');
            } else if (vMatch[1].match(nPattern)) {
              throw new Error('Invalid Variable Name "' + vMatch[1] + '" in "' + eMatch[0] + '"');
            }
            variables[i2] = {
              name: vMatch[1],
              explode: !!vMatch[3],
              maxlength: vMatch[4] && parseInt(vMatch[4], 10)
            };
          }
          if (!variables.length) {
            throw new Error('Expression Missing Variable(s) "' + eMatch[0] + '"');
          }
          parts.push({
            expression: eMatch[0],
            operator: eMatch[1],
            variables
          });
        }
        if (!parts.length) {
          parts.push(checkLiteral(expression));
        }
        this.parts = parts;
        return this;
      };
      Data.prototype.get = function(key2) {
        var data = this.data;
        var d = {
          // type of data 0: undefined/null, 1: string, 2: object, 3: array
          type: 0,
          // original values (except undefined/null)
          val: [],
          // cache for encoded values (only for non-maxlength expansion)
          encode: [],
          encodeReserved: []
        };
        var i2, l, value;
        if (this.cache[key2] !== void 0) {
          return this.cache[key2];
        }
        this.cache[key2] = d;
        if (String(Object.prototype.toString.call(data)) === "[object Function]") {
          value = data(key2);
        } else if (String(Object.prototype.toString.call(data[key2])) === "[object Function]") {
          value = data[key2](key2);
        } else {
          value = data[key2];
        }
        if (value === void 0 || value === null) {
          return d;
        } else if (String(Object.prototype.toString.call(value)) === "[object Array]") {
          for (i2 = 0, l = value.length; i2 < l; i2++) {
            if (value[i2] !== void 0 && value[i2] !== null) {
              d.val.push([void 0, String(value[i2])]);
            }
          }
          if (d.val.length) {
            d.type = 3;
          }
        } else if (String(Object.prototype.toString.call(value)) === "[object Object]") {
          for (i2 in value) {
            if (hasOwn.call(value, i2) && value[i2] !== void 0 && value[i2] !== null) {
              d.val.push([i2, String(value[i2])]);
            }
          }
          if (d.val.length) {
            d.type = 2;
          }
        } else {
          d.type = 1;
          d.val.push([void 0, String(value)]);
        }
        return d;
      };
      URI2.expand = function(expression, data) {
        var template = new URITemplate2(expression);
        var expansion = template.expand(data);
        return new URI2(expansion);
      };
      return URITemplate2;
    });
  })(URITemplate$1);
  return URITemplate$1.exports;
}
var horizon_axios_client = {};
var axios$1 = { exports: {} };
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind) return bind;
  hasRequiredBind = 1;
  bind = function bind2(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      return fn.apply(thisArg, args);
    };
  };
  return bind;
}
var utils$2;
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  var bind2 = requireBind();
  var toString2 = Object.prototype.toString;
  function isArray2(val) {
    return toString2.call(val) === "[object Array]";
  }
  function isUndefined2(val) {
    return typeof val === "undefined";
  }
  function isBuffer2(val) {
    return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString2.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString2(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject2(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject2(val) {
    if (toString2.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate(val) {
    return toString2.call(val) === "[object Date]";
  }
  function isFile(val) {
    return toString2.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString2.call(val) === "[object Blob]";
  }
  function isFunction2(val) {
    return toString2.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject2(val) && isFunction2(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach2(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray2(obj)) {
      for (var i2 = 0, l = obj.length; i2 < l; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      for (var key2 in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key2)) {
          fn.call(null, obj[key2], key2, obj);
        }
      }
    }
  }
  function merge2() {
    var result = {};
    function assignValue(val, key2) {
      if (isPlainObject2(result[key2]) && isPlainObject2(val)) {
        result[key2] = merge2(result[key2], val);
      } else if (isPlainObject2(val)) {
        result[key2] = merge2({}, val);
      } else if (isArray2(val)) {
        result[key2] = val.slice();
      } else {
        result[key2] = val;
      }
    }
    for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
      forEach2(arguments[i2], assignValue);
    }
    return result;
  }
  function extend2(a, b, thisArg) {
    forEach2(b, function assignValue(val, key2) {
      if (thisArg && typeof val === "function") {
        a[key2] = bind2(val, thisArg);
      } else {
        a[key2] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  utils$2 = {
    isArray: isArray2,
    isArrayBuffer,
    isBuffer: isBuffer2,
    isFormData,
    isArrayBufferView,
    isString: isString2,
    isNumber,
    isObject: isObject2,
    isPlainObject: isPlainObject2,
    isUndefined: isUndefined2,
    isDate,
    isFile,
    isBlob,
    isFunction: isFunction2,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach: forEach2,
    merge: merge2,
    extend: extend2,
    trim,
    stripBOM
  };
  return utils$2;
}
var buildURL;
var hasRequiredBuildURL;
function requireBuildURL() {
  if (hasRequiredBuildURL) return buildURL;
  hasRequiredBuildURL = 1;
  var utils2 = requireUtils$2();
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  buildURL = function buildURL2(url2, params, paramsSerializer) {
    if (!params) {
      return url2;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils2.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils2.forEach(params, function serialize(val, key2) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils2.isArray(val)) {
          key2 = key2 + "[]";
        } else {
          val = [val];
        }
        utils2.forEach(val, function parseValue2(v) {
          if (utils2.isDate(v)) {
            v = v.toISOString();
          } else if (utils2.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key2) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  };
  return buildURL;
}
var InterceptorManager_1;
var hasRequiredInterceptorManager;
function requireInterceptorManager() {
  if (hasRequiredInterceptorManager) return InterceptorManager_1;
  hasRequiredInterceptorManager = 1;
  var utils2 = requireUtils$2();
  function InterceptorManager() {
    this.handlers = [];
  }
  InterceptorManager.prototype.use = function use(fulfilled, rejected, options2) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options2 ? options2.synchronous : false,
      runWhen: options2 ? options2.runWhen : null
    });
    return this.handlers.length - 1;
  };
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager.prototype.forEach = function forEach2(fn) {
    utils2.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  InterceptorManager_1 = InterceptorManager;
  return InterceptorManager_1;
}
var normalizeHeaderName;
var hasRequiredNormalizeHeaderName;
function requireNormalizeHeaderName() {
  if (hasRequiredNormalizeHeaderName) return normalizeHeaderName;
  hasRequiredNormalizeHeaderName = 1;
  var utils2 = requireUtils$2();
  normalizeHeaderName = function normalizeHeaderName2(headers, normalizedName) {
    utils2.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
  return normalizeHeaderName;
}
var enhanceError;
var hasRequiredEnhanceError;
function requireEnhanceError() {
  if (hasRequiredEnhanceError) return enhanceError;
  hasRequiredEnhanceError = 1;
  enhanceError = function enhanceError2(error3, config2, code2, request2, response2) {
    error3.config = config2;
    if (code2) {
      error3.code = code2;
    }
    error3.request = request2;
    error3.response = response2;
    error3.isAxiosError = true;
    error3.toJSON = function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };
    return error3;
  };
  return enhanceError;
}
var createError;
var hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError) return createError;
  hasRequiredCreateError = 1;
  var enhanceError2 = requireEnhanceError();
  createError = function createError2(message, config2, code2, request2, response2) {
    var error3 = new Error(message);
    return enhanceError2(error3, config2, code2, request2, response2);
  };
  return createError;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle) return settle;
  hasRequiredSettle = 1;
  var createError2 = requireCreateError();
  settle = function settle2(resolve2, reject, response2) {
    var validateStatus = response2.config.validateStatus;
    if (!response2.status || !validateStatus || validateStatus(response2.status)) {
      resolve2(response2);
    } else {
      reject(createError2(
        "Request failed with status code " + response2.status,
        response2.config,
        null,
        response2.request,
        response2
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  var utils2 = requireUtils$2();
  cookies = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path2, domain, secure) {
          var cookie2 = [];
          cookie2.push(name + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie2.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path2)) {
            cookie2.push("path=" + path2);
          }
          if (utils2.isString(domain)) {
            cookie2.push("domain=" + domain);
          }
          if (secure === true) {
            cookie2.push("secure");
          }
          document.cookie = cookie2.join("; ");
        },
        read: function read2(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove3(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read2() {
          return null;
        },
        remove: function remove3() {
        }
      };
    }()
  );
  return cookies;
}
var isAbsoluteURL;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL) return isAbsoluteURL;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL = function isAbsoluteURL2(url2) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
  };
  return isAbsoluteURL;
}
var combineURLs;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs) return combineURLs;
  hasRequiredCombineURLs = 1;
  combineURLs = function combineURLs2(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs;
}
var buildFullPath;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath) return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL2 = requireIsAbsoluteURL();
  var combineURLs2 = requireCombineURLs();
  buildFullPath = function buildFullPath2(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath;
}
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders) return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = requireUtils$2();
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key2;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser2(line) {
      i2 = line.indexOf(":");
      key2 = utils2.trim(line.substr(0, i2)).toLowerCase();
      val = utils2.trim(line.substr(i2 + 1));
      if (key2) {
        if (parsed[key2] && ignoreDuplicateOf.indexOf(key2) >= 0) {
          return;
        }
        if (key2 === "set-cookie") {
          parsed[key2] = (parsed[key2] ? parsed[key2] : []).concat([val]);
        } else {
          parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = requireUtils$2();
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url2) {
        var href = url2;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  return isURLSameOrigin;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr) return xhr;
  hasRequiredXhr = 1;
  var utils2 = requireUtils$2();
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL2 = requireBuildURL();
  var buildFullPath2 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var createError2 = requireCreateError();
  xhr = function xhrAdapter(config2) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      var requestData = config2.data;
      var requestHeaders = config2.headers;
      var responseType = config2.responseType;
      if (utils2.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config2.auth) {
        var username = config2.auth.username || "";
        var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config2.baseURL, config2.url);
      request2.open(config2.method.toUpperCase(), buildURL2(fullPath, config2.params, config2.paramsSerializer), true);
      request2.timeout = config2.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response2 = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config: config2,
          request: request2
        };
        settle2(resolve2, reject, response2);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(createError2("Request aborted", config2, "ECONNABORTED", request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject(createError2("Network Error", config2, null, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(createError2(
          timeoutErrorMessage,
          config2,
          config2.transitional && config2.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config2.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key2) {
          if (typeof requestData === "undefined" && key2.toLowerCase() === "content-type") {
            delete requestHeaders[key2];
          } else {
            request2.setRequestHeader(key2, val);
          }
        });
      }
      if (!utils2.isUndefined(config2.withCredentials)) {
        request2.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request2.addEventListener("progress", config2.onDownloadProgress);
      }
      if (typeof config2.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config2.onUploadProgress);
      }
      if (config2.cancelToken) {
        config2.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request2) {
            return;
          }
          request2.abort();
          reject(cancel);
          request2 = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults_1;
  hasRequiredDefaults = 1;
  var utils2 = requireUtils$2();
  var normalizeHeaderName2 = requireNormalizeHeaderName();
  var enhanceError2 = requireEnhanceError();
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils2.isUndefined(headers) && utils2.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = requireXhr();
    } else if (typeof process$1 !== "undefined" && Object.prototype.toString.call(process$1) === "[object process]") {
      adapter = requireXhr();
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser2, encoder) {
    if (utils2.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils2.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults2 = {
    transitional: {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName2(headers, "Accept");
      normalizeHeaderName2(headers, "Content-Type");
      if (utils2.isFormData(data) || utils2.isArrayBuffer(data) || utils2.isBuffer(data) || utils2.isStream(data) || utils2.isFile(data) || utils2.isBlob(data)) {
        return data;
      }
      if (utils2.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils2.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils2.isObject(data) || headers && headers["Content-Type"] === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      var transitional = this.transitional;
      var silentJSONParsing = transitional && transitional.silentJSONParsing;
      var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils2.isString(data) && data.length) {
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw enhanceError2(e, this, "E_JSON_PARSE");
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults2.headers = {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  };
  utils2.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults2.headers[method] = {};
  });
  utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults2.headers[method] = utils2.merge(DEFAULT_CONTENT_TYPE);
  });
  defaults_1 = defaults2;
  return defaults_1;
}
var transformData;
var hasRequiredTransformData;
function requireTransformData() {
  if (hasRequiredTransformData) return transformData;
  hasRequiredTransformData = 1;
  var utils2 = requireUtils$2();
  var defaults2 = requireDefaults();
  transformData = function transformData2(data, headers, fns) {
    var context2 = this || defaults2;
    utils2.forEach(fns, function transform2(fn) {
      data = fn.call(context2, data, headers);
    });
    return data;
  };
  return transformData;
}
var isCancel;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel) return isCancel;
  hasRequiredIsCancel = 1;
  isCancel = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel;
}
var dispatchRequest;
var hasRequiredDispatchRequest;
function requireDispatchRequest() {
  if (hasRequiredDispatchRequest) return dispatchRequest;
  hasRequiredDispatchRequest = 1;
  var utils2 = requireUtils$2();
  var transformData2 = requireTransformData();
  var isCancel2 = requireIsCancel();
  var defaults2 = requireDefaults();
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
  }
  dispatchRequest = function dispatchRequest2(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = config2.headers || {};
    config2.data = transformData2.call(
      config2,
      config2.data,
      config2.headers,
      config2.transformRequest
    );
    config2.headers = utils2.merge(
      config2.headers.common || {},
      config2.headers[config2.method] || {},
      config2.headers
    );
    utils2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      function cleanHeaderConfig(method) {
        delete config2.headers[method];
      }
    );
    var adapter = config2.adapter || defaults2.adapter;
    return adapter(config2).then(function onAdapterResolution(response2) {
      throwIfCancellationRequested(config2);
      response2.data = transformData2.call(
        config2,
        response2.data,
        response2.headers,
        config2.transformResponse
      );
      return response2;
    }, function onAdapterRejection(reason) {
      if (!isCancel2(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData2.call(
            config2,
            reason.response.data,
            reason.response.headers,
            config2.transformResponse
          );
        }
      }
      return Promise.reject(reason);
    });
  };
  return dispatchRequest;
}
var mergeConfig;
var hasRequiredMergeConfig;
function requireMergeConfig() {
  if (hasRequiredMergeConfig) return mergeConfig;
  hasRequiredMergeConfig = 1;
  var utils2 = requireUtils$2();
  mergeConfig = function mergeConfig2(config1, config2) {
    config2 = config2 || {};
    var config3 = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source) {
      if (utils2.isPlainObject(target) && utils2.isPlainObject(source)) {
        return utils2.merge(target, source);
      } else if (utils2.isPlainObject(source)) {
        return utils2.merge({}, source);
      } else if (utils2.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        config3[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils2.isUndefined(config1[prop])) {
        config3[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        config3[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        config3[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils2.isUndefined(config1[prop])) {
        config3[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils2.forEach(directMergeKeys, function merge2(prop) {
      if (prop in config2) {
        config3[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config3[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key2) {
      return axiosKeys.indexOf(key2) === -1;
    });
    utils2.forEach(otherKeys, mergeDeepProperties);
    return config3;
  };
  return mergeConfig;
}
const version$1 = "0.21.4";
const require$$0$1 = {
  version: version$1
};
var validator;
var hasRequiredValidator;
function requireValidator() {
  if (hasRequiredValidator) return validator;
  hasRequiredValidator = 1;
  var pkg2 = require$$0$1;
  var validators = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i2) {
    validators[type2] = function validator2(thing) {
      return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
    };
  });
  var deprecatedWarnings = {};
  var currentVerArr = pkg2.version.split(".");
  function isOlderVersion(version2, thanVersion) {
    var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
    var destVer = version2.split(".");
    for (var i2 = 0; i2 < 3; i2++) {
      if (pkgVersionArr[i2] > destVer[i2]) {
        return true;
      } else if (pkgVersionArr[i2] < destVer[i2]) {
        return false;
      }
    }
    return false;
  }
  validators.transitional = function transitional(validator2, version2, message) {
    var isDeprecated = version2 && isOlderVersion(version2);
    function formatMessage(opt, desc) {
      return "[Axios v" + pkg2.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return function(value, opt, opts) {
      if (validator2 === false) {
        throw new Error(formatMessage(opt, " has been removed in " + version2));
      }
      if (isDeprecated && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options2, schema, allowUnknown) {
    if (typeof options2 !== "object") {
      throw new TypeError("options must be an object");
    }
    var keys2 = Object.keys(options2);
    var i2 = keys2.length;
    while (i2-- > 0) {
      var opt = keys2[i2];
      var validator2 = schema[opt];
      if (validator2) {
        var value = options2[opt];
        var result = value === void 0 || validator2(value, opt, options2);
        if (result !== true) {
          throw new TypeError("option " + opt + " must be " + result);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw Error("Unknown option " + opt);
      }
    }
  }
  validator = {
    isOlderVersion,
    assertOptions,
    validators
  };
  return validator;
}
var Axios_1;
var hasRequiredAxios$2;
function requireAxios$2() {
  if (hasRequiredAxios$2) return Axios_1;
  hasRequiredAxios$2 = 1;
  var utils2 = requireUtils$2();
  var buildURL2 = requireBuildURL();
  var InterceptorManager = requireInterceptorManager();
  var dispatchRequest2 = requireDispatchRequest();
  var mergeConfig2 = requireMergeConfig();
  var validator2 = requireValidator();
  var validators = validator2.validators;
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios.prototype.request = function request2(config2) {
    if (typeof config2 === "string") {
      config2 = arguments[1] || {};
      config2.url = arguments[0];
    } else {
      config2 = config2 || {};
    }
    config2 = mergeConfig2(this.defaults, config2);
    if (config2.method) {
      config2.method = config2.method.toLowerCase();
    } else if (this.defaults.method) {
      config2.method = this.defaults.method.toLowerCase();
    } else {
      config2.method = "get";
    }
    var transitional = config2.transitional;
    if (transitional !== void 0) {
      validator2.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
        forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
        clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
      }, false);
    }
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise2;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest2, void 0];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise2 = Promise.resolve(config2);
      while (chain.length) {
        promise2 = promise2.then(chain.shift(), chain.shift());
      }
      return promise2;
    }
    var newConfig = config2;
    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error3) {
        onRejected(error3);
        break;
      }
    }
    try {
      promise2 = dispatchRequest2(newConfig);
    } catch (error3) {
      return Promise.reject(error3);
    }
    while (responseInterceptorChain.length) {
      promise2 = promise2.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise2;
  };
  Axios.prototype.getUri = function getUri(config2) {
    config2 = mergeConfig2(this.defaults, config2);
    return buildURL2(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
  };
  utils2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url2, config2) {
      return this.request(mergeConfig2(config2 || {}, {
        method,
        url: url2,
        data: (config2 || {}).data
      }));
    };
  });
  utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    Axios.prototype[method] = function(url2, data, config2) {
      return this.request(mergeConfig2(config2 || {}, {
        method,
        url: url2,
        data
      }));
    };
  });
  Axios_1 = Axios;
  return Axios_1;
}
var Cancel_1;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel) return Cancel_1;
  hasRequiredCancel = 1;
  function Cancel(message) {
    this.message = message;
  }
  Cancel.prototype.toString = function toString2() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel.prototype.__CANCEL__ = true;
  Cancel_1 = Cancel;
  return Cancel_1;
}
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken) return CancelToken_1;
  hasRequiredCancelToken = 1;
  var Cancel = requireCancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread) return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr2) {
      return callback.apply(null, arr2);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError) return isAxiosError;
  hasRequiredIsAxiosError = 1;
  isAxiosError = function isAxiosError2(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var hasRequiredAxios$1;
function requireAxios$1() {
  if (hasRequiredAxios$1) return axios$1.exports;
  hasRequiredAxios$1 = 1;
  var utils2 = requireUtils$2();
  var bind2 = requireBind();
  var Axios = requireAxios$2();
  var mergeConfig2 = requireMergeConfig();
  var defaults2 = requireDefaults();
  function createInstance(defaultConfig) {
    var context2 = new Axios(defaultConfig);
    var instance = bind2(Axios.prototype.request, context2);
    utils2.extend(instance, Axios.prototype, context2);
    utils2.extend(instance, context2);
    return instance;
  }
  var axios2 = createInstance(defaults2);
  axios2.Axios = Axios;
  axios2.create = function create4(instanceConfig) {
    return createInstance(mergeConfig2(axios2.defaults, instanceConfig));
  };
  axios2.Cancel = requireCancel();
  axios2.CancelToken = requireCancelToken();
  axios2.isCancel = requireIsCancel();
  axios2.all = function all(promises) {
    return Promise.all(promises);
  };
  axios2.spread = requireSpread();
  axios2.isAxiosError = requireIsAxiosError();
  axios$1.exports = axios2;
  axios$1.exports.default = axios2;
  return axios$1.exports;
}
var axios;
var hasRequiredAxios;
function requireAxios() {
  if (hasRequiredAxios) return axios;
  hasRequiredAxios = 1;
  axios = requireAxios$1();
  return axios;
}
var hasRequiredHorizon_axios_client;
function requireHorizon_axios_client() {
  if (hasRequiredHorizon_axios_client) return horizon_axios_client;
  hasRequiredHorizon_axios_client = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCurrentServerTime = exports2.SERVER_TIME_MAP = void 0;
    var tslib_1 = require$$0$4;
    var axios_1 = tslib_1.__importDefault(requireAxios());
    var urijs_1 = tslib_1.__importDefault(requireURI());
    var version2 = require$$2$2.version;
    exports2.SERVER_TIME_MAP = {};
    var HorizonAxiosClient = axios_1.default.create({
      headers: {
        "X-Client-Name": "js-stellar-sdk",
        "X-Client-Version": version2
      }
    });
    function _toSeconds(ms2) {
      return Math.floor(ms2 / 1e3);
    }
    HorizonAxiosClient.interceptors.response.use(function interceptorHorizonResponse(response2) {
      var hostname = urijs_1.default(response2.config.url).hostname();
      var serverTime = _toSeconds(Date.parse(response2.headers.date));
      var localTimeRecorded = _toSeconds((/* @__PURE__ */ new Date()).getTime());
      if (!isNaN(serverTime)) {
        exports2.SERVER_TIME_MAP[hostname] = {
          serverTime,
          localTimeRecorded
        };
      }
      return response2;
    });
    exports2.default = HorizonAxiosClient;
    function getCurrentServerTime(hostname) {
      var entry = exports2.SERVER_TIME_MAP[hostname];
      if (!entry || !entry.localTimeRecorded || !entry.serverTime) {
        return null;
      }
      var serverTime = entry.serverTime, localTimeRecorded = entry.localTimeRecorded;
      var currentTime = _toSeconds((/* @__PURE__ */ new Date()).getTime());
      if (currentTime - localTimeRecorded > 60 * 5) {
        return null;
      }
      return currentTime - localTimeRecorded + serverTime;
    }
    exports2.getCurrentServerTime = getCurrentServerTime;
  })(horizon_axios_client);
  return horizon_axios_client;
}
var requiresPort;
var hasRequiredRequiresPort;
function requireRequiresPort() {
  if (hasRequiredRequiresPort) return requiresPort;
  hasRequiredRequiresPort = 1;
  requiresPort = function required(port, protocol) {
    protocol = protocol.split(":")[0];
    port = +port;
    if (!port) return false;
    switch (protocol) {
      case "http":
      case "ws":
        return port !== 80;
      case "https":
      case "wss":
        return port !== 443;
      case "ftp":
        return port !== 21;
      case "gopher":
        return port !== 70;
      case "file":
        return false;
    }
    return port !== 0;
  };
  return requiresPort;
}
var querystringify = {};
var hasRequiredQuerystringify;
function requireQuerystringify() {
  if (hasRequiredQuerystringify) return querystringify;
  hasRequiredQuerystringify = 1;
  var has = Object.prototype.hasOwnProperty, undef;
  function decode(input) {
    try {
      return decodeURIComponent(input.replace(/\+/g, " "));
    } catch (e) {
      return null;
    }
  }
  function querystring2(query) {
    var parser2 = /([^=?&]+)=?([^&]*)/g, result = {}, part;
    while (part = parser2.exec(query)) {
      var key2 = decode(part[1]), value = decode(part[2]);
      if (key2 === null || value === null || key2 in result) continue;
      result[key2] = value;
    }
    return result;
  }
  function querystringify$1(obj, prefix2) {
    prefix2 = prefix2 || "";
    var pairs = [], value, key2;
    if ("string" !== typeof prefix2) prefix2 = "?";
    for (key2 in obj) {
      if (has.call(obj, key2)) {
        value = obj[key2];
        if (!value && (value === null || value === undef || isNaN(value))) {
          value = "";
        }
        key2 = encodeURIComponent(key2);
        value = encodeURIComponent(value);
        if (key2 === null || value === null) continue;
        pairs.push(key2 + "=" + value);
      }
    }
    return pairs.length ? prefix2 + pairs.join("&") : "";
  }
  querystringify.stringify = querystringify$1;
  querystringify.parse = querystring2;
  return querystringify;
}
var urlParse$1;
var hasRequiredUrlParse;
function requireUrlParse() {
  if (hasRequiredUrlParse) return urlParse$1;
  hasRequiredUrlParse = 1;
  var required = requireRequiresPort(), qs2 = requireQuerystringify(), controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
  function trimLeft(str) {
    return (str ? str : "").toString().replace(controlOrWhitespace, "");
  }
  var rules = [
    ["#", "hash"],
    // Extract from the back.
    ["?", "query"],
    // Extract from the back.
    function sanitize(address, url2) {
      return isSpecial(url2.protocol) ? address.replace(/\\/g, "/") : address;
    },
    ["/", "pathname"],
    // Extract from the back.
    ["@", "auth", 1],
    // Extract from the front.
    [NaN, "host", void 0, 1, 1],
    // Set left over value.
    [/:(\d*)$/, "port", void 0, 1],
    // RegExp the back.
    [NaN, "hostname", void 0, 1, 1]
    // Set left over.
  ];
  var ignore = { hash: 1, query: 1 };
  function lolcation(loc) {
    var globalVar;
    if (typeof window !== "undefined") globalVar = window;
    else if (typeof commonjsGlobal !== "undefined") globalVar = commonjsGlobal;
    else if (typeof self !== "undefined") globalVar = self;
    else globalVar = {};
    var location2 = globalVar.location || {};
    loc = loc || location2;
    var finaldestination = {}, type2 = typeof loc, key2;
    if ("blob:" === loc.protocol) {
      finaldestination = new Url2(unescape(loc.pathname), {});
    } else if ("string" === type2) {
      finaldestination = new Url2(loc, {});
      for (key2 in ignore) delete finaldestination[key2];
    } else if ("object" === type2) {
      for (key2 in loc) {
        if (key2 in ignore) continue;
        finaldestination[key2] = loc[key2];
      }
      if (finaldestination.slashes === void 0) {
        finaldestination.slashes = slashes.test(loc.href);
      }
    }
    return finaldestination;
  }
  function isSpecial(scheme) {
    return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
  }
  function extractProtocol(address, location2) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, "");
    location2 = location2 || {};
    var match = protocolre.exec(address);
    var protocol = match[1] ? match[1].toLowerCase() : "";
    var forwardSlashes = !!match[2];
    var otherSlashes = !!match[3];
    var slashesCount = 0;
    var rest;
    if (forwardSlashes) {
      if (otherSlashes) {
        rest = match[2] + match[3] + match[4];
        slashesCount = match[2].length + match[3].length;
      } else {
        rest = match[2] + match[4];
        slashesCount = match[2].length;
      }
    } else {
      if (otherSlashes) {
        rest = match[3] + match[4];
        slashesCount = match[3].length;
      } else {
        rest = match[4];
      }
    }
    if (protocol === "file:") {
      if (slashesCount >= 2) {
        rest = rest.slice(2);
      }
    } else if (isSpecial(protocol)) {
      rest = match[4];
    } else if (protocol) {
      if (forwardSlashes) {
        rest = rest.slice(2);
      }
    } else if (slashesCount >= 2 && isSpecial(location2.protocol)) {
      rest = match[4];
    }
    return {
      protocol,
      slashes: forwardSlashes || isSpecial(protocol),
      slashesCount,
      rest
    };
  }
  function resolve2(relative, base2) {
    if (relative === "") return base2;
    var path2 = (base2 || "/").split("/").slice(0, -1).concat(relative.split("/")), i2 = path2.length, last = path2[i2 - 1], unshift = false, up = 0;
    while (i2--) {
      if (path2[i2] === ".") {
        path2.splice(i2, 1);
      } else if (path2[i2] === "..") {
        path2.splice(i2, 1);
        up++;
      } else if (up) {
        if (i2 === 0) unshift = true;
        path2.splice(i2, 1);
        up--;
      }
    }
    if (unshift) path2.unshift("");
    if (last === "." || last === "..") path2.push("");
    return path2.join("/");
  }
  function Url2(address, location2, parser2) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, "");
    if (!(this instanceof Url2)) {
      return new Url2(address, location2, parser2);
    }
    var relative, extracted, parse2, instruction, index2, key2, instructions = rules.slice(), type2 = typeof location2, url2 = this, i2 = 0;
    if ("object" !== type2 && "string" !== type2) {
      parser2 = location2;
      location2 = null;
    }
    if (parser2 && "function" !== typeof parser2) parser2 = qs2.parse;
    location2 = lolcation(location2);
    extracted = extractProtocol(address || "", location2);
    relative = !extracted.protocol && !extracted.slashes;
    url2.slashes = extracted.slashes || relative && location2.slashes;
    url2.protocol = extracted.protocol || location2.protocol || "";
    address = extracted.rest;
    if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url2.protocol))) {
      instructions[3] = [/(.*)/, "pathname"];
    }
    for (; i2 < instructions.length; i2++) {
      instruction = instructions[i2];
      if (typeof instruction === "function") {
        address = instruction(address, url2);
        continue;
      }
      parse2 = instruction[0];
      key2 = instruction[1];
      if (parse2 !== parse2) {
        url2[key2] = address;
      } else if ("string" === typeof parse2) {
        index2 = parse2 === "@" ? address.lastIndexOf(parse2) : address.indexOf(parse2);
        if (~index2) {
          if ("number" === typeof instruction[2]) {
            url2[key2] = address.slice(0, index2);
            address = address.slice(index2 + instruction[2]);
          } else {
            url2[key2] = address.slice(index2);
            address = address.slice(0, index2);
          }
        }
      } else if (index2 = parse2.exec(address)) {
        url2[key2] = index2[1];
        address = address.slice(0, index2.index);
      }
      url2[key2] = url2[key2] || (relative && instruction[3] ? location2[key2] || "" : "");
      if (instruction[4]) url2[key2] = url2[key2].toLowerCase();
    }
    if (parser2) url2.query = parser2(url2.query);
    if (relative && location2.slashes && url2.pathname.charAt(0) !== "/" && (url2.pathname !== "" || location2.pathname !== "")) {
      url2.pathname = resolve2(url2.pathname, location2.pathname);
    }
    if (url2.pathname.charAt(0) !== "/" && isSpecial(url2.protocol)) {
      url2.pathname = "/" + url2.pathname;
    }
    if (!required(url2.port, url2.protocol)) {
      url2.host = url2.hostname;
      url2.port = "";
    }
    url2.username = url2.password = "";
    if (url2.auth) {
      index2 = url2.auth.indexOf(":");
      if (~index2) {
        url2.username = url2.auth.slice(0, index2);
        url2.username = encodeURIComponent(decodeURIComponent(url2.username));
        url2.password = url2.auth.slice(index2 + 1);
        url2.password = encodeURIComponent(decodeURIComponent(url2.password));
      } else {
        url2.username = encodeURIComponent(decodeURIComponent(url2.auth));
      }
      url2.auth = url2.password ? url2.username + ":" + url2.password : url2.username;
    }
    url2.origin = url2.protocol !== "file:" && isSpecial(url2.protocol) && url2.host ? url2.protocol + "//" + url2.host : "null";
    url2.href = url2.toString();
  }
  function set3(part, value, fn) {
    var url2 = this;
    switch (part) {
      case "query":
        if ("string" === typeof value && value.length) {
          value = (fn || qs2.parse)(value);
        }
        url2[part] = value;
        break;
      case "port":
        url2[part] = value;
        if (!required(value, url2.protocol)) {
          url2.host = url2.hostname;
          url2[part] = "";
        } else if (value) {
          url2.host = url2.hostname + ":" + value;
        }
        break;
      case "hostname":
        url2[part] = value;
        if (url2.port) value += ":" + url2.port;
        url2.host = value;
        break;
      case "host":
        url2[part] = value;
        if (port.test(value)) {
          value = value.split(":");
          url2.port = value.pop();
          url2.hostname = value.join(":");
        } else {
          url2.hostname = value;
          url2.port = "";
        }
        break;
      case "protocol":
        url2.protocol = value.toLowerCase();
        url2.slashes = !fn;
        break;
      case "pathname":
      case "hash":
        if (value) {
          var char = part === "pathname" ? "/" : "#";
          url2[part] = value.charAt(0) !== char ? char + value : value;
        } else {
          url2[part] = value;
        }
        break;
      case "username":
      case "password":
        url2[part] = encodeURIComponent(value);
        break;
      case "auth":
        var index2 = value.indexOf(":");
        if (~index2) {
          url2.username = value.slice(0, index2);
          url2.username = encodeURIComponent(decodeURIComponent(url2.username));
          url2.password = value.slice(index2 + 1);
          url2.password = encodeURIComponent(decodeURIComponent(url2.password));
        } else {
          url2.username = encodeURIComponent(decodeURIComponent(value));
        }
    }
    for (var i2 = 0; i2 < rules.length; i2++) {
      var ins = rules[i2];
      if (ins[4]) url2[ins[1]] = url2[ins[1]].toLowerCase();
    }
    url2.auth = url2.password ? url2.username + ":" + url2.password : url2.username;
    url2.origin = url2.protocol !== "file:" && isSpecial(url2.protocol) && url2.host ? url2.protocol + "//" + url2.host : "null";
    url2.href = url2.toString();
    return url2;
  }
  function toString2(stringify2) {
    if (!stringify2 || "function" !== typeof stringify2) stringify2 = qs2.stringify;
    var query, url2 = this, host = url2.host, protocol = url2.protocol;
    if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
    var result = protocol + (url2.protocol && url2.slashes || isSpecial(url2.protocol) ? "//" : "");
    if (url2.username) {
      result += url2.username;
      if (url2.password) result += ":" + url2.password;
      result += "@";
    } else if (url2.password) {
      result += ":" + url2.password;
      result += "@";
    } else if (url2.protocol !== "file:" && isSpecial(url2.protocol) && !host && url2.pathname !== "/") {
      result += "@";
    }
    if (host[host.length - 1] === ":" || port.test(url2.hostname) && !url2.port) {
      host += ":";
    }
    result += host + url2.pathname;
    query = "object" === typeof url2.query ? stringify2(url2.query) : url2.query;
    if (query) result += "?" !== query.charAt(0) ? "?" + query : query;
    if (url2.hash) result += url2.hash;
    return result;
  }
  Url2.prototype = { set: set3, toString: toString2 };
  Url2.extractProtocol = extractProtocol;
  Url2.location = lolcation;
  Url2.trimLeft = trimLeft;
  Url2.qs = qs2;
  urlParse$1 = Url2;
  return urlParse$1;
}
var original;
var hasRequiredOriginal;
function requireOriginal() {
  if (hasRequiredOriginal) return original;
  hasRequiredOriginal = 1;
  var parse2 = requireUrlParse();
  function origin(url2) {
    if ("string" === typeof url2) url2 = parse2(url2);
    if (!url2.protocol || !url2.hostname) return "null";
    return (url2.protocol + "//" + url2.host).toLowerCase();
  }
  origin.same = function same(a, b) {
    return origin(a) === origin(b);
  };
  original = origin;
  return original;
}
var punycode$2 = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
var punycode$1 = punycode$2.exports;
var hasRequiredPunycode;
function requirePunycode() {
  if (hasRequiredPunycode) return punycode$2.exports;
  hasRequiredPunycode = 1;
  (function(module, exports2) {
    (function(root) {
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = module && !module.nodeType && module;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base2 = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors2 = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base2 - tMin, floor2 = Math.floor, stringFromCharCode = String.fromCharCode, key2;
      function error3(type2) {
        throw new RangeError(errors2[type2]);
      }
      function map2(array2, fn) {
        var length = array2.length;
        var result = [];
        while (length--) {
          result[length] = fn(array2[length]);
        }
        return result;
      }
      function mapDomain(string2, fn) {
        var parts = string2.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string2 = parts[1];
        }
        string2 = string2.replace(regexSeparators, ".");
        var labels = string2.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string2) {
        var output2 = [], counter = 0, length = string2.length, value, extra;
        while (counter < length) {
          value = string2.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output2.push(value);
              counter--;
            }
          } else {
            output2.push(value);
          }
        }
        return output2;
      }
      function ucs2encode(array2) {
        return map2(array2, function(value) {
          var output2 = "";
          if (value > 65535) {
            value -= 65536;
            output2 += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output2 += stringFromCharCode(value);
          return output2;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base2;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor2(delta / damp) : delta >> 1;
        delta += floor2(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base2) {
          delta = floor2(delta / baseMinusTMin);
        }
        return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output2 = [], inputLength = input.length, out, i2 = 0, n = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t2, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error3("not-basic");
          }
          output2.push(input.charCodeAt(j));
        }
        for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          for (oldi = i2, w = 1, k = base2; ; k += base2) {
            if (index2 >= inputLength) {
              error3("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base2 || digit > floor2((maxInt - i2) / w)) {
              error3("overflow");
            }
            i2 += digit * w;
            t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t2) {
              break;
            }
            baseMinusT = base2 - t2;
            if (w > floor2(maxInt / baseMinusT)) {
              error3("overflow");
            }
            w *= baseMinusT;
          }
          out = output2.length + 1;
          bias = adapt(i2 - oldi, out, oldi == 0);
          if (floor2(i2 / out) > maxInt - n) {
            error3("overflow");
          }
          n += floor2(i2 / out);
          i2 %= out;
          output2.splice(i2++, 0, n);
        }
        return ucs2encode(output2);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t2, currentValue, output2 = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output2.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output2.length;
        if (basicLength) {
          output2.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor2((maxInt - delta) / handledCPCountPlusOne)) {
            error3("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error3("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base2; ; k += base2) {
                t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                qMinusT = q - t2;
                baseMinusT = base2 - t2;
                output2.push(
                  stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                );
                q = floor2(qMinusT / baseMinusT);
              }
              output2.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output2.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string2) {
          return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string2) {
          return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key2 in punycode2) {
            punycode2.hasOwnProperty(key2) && (freeExports[key2] = punycode2[key2]);
          }
        }
      } else {
        root.punycode = punycode2;
      }
    })(punycode$1);
  })(punycode$2, punycode$2.exports);
  return punycode$2.exports;
}
var punycodeExports = requirePunycode();
const require$$0 = /* @__PURE__ */ getDefaultExportFromCjs$1(punycodeExports);
var objectInspect$3;
var hasRequiredObjectInspect$3;
function requireObjectInspect$3() {
  if (hasRequiredObjectInspect$3) return objectInspect$3;
  hasRequiredObjectInspect$3 = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = require$$0$3;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect$3 = function inspect_(obj, options2, depth, seen2) {
    var opts = options2 || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen2 === "undefined") {
      seen2 = [];
    } else if (indexOf2(seen2, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen2 = $arrSlice.call(seen2);
        seen2.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen2);
      }
      return inspect_(value, opts, depth + 1, seen2);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys2 = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++) {
        s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key2) {
          mapParts.push(inspect(key2, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style2 = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style2];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
    return key2 in this;
  };
  function has(obj, key2) {
    return hasOwn.call(obj, key2);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf2(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x) {
        return i2;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (indexOf2(xs[i2], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++) {
        xs[i2] = has(obj, i2) ? inspect(obj[i2], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key2 in obj) {
      if (!has(obj, key2)) {
        continue;
      }
      if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key2)) {
        xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
      } else {
        xs.push(key2 + ": " + inspect(obj[key2], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect$3;
}
var objectInspect$2;
var hasRequiredObjectInspect$2;
function requireObjectInspect$2() {
  if (hasRequiredObjectInspect$2) return objectInspect$2;
  hasRequiredObjectInspect$2 = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = require$$0$3;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect$2 = function inspect_(obj, options2, depth, seen2) {
    var opts = options2 || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen2 === "undefined") {
      seen2 = [];
    } else if (indexOf2(seen2, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen2 = $arrSlice.call(seen2);
        seen2.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen2);
      }
      return inspect_(value, opts, depth + 1, seen2);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys2 = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++) {
        s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key2) {
          mapParts.push(inspect(key2, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style2 = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style2];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
    return key2 in this;
  };
  function has(obj, key2) {
    return hasOwn.call(obj, key2);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf2(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x) {
        return i2;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (indexOf2(xs[i2], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++) {
        xs[i2] = has(obj, i2) ? inspect(obj[i2], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key2 in obj) {
      if (!has(obj, key2)) {
        continue;
      }
      if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key2)) {
        xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
      } else {
        xs.push(key2 + ": " + inspect(obj[key2], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect$2;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect = /* @__PURE__ */ requireObjectInspect$2();
  var $TypeError = /* @__PURE__ */ requireType();
  var listGetNode = function(list, key2, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key2) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key2) {
    if (!objects) {
      return void 0;
    }
    var node2 = listGetNode(objects, key2);
    return node2 && node2.value;
  };
  var listSet = function(objects, key2, value) {
    var node2 = listGetNode(objects, key2);
    if (node2) {
      node2.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: key2,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key2) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key2);
  };
  var listDelete = function(objects, key2) {
    if (objects) {
      return listGetNode(objects, key2, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect(key2));
        }
      },
      "delete": function(key2) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key2);
        if (deletedNode && root && root === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key2) {
        return listGet($o, key2);
      },
      has: function(key2) {
        return listHas($o, key2);
      },
      set: function(key2, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key2,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic([intrinsic]);
    }
    return intrinsic;
  };
  return callBound;
}
var objectInspect$1;
var hasRequiredObjectInspect$1;
function requireObjectInspect$1() {
  if (hasRequiredObjectInspect$1) return objectInspect$1;
  hasRequiredObjectInspect$1 = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = require$$0$3;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect$1 = function inspect_(obj, options2, depth, seen2) {
    var opts = options2 || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen2 === "undefined") {
      seen2 = [];
    } else if (indexOf2(seen2, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen2 = $arrSlice.call(seen2);
        seen2.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen2);
      }
      return inspect_(value, opts, depth + 1, seen2);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys2 = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++) {
        s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key2) {
          mapParts.push(inspect(key2, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style2 = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style2];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
    return key2 in this;
  };
  function has(obj, key2) {
    return hasOwn.call(obj, key2);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf2(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x) {
        return i2;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (indexOf2(xs[i2], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++) {
        xs[i2] = has(obj, i2) ? inspect(obj[i2], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key2 in obj) {
      if (!has(obj, key2)) {
        continue;
      }
      if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key2)) {
        xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
      } else {
        xs.push(key2 + ": " + inspect(obj[key2], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect$1;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect = /* @__PURE__ */ requireObjectInspect$1();
  var $TypeError = /* @__PURE__ */ requireType();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect(key2));
        }
      },
      "delete": function(key2) {
        if ($m) {
          var result = $mapDelete($m, key2);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result;
        }
        return false;
      },
      get: function(key2) {
        if ($m) {
          return $mapGet($m, key2);
        }
      },
      has: function(key2) {
        if ($m) {
          return $mapHas($m, key2);
        }
        return false;
      },
      set: function(key2, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key2, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = require$$0$3;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj, options2, depth, seen2) {
    var opts = options2 || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen2 === "undefined") {
      seen2 = [];
    } else if (indexOf2(seen2, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen2 = $arrSlice.call(seen2);
        seen2.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen2);
      }
      return inspect_(value, opts, depth + 1, seen2);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys2 = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++) {
        s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key2) {
          mapParts.push(inspect(key2, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style2 = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style2];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
    return key2 in this;
  };
  function has(obj, key2) {
    return hasOwn.call(obj, key2);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf2(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x) {
        return i2;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (indexOf2(xs[i2], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++) {
        xs[i2] = has(obj, i2) ? inspect(obj[i2], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key2 in obj) {
      if (!has(obj, key2)) {
        continue;
      }
      if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key2)) {
        xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
      } else {
        xs.push(key2 + ": " + inspect(obj[key2], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError = /* @__PURE__ */ requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect(key2));
          }
        },
        "delete": function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key2);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key2);
            }
          }
          return false;
        },
        get: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key2);
            }
          }
          return $m && $m.get(key2);
        },
        has: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key2);
            }
          }
          return !!$m && $m.has(key2);
        },
        set: function(key2, value) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key2, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key2, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError = /* @__PURE__ */ requireType();
  var inspect = /* @__PURE__ */ requireObjectInspect$3();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect(key2));
        }
      },
      "delete": function(key2) {
        return !!$channelData && $channelData["delete"](key2);
      },
      get: function(key2) {
        return $channelData && $channelData.get(key2);
      },
      has: function(key2) {
        return !!$channelData && $channelData.has(key2);
      },
      set: function(key2, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key2, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils$1;
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var hexTable = function() {
    var array2 = [];
    for (var i2 = 0; i2 < 256; ++i2) {
      array2.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
    }
    return array2;
  }();
  var compactQueue = function compactQueue2(queue2) {
    while (queue2.length > 1) {
      var item = queue2.pop();
      var obj = item.obj[item.prop];
      if (isArray2(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source, options2) {
    var obj = options2 && options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var i2 = 0; i2 < source.length; ++i2) {
      if (typeof source[i2] !== "undefined") {
        obj[i2] = source[i2];
      }
    }
    return obj;
  };
  var merge2 = function merge3(target, source, options2) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray2(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray2(target) && !isArray2(source)) {
      mergeTarget = arrayToObject(target, options2);
    }
    if (isArray2(target) && isArray2(source)) {
      source.forEach(function(item, i2) {
        if (has.call(target, i2)) {
          var targetItem = target[i2];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i2] = merge3(targetItem, item, options2);
          } else {
            target.push(item);
          }
        } else {
          target[i2] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key2) {
      var value = source[key2];
      if (has.call(acc, key2)) {
        acc[key2] = merge3(acc[key2], value, options2);
      } else {
        acc[key2] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key2) {
      acc[key2] = source[key2];
      return acc;
    }, target);
  };
  var decode = function(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
    if (str.length === 0) {
      return str;
    }
    var string2 = str;
    if (typeof str === "symbol") {
      string2 = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string2 = String(str);
    }
    if (charset === "iso-8859-1") {
      return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0; j < string2.length; j += limit) {
      var segment = string2.length >= limit ? string2.slice(j, j + limit) : string2;
      var arr2 = [];
      for (var i2 = 0; i2 < segment.length; ++i2) {
        var c = segment.charCodeAt(i2);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats2.RFC1738 && (c === 40 || c === 41)) {
          arr2[arr2.length] = segment.charAt(i2);
          continue;
        }
        if (c < 128) {
          arr2[arr2.length] = hexTable[c];
          continue;
        }
        if (c < 2048) {
          arr2[arr2.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          arr2[arr2.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        i2 += 1;
        c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i2) & 1023);
        arr2[arr2.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      out += arr2.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue2 = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i2 = 0; i2 < queue2.length; ++i2) {
      var item = queue2[i2];
      var obj = item.obj[item.prop];
      var keys2 = Object.keys(obj);
      for (var j = 0; j < keys2.length; ++j) {
        var key2 = keys2[j];
        var val = obj[key2];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue2.push({ obj, prop: key2 });
          refs.push(val);
        }
      }
    }
    compactQueue(queue2);
    return value;
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer2 = function isBuffer3(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray2(val)) {
      var mapped = [];
      for (var i2 = 0; i2 < val.length; i2 += 1) {
        mapped.push(fn(val[i2]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils$1 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode,
    encode,
    isBuffer: isBuffer2,
    isRegExp,
    maybeMap,
    merge: merge2
  };
  return utils$1;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = /* @__PURE__ */ requireUtils$1();
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix2) {
      return prefix2 + "[]";
    },
    comma: "comma",
    indices: function indices(prefix2, key2) {
      return prefix2 + "[" + key2 + "]";
    },
    repeat: function repeat(prefix2) {
      return prefix2;
    }
  };
  var isArray2 = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr2, valueOrArray) {
    push.apply(arr2, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults2 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify2 = function stringify3(object, prefix2, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter2 === "function") {
      obj = filter2(prefix2, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix2, defaults2.encoder, charset, "key", format2) : prefix2;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults2.encoder, charset, "key", format2);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults2.encoder, charset, "value", format2))];
      }
      return [formatter(prefix2) + "=" + formatter(String(obj))];
    }
    var values2 = [];
    if (typeof obj === "undefined") {
      return values2;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray2(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils2.maybeMap(obj, encoder);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray2(filter2)) {
      objKeys = filter2;
    } else {
      var keys2 = Object.keys(obj);
      objKeys = sort ? keys2.sort(sort) : keys2;
    }
    var encodedPrefix = encodeDotInKeys ? prefix2.replace(/\./g, "%2E") : prefix2;
    var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key2 = objKeys[j];
      var value = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? key2.replace(/\./g, "%2E") : key2;
      var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values2, stringify3(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
        filter2,
        sort,
        allowDots,
        serializeDate,
        format2,
        formatter,
        encodeValuesOnly,
        charset,
        valueSideChannel
      ));
    }
    return values2;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults2.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats2.formatters[format2];
    var filter2 = defaults2.filter;
    if (typeof opts.filter === "function" || isArray2(opts.filter)) {
      filter2 = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults2.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      commaRoundTrip: opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults2.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
      filter: filter2,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options2 = normalizeStringifyOptions(opts);
    var objKeys;
    var filter2;
    if (typeof options2.filter === "function") {
      filter2 = options2.filter;
      obj = filter2("", obj);
    } else if (isArray2(options2.filter)) {
      filter2 = options2.filter;
      objKeys = filter2;
    }
    var keys2 = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options2.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options2.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options2.sort) {
      objKeys.sort(options2.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i2 = 0; i2 < objKeys.length; ++i2) {
      var key2 = objKeys[i2];
      if (options2.skipNulls && obj[key2] === null) {
        continue;
      }
      pushToArray(keys2, stringify2(
        obj[key2],
        key2,
        generateArrayPrefix,
        commaRoundTrip,
        options2.allowEmptyArrays,
        options2.strictNullHandling,
        options2.skipNulls,
        options2.encodeDotInKeys,
        options2.encode ? options2.encoder : null,
        options2.filter,
        options2.sort,
        options2.allowDots,
        options2.serializeDate,
        options2.format,
        options2.formatter,
        options2.encodeValuesOnly,
        options2.charset,
        sideChannel2
      ));
    }
    var joined = keys2.join(options2.delimiter);
    var prefix2 = options2.addQueryPrefix === true ? "?" : "";
    if (options2.charsetSentinel) {
      if (options2.charset === "iso-8859-1") {
        prefix2 += "utf8=%26%2310003%3B&";
      } else {
        prefix2 += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix2 + joined : "";
  };
  return stringify_1;
}
var parse$2;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$2;
  hasRequiredParse = 1;
  var utils2 = /* @__PURE__ */ requireUtils$1();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var defaults2 = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options2) {
    if (val && typeof val === "string" && options2.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options2) {
    var obj = { __proto__: null };
    var cleanStr = options2.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
    var parts = cleanStr.split(options2.delimiter, limit);
    var skipIndex = -1;
    var i2;
    var charset = options2.charset;
    if (options2.charsetSentinel) {
      for (i2 = 0; i2 < parts.length; ++i2) {
        if (parts[i2].indexOf("utf8=") === 0) {
          if (parts[i2] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i2] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i2;
          i2 = parts.length;
        }
      }
    }
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (i2 === skipIndex) {
        continue;
      }
      var part = parts[i2];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key2, val;
      if (pos === -1) {
        key2 = options2.decoder(part, defaults2.decoder, charset, "key");
        val = options2.strictNullHandling ? null : "";
      } else {
        key2 = options2.decoder(part.slice(0, pos), defaults2.decoder, charset, "key");
        val = utils2.maybeMap(
          parseArrayValue(part.slice(pos + 1), options2),
          function(encodedVal) {
            return options2.decoder(encodedVal, defaults2.decoder, charset, "value");
          }
        );
      }
      if (val && options2.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray2(val) ? [val] : val;
      }
      var existing = has.call(obj, key2);
      if (existing && options2.duplicates === "combine") {
        obj[key2] = utils2.combine(obj[key2], val);
      } else if (!existing || options2.duplicates === "last") {
        obj[key2] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options2, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options2);
    for (var i2 = chain.length - 1; i2 >= 0; --i2) {
      var obj;
      var root = chain[i2];
      if (root === "[]" && options2.parseArrays) {
        obj = options2.allowEmptyArrays && (leaf === "" || options2.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
      } else {
        obj = options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var decodedRoot = options2.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index2 = parseInt(decodedRoot, 10);
        if (!options2.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index2) && root !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options2.parseArrays && index2 <= options2.arrayLimit)) {
          obj = [];
          obj[index2] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options2, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key2 = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options2.depth > 0 && brackets.exec(key2);
    var parent2 = segment ? key2.slice(0, segment.index) : key2;
    var keys2 = [];
    if (parent2) {
      if (!options2.plainObjects && has.call(Object.prototype, parent2)) {
        if (!options2.allowPrototypes) {
          return;
        }
      }
      keys2.push(parent2);
    }
    var i2 = 0;
    while (options2.depth > 0 && (segment = child.exec(key2)) !== null && i2 < options2.depth) {
      i2 += 1;
      if (!options2.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options2.allowPrototypes) {
          return;
        }
      }
      keys2.push(segment[1]);
    }
    if (segment) {
      if (options2.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options2.depth + " and strictDepth is true");
      }
      keys2.push("[" + key2.slice(segment.index) + "]");
    }
    return parseObject(keys2, val, options2, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults2.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults2.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults2.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  parse$2 = function(str, opts) {
    var options2 = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options2) : str;
    var obj = options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    var keys2 = Object.keys(tempObj);
    for (var i2 = 0; i2 < keys2.length; ++i2) {
      var key2 = keys2[i2];
      var newObj = parseKeys(key2, tempObj[key2], options2, typeof str === "string");
      obj = utils2.merge(obj, newObj, options2);
    }
    if (options2.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse$2;
}
var lib;
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  var stringify2 = /* @__PURE__ */ requireStringify();
  var parse2 = /* @__PURE__ */ requireParse();
  var formats2 = /* @__PURE__ */ requireFormats();
  lib = {
    formats: formats2,
    parse: parse2,
    stringify: stringify2
  };
  return lib;
}
var libExports$1 = /* @__PURE__ */ requireLib$1();
const qs = /* @__PURE__ */ getDefaultExportFromCjs$1(libExports$1);
var punycode = require$$0;
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  "\n",
  "	"
], unwise = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(autoEscape), hostEndingChars = [
  "/",
  "?",
  "#"
], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: true,
  "javascript:": true
}, hostlessProtocol = {
  javascript: true,
  "javascript:": true
}, slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring = qs;
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && typeof url2 === "object" && url2 instanceof Url) {
    return url2;
  }
  var u = new Url();
  u.parse(url2, parseQueryString, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  if (typeof url2 !== "string") {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
      var hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i2 = 0; i2 < nonHostChars.length; i2++) {
      var hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i2 = 0, l = hostparts.length; i2 < l; i2++) {
        var part = hostparts[i2];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p = this.port ? ":" + this.port : "";
    var h = this.hostname || "";
    this.host = h + p;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i2 = 0, l = autoEscape.length; i2 < l; i2++) {
      var ae = autoEscape[i2];
      if (rest.indexOf(ae) === -1) {
        continue;
      }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    this.search = "";
    this.query = {};
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p = this.pathname || "";
    var s = this.search || "";
    this.path = p + s;
  }
  this.href = this.format();
  return this;
};
function urlFormat(obj) {
  if (typeof obj === "string") {
    obj = urlParse(obj);
  }
  if (!(obj instanceof Url)) {
    return Url.prototype.format.call(obj);
  }
  return obj.format();
}
Url.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: false
    });
  }
  var search = this.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":") {
    protocol += ":";
  }
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/") {
      pathname = "/" + pathname;
    }
  } else if (!host) {
    host = "";
  }
  if (hash2 && hash2.charAt(0) !== "#") {
    hash2 = "#" + hash2;
  }
  if (search && search.charAt(0) !== "?") {
    search = "?" + search;
  }
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash2;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
  if (!source) {
    return relative;
  }
  return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
  if (typeof relative === "string") {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol") {
        result[rkey] = relative[rkey];
      }
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = "/";
      result.path = result.pathname;
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys2 = Object.keys(relative);
      for (var v = 0; v < keys2.length; v++) {
        var k = keys2[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift())) {
      }
      if (!relative.host) {
        relative.host = "";
      }
      if (!relative.hostname) {
        relative.hostname = "";
      }
      if (relPath[0] !== "") {
        relPath.unshift("");
      }
      if (relPath.length < 2) {
        relPath.unshift("");
      }
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p = result.pathname || "";
      var s = result.search || "";
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "") {
        srcPath[0] = result.host;
      } else {
        srcPath.unshift(result.host);
      }
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "") {
          relPath[0] = relative.host;
        } else {
          relPath.unshift(relative.host);
        }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath) {
      srcPath = [];
    }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last = srcPath[i2];
    if (last === ".") {
      srcPath.splice(i2, 1);
    } else if (last === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
    result.host = result.hostname;
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute2) {
    srcPath.unshift("");
  }
  if (srcPath.length > 0) {
    result.pathname = srcPath.join("/");
  } else {
    result.pathname = null;
    result.path = null;
  }
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse$1 = urlParse;
var resolve$1 = urlResolve;
var resolveObject = urlResolveObject;
var format = urlFormat;
var Url_1 = Url;
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i2 = parts.length - 1; i2 >= 0; i2--) {
    var last = parts[i2];
    if (last === ".") {
      parts.splice(i2, 1);
    } else if (last === "..") {
      parts.splice(i2, 1);
      up++;
    } else if (up) {
      parts.splice(i2, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    var path2 = i2 >= 0 ? arguments[i2] : "/";
    if (typeof path2 !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path2) {
      continue;
    }
    resolvedPath = path2 + "/" + resolvedPath;
    resolvedAbsolute = path2.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
    return !!p;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (f(xs[i2], i2, xs)) res.push(xs[i2]);
  }
  return res;
}
var _globalThis = function(Object2) {
  function get3() {
    var _global2 = this || self;
    delete Object2.prototype.__magic__;
    return _global2;
  }
  if (typeof globalThis === "object") {
    return globalThis;
  }
  if (this) {
    return get3();
  } else {
    Object2.defineProperty(Object2.prototype, "__magic__", {
      configurable: true,
      get: get3
    });
    var _global = __magic__;
    return _global;
  }
}(Object);
var formatImport = (
  /** @type {formatImport}*/
  format
);
var parseImport = (
  /** @type {parseImport}*/
  parse$1
);
var resolveImport = (
  /** @type {resolveImport}*/
  resolve$1
);
var UrlImport = (
  /** @type {UrlImport}*/
  Url_1
);
var URL$1 = _globalThis.URL;
var URLSearchParams$1 = _globalThis.URLSearchParams;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
var CHAR_FORWARD_SLASH = 47;
function isURLInstance(instance) {
  var resolved = (
    /** @type {URL|null} */
    instance != null ? instance : null
  );
  return Boolean(resolved !== null && (resolved == null ? void 0 : resolved.href) && (resolved == null ? void 0 : resolved.origin));
}
function getPathFromURLPosix(url2) {
  if (url2.hostname !== "") {
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  }
  var pathname = url2.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      var third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        throw new TypeError("File URL path must not include encoded / characters");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var domainToASCII = (
  /**
   * @type {domainToASCII}
   */
  function domainToASCII2(domain) {
    if (typeof domain === "undefined") {
      throw new TypeError('The "domain" argument must be specified');
    }
    return new URL$1("http://" + domain).hostname;
  }
);
var domainToUnicode = (
  /**
   * @type {domainToUnicode}
   */
  function domainToUnicode2(domain) {
    if (typeof domain === "undefined") {
      throw new TypeError('The "domain" argument must be specified');
    }
    return new URL$1("http://" + domain).hostname;
  }
);
var pathToFileURL = (
  /**
   * @type {(url: string) => URL}
   */
  function pathToFileURL2(filepath) {
    var outURL = new URL$1("file://");
    var resolved = resolve(filepath);
    var filePathLast = filepath.charCodeAt(filepath.length - 1);
    if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
      resolved += "/";
    }
    outURL.pathname = encodePathChars(resolved);
    return outURL;
  }
);
var fileURLToPath = (
  /**
   * @type {fileURLToPath & ((path: string | URL) => string)}
   */
  function fileURLToPath2(path2) {
    if (!isURLInstance(path2) && typeof path2 !== "string") {
      throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path2 + " (" + path2 + ")");
    }
    var resolved = new URL$1(path2);
    if (resolved.protocol !== "file:") {
      throw new TypeError("The URL must be of scheme file");
    }
    return getPathFromURLPosix(resolved);
  }
);
var formatImportWithOverloads = (
  /**
   * @type {(
   *   ((urlObject: URL, options?: URLFormatOptions) => string) &
   *   ((urlObject: UrlObject | string, options?: never) => string)
   * )}
   */
  function formatImportWithOverloads2(urlObject, options2) {
    var _options$auth, _options$fragment, _options$search, _options$unicode;
    if (options2 === void 0) {
      options2 = {};
    }
    if (!(urlObject instanceof URL$1)) {
      return formatImport(urlObject);
    }
    if (typeof options2 !== "object" || options2 === null) {
      throw new TypeError('The "options" argument must be of type object.');
    }
    var auth = (_options$auth = options2.auth) != null ? _options$auth : true;
    var fragment = (_options$fragment = options2.fragment) != null ? _options$fragment : true;
    var search = (_options$search = options2.search) != null ? _options$search : true;
    (_options$unicode = options2.unicode) != null ? _options$unicode : false;
    var parsed = new URL$1(urlObject.toString());
    if (!auth) {
      parsed.username = "";
      parsed.password = "";
    }
    if (!fragment) {
      parsed.hash = "";
    }
    if (!search) {
      parsed.search = "";
    }
    return parsed.toString();
  }
);
var api = {
  format: formatImportWithOverloads,
  parse: parseImport,
  resolve: resolveImport,
  resolveObject,
  Url: UrlImport,
  URL: URL$1,
  URLSearchParams: URLSearchParams$1,
  domainToASCII,
  domainToUnicode,
  pathToFileURL,
  fileURLToPath
};
const url = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  URL: URL$1,
  URLSearchParams: URLSearchParams$1,
  Url: UrlImport,
  default: api,
  domainToASCII,
  domainToUnicode,
  fileURLToPath,
  format: formatImportWithOverloads,
  parse: parseImport,
  pathToFileURL,
  resolve: resolveImport,
  resolveObject
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(url);
var httpsBrowserify = { exports: {} };
var streamHttp = {};
var request = { exports: {} };
var capability = {};
var hasRequiredCapability;
function requireCapability() {
  if (hasRequiredCapability) return capability;
  hasRequiredCapability = 1;
  (function(exports2) {
    exports2.fetch = isFunction2(commonjsGlobal.fetch) && isFunction2(commonjsGlobal.ReadableStream);
    exports2.writableStream = isFunction2(commonjsGlobal.WritableStream);
    exports2.abortController = isFunction2(commonjsGlobal.AbortController);
    var xhr2;
    function getXHR() {
      if (xhr2 !== void 0) return xhr2;
      if (commonjsGlobal.XMLHttpRequest) {
        xhr2 = new commonjsGlobal.XMLHttpRequest();
        try {
          xhr2.open("GET", commonjsGlobal.XDomainRequest ? "/" : "https://example.com");
        } catch (e) {
          xhr2 = null;
        }
      } else {
        xhr2 = null;
      }
      return xhr2;
    }
    function checkTypeSupport(type2) {
      var xhr3 = getXHR();
      if (!xhr3) return false;
      try {
        xhr3.responseType = type2;
        return xhr3.responseType === type2;
      } catch (e) {
      }
      return false;
    }
    exports2.arraybuffer = exports2.fetch || checkTypeSupport("arraybuffer");
    exports2.msstream = !exports2.fetch && checkTypeSupport("ms-stream");
    exports2.mozchunkedarraybuffer = !exports2.fetch && checkTypeSupport("moz-chunked-arraybuffer");
    exports2.overrideMimeType = exports2.fetch || (getXHR() ? isFunction2(getXHR().overrideMimeType) : false);
    function isFunction2(value) {
      return typeof value === "function";
    }
    xhr2 = null;
  })(capability);
  return capability;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var response = {};
var readableBrowser = { exports: {} };
var streamBrowser;
var hasRequiredStreamBrowser;
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser) return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = requireEvents().EventEmitter;
  return streamBrowser;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys2(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols2);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key2) {
        _defineProperty2(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty2(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = requireDist(), Buffer2 = _require.Buffer;
  var _require2 = requireUtil$2(), inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck2(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass2(BufferList2, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join3(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i2 = 0;
        while (p) {
          copyBuffer(p.data, ret, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_23, options2) {
        return inspect(this, _objectSpread2(_objectSpread2({}, options2), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errorsBrowser = {};
var hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code2, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inheritsLoose2(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code2;
    codes[code2] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len2 = expected.length;
      expected = expected.map(function(i2) {
        return String(i2);
      });
      if (len2 > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
      } else if (len2 === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  return errorsBrowser;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options2, isDuplex, duplexKey) {
    return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
  }
  function getHighWaterMark(state2, options2, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser$c()
  };
  var Stream = requireStreamBrowser();
  var Buffer2 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits_browser()(Writable, Stream);
  function nop() {
  }
  function WritableState(options2, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options2.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options2.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options2.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_23) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options2) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options2);
    this._writableState = new WritableState(options2, this, isDuplex);
    this.writable = true;
    if (options2) {
      if (typeof options2.write === "function") this._write = options2.write;
      if (typeof options2.writev === "function") this._writev = options2.writev;
      if (typeof options2.destroy === "function") this._destroy = options2.destroy;
      if (typeof options2.final === "function") this._final = options2.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len2 = state2.objectMode ? 1 : chunk.length;
    state2.length += len2;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len2, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
    state2.writelen = len2;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len2 = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len2, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set3(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key2 in obj) keys3.push(key2);
    return keys3;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits_browser()(Duplex, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v = 0; v < keys2.length; v++) {
      var method = keys2[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options2) {
    if (!(this instanceof Duplex)) return new Duplex(options2);
    Readable.call(this, options2);
    Writable.call(this, options2);
    this.allowHalfOpen = true;
    if (options2) {
      if (options2.readable === false) this.readable = false;
      if (options2.writable === false) this.writable = false;
      if (options2.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set3(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty2(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve2 = iter[kLastResolve];
    if (resolve2 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve2(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve2, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve2(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve2, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error3 = this[kError];
      if (error3 !== null) {
        return Promise.reject(error3);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve2, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve2(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise2;
      if (lastPromise) {
        promise2 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise2 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise2;
      return promise2;
    }
  }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve2, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty2(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty2(_Object$create, kHandlePromise, {
      value: function value(resolve2, reject) {
        var data = iterator2[kStream].read();
        if (data) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve2(createIterResult(data, false));
        } else {
          iterator2[kLastResolve] = resolve2;
          iterator2[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator2[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator2[kLastReject];
        if (reject !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          reject(err);
        }
        iterator2[kError] = err;
        return;
      }
      var resolve2 = iterator2[kLastResolve];
      if (resolve2 !== null) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        resolve2(createIterResult(void 0, true));
      }
      iterator2[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator2));
    return iterator2;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  requireEvents().EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser();
  var Buffer2 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil$2();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList2 = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits_browser()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options2, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options2.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options2.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options2.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options2.encoding);
      this.encoding = options2.encoding;
    }
  }
  function Readable(options2) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options2);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options2, this, isDuplex);
    this.readable = true;
    if (options2) {
      if (typeof options2.read === "function") this._read = options2.read;
      if (typeof options2.destroy === "function") this._destroy = options2.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set3(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len2 = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len2 === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len2 = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i2 = 0; i2 < len2; i2++) dests[i2].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i2 in stream) {
      if (this[i2] === void 0 && typeof stream[i2] === "function") {
        this[i2] = /* @__PURE__ */ function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i2);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.flowing;
    },
    set: function set3(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFromBrowser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf2(xs, x) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x) return i2;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  requireInherits_browser()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options2) {
    if (!(this instanceof Transform)) return new Transform(options2);
    Duplex.call(this, options2);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options2) {
      if (typeof options2.transform === "function") this._transform = options2.transform;
      if (typeof options2.flush === "function") this._flush = options2.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform = require_stream_transform();
  requireInherits_browser()(PassThrough, Transform);
  function PassThrough(options2) {
    if (!(this instanceof PassThrough)) return new PassThrough(options2);
    Transform.call(this, options2);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call2(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error3;
    var destroys = streams.map(function(stream, i2) {
      var reading = i2 < streams.length - 1;
      var writing = i2 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error3) error3 = err;
        if (err) destroys.forEach(call2);
        if (reading) return;
        destroys.forEach(call2);
        callback(error3);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  if (hasRequiredReadableBrowser) return readableBrowser.exports;
  hasRequiredReadableBrowser = 1;
  (function(module, exports2) {
    exports2 = module.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = requireEndOfStream();
    exports2.pipeline = requirePipeline();
  })(readableBrowser, readableBrowser.exports);
  return readableBrowser.exports;
}
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  var capability2 = requireCapability();
  var inherits = requireInherits_browser();
  var stream = requireReadableBrowser();
  var rStates = response.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  };
  var IncomingMessage = response.IncomingMessage = function(xhr2, response2, mode, resetTimers) {
    var self2 = this;
    stream.Readable.call(self2);
    self2._mode = mode;
    self2.headers = {};
    self2.rawHeaders = [];
    self2.trailers = {};
    self2.rawTrailers = [];
    self2.on("end", function() {
      process$1.nextTick(function() {
        self2.emit("close");
      });
    });
    if (mode === "fetch") {
      let read2 = function() {
        reader.read().then(function(result) {
          if (self2._destroyed)
            return;
          resetTimers(result.done);
          if (result.done) {
            self2.push(null);
            return;
          }
          self2.push(Buffer.from(result.value));
          read2();
        }).catch(function(err) {
          resetTimers(true);
          if (!self2._destroyed)
            self2.emit("error", err);
        });
      };
      self2._fetchResponse = response2;
      self2.url = response2.url;
      self2.statusCode = response2.status;
      self2.statusMessage = response2.statusText;
      response2.headers.forEach(function(header2, key2) {
        self2.headers[key2.toLowerCase()] = header2;
        self2.rawHeaders.push(key2, header2);
      });
      if (capability2.writableStream) {
        var writable = new WritableStream({
          write: function(chunk) {
            resetTimers(false);
            return new Promise(function(resolve2, reject) {
              if (self2._destroyed) {
                reject();
              } else if (self2.push(Buffer.from(chunk))) {
                resolve2();
              } else {
                self2._resumeFetch = resolve2;
              }
            });
          },
          close: function() {
            resetTimers(true);
            if (!self2._destroyed)
              self2.push(null);
          },
          abort: function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          }
        });
        try {
          response2.body.pipeTo(writable).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          });
          return;
        } catch (e) {
        }
      }
      var reader = response2.body.getReader();
      read2();
    } else {
      self2._xhr = xhr2;
      self2._pos = 0;
      self2.url = xhr2.responseURL;
      self2.statusCode = xhr2.status;
      self2.statusMessage = xhr2.statusText;
      var headers = xhr2.getAllResponseHeaders().split(/\r?\n/);
      headers.forEach(function(header2) {
        var matches = header2.match(/^([^:]+):\s*(.*)/);
        if (matches) {
          var key2 = matches[1].toLowerCase();
          if (key2 === "set-cookie") {
            if (self2.headers[key2] === void 0) {
              self2.headers[key2] = [];
            }
            self2.headers[key2].push(matches[2]);
          } else if (self2.headers[key2] !== void 0) {
            self2.headers[key2] += ", " + matches[2];
          } else {
            self2.headers[key2] = matches[2];
          }
          self2.rawHeaders.push(matches[1], matches[2]);
        }
      });
      self2._charset = "x-user-defined";
      if (!capability2.overrideMimeType) {
        var mimeType = self2.rawHeaders["mime-type"];
        if (mimeType) {
          var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
          if (charsetMatch) {
            self2._charset = charsetMatch[1].toLowerCase();
          }
        }
        if (!self2._charset)
          self2._charset = "utf-8";
      }
    }
  };
  inherits(IncomingMessage, stream.Readable);
  IncomingMessage.prototype._read = function() {
    var self2 = this;
    var resolve2 = self2._resumeFetch;
    if (resolve2) {
      self2._resumeFetch = null;
      resolve2();
    }
  };
  IncomingMessage.prototype._onXHRProgress = function(resetTimers) {
    var self2 = this;
    var xhr2 = self2._xhr;
    var response2 = null;
    switch (self2._mode) {
      case "text":
        response2 = xhr2.responseText;
        if (response2.length > self2._pos) {
          var newData = response2.substr(self2._pos);
          if (self2._charset === "x-user-defined") {
            var buffer2 = Buffer.alloc(newData.length);
            for (var i2 = 0; i2 < newData.length; i2++)
              buffer2[i2] = newData.charCodeAt(i2) & 255;
            self2.push(buffer2);
          } else {
            self2.push(newData, self2._charset);
          }
          self2._pos = response2.length;
        }
        break;
      case "arraybuffer":
        if (xhr2.readyState !== rStates.DONE || !xhr2.response)
          break;
        response2 = xhr2.response;
        self2.push(Buffer.from(new Uint8Array(response2)));
        break;
      case "moz-chunked-arraybuffer":
        response2 = xhr2.response;
        if (xhr2.readyState !== rStates.LOADING || !response2)
          break;
        self2.push(Buffer.from(new Uint8Array(response2)));
        break;
      case "ms-stream":
        response2 = xhr2.response;
        if (xhr2.readyState !== rStates.LOADING)
          break;
        var reader = new commonjsGlobal.MSStreamReader();
        reader.onprogress = function() {
          if (reader.result.byteLength > self2._pos) {
            self2.push(Buffer.from(new Uint8Array(reader.result.slice(self2._pos))));
            self2._pos = reader.result.byteLength;
          }
        };
        reader.onload = function() {
          resetTimers(true);
          self2.push(null);
        };
        reader.readAsArrayBuffer(response2);
        break;
    }
    if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
      resetTimers(true);
      self2.push(null);
    }
  };
  return response;
}
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request.exports;
  hasRequiredRequest = 1;
  var capability2 = requireCapability();
  var inherits = requireInherits_browser();
  var response2 = requireResponse();
  var stream = requireReadableBrowser();
  var IncomingMessage = response2.IncomingMessage;
  var rStates = response2.readyStates;
  function decideMode(preferBinary, useFetch) {
    if (capability2.fetch && useFetch) {
      return "fetch";
    } else if (capability2.mozchunkedarraybuffer) {
      return "moz-chunked-arraybuffer";
    } else if (capability2.msstream) {
      return "ms-stream";
    } else if (capability2.arraybuffer && preferBinary) {
      return "arraybuffer";
    } else {
      return "text";
    }
  }
  var ClientRequest = request.exports = function(opts) {
    var self2 = this;
    stream.Writable.call(self2);
    self2._opts = opts;
    self2._body = [];
    self2._headers = {};
    if (opts.auth)
      self2.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
    Object.keys(opts.headers).forEach(function(name) {
      self2.setHeader(name, opts.headers[name]);
    });
    var preferBinary;
    var useFetch = true;
    if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability2.abortController) {
      useFetch = false;
      preferBinary = true;
    } else if (opts.mode === "prefer-streaming") {
      preferBinary = false;
    } else if (opts.mode === "allow-wrong-content-type") {
      preferBinary = !capability2.overrideMimeType;
    } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
      preferBinary = true;
    } else {
      throw new Error("Invalid value for opts.mode");
    }
    self2._mode = decideMode(preferBinary, useFetch);
    self2._fetchTimer = null;
    self2._socketTimeout = null;
    self2._socketTimer = null;
    self2.on("finish", function() {
      self2._onFinish();
    });
  };
  inherits(ClientRequest, stream.Writable);
  ClientRequest.prototype.setHeader = function(name, value) {
    var self2 = this;
    var lowerName = name.toLowerCase();
    if (unsafeHeaders.indexOf(lowerName) !== -1)
      return;
    self2._headers[lowerName] = {
      name,
      value
    };
  };
  ClientRequest.prototype.getHeader = function(name) {
    var header2 = this._headers[name.toLowerCase()];
    if (header2)
      return header2.value;
    return null;
  };
  ClientRequest.prototype.removeHeader = function(name) {
    var self2 = this;
    delete self2._headers[name.toLowerCase()];
  };
  ClientRequest.prototype._onFinish = function() {
    var self2 = this;
    if (self2._destroyed)
      return;
    var opts = self2._opts;
    if ("timeout" in opts && opts.timeout !== 0) {
      self2.setTimeout(opts.timeout);
    }
    var headersObj = self2._headers;
    var body = null;
    if (opts.method !== "GET" && opts.method !== "HEAD") {
      body = new Blob(self2._body, {
        type: (headersObj["content-type"] || {}).value || ""
      });
    }
    var headersList = [];
    Object.keys(headersObj).forEach(function(keyName) {
      var name = headersObj[keyName].name;
      var value = headersObj[keyName].value;
      if (Array.isArray(value)) {
        value.forEach(function(v) {
          headersList.push([name, v]);
        });
      } else {
        headersList.push([name, value]);
      }
    });
    if (self2._mode === "fetch") {
      var signal = null;
      if (capability2.abortController) {
        var controller = new AbortController();
        signal = controller.signal;
        self2._fetchAbortController = controller;
        if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
          self2._fetchTimer = commonjsGlobal.setTimeout(function() {
            self2.emit("requestTimeout");
            if (self2._fetchAbortController)
              self2._fetchAbortController.abort();
          }, opts.requestTimeout);
        }
      }
      commonjsGlobal.fetch(self2._opts.url, {
        method: self2._opts.method,
        headers: headersList,
        body: body || void 0,
        mode: "cors",
        credentials: opts.withCredentials ? "include" : "same-origin",
        signal
      }).then(function(response3) {
        self2._fetchResponse = response3;
        self2._resetTimers(false);
        self2._connect();
      }, function(reason) {
        self2._resetTimers(true);
        if (!self2._destroyed)
          self2.emit("error", reason);
      });
    } else {
      var xhr2 = self2._xhr = new commonjsGlobal.XMLHttpRequest();
      try {
        xhr2.open(self2._opts.method, self2._opts.url, true);
      } catch (err) {
        process$1.nextTick(function() {
          self2.emit("error", err);
        });
        return;
      }
      if ("responseType" in xhr2)
        xhr2.responseType = self2._mode;
      if ("withCredentials" in xhr2)
        xhr2.withCredentials = !!opts.withCredentials;
      if (self2._mode === "text" && "overrideMimeType" in xhr2)
        xhr2.overrideMimeType("text/plain; charset=x-user-defined");
      if ("requestTimeout" in opts) {
        xhr2.timeout = opts.requestTimeout;
        xhr2.ontimeout = function() {
          self2.emit("requestTimeout");
        };
      }
      headersList.forEach(function(header2) {
        xhr2.setRequestHeader(header2[0], header2[1]);
      });
      self2._response = null;
      xhr2.onreadystatechange = function() {
        switch (xhr2.readyState) {
          case rStates.LOADING:
          case rStates.DONE:
            self2._onXHRProgress();
            break;
        }
      };
      if (self2._mode === "moz-chunked-arraybuffer") {
        xhr2.onprogress = function() {
          self2._onXHRProgress();
        };
      }
      xhr2.onerror = function() {
        if (self2._destroyed)
          return;
        self2._resetTimers(true);
        self2.emit("error", new Error("XHR error"));
      };
      try {
        xhr2.send(body);
      } catch (err) {
        process$1.nextTick(function() {
          self2.emit("error", err);
        });
        return;
      }
    }
  };
  function statusValid(xhr2) {
    try {
      var status = xhr2.status;
      return status !== null && status !== 0;
    } catch (e) {
      return false;
    }
  }
  ClientRequest.prototype._onXHRProgress = function() {
    var self2 = this;
    self2._resetTimers(false);
    if (!statusValid(self2._xhr) || self2._destroyed)
      return;
    if (!self2._response)
      self2._connect();
    self2._response._onXHRProgress(self2._resetTimers.bind(self2));
  };
  ClientRequest.prototype._connect = function() {
    var self2 = this;
    if (self2._destroyed)
      return;
    self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
    self2._response.on("error", function(err) {
      self2.emit("error", err);
    });
    self2.emit("response", self2._response);
  };
  ClientRequest.prototype._write = function(chunk, encoding, cb) {
    var self2 = this;
    self2._body.push(chunk);
    cb();
  };
  ClientRequest.prototype._resetTimers = function(done) {
    var self2 = this;
    commonjsGlobal.clearTimeout(self2._socketTimer);
    self2._socketTimer = null;
    if (done) {
      commonjsGlobal.clearTimeout(self2._fetchTimer);
      self2._fetchTimer = null;
    } else if (self2._socketTimeout) {
      self2._socketTimer = commonjsGlobal.setTimeout(function() {
        self2.emit("timeout");
      }, self2._socketTimeout);
    }
  };
  ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function(err) {
    var self2 = this;
    self2._destroyed = true;
    self2._resetTimers(true);
    if (self2._response)
      self2._response._destroyed = true;
    if (self2._xhr)
      self2._xhr.abort();
    else if (self2._fetchAbortController)
      self2._fetchAbortController.abort();
    if (err)
      self2.emit("error", err);
  };
  ClientRequest.prototype.end = function(data, encoding, cb) {
    var self2 = this;
    if (typeof data === "function") {
      cb = data;
      data = void 0;
    }
    stream.Writable.prototype.end.call(self2, data, encoding, cb);
  };
  ClientRequest.prototype.setTimeout = function(timeout, cb) {
    var self2 = this;
    if (cb)
      self2.once("timeout", cb);
    self2._socketTimeout = timeout;
    self2._resetTimers(false);
  };
  ClientRequest.prototype.flushHeaders = function() {
  };
  ClientRequest.prototype.setNoDelay = function() {
  };
  ClientRequest.prototype.setSocketKeepAlive = function() {
  };
  var unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "date",
    "dnt",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];
  return request.exports;
}
var immutable;
var hasRequiredImmutable;
function requireImmutable() {
  if (hasRequiredImmutable) return immutable;
  hasRequiredImmutable = 1;
  immutable = extend2;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend2() {
    var target = {};
    for (var i2 = 0; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  }
  return immutable;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Unordered Collection",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
  return browser;
}
var hasRequiredStreamHttp;
function requireStreamHttp() {
  if (hasRequiredStreamHttp) return streamHttp;
  hasRequiredStreamHttp = 1;
  (function(exports2) {
    var ClientRequest = requireRequest();
    var response2 = requireResponse();
    var extend2 = requireImmutable();
    var statusCodes = requireBrowser();
    var url2 = require$$1;
    var http = exports2;
    http.request = function(opts, cb) {
      if (typeof opts === "string")
        opts = url2.parse(opts);
      else
        opts = extend2(opts);
      var defaultProtocol = commonjsGlobal.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
      var protocol = opts.protocol || defaultProtocol;
      var host = opts.hostname || opts.host;
      var port = opts.port;
      var path2 = opts.path || "/";
      if (host && host.indexOf(":") !== -1)
        host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path2;
      opts.method = (opts.method || "GET").toUpperCase();
      opts.headers = opts.headers || {};
      var req = new ClientRequest(opts);
      if (cb)
        req.on("response", cb);
      return req;
    };
    http.get = function get3(opts, cb) {
      var req = http.request(opts, cb);
      req.end();
      return req;
    };
    http.ClientRequest = ClientRequest;
    http.IncomingMessage = response2.IncomingMessage;
    http.Agent = function() {
    };
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent();
    http.STATUS_CODES = statusCodes;
    http.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  })(streamHttp);
  return streamHttp;
}
var hasRequiredHttpsBrowserify;
function requireHttpsBrowserify() {
  if (hasRequiredHttpsBrowserify) return httpsBrowserify.exports;
  hasRequiredHttpsBrowserify = 1;
  (function(module) {
    var http = requireStreamHttp();
    var url2 = require$$1;
    var https = module.exports;
    for (var key2 in http) {
      if (http.hasOwnProperty(key2)) https[key2] = http[key2];
    }
    https.request = function(params, cb) {
      params = validateParams(params);
      return http.request.call(this, params, cb);
    };
    https.get = function(params, cb) {
      params = validateParams(params);
      return http.get.call(this, params, cb);
    };
    function validateParams(params) {
      if (typeof params === "string") {
        params = url2.parse(params);
      }
      if (!params.protocol) {
        params.protocol = "https:";
      }
      if (params.protocol !== "https:") {
        throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
      }
      return params;
    }
  })(httpsBrowserify);
  return httpsBrowserify.exports;
}
var eventsource;
var hasRequiredEventsource;
function requireEventsource() {
  if (hasRequiredEventsource) return eventsource;
  hasRequiredEventsource = 1;
  var original2 = requireOriginal();
  var parse2 = require$$1.parse;
  var events2 = requireEvents();
  var https = requireHttpsBrowserify();
  var http = requireStreamHttp();
  var util2 = requireUtil$2();
  var httpsOptions = [
    "pfx",
    "key",
    "passphrase",
    "cert",
    "ca",
    "ciphers",
    "rejectUnauthorized",
    "secureProtocol",
    "servername",
    "checkServerIdentity"
  ];
  var bom = [239, 187, 191];
  var colon = 58;
  var space = 32;
  var lineFeed = 10;
  var carriageReturn = 13;
  function hasBom(buf) {
    return bom.every(function(charCode, index2) {
      return buf[index2] === charCode;
    });
  }
  function EventSource(url2, eventSourceInitDict) {
    var readyState = EventSource.CONNECTING;
    var headers = eventSourceInitDict && eventSourceInitDict.headers;
    var hasNewOrigin = false;
    Object.defineProperty(this, "readyState", {
      get: function() {
        return readyState;
      }
    });
    Object.defineProperty(this, "url", {
      get: function() {
        return url2;
      }
    });
    var self2 = this;
    self2.reconnectInterval = 1e3;
    self2.connectionInProgress = false;
    function onConnectionClosed(message) {
      if (readyState === EventSource.CLOSED) return;
      readyState = EventSource.CONNECTING;
      _emit("error", new Event2("error", { message }));
      if (reconnectUrl) {
        url2 = reconnectUrl;
        reconnectUrl = null;
        hasNewOrigin = false;
      }
      setTimeout(function() {
        if (readyState !== EventSource.CONNECTING || self2.connectionInProgress) {
          return;
        }
        self2.connectionInProgress = true;
        connect();
      }, self2.reconnectInterval);
    }
    var req;
    var lastEventId = "";
    if (headers && headers["Last-Event-ID"]) {
      lastEventId = headers["Last-Event-ID"];
      delete headers["Last-Event-ID"];
    }
    var discardTrailingNewline = false;
    var data = "";
    var eventName = "";
    var reconnectUrl = null;
    function connect() {
      var options2 = parse2(url2);
      var isSecure = options2.protocol === "https:";
      options2.headers = { "Cache-Control": "no-cache", "Accept": "text/event-stream" };
      if (lastEventId) options2.headers["Last-Event-ID"] = lastEventId;
      if (headers) {
        var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;
        for (var i2 in reqHeaders) {
          var header2 = reqHeaders[i2];
          if (header2) {
            options2.headers[i2] = header2;
          }
        }
      }
      options2.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);
      if (eventSourceInitDict && eventSourceInitDict.createConnection !== void 0) {
        options2.createConnection = eventSourceInitDict.createConnection;
      }
      var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
      if (useProxy) {
        var proxy = parse2(eventSourceInitDict.proxy);
        isSecure = proxy.protocol === "https:";
        options2.protocol = isSecure ? "https:" : "http:";
        options2.path = url2;
        options2.headers.Host = options2.host;
        options2.hostname = proxy.hostname;
        options2.host = proxy.host;
        options2.port = proxy.port;
      }
      if (eventSourceInitDict && eventSourceInitDict.https) {
        for (var optName in eventSourceInitDict.https) {
          if (httpsOptions.indexOf(optName) === -1) {
            continue;
          }
          var option2 = eventSourceInitDict.https[optName];
          if (option2 !== void 0) {
            options2[optName] = option2;
          }
        }
      }
      if (eventSourceInitDict && eventSourceInitDict.withCredentials !== void 0) {
        options2.withCredentials = eventSourceInitDict.withCredentials;
      }
      req = (isSecure ? https : http).request(options2, function(res) {
        self2.connectionInProgress = false;
        if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
          _emit("error", new Event2("error", { status: res.statusCode, message: res.statusMessage }));
          onConnectionClosed();
          return;
        }
        if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
          var location2 = res.headers.location;
          if (!location2) {
            _emit("error", new Event2("error", { status: res.statusCode, message: res.statusMessage }));
            return;
          }
          var prevOrigin = original2(url2);
          var nextOrigin = original2(location2);
          hasNewOrigin = prevOrigin !== nextOrigin;
          if (res.statusCode === 307) reconnectUrl = url2;
          url2 = location2;
          process$1.nextTick(connect);
          return;
        }
        if (res.statusCode !== 200) {
          _emit("error", new Event2("error", { status: res.statusCode, message: res.statusMessage }));
          return self2.close();
        }
        readyState = EventSource.OPEN;
        res.on("close", function() {
          res.removeAllListeners("close");
          res.removeAllListeners("end");
          onConnectionClosed();
        });
        res.on("end", function() {
          res.removeAllListeners("close");
          res.removeAllListeners("end");
          onConnectionClosed();
        });
        _emit("open", new Event2("open"));
        var isFirst = true;
        var buf;
        var startingPos = 0;
        var startingFieldLength = -1;
        res.on("data", function(chunk) {
          buf = buf ? Buffer.concat([buf, chunk]) : chunk;
          if (isFirst && hasBom(buf)) {
            buf = buf.slice(bom.length);
          }
          isFirst = false;
          var pos = 0;
          var length = buf.length;
          while (pos < length) {
            if (discardTrailingNewline) {
              if (buf[pos] === lineFeed) {
                ++pos;
              }
              discardTrailingNewline = false;
            }
            var lineLength = -1;
            var fieldLength = startingFieldLength;
            var c;
            for (var i3 = startingPos; lineLength < 0 && i3 < length; ++i3) {
              c = buf[i3];
              if (c === colon) {
                if (fieldLength < 0) {
                  fieldLength = i3 - pos;
                }
              } else if (c === carriageReturn) {
                discardTrailingNewline = true;
                lineLength = i3 - pos;
              } else if (c === lineFeed) {
                lineLength = i3 - pos;
              }
            }
            if (lineLength < 0) {
              startingPos = length - pos;
              startingFieldLength = fieldLength;
              break;
            } else {
              startingPos = 0;
              startingFieldLength = -1;
            }
            parseEventStreamLine(buf, pos, fieldLength, lineLength);
            pos += lineLength + 1;
          }
          if (pos === length) {
            buf = void 0;
          } else if (pos > 0) {
            buf = buf.slice(pos);
          }
        });
      });
      req.on("error", function(err) {
        self2.connectionInProgress = false;
        onConnectionClosed(err.message);
      });
      if (req.setNoDelay) req.setNoDelay(true);
      req.end();
    }
    connect();
    function _emit() {
      if (self2.listeners(arguments[0]).length > 0) {
        self2.emit.apply(self2, arguments);
      }
    }
    this._close = function() {
      if (readyState === EventSource.CLOSED) return;
      readyState = EventSource.CLOSED;
      if (req.abort) req.abort();
      if (req.xhr && req.xhr.abort) req.xhr.abort();
    };
    function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
      if (lineLength === 0) {
        if (data.length > 0) {
          var type2 = eventName || "message";
          _emit(type2, new MessageEvent(type2, {
            data: data.slice(0, -1),
            // remove trailing newline
            lastEventId,
            origin: original2(url2)
          }));
          data = "";
        }
        eventName = void 0;
      } else if (fieldLength > 0) {
        var noValue = fieldLength < 0;
        var step = 0;
        var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
        if (noValue) {
          step = lineLength;
        } else if (buf[pos + fieldLength + 1] !== space) {
          step = fieldLength + 1;
        } else {
          step = fieldLength + 2;
        }
        pos += step;
        var valueLength = lineLength - step;
        var value = buf.slice(pos, pos + valueLength).toString();
        if (field === "data") {
          data += value + "\n";
        } else if (field === "event") {
          eventName = value;
        } else if (field === "id") {
          lastEventId = value;
        } else if (field === "retry") {
          var retry = parseInt(value, 10);
          if (!Number.isNaN(retry)) {
            self2.reconnectInterval = retry;
          }
        }
      }
    }
  }
  eventsource = EventSource;
  util2.inherits(EventSource, events2.EventEmitter);
  EventSource.prototype.constructor = EventSource;
  ["open", "error", "message"].forEach(function(method) {
    Object.defineProperty(EventSource.prototype, "on" + method, {
      /**
       * Returns the current listener
       *
       * @return {Mixed} the set function or undefined
       * @api private
       */
      get: function get3() {
        var listener = this.listeners(method)[0];
        return listener ? listener._listener ? listener._listener : listener : void 0;
      },
      /**
       * Start listening for events
       *
       * @param {Function} listener the listener
       * @return {Mixed} the set function or undefined
       * @api private
       */
      set: function set3(listener) {
        this.removeAllListeners(method);
        this.addEventListener(method, listener);
      }
    });
  });
  Object.defineProperty(EventSource, "CONNECTING", { enumerable: true, value: 0 });
  Object.defineProperty(EventSource, "OPEN", { enumerable: true, value: 1 });
  Object.defineProperty(EventSource, "CLOSED", { enumerable: true, value: 2 });
  EventSource.prototype.CONNECTING = 0;
  EventSource.prototype.OPEN = 1;
  EventSource.prototype.CLOSED = 2;
  EventSource.prototype.close = function() {
    this._close();
  };
  EventSource.prototype.addEventListener = function addEventListener(type2, listener) {
    if (typeof listener === "function") {
      listener._listener = listener;
      this.on(type2, listener);
    }
  };
  EventSource.prototype.dispatchEvent = function dispatchEvent(event) {
    if (!event.type) {
      throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
    }
    this.emit(event.type, event.detail);
  };
  EventSource.prototype.removeEventListener = function removeEventListener(type2, listener) {
    if (typeof listener === "function") {
      listener._listener = void 0;
      this.removeListener(type2, listener);
    }
  };
  function Event2(type2, optionalProperties) {
    Object.defineProperty(this, "type", { writable: false, value: type2, enumerable: true });
    if (optionalProperties) {
      for (var f in optionalProperties) {
        if (optionalProperties.hasOwnProperty(f)) {
          Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true });
        }
      }
    }
  }
  function MessageEvent(type2, eventInitDict) {
    Object.defineProperty(this, "type", { writable: false, value: type2, enumerable: true });
    for (var f in eventInitDict) {
      if (eventInitDict.hasOwnProperty(f)) {
        Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true });
      }
    }
  }
  function removeUnsafeHeaders(headers) {
    var safe = {};
    for (var key2 in headers) {
      if (/^(cookie|authorization)$/i.test(key2)) {
        continue;
      }
      safe[key2] = headers[key2];
    }
    return safe;
  }
  return eventsource;
}
var hasRequiredCall_builder;
function requireCall_builder() {
  if (hasRequiredCall_builder) return call_builder;
  hasRequiredCall_builder = 1;
  Object.defineProperty(call_builder, "__esModule", { value: true });
  call_builder.CallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var detect_node_1 = tslib_1.__importDefault(requireBrowser$1());
  var urijs_1 = tslib_1.__importDefault(requireURI());
  var URITemplate_1 = tslib_1.__importDefault(requireURITemplate());
  var errors_1 = requireErrors();
  var horizon_axios_client_1 = tslib_1.__importDefault(requireHorizon_axios_client());
  var version2 = require$$2$2.version;
  var JOINABLE = ["transaction"];
  var EventSource;
  var anyGlobal = commonjsGlobal;
  if (anyGlobal.EventSource) {
    EventSource = anyGlobal.EventSource;
  } else if (detect_node_1.default) {
    EventSource = requireEventsource();
  } else {
    EventSource = anyGlobal.window.EventSource;
  }
  var CallBuilder = function() {
    function CallBuilder2(serverUrl, neighborRoot) {
      if (neighborRoot === void 0) {
        neighborRoot = "";
      }
      this.url = serverUrl.clone();
      this.filter = [];
      this.originalSegments = this.url.segment() || [];
      this.neighborRoot = neighborRoot;
    }
    CallBuilder2.prototype.call = function() {
      var _this = this;
      this.checkFilter();
      return this._sendNormalRequest(this.url).then(function(r) {
        return _this._parseResponse(r);
      });
    };
    CallBuilder2.prototype.stream = function(options2) {
      var _this = this;
      if (options2 === void 0) {
        options2 = {};
      }
      this.checkFilter();
      this.url.setQuery("X-Client-Name", "js-stellar-sdk");
      this.url.setQuery("X-Client-Version", version2);
      var es;
      var timeout;
      var createTimeout = function() {
        timeout = setTimeout(function() {
          if (es) {
            es.close();
          }
          es = createEventSource();
        }, options2.reconnectTimeout || 15 * 1e3);
      };
      var createEventSource = function() {
        try {
          es = new EventSource(_this.url.toString());
        } catch (err) {
          if (options2.onerror) {
            options2.onerror(err);
          }
        }
        createTimeout();
        if (es) {
          var closed_1 = false;
          var onClose_1 = function() {
            if (closed_1) {
              return;
            }
            clearTimeout(timeout);
            es.close();
            createEventSource();
            closed_1 = true;
          };
          var onMessage = function(message) {
            if (message.type === "close") {
              onClose_1();
              return;
            }
            var result = message.data ? _this._parseRecord(JSON.parse(message.data)) : message;
            if (result.paging_token) {
              _this.url.setQuery("cursor", result.paging_token);
            }
            clearTimeout(timeout);
            createTimeout();
            if (typeof options2.onmessage !== "undefined") {
              options2.onmessage(result);
            }
          };
          var onError = function(error3) {
            if (options2.onerror) {
              options2.onerror(error3);
            }
          };
          if (es.addEventListener) {
            es.addEventListener("message", onMessage.bind(_this));
            es.addEventListener("error", onError.bind(_this));
            es.addEventListener("close", onClose_1.bind(_this));
          } else {
            es.onmessage = onMessage.bind(_this);
            es.onerror = onError.bind(_this);
          }
        }
        return es;
      };
      createEventSource();
      return function close() {
        clearTimeout(timeout);
        if (es) {
          es.close();
        }
      };
    };
    CallBuilder2.prototype.cursor = function(cursor2) {
      this.url.setQuery("cursor", cursor2);
      return this;
    };
    CallBuilder2.prototype.limit = function(recordsNumber) {
      this.url.setQuery("limit", recordsNumber.toString());
      return this;
    };
    CallBuilder2.prototype.order = function(direction) {
      this.url.setQuery("order", direction);
      return this;
    };
    CallBuilder2.prototype.join = function(include) {
      this.url.setQuery("join", include);
      return this;
    };
    CallBuilder2.prototype.forEndpoint = function(endpoint, param) {
      if (this.neighborRoot === "") {
        throw new Error("Invalid usage: neighborRoot not set in constructor");
      }
      this.filter.push([endpoint, param, this.neighborRoot]);
      return this;
    };
    CallBuilder2.prototype.checkFilter = function() {
      if (this.filter.length >= 2) {
        throw new errors_1.BadRequestError("Too many filters specified", this.filter);
      }
      if (this.filter.length === 1) {
        var newSegment = this.originalSegments.concat(this.filter[0]);
        this.url.segment(newSegment);
      }
    };
    CallBuilder2.prototype._requestFnForLink = function(link) {
      var _this = this;
      return function(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return tslib_1.__awaiter(_this, void 0, void 0, function() {
          var uri2, template, r;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (link.templated) {
                  template = URITemplate_1.default(link.href);
                  uri2 = urijs_1.default(template.expand(opts));
                } else {
                  uri2 = urijs_1.default(link.href);
                }
                return [4, this._sendNormalRequest(uri2)];
              case 1:
                r = _a.sent();
                return [2, this._parseResponse(r)];
            }
          });
        });
      };
    };
    CallBuilder2.prototype._parseRecord = function(json) {
      var _this = this;
      if (!json._links) {
        return json;
      }
      var _loop_1 = function(key3) {
        var n = json._links[key3];
        var included = false;
        if (typeof json[key3] !== "undefined") {
          json[key3 + "_attr"] = json[key3];
          included = true;
        }
        if (included && JOINABLE.indexOf(key3) >= 0) {
          var record_1 = this_1._parseRecord(json[key3]);
          json[key3] = function() {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              return tslib_1.__generator(this, function(_a2) {
                return [2, record_1];
              });
            });
          };
        } else {
          json[key3] = this_1._requestFnForLink(n);
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = Object.keys(json._links); _i < _a.length; _i++) {
        var key2 = _a[_i];
        _loop_1(key2);
      }
      return json;
    };
    CallBuilder2.prototype._sendNormalRequest = function(initialUrl) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var url2;
        return tslib_1.__generator(this, function(_a) {
          url2 = initialUrl;
          if (url2.authority() === "") {
            url2 = url2.authority(this.url.authority());
          }
          if (url2.protocol() === "") {
            url2 = url2.protocol(this.url.protocol());
          }
          return [2, horizon_axios_client_1.default.get(url2.toString()).then(function(response2) {
            return response2.data;
          }).catch(this._handleNetworkError)];
        });
      });
    };
    CallBuilder2.prototype._parseResponse = function(json) {
      if (json._embedded && json._embedded.records) {
        return this._toCollectionPage(json);
      }
      return this._parseRecord(json);
    };
    CallBuilder2.prototype._toCollectionPage = function(json) {
      var _this = this;
      for (var i2 = 0; i2 < json._embedded.records.length; i2 += 1) {
        json._embedded.records[i2] = this._parseRecord(json._embedded.records[i2]);
      }
      return {
        records: json._embedded.records,
        next: function() {
          return tslib_1.__awaiter(_this, void 0, void 0, function() {
            var r;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._sendNormalRequest(urijs_1.default(json._links.next.href))];
                case 1:
                  r = _a.sent();
                  return [2, this._toCollectionPage(r)];
              }
            });
          });
        },
        prev: function() {
          return tslib_1.__awaiter(_this, void 0, void 0, function() {
            var r;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._sendNormalRequest(urijs_1.default(json._links.prev.href))];
                case 1:
                  r = _a.sent();
                  return [2, this._toCollectionPage(r)];
              }
            });
          });
        }
      };
    };
    CallBuilder2.prototype._handleNetworkError = function(error3) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        return tslib_1.__generator(this, function(_a) {
          if (error3.response && error3.response.status && error3.response.statusText) {
            switch (error3.response.status) {
              case 404:
                return [2, Promise.reject(new errors_1.NotFoundError(error3.response.statusText, error3.response.data))];
              default:
                return [2, Promise.reject(new errors_1.NetworkError(error3.response.statusText, error3.response.data))];
            }
          } else {
            return [2, Promise.reject(new Error(error3.message))];
          }
        });
      });
    };
    return CallBuilder2;
  }();
  call_builder.CallBuilder = CallBuilder;
  return call_builder;
}
var account_call_builder = {};
var hasRequiredAccount_call_builder;
function requireAccount_call_builder() {
  if (hasRequiredAccount_call_builder) return account_call_builder;
  hasRequiredAccount_call_builder = 1;
  Object.defineProperty(account_call_builder, "__esModule", { value: true });
  account_call_builder.AccountCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var AccountCallBuilder = function(_super) {
    tslib_1.__extends(AccountCallBuilder2, _super);
    function AccountCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("accounts");
      return _this;
    }
    AccountCallBuilder2.prototype.accountId = function(id) {
      var builder = new call_builder_1.CallBuilder(this.url.clone());
      builder.filter.push([id]);
      return builder;
    };
    AccountCallBuilder2.prototype.forSigner = function(id) {
      this.url.setQuery("signer", id);
      return this;
    };
    AccountCallBuilder2.prototype.forAsset = function(asset2) {
      this.url.setQuery("asset", "" + asset2);
      return this;
    };
    AccountCallBuilder2.prototype.sponsor = function(id) {
      this.url.setQuery("sponsor", id);
      return this;
    };
    AccountCallBuilder2.prototype.forLiquidityPool = function(id) {
      this.url.setQuery("liquidity_pool", id);
      return this;
    };
    return AccountCallBuilder2;
  }(call_builder_1.CallBuilder);
  account_call_builder.AccountCallBuilder = AccountCallBuilder;
  return account_call_builder;
}
var assets_call_builder = {};
var hasRequiredAssets_call_builder;
function requireAssets_call_builder() {
  if (hasRequiredAssets_call_builder) return assets_call_builder;
  hasRequiredAssets_call_builder = 1;
  Object.defineProperty(assets_call_builder, "__esModule", { value: true });
  assets_call_builder.AssetsCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var AssetsCallBuilder = function(_super) {
    tslib_1.__extends(AssetsCallBuilder2, _super);
    function AssetsCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("assets");
      return _this;
    }
    AssetsCallBuilder2.prototype.forCode = function(value) {
      this.url.setQuery("asset_code", value);
      return this;
    };
    AssetsCallBuilder2.prototype.forIssuer = function(value) {
      this.url.setQuery("asset_issuer", value);
      return this;
    };
    return AssetsCallBuilder2;
  }(call_builder_1.CallBuilder);
  assets_call_builder.AssetsCallBuilder = AssetsCallBuilder;
  return assets_call_builder;
}
var claimable_balances_call_builder = {};
var hasRequiredClaimable_balances_call_builder;
function requireClaimable_balances_call_builder() {
  if (hasRequiredClaimable_balances_call_builder) return claimable_balances_call_builder;
  hasRequiredClaimable_balances_call_builder = 1;
  Object.defineProperty(claimable_balances_call_builder, "__esModule", { value: true });
  claimable_balances_call_builder.ClaimableBalanceCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var ClaimableBalanceCallBuilder = function(_super) {
    tslib_1.__extends(ClaimableBalanceCallBuilder2, _super);
    function ClaimableBalanceCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("claimable_balances");
      return _this;
    }
    ClaimableBalanceCallBuilder2.prototype.claimableBalance = function(claimableBalanceId) {
      var builder = new call_builder_1.CallBuilder(this.url.clone());
      builder.filter.push([claimableBalanceId]);
      return builder;
    };
    ClaimableBalanceCallBuilder2.prototype.sponsor = function(sponsor) {
      this.url.setQuery("sponsor", sponsor);
      return this;
    };
    ClaimableBalanceCallBuilder2.prototype.claimant = function(claimant2) {
      this.url.setQuery("claimant", claimant2);
      return this;
    };
    ClaimableBalanceCallBuilder2.prototype.asset = function(asset2) {
      this.url.setQuery("asset", asset2.toString());
      return this;
    };
    return ClaimableBalanceCallBuilder2;
  }(call_builder_1.CallBuilder);
  claimable_balances_call_builder.ClaimableBalanceCallBuilder = ClaimableBalanceCallBuilder;
  return claimable_balances_call_builder;
}
var effect_call_builder = {};
var hasRequiredEffect_call_builder;
function requireEffect_call_builder() {
  if (hasRequiredEffect_call_builder) return effect_call_builder;
  hasRequiredEffect_call_builder = 1;
  Object.defineProperty(effect_call_builder, "__esModule", { value: true });
  effect_call_builder.EffectCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var EffectCallBuilder = function(_super) {
    tslib_1.__extends(EffectCallBuilder2, _super);
    function EffectCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl, "effects") || this;
      _this.url.segment("effects");
      return _this;
    }
    EffectCallBuilder2.prototype.forAccount = function(accountId) {
      return this.forEndpoint("accounts", accountId);
    };
    EffectCallBuilder2.prototype.forLedger = function(sequence) {
      return this.forEndpoint("ledgers", sequence.toString());
    };
    EffectCallBuilder2.prototype.forTransaction = function(transactionId) {
      return this.forEndpoint("transactions", transactionId);
    };
    EffectCallBuilder2.prototype.forOperation = function(operationId) {
      return this.forEndpoint("operations", operationId);
    };
    EffectCallBuilder2.prototype.forLiquidityPool = function(poolId) {
      return this.forEndpoint("liquidity_pools", poolId);
    };
    return EffectCallBuilder2;
  }(call_builder_1.CallBuilder);
  effect_call_builder.EffectCallBuilder = EffectCallBuilder;
  return effect_call_builder;
}
var friendbot_builder = {};
var hasRequiredFriendbot_builder;
function requireFriendbot_builder() {
  if (hasRequiredFriendbot_builder) return friendbot_builder;
  hasRequiredFriendbot_builder = 1;
  Object.defineProperty(friendbot_builder, "__esModule", { value: true });
  friendbot_builder.FriendbotBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var FriendbotBuilder = function(_super) {
    tslib_1.__extends(FriendbotBuilder2, _super);
    function FriendbotBuilder2(serverUrl, address) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("friendbot");
      _this.url.setQuery("addr", address);
      return _this;
    }
    return FriendbotBuilder2;
  }(call_builder_1.CallBuilder);
  friendbot_builder.FriendbotBuilder = FriendbotBuilder;
  return friendbot_builder;
}
var ledger_call_builder = {};
var hasRequiredLedger_call_builder;
function requireLedger_call_builder() {
  if (hasRequiredLedger_call_builder) return ledger_call_builder;
  hasRequiredLedger_call_builder = 1;
  Object.defineProperty(ledger_call_builder, "__esModule", { value: true });
  ledger_call_builder.LedgerCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var LedgerCallBuilder = function(_super) {
    tslib_1.__extends(LedgerCallBuilder2, _super);
    function LedgerCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("ledgers");
      return _this;
    }
    LedgerCallBuilder2.prototype.ledger = function(sequence) {
      this.filter.push(["ledgers", sequence.toString()]);
      return this;
    };
    return LedgerCallBuilder2;
  }(call_builder_1.CallBuilder);
  ledger_call_builder.LedgerCallBuilder = LedgerCallBuilder;
  return ledger_call_builder;
}
var liquidity_pool_call_builder = {};
var hasRequiredLiquidity_pool_call_builder;
function requireLiquidity_pool_call_builder() {
  if (hasRequiredLiquidity_pool_call_builder) return liquidity_pool_call_builder;
  hasRequiredLiquidity_pool_call_builder = 1;
  Object.defineProperty(liquidity_pool_call_builder, "__esModule", { value: true });
  liquidity_pool_call_builder.LiquidityPoolCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var LiquidityPoolCallBuilder = function(_super) {
    tslib_1.__extends(LiquidityPoolCallBuilder2, _super);
    function LiquidityPoolCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("liquidity_pools");
      return _this;
    }
    LiquidityPoolCallBuilder2.prototype.forAssets = function() {
      var assets = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        assets[_i] = arguments[_i];
      }
      var assetList = assets.map(function(asset2) {
        return asset2.toString();
      }).join(",");
      this.url.setQuery("reserves", assetList);
      return this;
    };
    LiquidityPoolCallBuilder2.prototype.forAccount = function(id) {
      this.url.setQuery("account", id);
      return this;
    };
    LiquidityPoolCallBuilder2.prototype.liquidityPoolId = function(id) {
      if (!id.match(/[a-fA-F0-9]{64}/)) {
        throw new TypeError(id + " does not look like a liquidity pool ID");
      }
      var builder = new call_builder_1.CallBuilder(this.url.clone());
      builder.filter.push([id.toLowerCase()]);
      return builder;
    };
    return LiquidityPoolCallBuilder2;
  }(call_builder_1.CallBuilder);
  liquidity_pool_call_builder.LiquidityPoolCallBuilder = LiquidityPoolCallBuilder;
  return liquidity_pool_call_builder;
}
var offer_call_builder = {};
var hasRequiredOffer_call_builder;
function requireOffer_call_builder() {
  if (hasRequiredOffer_call_builder) return offer_call_builder;
  hasRequiredOffer_call_builder = 1;
  Object.defineProperty(offer_call_builder, "__esModule", { value: true });
  offer_call_builder.OfferCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var OfferCallBuilder = function(_super) {
    tslib_1.__extends(OfferCallBuilder2, _super);
    function OfferCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl, "offers") || this;
      _this.url.segment("offers");
      return _this;
    }
    OfferCallBuilder2.prototype.offer = function(offerId) {
      var builder = new call_builder_1.CallBuilder(this.url.clone());
      builder.filter.push([offerId]);
      return builder;
    };
    OfferCallBuilder2.prototype.forAccount = function(id) {
      return this.forEndpoint("accounts", id);
    };
    OfferCallBuilder2.prototype.buying = function(asset2) {
      if (!asset2.isNative()) {
        this.url.setQuery("buying_asset_type", asset2.getAssetType());
        this.url.setQuery("buying_asset_code", asset2.getCode());
        this.url.setQuery("buying_asset_issuer", asset2.getIssuer());
      } else {
        this.url.setQuery("buying_asset_type", "native");
      }
      return this;
    };
    OfferCallBuilder2.prototype.selling = function(asset2) {
      if (!asset2.isNative()) {
        this.url.setQuery("selling_asset_type", asset2.getAssetType());
        this.url.setQuery("selling_asset_code", asset2.getCode());
        this.url.setQuery("selling_asset_issuer", asset2.getIssuer());
      } else {
        this.url.setQuery("selling_asset_type", "native");
      }
      return this;
    };
    OfferCallBuilder2.prototype.sponsor = function(id) {
      this.url.setQuery("sponsor", id);
      return this;
    };
    return OfferCallBuilder2;
  }(call_builder_1.CallBuilder);
  offer_call_builder.OfferCallBuilder = OfferCallBuilder;
  return offer_call_builder;
}
var operation_call_builder = {};
var hasRequiredOperation_call_builder;
function requireOperation_call_builder() {
  if (hasRequiredOperation_call_builder) return operation_call_builder;
  hasRequiredOperation_call_builder = 1;
  Object.defineProperty(operation_call_builder, "__esModule", { value: true });
  operation_call_builder.OperationCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var OperationCallBuilder = function(_super) {
    tslib_1.__extends(OperationCallBuilder2, _super);
    function OperationCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl, "operations") || this;
      _this.url.segment("operations");
      return _this;
    }
    OperationCallBuilder2.prototype.operation = function(operationId) {
      var builder = new call_builder_1.CallBuilder(this.url.clone());
      builder.filter.push([operationId]);
      return builder;
    };
    OperationCallBuilder2.prototype.forAccount = function(accountId) {
      return this.forEndpoint("accounts", accountId);
    };
    OperationCallBuilder2.prototype.forClaimableBalance = function(claimableBalanceId) {
      return this.forEndpoint("claimable_balances", claimableBalanceId);
    };
    OperationCallBuilder2.prototype.forLedger = function(sequence) {
      return this.forEndpoint("ledgers", sequence.toString());
    };
    OperationCallBuilder2.prototype.forTransaction = function(transactionId) {
      return this.forEndpoint("transactions", transactionId);
    };
    OperationCallBuilder2.prototype.forLiquidityPool = function(poolId) {
      return this.forEndpoint("liquidity_pools", poolId);
    };
    OperationCallBuilder2.prototype.includeFailed = function(value) {
      this.url.setQuery("include_failed", value.toString());
      return this;
    };
    return OperationCallBuilder2;
  }(call_builder_1.CallBuilder);
  operation_call_builder.OperationCallBuilder = OperationCallBuilder;
  return operation_call_builder;
}
var orderbook_call_builder = {};
var hasRequiredOrderbook_call_builder;
function requireOrderbook_call_builder() {
  if (hasRequiredOrderbook_call_builder) return orderbook_call_builder;
  hasRequiredOrderbook_call_builder = 1;
  Object.defineProperty(orderbook_call_builder, "__esModule", { value: true });
  orderbook_call_builder.OrderbookCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var OrderbookCallBuilder = function(_super) {
    tslib_1.__extends(OrderbookCallBuilder2, _super);
    function OrderbookCallBuilder2(serverUrl, selling, buying) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("order_book");
      if (!selling.isNative()) {
        _this.url.setQuery("selling_asset_type", selling.getAssetType());
        _this.url.setQuery("selling_asset_code", selling.getCode());
        _this.url.setQuery("selling_asset_issuer", selling.getIssuer());
      } else {
        _this.url.setQuery("selling_asset_type", "native");
      }
      if (!buying.isNative()) {
        _this.url.setQuery("buying_asset_type", buying.getAssetType());
        _this.url.setQuery("buying_asset_code", buying.getCode());
        _this.url.setQuery("buying_asset_issuer", buying.getIssuer());
      } else {
        _this.url.setQuery("buying_asset_type", "native");
      }
      return _this;
    }
    return OrderbookCallBuilder2;
  }(call_builder_1.CallBuilder);
  orderbook_call_builder.OrderbookCallBuilder = OrderbookCallBuilder;
  return orderbook_call_builder;
}
var payment_call_builder = {};
var hasRequiredPayment_call_builder;
function requirePayment_call_builder() {
  if (hasRequiredPayment_call_builder) return payment_call_builder;
  hasRequiredPayment_call_builder = 1;
  Object.defineProperty(payment_call_builder, "__esModule", { value: true });
  payment_call_builder.PaymentCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var PaymentCallBuilder = function(_super) {
    tslib_1.__extends(PaymentCallBuilder2, _super);
    function PaymentCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl, "payments") || this;
      _this.url.segment("payments");
      return _this;
    }
    PaymentCallBuilder2.prototype.forAccount = function(accountId) {
      return this.forEndpoint("accounts", accountId);
    };
    PaymentCallBuilder2.prototype.forLedger = function(sequence) {
      return this.forEndpoint("ledgers", sequence.toString());
    };
    PaymentCallBuilder2.prototype.forTransaction = function(transactionId) {
      return this.forEndpoint("transactions", transactionId);
    };
    return PaymentCallBuilder2;
  }(call_builder_1.CallBuilder);
  payment_call_builder.PaymentCallBuilder = PaymentCallBuilder;
  return payment_call_builder;
}
var strict_receive_path_call_builder = {};
var hasRequiredStrict_receive_path_call_builder;
function requireStrict_receive_path_call_builder() {
  if (hasRequiredStrict_receive_path_call_builder) return strict_receive_path_call_builder;
  hasRequiredStrict_receive_path_call_builder = 1;
  Object.defineProperty(strict_receive_path_call_builder, "__esModule", { value: true });
  strict_receive_path_call_builder.StrictReceivePathCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var StrictReceivePathCallBuilder = function(_super) {
    tslib_1.__extends(StrictReceivePathCallBuilder2, _super);
    function StrictReceivePathCallBuilder2(serverUrl, source, destinationAsset, destinationAmount) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("paths/strict-receive");
      if (typeof source === "string") {
        _this.url.setQuery("source_account", source);
      } else {
        var assets = source.map(function(asset2) {
          if (asset2.isNative()) {
            return "native";
          }
          return asset2.getCode() + ":" + asset2.getIssuer();
        }).join(",");
        _this.url.setQuery("source_assets", assets);
      }
      _this.url.setQuery("destination_amount", destinationAmount);
      if (!destinationAsset.isNative()) {
        _this.url.setQuery("destination_asset_type", destinationAsset.getAssetType());
        _this.url.setQuery("destination_asset_code", destinationAsset.getCode());
        _this.url.setQuery("destination_asset_issuer", destinationAsset.getIssuer());
      } else {
        _this.url.setQuery("destination_asset_type", "native");
      }
      return _this;
    }
    return StrictReceivePathCallBuilder2;
  }(call_builder_1.CallBuilder);
  strict_receive_path_call_builder.StrictReceivePathCallBuilder = StrictReceivePathCallBuilder;
  return strict_receive_path_call_builder;
}
var strict_send_path_call_builder = {};
var hasRequiredStrict_send_path_call_builder;
function requireStrict_send_path_call_builder() {
  if (hasRequiredStrict_send_path_call_builder) return strict_send_path_call_builder;
  hasRequiredStrict_send_path_call_builder = 1;
  Object.defineProperty(strict_send_path_call_builder, "__esModule", { value: true });
  strict_send_path_call_builder.StrictSendPathCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var StrictSendPathCallBuilder = function(_super) {
    tslib_1.__extends(StrictSendPathCallBuilder2, _super);
    function StrictSendPathCallBuilder2(serverUrl, sourceAsset, sourceAmount, destination) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("paths/strict-send");
      if (sourceAsset.isNative()) {
        _this.url.setQuery("source_asset_type", "native");
      } else {
        _this.url.setQuery("source_asset_type", sourceAsset.getAssetType());
        _this.url.setQuery("source_asset_code", sourceAsset.getCode());
        _this.url.setQuery("source_asset_issuer", sourceAsset.getIssuer());
      }
      _this.url.setQuery("source_amount", sourceAmount);
      if (typeof destination === "string") {
        _this.url.setQuery("destination_account", destination);
      } else {
        var assets = destination.map(function(asset2) {
          if (asset2.isNative()) {
            return "native";
          }
          return asset2.getCode() + ":" + asset2.getIssuer();
        }).join(",");
        _this.url.setQuery("destination_assets", assets);
      }
      return _this;
    }
    return StrictSendPathCallBuilder2;
  }(call_builder_1.CallBuilder);
  strict_send_path_call_builder.StrictSendPathCallBuilder = StrictSendPathCallBuilder;
  return strict_send_path_call_builder;
}
var trade_aggregation_call_builder = {};
var hasRequiredTrade_aggregation_call_builder;
function requireTrade_aggregation_call_builder() {
  if (hasRequiredTrade_aggregation_call_builder) return trade_aggregation_call_builder;
  hasRequiredTrade_aggregation_call_builder = 1;
  Object.defineProperty(trade_aggregation_call_builder, "__esModule", { value: true });
  trade_aggregation_call_builder.TradeAggregationCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var errors_1 = requireErrors();
  var allowedResolutions = [
    6e4,
    3e5,
    9e5,
    36e5,
    864e5,
    6048e5
  ];
  var TradeAggregationCallBuilder = function(_super) {
    tslib_1.__extends(TradeAggregationCallBuilder2, _super);
    function TradeAggregationCallBuilder2(serverUrl, base2, counter, start_time, end_time, resolution, offset) {
      var _this = _super.call(this, serverUrl) || this;
      _this.url.segment("trade_aggregations");
      if (!base2.isNative()) {
        _this.url.setQuery("base_asset_type", base2.getAssetType());
        _this.url.setQuery("base_asset_code", base2.getCode());
        _this.url.setQuery("base_asset_issuer", base2.getIssuer());
      } else {
        _this.url.setQuery("base_asset_type", "native");
      }
      if (!counter.isNative()) {
        _this.url.setQuery("counter_asset_type", counter.getAssetType());
        _this.url.setQuery("counter_asset_code", counter.getCode());
        _this.url.setQuery("counter_asset_issuer", counter.getIssuer());
      } else {
        _this.url.setQuery("counter_asset_type", "native");
      }
      if (typeof start_time !== "number" || typeof end_time !== "number") {
        throw new errors_1.BadRequestError("Invalid time bounds", [start_time, end_time]);
      } else {
        _this.url.setQuery("start_time", start_time.toString());
        _this.url.setQuery("end_time", end_time.toString());
      }
      if (!_this.isValidResolution(resolution)) {
        throw new errors_1.BadRequestError("Invalid resolution", resolution);
      } else {
        _this.url.setQuery("resolution", resolution.toString());
      }
      if (!_this.isValidOffset(offset, resolution)) {
        throw new errors_1.BadRequestError("Invalid offset", offset);
      } else {
        _this.url.setQuery("offset", offset.toString());
      }
      return _this;
    }
    TradeAggregationCallBuilder2.prototype.isValidResolution = function(resolution) {
      for (var _i = 0, allowedResolutions_1 = allowedResolutions; _i < allowedResolutions_1.length; _i++) {
        var allowed = allowedResolutions_1[_i];
        if (allowed === resolution) {
          return true;
        }
      }
      return false;
    };
    TradeAggregationCallBuilder2.prototype.isValidOffset = function(offset, resolution) {
      var hour = 36e5;
      return !(offset > resolution || offset >= 24 * hour || offset % hour !== 0);
    };
    return TradeAggregationCallBuilder2;
  }(call_builder_1.CallBuilder);
  trade_aggregation_call_builder.TradeAggregationCallBuilder = TradeAggregationCallBuilder;
  return trade_aggregation_call_builder;
}
var trades_call_builder = {};
var hasRequiredTrades_call_builder;
function requireTrades_call_builder() {
  if (hasRequiredTrades_call_builder) return trades_call_builder;
  hasRequiredTrades_call_builder = 1;
  Object.defineProperty(trades_call_builder, "__esModule", { value: true });
  trades_call_builder.TradesCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var TradesCallBuilder = function(_super) {
    tslib_1.__extends(TradesCallBuilder2, _super);
    function TradesCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl, "trades") || this;
      _this.url.segment("trades");
      return _this;
    }
    TradesCallBuilder2.prototype.forAssetPair = function(base2, counter) {
      if (!base2.isNative()) {
        this.url.setQuery("base_asset_type", base2.getAssetType());
        this.url.setQuery("base_asset_code", base2.getCode());
        this.url.setQuery("base_asset_issuer", base2.getIssuer());
      } else {
        this.url.setQuery("base_asset_type", "native");
      }
      if (!counter.isNative()) {
        this.url.setQuery("counter_asset_type", counter.getAssetType());
        this.url.setQuery("counter_asset_code", counter.getCode());
        this.url.setQuery("counter_asset_issuer", counter.getIssuer());
      } else {
        this.url.setQuery("counter_asset_type", "native");
      }
      return this;
    };
    TradesCallBuilder2.prototype.forOffer = function(offerId) {
      this.url.setQuery("offer_id", offerId);
      return this;
    };
    TradesCallBuilder2.prototype.forType = function(tradeType) {
      this.url.setQuery("trade_type", tradeType);
      return this;
    };
    TradesCallBuilder2.prototype.forAccount = function(accountId) {
      return this.forEndpoint("accounts", accountId);
    };
    TradesCallBuilder2.prototype.forLiquidityPool = function(liquidityPoolId) {
      return this.forEndpoint("liquidity_pools", liquidityPoolId);
    };
    return TradesCallBuilder2;
  }(call_builder_1.CallBuilder);
  trades_call_builder.TradesCallBuilder = TradesCallBuilder;
  return trades_call_builder;
}
var transaction_call_builder = {};
var hasRequiredTransaction_call_builder;
function requireTransaction_call_builder() {
  if (hasRequiredTransaction_call_builder) return transaction_call_builder;
  hasRequiredTransaction_call_builder = 1;
  Object.defineProperty(transaction_call_builder, "__esModule", { value: true });
  transaction_call_builder.TransactionCallBuilder = void 0;
  var tslib_1 = require$$0$4;
  var call_builder_1 = requireCall_builder();
  var TransactionCallBuilder = function(_super) {
    tslib_1.__extends(TransactionCallBuilder2, _super);
    function TransactionCallBuilder2(serverUrl) {
      var _this = _super.call(this, serverUrl, "transactions") || this;
      _this.url.segment("transactions");
      return _this;
    }
    TransactionCallBuilder2.prototype.transaction = function(transactionId) {
      var builder = new call_builder_1.CallBuilder(this.url.clone());
      builder.filter.push([transactionId]);
      return builder;
    };
    TransactionCallBuilder2.prototype.forAccount = function(accountId) {
      return this.forEndpoint("accounts", accountId);
    };
    TransactionCallBuilder2.prototype.forClaimableBalance = function(claimableBalanceId) {
      return this.forEndpoint("claimable_balances", claimableBalanceId);
    };
    TransactionCallBuilder2.prototype.forLedger = function(sequence) {
      return this.forEndpoint("ledgers", sequence.toString());
    };
    TransactionCallBuilder2.prototype.forLiquidityPool = function(poolId) {
      return this.forEndpoint("liquidity_pools", poolId);
    };
    TransactionCallBuilder2.prototype.includeFailed = function(value) {
      this.url.setQuery("include_failed", value.toString());
      return this;
    };
    return TransactionCallBuilder2;
  }(call_builder_1.CallBuilder);
  transaction_call_builder.TransactionCallBuilder = TransactionCallBuilder;
  return transaction_call_builder;
}
var hasRequiredServer;
function requireServer() {
  if (hasRequiredServer) return server;
  hasRequiredServer = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Server = exports2.SUBMIT_TRANSACTION_TIMEOUT = void 0;
    var tslib_1 = require$$0$4;
    var bignumber_js_1 = tslib_1.__importDefault(requireBignumber());
    var isEmpty_12 = tslib_1.__importDefault(requireIsEmpty());
    var merge_12 = tslib_1.__importDefault(requireMerge());
    var stellar_base_1 = requireLib$2();
    var urijs_1 = tslib_1.__importDefault(requireURI());
    var call_builder_1 = requireCall_builder();
    var config_1 = requireConfig();
    var errors_1 = requireErrors();
    var account_call_builder_1 = requireAccount_call_builder();
    var account_response_1 = requireAccount_response();
    var assets_call_builder_1 = requireAssets_call_builder();
    var claimable_balances_call_builder_1 = requireClaimable_balances_call_builder();
    var effect_call_builder_1 = requireEffect_call_builder();
    var friendbot_builder_1 = requireFriendbot_builder();
    var ledger_call_builder_1 = requireLedger_call_builder();
    var liquidity_pool_call_builder_1 = requireLiquidity_pool_call_builder();
    var offer_call_builder_1 = requireOffer_call_builder();
    var operation_call_builder_1 = requireOperation_call_builder();
    var orderbook_call_builder_1 = requireOrderbook_call_builder();
    var payment_call_builder_1 = requirePayment_call_builder();
    var strict_receive_path_call_builder_1 = requireStrict_receive_path_call_builder();
    var strict_send_path_call_builder_1 = requireStrict_send_path_call_builder();
    var trade_aggregation_call_builder_1 = requireTrade_aggregation_call_builder();
    var trades_call_builder_1 = requireTrades_call_builder();
    var transaction_call_builder_1 = requireTransaction_call_builder();
    var horizon_axios_client_1 = tslib_1.__importStar(requireHorizon_axios_client());
    exports2.SUBMIT_TRANSACTION_TIMEOUT = 60 * 1e3;
    var STROOPS_IN_LUMEN = 1e7;
    var ACCOUNT_REQUIRES_MEMO = "MQ==";
    function _getAmountInLumens(amt) {
      return new bignumber_js_1.default(amt).div(STROOPS_IN_LUMEN).toString();
    }
    var Server = function() {
      function Server2(serverURL, opts) {
        if (opts === void 0) {
          opts = {};
        }
        this.serverURL = urijs_1.default(serverURL);
        var allowHttp = typeof opts.allowHttp === "undefined" ? config_1.Config.isAllowHttp() : opts.allowHttp;
        var customHeaders = {};
        if (opts.appName) {
          customHeaders["X-App-Name"] = opts.appName;
        }
        if (opts.appVersion) {
          customHeaders["X-App-Version"] = opts.appVersion;
        }
        if (!isEmpty_12.default(customHeaders)) {
          horizon_axios_client_1.default.interceptors.request.use(function(config2) {
            config2.headers = merge_12.default(customHeaders, config2.headers);
            return config2;
          });
        }
        if (this.serverURL.protocol() !== "https" && !allowHttp) {
          throw new Error("Cannot connect to insecure horizon server");
        }
      }
      Server2.prototype.fetchTimebounds = function(seconds, _isRetry) {
        if (_isRetry === void 0) {
          _isRetry = false;
        }
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var currentTime;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                currentTime = horizon_axios_client_1.getCurrentServerTime(this.serverURL.hostname());
                if (currentTime) {
                  return [2, {
                    minTime: 0,
                    maxTime: currentTime + seconds
                  }];
                }
                if (_isRetry) {
                  return [2, {
                    minTime: 0,
                    maxTime: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3) + seconds
                  }];
                }
                return [4, horizon_axios_client_1.default.get(urijs_1.default(this.serverURL).toString())];
              case 1:
                _a.sent();
                return [4, this.fetchTimebounds(seconds, true)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      };
      Server2.prototype.fetchBaseFee = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var response2;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.feeStats()];
              case 1:
                response2 = _a.sent();
                return [2, parseInt(response2.last_ledger_base_fee, 10) || 100];
            }
          });
        });
      };
      Server2.prototype.feeStats = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var cb;
          return tslib_1.__generator(this, function(_a) {
            cb = new call_builder_1.CallBuilder(urijs_1.default(this.serverURL));
            cb.filter.push(["fee_stats"]);
            return [2, cb.call()];
          });
        });
      };
      Server2.prototype.submitTransaction = function(transaction2, opts) {
        if (opts === void 0) {
          opts = { skipMemoRequiredCheck: false };
        }
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var tx;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!opts.skipMemoRequiredCheck) return [3, 2];
                return [4, this.checkMemoRequired(transaction2)];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                tx = encodeURIComponent(transaction2.toEnvelope().toXDR().toString("base64"));
                return [2, horizon_axios_client_1.default.post(urijs_1.default(this.serverURL).segment("transactions").toString(), "tx=" + tx, { timeout: exports2.SUBMIT_TRANSACTION_TIMEOUT }).then(function(response2) {
                  if (!response2.data.result_xdr) {
                    return response2.data;
                  }
                  var responseXDR = stellar_base_1.xdr.TransactionResult.fromXDR(response2.data.result_xdr, "base64");
                  var results = responseXDR.result().value();
                  var offerResults;
                  var hasManageOffer;
                  if (results.length) {
                    offerResults = results.map(function(result, i2) {
                      if (result.value().switch().name !== "manageBuyOffer" && result.value().switch().name !== "manageSellOffer") {
                        return null;
                      }
                      hasManageOffer = true;
                      var amountBought = new bignumber_js_1.default(0);
                      var amountSold = new bignumber_js_1.default(0);
                      var offerSuccess = result.value().value().success();
                      var offersClaimed = offerSuccess.offersClaimed().map(function(offerClaimedAtom) {
                        var offerClaimed = offerClaimedAtom.value();
                        var sellerId = "";
                        switch (offerClaimedAtom.switch()) {
                          case stellar_base_1.xdr.ClaimAtomType.claimAtomTypeV0():
                            sellerId = stellar_base_1.StrKey.encodeEd25519PublicKey(offerClaimed.sellerEd25519());
                            break;
                          case stellar_base_1.xdr.ClaimAtomType.claimAtomTypeOrderBook():
                            sellerId = stellar_base_1.StrKey.encodeEd25519PublicKey(offerClaimed.sellerId().ed25519());
                            break;
                          default:
                            throw new Error("Invalid offer result type: " + offerClaimedAtom.switch());
                        }
                        var claimedOfferAmountBought = new bignumber_js_1.default(offerClaimed.amountBought().toString());
                        var claimedOfferAmountSold = new bignumber_js_1.default(offerClaimed.amountSold().toString());
                        amountBought = amountBought.add(claimedOfferAmountSold);
                        amountSold = amountSold.add(claimedOfferAmountBought);
                        var sold = stellar_base_1.Asset.fromOperation(offerClaimed.assetSold());
                        var bought = stellar_base_1.Asset.fromOperation(offerClaimed.assetBought());
                        var assetSold = {
                          type: sold.getAssetType(),
                          assetCode: sold.getCode(),
                          issuer: sold.getIssuer()
                        };
                        var assetBought = {
                          type: bought.getAssetType(),
                          assetCode: bought.getCode(),
                          issuer: bought.getIssuer()
                        };
                        return {
                          sellerId,
                          offerId: offerClaimed.offerId().toString(),
                          assetSold,
                          amountSold: _getAmountInLumens(claimedOfferAmountSold),
                          assetBought,
                          amountBought: _getAmountInLumens(claimedOfferAmountBought)
                        };
                      });
                      var effect = offerSuccess.offer().switch().name;
                      var currentOffer;
                      if (typeof offerSuccess.offer().value === "function" && offerSuccess.offer().value()) {
                        var offerXDR = offerSuccess.offer().value();
                        currentOffer = {
                          offerId: offerXDR.offerId().toString(),
                          selling: {},
                          buying: {},
                          amount: _getAmountInLumens(offerXDR.amount().toString()),
                          price: {
                            n: offerXDR.price().n(),
                            d: offerXDR.price().d()
                          }
                        };
                        var selling = stellar_base_1.Asset.fromOperation(offerXDR.selling());
                        currentOffer.selling = {
                          type: selling.getAssetType(),
                          assetCode: selling.getCode(),
                          issuer: selling.getIssuer()
                        };
                        var buying = stellar_base_1.Asset.fromOperation(offerXDR.buying());
                        currentOffer.buying = {
                          type: buying.getAssetType(),
                          assetCode: buying.getCode(),
                          issuer: buying.getIssuer()
                        };
                      }
                      return {
                        offersClaimed,
                        effect,
                        operationIndex: i2,
                        currentOffer,
                        amountBought: _getAmountInLumens(amountBought),
                        amountSold: _getAmountInLumens(amountSold),
                        isFullyOpen: !offersClaimed.length && effect !== "manageOfferDeleted",
                        wasPartiallyFilled: !!offersClaimed.length && effect !== "manageOfferDeleted",
                        wasImmediatelyFilled: !!offersClaimed.length && effect === "manageOfferDeleted",
                        wasImmediatelyDeleted: !offersClaimed.length && effect === "manageOfferDeleted"
                      };
                    }).filter(function(result) {
                      return !!result;
                    });
                  }
                  return Object.assign({}, response2.data, {
                    offerResults: hasManageOffer ? offerResults : void 0
                  });
                }).catch(function(response2) {
                  if (response2 instanceof Error) {
                    return Promise.reject(response2);
                  }
                  return Promise.reject(new errors_1.BadResponseError("Transaction submission failed. Server responded: " + response2.status + " " + response2.statusText, response2.data));
                })];
            }
          });
        });
      };
      Server2.prototype.accounts = function() {
        return new account_call_builder_1.AccountCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.claimableBalances = function() {
        return new claimable_balances_call_builder_1.ClaimableBalanceCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.ledgers = function() {
        return new ledger_call_builder_1.LedgerCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.transactions = function() {
        return new transaction_call_builder_1.TransactionCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.offers = function() {
        return new offer_call_builder_1.OfferCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.orderbook = function(selling, buying) {
        return new orderbook_call_builder_1.OrderbookCallBuilder(urijs_1.default(this.serverURL), selling, buying);
      };
      Server2.prototype.trades = function() {
        return new trades_call_builder_1.TradesCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.operations = function() {
        return new operation_call_builder_1.OperationCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.liquidityPools = function() {
        return new liquidity_pool_call_builder_1.LiquidityPoolCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.strictReceivePaths = function(source, destinationAsset, destinationAmount) {
        return new strict_receive_path_call_builder_1.StrictReceivePathCallBuilder(urijs_1.default(this.serverURL), source, destinationAsset, destinationAmount);
      };
      Server2.prototype.strictSendPaths = function(sourceAsset, sourceAmount, destination) {
        return new strict_send_path_call_builder_1.StrictSendPathCallBuilder(urijs_1.default(this.serverURL), sourceAsset, sourceAmount, destination);
      };
      Server2.prototype.payments = function() {
        return new payment_call_builder_1.PaymentCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.effects = function() {
        return new effect_call_builder_1.EffectCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.friendbot = function(address) {
        return new friendbot_builder_1.FriendbotBuilder(urijs_1.default(this.serverURL), address);
      };
      Server2.prototype.assets = function() {
        return new assets_call_builder_1.AssetsCallBuilder(urijs_1.default(this.serverURL));
      };
      Server2.prototype.loadAccount = function(accountId) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var res;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.accounts().accountId(accountId).call()];
              case 1:
                res = _a.sent();
                return [2, new account_response_1.AccountResponse(res)];
            }
          });
        });
      };
      Server2.prototype.tradeAggregation = function(base2, counter, start_time, end_time, resolution, offset) {
        return new trade_aggregation_call_builder_1.TradeAggregationCallBuilder(urijs_1.default(this.serverURL), base2, counter, start_time, end_time, resolution, offset);
      };
      Server2.prototype.checkMemoRequired = function(transaction2) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var destinations, i2, operation2, destination, account2, e_1;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (transaction2 instanceof stellar_base_1.FeeBumpTransaction) {
                  transaction2 = transaction2.innerTransaction;
                }
                if (transaction2.memo.type !== "none") {
                  return [2];
                }
                destinations = /* @__PURE__ */ new Set();
                i2 = 0;
                _a.label = 1;
              case 1:
                if (!(i2 < transaction2.operations.length)) return [3, 6];
                operation2 = transaction2.operations[i2];
                switch (operation2.type) {
                  case "payment":
                  case "pathPaymentStrictReceive":
                  case "pathPaymentStrictSend":
                  case "accountMerge":
                    break;
                  default:
                    return [3, 5];
                }
                destination = operation2.destination;
                if (destinations.has(destination)) {
                  return [3, 5];
                }
                destinations.add(destination);
                if (destination.startsWith("M")) {
                  return [3, 5];
                }
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.loadAccount(destination)];
              case 3:
                account2 = _a.sent();
                if (account2.data_attr["config.memo_required"] === ACCOUNT_REQUIRES_MEMO) {
                  throw new errors_1.AccountRequiresMemoError("account requires memo", destination, i2);
                }
                return [3, 5];
              case 4:
                e_1 = _a.sent();
                if (e_1 instanceof errors_1.AccountRequiresMemoError) {
                  throw e_1;
                }
                if (!(e_1 instanceof errors_1.NotFoundError)) {
                  throw e_1;
                }
                return [3, 5];
              case 5:
                i2++;
                return [3, 1];
              case 6:
                return [2];
            }
          });
        });
      };
      return Server2;
    }();
    exports2.Server = Server;
  })(server);
  return server;
}
var federation_server = {};
var stellar_toml_resolver = {};
var parser;
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  parser = function() {
    function peg$subclass(child, parent2) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent2.prototype;
      child.prototype = new ctor();
    }
    function SyntaxError2(message, expected, found, offset, line, column) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line;
      this.column = column;
      this.name = "SyntaxError";
    }
    peg$subclass(SyntaxError2, Error);
    function parse2(input) {
      var options2 = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c1 = function() {
        return nodes;
      }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
        addNode(node2("ObjectPath", name, line, column));
      }, peg$c12 = function(name) {
        addNode(node2("ArrayPath", name, line, column));
      }, peg$c13 = function(parts, name) {
        return parts.concat(name);
      }, peg$c14 = function(name) {
        return [name];
      }, peg$c15 = function(name) {
        return name;
      }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key2, value) {
        addNode(node2("Assign", value, line, column, key2));
      }, peg$c21 = function(chars) {
        return chars.join("");
      }, peg$c22 = function(node3) {
        return node3.value;
      }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
        return node2("String", chars.join(""), line, column);
      }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
        return char;
      }, peg$c34 = function(char) {
        return char;
      }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
        return "";
      }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left, right) {
        return node2("Float", parseFloat(left + "e" + right), line, column);
      }, peg$c43 = function(text) {
        return node2("Float", parseFloat(text), line, column);
      }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
        return digits.join("");
      }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
        return "-" + digits.join("");
      }, peg$c50 = function(text) {
        return node2("Integer", parseInt(text, 10), line, column);
      }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
        return node2("Boolean", true, line, column);
      }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
        return node2("Boolean", false, line, column);
      }, peg$c57 = function() {
        return node2("Array", [], line, column);
      }, peg$c58 = function(value) {
        return node2("Array", value ? [value] : [], line, column);
      }, peg$c59 = function(values2) {
        return node2("Array", values2, line, column);
      }, peg$c60 = function(values2, value) {
        return node2("Array", values2.concat(value), line, column);
      }, peg$c61 = function(value) {
        return value;
      }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values2) {
        return node2("InlineTable", values2, line, column);
      }, peg$c69 = function(key2, value) {
        return node2("InlineTableValue", value, line, column, key2);
      }, peg$c70 = function(digits) {
        return "." + digits;
      }, peg$c71 = function(date) {
        return date.join("");
      }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time) {
        return time.join("");
      }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date, time) {
        return node2("Date", /* @__PURE__ */ new Date(date + "T" + time + "Z"), line, column);
      }, peg$c80 = function(date, time) {
        return node2("Date", /* @__PURE__ */ new Date(date + "T" + time), line, column);
      }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
        return "";
      }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
        return d.join("");
      }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
        return '"';
      }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
        return "\\";
      }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
        return "\b";
      }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
        return "	";
      }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
        return "\n";
      }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
        return "\f";
      }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
        return "\r";
      }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
        return convertCodePoint(digits.join(""));
      }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
      if ("startRule" in options2) {
        if (!(options2.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
      }
      function line() {
        return peg$computePosDetails(peg$reportedPos).line;
      }
      function column() {
        return peg$computePosDetails(peg$reportedPos).column;
      }
      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p, ch;
          for (p = startPos; p < endPos; p++) {
            ch = input.charAt(p);
            if (ch === "\n") {
              if (!details.seenCR) {
                details.line++;
              }
              details.column = 1;
              details.seenCR = false;
            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
              details.line++;
              details.column = 1;
              details.seenCR = true;
            } else {
              details.column++;
              details.seenCR = false;
            }
          }
        }
        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0;
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advance(peg$cachedPosDetails, peg$cachedPos, pos);
          peg$cachedPos = pos;
        }
        return peg$cachedPosDetails;
      }
      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
      }
      function peg$buildException(message, expected, pos) {
        function cleanupExpected(expected2) {
          var i2 = 1;
          expected2.sort(function(a, b) {
            if (a.description < b.description) {
              return -1;
            } else if (a.description > b.description) {
              return 1;
            } else {
              return 0;
            }
          });
          while (i2 < expected2.length) {
            if (expected2[i2 - 1] === expected2[i2]) {
              expected2.splice(i2, 1);
            } else {
              i2++;
            }
          }
        }
        function buildMessage(expected2, found2) {
          function stringEscape(s) {
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
              return "\\x" + hex(ch);
            }).replace(/[\u0180-\u0FFF]/g, function(ch) {
              return "\\u0" + hex(ch);
            }).replace(/[\u1080-\uFFFF]/g, function(ch) {
              return "\\u" + hex(ch);
            });
          }
          var expectedDescs = new Array(expected2.length), expectedDesc, foundDesc, i2;
          for (i2 = 0; i2 < expected2.length; i2++) {
            expectedDescs[i2] = expected2[i2].description;
          }
          expectedDesc = expected2.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected2.length - 1] : expectedDescs[0];
          foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
          return "Expected " + expectedDesc + " but " + foundDesc + " found.";
        }
        var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
        if (expected !== null) {
          cleanupExpected(expected);
        }
        return new SyntaxError2(
          buildMessage(expected, found),
          expected,
          found,
          pos,
          posDetails.line,
          posDetails.column
        );
      }
      function peg$parsestart() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 0, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseline();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseline();
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c1();
        }
        s0 = s1;
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseline() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key2 = peg$currPos * 49 + 1, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpression();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parsecomment();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parsecomment();
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseNL();
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseNL();
                  }
                } else {
                  s5 = peg$c2;
                }
                if (s5 === peg$FAILED) {
                  s5 = peg$parseEOF();
                }
                if (s5 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4, s5];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseNL();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseNL();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseEOF();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseexpression() {
        var s0;
        var key2 = peg$currPos * 49 + 2, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parsecomment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsepath();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetablearray();
            if (s0 === peg$FAILED) {
              s0 = peg$parseassignment();
            }
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s2, s3, s4, s5;
        var key2 = peg$currPos * 49 + 3, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseNL();
          if (s5 === peg$FAILED) {
            s5 = peg$parseEOF();
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c5;
          } else {
            peg$currPos = s4;
            s4 = peg$c2;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseNL();
            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c5;
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsepath() {
        var s0, s1, s2, s3, s4, s5;
        var key2 = peg$currPos * 49 + 4, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetable_key();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s5 = peg$c9;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c11(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetablearray() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key2 = peg$currPos * 49 + 5, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c7;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsetable_key();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s6 = peg$c9;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s7 = peg$c9;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c12(s4);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetable_key() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 6, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedot_ended_table_key_part();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsedot_ended_table_key_part();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsetable_key_part();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsetable_key_part();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetable_key_part() {
        var s0, s1, s2, s3, s4;
        var key2 = peg$currPos * 49 + 7, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c15(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedot_ended_table_key_part() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key2 = peg$currPos * 49 + 8, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseassignment() {
        var s0, s1, s2, s3, s4, s5;
        var key2 = peg$currPos * 49 + 9, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsekey();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c18;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsevalue();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c20(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsequoted_key();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsevalue();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsekey() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 10, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseASCII_BASIC();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseASCII_BASIC();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c21(s1);
        }
        s0 = s1;
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsequoted_key() {
        var s0, s1;
        var key2 = peg$currPos * 49 + 11, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedouble_quoted_single_line_string();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c22(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsesingle_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsevalue() {
        var s0;
        var key2 = peg$currPos * 49 + 12, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedatetime();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefloat();
            if (s0 === peg$FAILED) {
              s0 = peg$parseinteger();
              if (s0 === peg$FAILED) {
                s0 = peg$parseboolean();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsearray();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseinline_table();
                  }
                }
              }
            }
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsestring() {
        var s0;
        var key2 = peg$currPos * 49 + 13, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parsedouble_quoted_multiline_string();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_quoted_single_line_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsesingle_quoted_multiline_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_single_line_string();
            }
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedouble_quoted_multiline_string() {
        var s0, s1, s2, s3, s4;
        var key2 = peg$currPos * 49 + 14, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsemultiline_string_char();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsemultiline_string_char();
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s4 = peg$c23;
                peg$currPos += 3;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedouble_quoted_single_line_string() {
        var s0, s1, s2, s3;
        var key2 = peg$currPos * 49 + 15, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsestring_char();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsestring_char();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c27;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesingle_quoted_multiline_string() {
        var s0, s1, s2, s3, s4;
        var key2 = peg$currPos * 49 + 16, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c29) {
          s1 = peg$c29;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsemultiline_literal_char();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsemultiline_literal_char();
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c29) {
                s4 = peg$c29;
                peg$currPos += 3;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c30);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesingle_quoted_single_line_string() {
        var s0, s1, s2, s3;
        var key2 = peg$currPos * 49 + 17, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseliteral_char();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseliteral_char();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c31;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsestring_char() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 18, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parseESCAPED();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c27;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseliteral_char() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 19, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 39) {
          s2 = peg$c31;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_string_char() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 20, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parseESCAPED();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemultiline_string_delim();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 3) === peg$c23) {
              s2 = peg$c23;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c34(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_string_delim() {
        var s0, s1, s2, s3, s4;
        var key2 = peg$currPos * 49 + 21, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseNLS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseNLS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c37();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_literal_char() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 22, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 3) === peg$c29) {
          s2 = peg$c29;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsefloat() {
        var s0, s1, s2, s3;
        var key2 = peg$currPos * 49 + 23, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsefloat_text();
        if (s1 === peg$FAILED) {
          s1 = peg$parseinteger_text();
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 101) {
            s2 = peg$c38;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c39);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 69) {
              s2 = peg$c40;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c41);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseinteger_text();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c42(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c43(s1);
          }
          s0 = s1;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsefloat_text() {
        var s0, s1, s2, s3, s4, s5;
        var key2 = peg$currPos * 49 + 24, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c25;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseDIGITS();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGITS();
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c46(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDIGITS();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGITS();
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c49(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinteger() {
        var s0, s1;
        var key2 = peg$currPos * 49 + 25, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseinteger_text();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c50(s1);
        }
        s0 = s1;
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinteger_text() {
        var s0, s1, s2, s3, s4;
        var key2 = peg$currPos * 49 + 26, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c25;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = peg$c5;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = peg$c5;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseboolean() {
        var s0, s1;
        var key2 = peg$currPos * 49 + 27, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c51) {
          s1 = peg$c51;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c53();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c54) {
            s1 = peg$c54;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c55);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c56();
          }
          s0 = s1;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray() {
        var s0, s1, s2, s3, s4;
        var key2 = peg$currPos * 49 + 28, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsearray_sep();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearray_sep();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c10);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c57();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsearray_value();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c58(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearray_value_list();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsearray_value_list();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c59(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsearray_value_list();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsearray_value_list();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsearray_value();
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s4 = peg$c9;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c60(s2, s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_value() {
        var s0, s1, s2, s3, s4;
        var key2 = peg$currPos * 49 + 29, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsearray_sep();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsearray_sep();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsearray_sep();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsearray_sep();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c61(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_value_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key2 = peg$currPos * 49 + 30, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsearray_sep();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsearray_sep();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsearray_sep();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsearray_sep();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c62;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c63);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsearray_sep();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsearray_sep();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_sep() {
        var s0;
        var key2 = peg$currPos * 49 + 31, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parseS();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecomment();
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinline_table() {
        var s0, s1, s2, s3, s4, s5;
        var key2 = peg$currPos * 49 + 32, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c64;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseinline_table_assignment();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseinline_table_assignment();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s5 = peg$c66;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c67);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c68(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinline_table_assignment() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key2 = peg$currPos * 49 + 33, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s4 = peg$c18;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsevalue();
                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parseS();
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parseS();
                    }
                    if (s7 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s8 = peg$c62;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c63);
                        }
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = [];
                        s10 = peg$parseS();
                        while (s10 !== peg$FAILED) {
                          s9.push(s10);
                          s10 = peg$parseS();
                        }
                        if (s9 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c69(s2, s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c18;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c69(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesecfragment() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 34, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseDIGITS();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c70(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedate() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        var key2 = peg$currPos * 49 + 35, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDIGIT_OR_UNDER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s6 = peg$c47;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c48);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseDIGIT_OR_UNDER();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 45) {
                        s9 = peg$c47;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c48);
                        }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseDIGIT_OR_UNDER();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseDIGIT_OR_UNDER();
                          if (s11 !== peg$FAILED) {
                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                            s1 = s2;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c71(s1);
        }
        s0 = s1;
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetime() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key2 = peg$currPos * 49 + 36, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment();
                        if (s10 === peg$FAILED) {
                          s10 = peg$c25;
                        }
                        if (s10 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetime_with_offset() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
        var key2 = peg$currPos * 49 + 37, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment();
                        if (s10 === peg$FAILED) {
                          s10 = peg$c25;
                        }
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 45) {
                            s11 = peg$c47;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c48);
                            }
                          }
                          if (s11 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 43) {
                              s11 = peg$c44;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c45);
                              }
                            }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseDIGIT_OR_UNDER();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseDIGIT_OR_UNDER();
                              if (s13 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 58) {
                                  s14 = peg$c72;
                                  peg$currPos++;
                                } else {
                                  s14 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c73);
                                  }
                                }
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parseDIGIT_OR_UNDER();
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parseDIGIT_OR_UNDER();
                                    if (s16 !== peg$FAILED) {
                                      s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                      s1 = s2;
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedatetime() {
        var s0, s1, s2, s3, s4;
        var key2 = peg$currPos * 49 + 38, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedate();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 84) {
            s2 = peg$c75;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetime();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 90) {
                s4 = peg$c77;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c79(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s2 = peg$c75;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetime_with_offset();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c80(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseS() {
        var s0;
        var key2 = peg$currPos * 49 + 39, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (peg$c81.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c82);
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseNL() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 40, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c83;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 13) {
            s1 = peg$c85;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s2 = peg$c83;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseNLS() {
        var s0;
        var key2 = peg$currPos * 49 + 41, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$parseNL();
        if (s0 === peg$FAILED) {
          s0 = peg$parseS();
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        var key2 = peg$currPos * 49 + 42, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = peg$c5;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseHEX() {
        var s0;
        var key2 = peg$currPos * 49 + 43, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (peg$c87.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseDIGIT_OR_UNDER() {
        var s0, s1;
        var key2 = peg$currPos * 49 + 44, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (peg$c89.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c90);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 95) {
            s1 = peg$c91;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c93();
          }
          s0 = s1;
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseASCII_BASIC() {
        var s0;
        var key2 = peg$currPos * 49 + 45, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        if (peg$c94.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c95);
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseDIGITS() {
        var s0, s1, s2;
        var key2 = peg$currPos * 49 + 46, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseDIGIT_OR_UNDER();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c96(s1);
        }
        s0 = s1;
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseESCAPED() {
        var s0, s1;
        var key2 = peg$currPos * 49 + 47, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c97) {
          s1 = peg$c97;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c99();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c100) {
            s1 = peg$c100;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c101);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c102();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c103) {
              s1 = peg$c103;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c104);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c105();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c106) {
                s1 = peg$c106;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c107);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c108();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c109) {
                  s1 = peg$c109;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c110);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c111();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c112) {
                    s1 = peg$c112;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c113);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c114();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c115) {
                      s1 = peg$c115;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c116);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c117();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseESCAPED_UNICODE();
                    }
                  }
                }
              }
            }
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseESCAPED_UNICODE() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key2 = peg$currPos * 49 + 48, cached = peg$cache[key2];
        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c118) {
          s1 = peg$c118;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseHEX();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseHEX();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseHEX();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseHEX();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseHEX();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseHEX();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseHEX();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseHEX();
                        if (s10 !== peg$FAILED) {
                          s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                          s2 = s3;
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c120(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s3 = [s3, s4, s5, s6];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key2] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      var nodes = [];
      function genError(err, line2, col) {
        var ex = new Error(err);
        ex.line = line2;
        ex.column = col;
        throw ex;
      }
      function addNode(node3) {
        nodes.push(node3);
      }
      function node2(type2, value, line2, column2, key2) {
        var obj = { type: type2, value, line: line2(), column: column2() };
        if (key2) obj.key = key2;
        return obj;
      }
      function convertCodePoint(str, line2, col) {
        var num = parseInt("0x" + str);
        if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
          genError("Invalid Unicode escape code: " + str, line2, col);
        } else {
          return fromCodePoint(num);
        }
      }
      function fromCodePoint() {
        var MAX_SIZE = 16384;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index2 = -1;
        var length = arguments.length;
        if (!length) {
          return "";
        }
        var result = "";
        while (++index2 < length) {
          var codePoint = Number(arguments[index2]);
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            highSurrogate = (codePoint >> 10) + 55296;
            lowSurrogate = codePoint % 1024 + 56320;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index2 + 1 == length || codeUnits.length > MAX_SIZE) {
            result += String.fromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({ type: "end", description: "end of input" });
        }
        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
      }
    }
    return {
      SyntaxError: SyntaxError2,
      parse: parse2
    };
  }();
  return parser;
}
var compiler;
var hasRequiredCompiler;
function requireCompiler() {
  if (hasRequiredCompiler) return compiler;
  hasRequiredCompiler = 1;
  function compile(nodes) {
    var assignedPaths = [];
    var valueAssignments = [];
    var currentPath = "";
    var data = {};
    var context2 = data;
    return reduce(nodes);
    function reduce(nodes2) {
      var node2;
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        node2 = nodes2[i2];
        switch (node2.type) {
          case "Assign":
            assign(node2);
            break;
          case "ObjectPath":
            setPath2(node2);
            break;
          case "ArrayPath":
            addTableArray(node2);
            break;
        }
      }
      return data;
    }
    function genError(err, line, col) {
      var ex = new Error(err);
      ex.line = line;
      ex.column = col;
      throw ex;
    }
    function assign(node2) {
      var key2 = node2.key;
      var value = node2.value;
      var line = node2.line;
      var column = node2.column;
      var fullPath;
      if (currentPath) {
        fullPath = currentPath + "." + key2;
      } else {
        fullPath = key2;
      }
      if (typeof context2[key2] !== "undefined") {
        genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
      }
      context2[key2] = reduceValueNode(value);
      if (!pathAssigned(fullPath)) {
        assignedPaths.push(fullPath);
        valueAssignments.push(fullPath);
      }
    }
    function pathAssigned(path2) {
      return assignedPaths.indexOf(path2) !== -1;
    }
    function reduceValueNode(node2) {
      if (node2.type === "Array") {
        return reduceArrayWithTypeChecking(node2.value);
      } else if (node2.type === "InlineTable") {
        return reduceInlineTableNode(node2.value);
      } else {
        return node2.value;
      }
    }
    function reduceInlineTableNode(values2) {
      var obj = {};
      for (var i2 = 0; i2 < values2.length; i2++) {
        var val = values2[i2];
        if (val.value.type === "InlineTable") {
          obj[val.key] = reduceInlineTableNode(val.value.value);
        } else if (val.type === "InlineTableValue") {
          obj[val.key] = reduceValueNode(val.value);
        }
      }
      return obj;
    }
    function setPath2(node2) {
      var path2 = node2.value;
      var quotedPath = path2.map(quoteDottedString).join(".");
      var line = node2.line;
      var column = node2.column;
      if (pathAssigned(quotedPath)) {
        genError("Cannot redefine existing key '" + path2 + "'.", line, column);
      }
      assignedPaths.push(quotedPath);
      context2 = deepRef(data, path2, {}, line, column);
      currentPath = path2;
    }
    function addTableArray(node2) {
      var path2 = node2.value;
      var quotedPath = path2.map(quoteDottedString).join(".");
      var line = node2.line;
      var column = node2.column;
      if (!pathAssigned(quotedPath)) {
        assignedPaths.push(quotedPath);
      }
      assignedPaths = assignedPaths.filter(function(p) {
        return p.indexOf(quotedPath) !== 0;
      });
      assignedPaths.push(quotedPath);
      context2 = deepRef(data, path2, [], line, column);
      currentPath = quotedPath;
      if (context2 instanceof Array) {
        var newObj = {};
        context2.push(newObj);
        context2 = newObj;
      } else {
        genError("Cannot redefine existing key '" + path2 + "'.", line, column);
      }
    }
    function deepRef(start, keys2, value, line, column) {
      var traversed = [];
      var traversedPath = "";
      keys2.join(".");
      var ctx = start;
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var key2 = keys2[i2];
        traversed.push(key2);
        traversedPath = traversed.join(".");
        if (typeof ctx[key2] === "undefined") {
          if (i2 === keys2.length - 1) {
            ctx[key2] = value;
          } else {
            ctx[key2] = {};
          }
        } else if (i2 !== keys2.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
          genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
        }
        ctx = ctx[key2];
        if (ctx instanceof Array && ctx.length && i2 < keys2.length - 1) {
          ctx = ctx[ctx.length - 1];
        }
      }
      return ctx;
    }
    function reduceArrayWithTypeChecking(array2) {
      var firstType = null;
      for (var i2 = 0; i2 < array2.length; i2++) {
        var node2 = array2[i2];
        if (firstType === null) {
          firstType = node2.type;
        } else {
          if (node2.type !== firstType) {
            genError("Cannot add value of type " + node2.type + " to array of type " + firstType + ".", node2.line, node2.column);
          }
        }
      }
      return array2.map(reduceValueNode);
    }
    function quoteDottedString(str) {
      if (str.indexOf(".") > -1) {
        return '"' + str + '"';
      } else {
        return str;
      }
    }
  }
  compiler = {
    compile
  };
  return compiler;
}
var toml;
var hasRequiredToml;
function requireToml() {
  if (hasRequiredToml) return toml;
  hasRequiredToml = 1;
  var parser2 = requireParser();
  var compiler2 = requireCompiler();
  toml = {
    parse: function(input) {
      var nodes = parser2.parse(input.toString());
      return compiler2.compile(nodes);
    }
  };
  return toml;
}
var hasRequiredStellar_toml_resolver;
function requireStellar_toml_resolver() {
  if (hasRequiredStellar_toml_resolver) return stellar_toml_resolver;
  hasRequiredStellar_toml_resolver = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StellarTomlResolver = exports2.STELLAR_TOML_MAX_SIZE = void 0;
    var tslib_1 = require$$0$4;
    var axios_1 = tslib_1.__importDefault(requireAxios());
    var toml_1 = tslib_1.__importDefault(requireToml());
    var config_1 = requireConfig();
    exports2.STELLAR_TOML_MAX_SIZE = 100 * 1024;
    var CancelToken = axios_1.default.CancelToken;
    var StellarTomlResolver = function() {
      function StellarTomlResolver2() {
      }
      StellarTomlResolver2.resolve = function(domain, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var allowHttp, timeout, protocol;
          return tslib_1.__generator(this, function(_a) {
            allowHttp = typeof opts.allowHttp === "undefined" ? config_1.Config.isAllowHttp() : opts.allowHttp;
            timeout = typeof opts.timeout === "undefined" ? config_1.Config.getTimeout() : opts.timeout;
            protocol = allowHttp ? "http" : "https";
            return [2, axios_1.default.get(protocol + "://" + domain + "/.well-known/stellar.toml", {
              maxContentLength: exports2.STELLAR_TOML_MAX_SIZE,
              cancelToken: timeout ? new CancelToken(function(cancel) {
                return setTimeout(function() {
                  return cancel("timeout of " + timeout + "ms exceeded");
                }, timeout);
              }) : void 0,
              timeout
            }).then(function(response2) {
              try {
                var tomlObject = toml_1.default.parse(response2.data);
                return Promise.resolve(tomlObject);
              } catch (e) {
                return Promise.reject(new Error("stellar.toml is invalid - Parsing error on line " + e.line + ", column " + e.column + ": " + e.message));
              }
            }).catch(function(err) {
              if (err.message.match(/^maxContentLength size/)) {
                throw new Error("stellar.toml file exceeds allowed size of " + exports2.STELLAR_TOML_MAX_SIZE);
              } else {
                throw err;
              }
            })];
          });
        });
      };
      return StellarTomlResolver2;
    }();
    exports2.StellarTomlResolver = StellarTomlResolver;
  })(stellar_toml_resolver);
  return stellar_toml_resolver;
}
var hasRequiredFederation_server;
function requireFederation_server() {
  if (hasRequiredFederation_server) return federation_server;
  hasRequiredFederation_server = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FederationServer = exports2.FEDERATION_RESPONSE_MAX_SIZE = void 0;
    var tslib_1 = require$$0$4;
    var axios_1 = tslib_1.__importDefault(requireAxios());
    var stellar_base_1 = requireLib$2();
    var urijs_1 = tslib_1.__importDefault(requireURI());
    var config_1 = requireConfig();
    var errors_1 = requireErrors();
    var stellar_toml_resolver_1 = requireStellar_toml_resolver();
    exports2.FEDERATION_RESPONSE_MAX_SIZE = 100 * 1024;
    var FederationServer = function() {
      function FederationServer2(serverURL, domain, opts) {
        if (opts === void 0) {
          opts = {};
        }
        this.serverURL = urijs_1.default(serverURL);
        this.domain = domain;
        var allowHttp = typeof opts.allowHttp === "undefined" ? config_1.Config.isAllowHttp() : opts.allowHttp;
        this.timeout = typeof opts.timeout === "undefined" ? config_1.Config.getTimeout() : opts.timeout;
        if (this.serverURL.protocol() !== "https" && !allowHttp) {
          throw new Error("Cannot connect to insecure federation server");
        }
      }
      FederationServer2.resolve = function(value, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var addressParts, domain, federationServer;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (value.indexOf("*") < 0) {
                  if (!stellar_base_1.StrKey.isValidEd25519PublicKey(value)) {
                    return [2, Promise.reject(new Error("Invalid Account ID"))];
                  }
                  return [2, Promise.resolve({ account_id: value })];
                }
                addressParts = value.split("*");
                domain = addressParts[1];
                if (addressParts.length !== 2 || !domain) {
                  return [2, Promise.reject(new Error("Invalid Stellar address"))];
                }
                return [4, FederationServer2.createForDomain(domain, opts)];
              case 1:
                federationServer = _a.sent();
                return [2, federationServer.resolveAddress(value)];
            }
          });
        });
      };
      FederationServer2.createForDomain = function(domain, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var tomlObject;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, stellar_toml_resolver_1.StellarTomlResolver.resolve(domain, opts)];
              case 1:
                tomlObject = _a.sent();
                if (!tomlObject.FEDERATION_SERVER) {
                  return [2, Promise.reject(new Error("stellar.toml does not contain FEDERATION_SERVER field"))];
                }
                return [2, new FederationServer2(tomlObject.FEDERATION_SERVER, domain, opts)];
            }
          });
        });
      };
      FederationServer2.prototype.resolveAddress = function(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var stellarAddress, url2;
          return tslib_1.__generator(this, function(_a) {
            stellarAddress = address;
            if (address.indexOf("*") < 0) {
              if (!this.domain) {
                return [2, Promise.reject(new Error("Unknown domain. Make sure `address` contains a domain (ex. `bob*stellar.org`) or pass `domain` parameter when instantiating the server object."))];
              }
              stellarAddress = address + "*" + this.domain;
            }
            url2 = this.serverURL.query({ type: "name", q: stellarAddress });
            return [2, this._sendRequest(url2)];
          });
        });
      };
      FederationServer2.prototype.resolveAccountId = function(accountId) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var url2;
          return tslib_1.__generator(this, function(_a) {
            url2 = this.serverURL.query({ type: "id", q: accountId });
            return [2, this._sendRequest(url2)];
          });
        });
      };
      FederationServer2.prototype.resolveTransactionId = function(transactionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var url2;
          return tslib_1.__generator(this, function(_a) {
            url2 = this.serverURL.query({ type: "txid", q: transactionId });
            return [2, this._sendRequest(url2)];
          });
        });
      };
      FederationServer2.prototype._sendRequest = function(url2) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var timeout;
          return tslib_1.__generator(this, function(_a) {
            timeout = this.timeout;
            return [2, axios_1.default.get(url2.toString(), {
              maxContentLength: exports2.FEDERATION_RESPONSE_MAX_SIZE,
              timeout
            }).then(function(response2) {
              if (typeof response2.data.memo !== "undefined" && typeof response2.data.memo !== "string") {
                throw new Error("memo value should be of type string");
              }
              return response2.data;
            }).catch(function(response2) {
              if (response2 instanceof Error) {
                if (response2.message.match(/^maxContentLength size/)) {
                  throw new Error("federation response exceeds allowed size of " + exports2.FEDERATION_RESPONSE_MAX_SIZE);
                } else {
                  return Promise.reject(response2);
                }
              } else {
                return Promise.reject(new errors_1.BadResponseError("Server query failed. Server responded: " + response2.status + " " + response2.statusText, response2.data));
              }
            })];
          });
        });
      };
      return FederationServer2;
    }();
    exports2.FederationServer = FederationServer;
  })(federation_server);
  return federation_server;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Utils = void 0;
    var tslib_1 = require$$0$4;
    var clone_12 = tslib_1.__importDefault(requireClone());
    var randombytes_1 = tslib_1.__importDefault(requireBrowser$d());
    var stellar_base_1 = requireLib$2();
    var errors_1 = requireErrors();
    (function(Utils) {
      function buildChallengeTx(serverKeypair, clientAccountID, homeDomain, timeout, networkPassphrase, webAuthDomain, memo2, clientDomain, clientSigningKey) {
        if (timeout === void 0) {
          timeout = 300;
        }
        if (memo2 === void 0) {
          memo2 = null;
        }
        if (clientDomain === void 0) {
          clientDomain = null;
        }
        if (clientSigningKey === void 0) {
          clientSigningKey = null;
        }
        if (clientAccountID.startsWith("M") && memo2) {
          throw Error("memo cannot be used if clientAccountID is a muxed account");
        }
        var account2 = new stellar_base_1.Account(serverKeypair.publicKey(), "-1");
        var now2 = Math.floor(Date.now() / 1e3);
        var value = randombytes_1.default(48).toString("base64");
        var builder = new stellar_base_1.TransactionBuilder(account2, {
          fee: stellar_base_1.BASE_FEE,
          networkPassphrase,
          timebounds: {
            minTime: now2,
            maxTime: now2 + timeout
          }
        }).addOperation(stellar_base_1.Operation.manageData({
          name: homeDomain + " auth",
          value,
          source: clientAccountID,
          withMuxing: true
        })).addOperation(stellar_base_1.Operation.manageData({
          name: "web_auth_domain",
          value: webAuthDomain,
          source: account2.accountId()
        }));
        if (clientDomain) {
          if (!clientSigningKey) {
            throw Error("clientSigningKey is required if clientDomain is provided");
          }
          builder.addOperation(stellar_base_1.Operation.manageData({
            name: "client_domain",
            value: clientDomain,
            source: clientSigningKey
          }));
        }
        if (memo2) {
          builder.addMemo(stellar_base_1.Memo.id(memo2));
        }
        var transaction2 = builder.build();
        transaction2.sign(serverKeypair);
        return transaction2.toEnvelope().toXDR("base64").toString();
      }
      Utils.buildChallengeTx = buildChallengeTx;
      function readChallengeTx(challengeTx, serverAccountID, networkPassphrase, homeDomains, webAuthDomain) {
        var _a;
        if (serverAccountID.startsWith("M")) {
          throw Error("Invalid serverAccountID: multiplexed accounts are not supported.");
        }
        var transaction2;
        try {
          transaction2 = new stellar_base_1.Transaction(challengeTx, networkPassphrase, true);
        } catch (_b) {
          try {
            transaction2 = new stellar_base_1.FeeBumpTransaction(challengeTx, networkPassphrase, true);
          } catch (_c) {
            throw new errors_1.InvalidSep10ChallengeError("Invalid challenge: unable to deserialize challengeTx transaction string");
          }
          throw new errors_1.InvalidSep10ChallengeError("Invalid challenge: expected a Transaction but received a FeeBumpTransaction");
        }
        var sequence = Number.parseInt(transaction2.sequence, 10);
        if (sequence !== 0) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction sequence number should be zero");
        }
        if (transaction2.source !== serverAccountID) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction source account is not equal to the server's account");
        }
        if (transaction2.operations.length < 1) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction should contain at least one operation");
        }
        var _d = transaction2.operations, operation2 = _d[0], subsequentOperations = _d.slice(1);
        if (!operation2.source) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction's operation should contain a source account");
        }
        var clientAccountID = operation2.source;
        var memo2 = null;
        if (transaction2.memo.type !== stellar_base_1.MemoNone) {
          if (clientAccountID.startsWith("M")) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction has a memo but the client account ID is a muxed account");
          }
          if (transaction2.memo.type !== stellar_base_1.MemoID) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction's memo must be of type `id`");
          }
          memo2 = transaction2.memo.value;
        }
        if (operation2.type !== "manageData") {
          throw new errors_1.InvalidSep10ChallengeError("The transaction's operation type should be 'manageData'");
        }
        if (transaction2.timeBounds && Number.parseInt((_a = transaction2.timeBounds) === null || _a === void 0 ? void 0 : _a.maxTime, 10) === stellar_base_1.TimeoutInfinite) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction requires non-infinite timebounds");
        }
        if (!validateTimebounds(transaction2, 60 * 5)) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction has expired");
        }
        if (operation2.value === void 0) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction's operation values should not be null");
        }
        if (!operation2.value) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction's operation value should not be null");
        }
        if (Buffer.from(operation2.value.toString(), "base64").length !== 48) {
          throw new errors_1.InvalidSep10ChallengeError("The transaction's operation value should be a 64 bytes base64 random string");
        }
        if (!homeDomains) {
          throw new errors_1.InvalidSep10ChallengeError("Invalid homeDomains: a home domain must be provided for verification");
        }
        var matchedHomeDomain;
        if (typeof homeDomains === "string") {
          if (homeDomains + " auth" === operation2.name) {
            matchedHomeDomain = homeDomains;
          }
        } else if (Array.isArray(homeDomains)) {
          matchedHomeDomain = homeDomains.find(function(domain) {
            return domain + " auth" === operation2.name;
          });
        } else {
          throw new errors_1.InvalidSep10ChallengeError("Invalid homeDomains: homeDomains type is " + typeof homeDomains + " but should be a string or an array");
        }
        if (!matchedHomeDomain) {
          throw new errors_1.InvalidSep10ChallengeError("Invalid homeDomains: the transaction's operation key name does not match the expected home domain");
        }
        for (var _i = 0, subsequentOperations_1 = subsequentOperations; _i < subsequentOperations_1.length; _i++) {
          var op = subsequentOperations_1[_i];
          if (op.type !== "manageData") {
            throw new errors_1.InvalidSep10ChallengeError("The transaction has operations that are not of type 'manageData'");
          }
          if (op.source !== serverAccountID && op.name !== "client_domain") {
            throw new errors_1.InvalidSep10ChallengeError("The transaction has operations that are unrecognized");
          }
          if (op.name === "web_auth_domain") {
            if (op.value === void 0) {
              throw new errors_1.InvalidSep10ChallengeError("'web_auth_domain' operation value should not be null");
            }
            if (op.value.compare(Buffer.from(webAuthDomain))) {
              throw new errors_1.InvalidSep10ChallengeError("'web_auth_domain' operation value does not match " + webAuthDomain);
            }
          }
        }
        if (!verifyTxSignedBy(transaction2, serverAccountID)) {
          throw new errors_1.InvalidSep10ChallengeError("Transaction not signed by server: '" + serverAccountID + "'");
        }
        return { tx: transaction2, clientAccountID, matchedHomeDomain, memo: memo2 };
      }
      Utils.readChallengeTx = readChallengeTx;
      function verifyChallengeTxThreshold(challengeTx, serverAccountID, networkPassphrase, threshold, signerSummary, homeDomains, webAuthDomain) {
        var _a;
        var signers = signerSummary.map(function(signer2) {
          return signer2.key;
        });
        var signersFound = verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers, homeDomains, webAuthDomain);
        var weight = 0;
        var _loop_1 = function(signer2) {
          var sigWeight = ((_a = signerSummary.find(function(s) {
            return s.key === signer2;
          })) === null || _a === void 0 ? void 0 : _a.weight) || 0;
          weight += sigWeight;
        };
        for (var _i = 0, signersFound_1 = signersFound; _i < signersFound_1.length; _i++) {
          var signer = signersFound_1[_i];
          _loop_1(signer);
        }
        if (weight < threshold) {
          throw new errors_1.InvalidSep10ChallengeError("signers with weight " + weight + " do not meet threshold " + threshold + '"');
        }
        return signersFound;
      }
      Utils.verifyChallengeTxThreshold = verifyChallengeTxThreshold;
      function verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers, homeDomains, webAuthDomain) {
        var tx = readChallengeTx(challengeTx, serverAccountID, networkPassphrase, homeDomains, webAuthDomain).tx;
        var serverKP;
        try {
          serverKP = stellar_base_1.Keypair.fromPublicKey(serverAccountID);
        } catch (err) {
          throw new Error("Couldn't infer keypair from the provided 'serverAccountID': " + err.message);
        }
        var clientSigners = /* @__PURE__ */ new Set();
        for (var _i = 0, signers_1 = signers; _i < signers_1.length; _i++) {
          var signer = signers_1[_i];
          if (signer === serverKP.publicKey()) {
            continue;
          }
          if (signer.charAt(0) !== "G") {
            continue;
          }
          clientSigners.add(signer);
        }
        if (clientSigners.size === 0) {
          throw new errors_1.InvalidSep10ChallengeError("No verifiable client signers provided, at least one G... address must be provided");
        }
        var clientSigningKey;
        for (var _a = 0, _b = tx.operations; _a < _b.length; _a++) {
          var op = _b[_a];
          if (op.type === "manageData" && op.name === "client_domain") {
            if (clientSigningKey) {
              throw new errors_1.InvalidSep10ChallengeError("Found more than one client_domain operation");
            }
            clientSigningKey = op.source;
          }
        }
        var allSigners = tslib_1.__spreadArrays([
          serverKP.publicKey()
        ], Array.from(clientSigners));
        if (clientSigningKey) {
          allSigners.push(clientSigningKey);
        }
        var signersFound = gatherTxSigners(tx, allSigners);
        var serverSignatureFound = false;
        var clientSigningKeySignatureFound = false;
        for (var _c = 0, signersFound_2 = signersFound; _c < signersFound_2.length; _c++) {
          var signer = signersFound_2[_c];
          if (signer === serverKP.publicKey()) {
            serverSignatureFound = true;
          }
          if (signer === clientSigningKey) {
            clientSigningKeySignatureFound = true;
          }
        }
        if (!serverSignatureFound) {
          throw new errors_1.InvalidSep10ChallengeError("Transaction not signed by server: '" + serverKP.publicKey() + "'");
        }
        if (clientSigningKey && !clientSigningKeySignatureFound) {
          throw new errors_1.InvalidSep10ChallengeError("Transaction not signed by the source account of the 'client_domain' ManageData operation");
        }
        if (signersFound.length === 1) {
          throw new errors_1.InvalidSep10ChallengeError("None of the given signers match the transaction signatures");
        }
        if (signersFound.length !== tx.signatures.length) {
          throw new errors_1.InvalidSep10ChallengeError("Transaction has unrecognized signatures");
        }
        signersFound.splice(signersFound.indexOf(serverKP.publicKey()), 1);
        if (clientSigningKey) {
          signersFound.splice(signersFound.indexOf(clientSigningKey), 1);
        }
        return signersFound;
      }
      Utils.verifyChallengeTxSigners = verifyChallengeTxSigners;
      function verifyTxSignedBy(transaction2, accountID) {
        return gatherTxSigners(transaction2, [accountID]).length !== 0;
      }
      Utils.verifyTxSignedBy = verifyTxSignedBy;
      function gatherTxSigners(transaction2, signers) {
        var hashedSignatureBase = transaction2.hash();
        var txSignatures = clone_12.default(transaction2.signatures);
        var signersFound = /* @__PURE__ */ new Set();
        for (var _i = 0, signers_2 = signers; _i < signers_2.length; _i++) {
          var signer = signers_2[_i];
          if (txSignatures.length === 0) {
            break;
          }
          var keypair2 = void 0;
          try {
            keypair2 = stellar_base_1.Keypair.fromPublicKey(signer);
          } catch (err) {
            throw new errors_1.InvalidSep10ChallengeError("Signer is not a valid address: " + err.message);
          }
          for (var i2 = 0; i2 < txSignatures.length; i2++) {
            var decSig = txSignatures[i2];
            if (!decSig.hint().equals(keypair2.signatureHint())) {
              continue;
            }
            if (keypair2.verify(hashedSignatureBase, decSig.signature())) {
              signersFound.add(signer);
              txSignatures.splice(i2, 1);
              break;
            }
          }
        }
        return Array.from(signersFound);
      }
      Utils.gatherTxSigners = gatherTxSigners;
      function validateTimebounds(transaction2, gracePeriod) {
        if (!transaction2.timeBounds) {
          return false;
        }
        var now2 = Math.floor(Date.now() / 1e3);
        var _a = transaction2.timeBounds, minTime = _a.minTime, maxTime = _a.maxTime;
        return now2 >= Number.parseInt(minTime, 10) - gracePeriod && now2 <= Number.parseInt(maxTime, 10) + gracePeriod;
      }
    })(exports2.Utils || (exports2.Utils = {}));
  })(utils);
  return utils;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$3.exports;
  hasRequiredLib = 1;
  (function(module, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = void 0;
    var tslib_1 = require$$0$4;
    requireEs6Promise().polyfill();
    var version2 = require$$2$2.version;
    exports2.version = version2;
    tslib_1.__exportStar(requireHorizon_api(), exports2);
    tslib_1.__exportStar(requireServer_api(), exports2);
    tslib_1.__exportStar(requireAccount_response(), exports2);
    tslib_1.__exportStar(requireErrors(), exports2);
    var config_1 = requireConfig();
    Object.defineProperty(exports2, "Config", { enumerable: true, get: function() {
      return config_1.Config;
    } });
    var server_1 = requireServer();
    Object.defineProperty(exports2, "Server", { enumerable: true, get: function() {
      return server_1.Server;
    } });
    var federation_server_1 = requireFederation_server();
    Object.defineProperty(exports2, "FederationServer", { enumerable: true, get: function() {
      return federation_server_1.FederationServer;
    } });
    Object.defineProperty(exports2, "FEDERATION_RESPONSE_MAX_SIZE", { enumerable: true, get: function() {
      return federation_server_1.FEDERATION_RESPONSE_MAX_SIZE;
    } });
    var stellar_toml_resolver_1 = requireStellar_toml_resolver();
    Object.defineProperty(exports2, "StellarTomlResolver", { enumerable: true, get: function() {
      return stellar_toml_resolver_1.StellarTomlResolver;
    } });
    Object.defineProperty(exports2, "STELLAR_TOML_MAX_SIZE", { enumerable: true, get: function() {
      return stellar_toml_resolver_1.STELLAR_TOML_MAX_SIZE;
    } });
    var horizon_axios_client_1 = requireHorizon_axios_client();
    Object.defineProperty(exports2, "HorizonAxiosClient", { enumerable: true, get: function() {
      return horizon_axios_client_1.default;
    } });
    Object.defineProperty(exports2, "SERVER_TIME_MAP", { enumerable: true, get: function() {
      return horizon_axios_client_1.SERVER_TIME_MAP;
    } });
    Object.defineProperty(exports2, "getCurrentServerTime", { enumerable: true, get: function() {
      return horizon_axios_client_1.getCurrentServerTime;
    } });
    tslib_1.__exportStar(requireUtils(), exports2);
    tslib_1.__exportStar(requireLib$2(), exports2);
    exports2.default = module.exports;
  })(lib$3, lib$3.exports);
  return lib$3.exports;
}
var libExports = requireLib();
function getImplementation$1() {
  if (window.electron) {
    const impl = __vitePreload(() => import("./electron-6MdhFNr2.js"), true ? [] : void 0);
    return impl;
  } else if (typeof window !== "undefined") {
    const impl = __vitePreload(() => import("./web-OrCDcvNT.js"), true ? [] : void 0);
    return impl;
  } else {
    throw new Error("There is no IPC implementation for your platform.");
  }
}
const implementation$1 = getImplementation$1();
function call(messageType, ...args) {
  return implementation$1.then((i2) => i2.call(messageType, ...args));
}
function subscribeToMessages(messageType, callback) {
  return implementation$1.then((i2) => i2.subscribeToMessages(messageType, callback));
}
const keyStore = {
  getKeyIDs: () => call(Messages.GetKeyIDs),
  getPublicKeyData: (keyID) => call(Messages.GetPublicKeyData, keyID),
  getPrivateKeyData: (keyID, password) => call(Messages.GetPrivateKeyData, keyID, password),
  signTransaction: async (accountID, transaction2, password) => {
    const txXDR = transaction2.toEnvelope().toXDR("base64");
    const signedXDR = await call(Messages.SignTransaction, accountID, txXDR, password);
    return new libExports.Transaction(signedXDR, transaction2.networkPassphrase);
  },
  saveKey: (keyID, password, privateData, publicData) => call(Messages.SaveKey, keyID, password, privateData, publicData),
  savePublicKeyData: (keyID, publicData) => call(Messages.SavePublicKeyData, keyID, publicData),
  removeKey: (keyID) => call(Messages.RemoveKey, keyID)
};
function getKeyStore() {
  return keyStore;
}
let trackErrorImplementation = console.error;
function trackError(error3) {
  trackErrorImplementation(error3);
}
const NotificationsContext = React.createContext({
  notifications: [],
  showConnectionError: () => void 0,
  showError: () => void 0,
  showNotification: () => void 0
});
function NotificationsProvider(props) {
  const nextIDRef = React.useRef(1);
  const [notifications, setNotifications] = React.useState([]);
  const { t: t2 } = useTranslation();
  const showNotification = (type2, message, options2 = {}) => {
    const id = nextIDRef.current++;
    setNotifications((prevNotifications) => prevNotifications.concat({ ...options2, id, message, type: type2 }));
  };
  const showConnectionError = (error3) => {
    showNotification("connection", String(error3.message || error3));
    console.error(error3);
  };
  const showError = (error3) => {
    if (error3) {
      showNotification("error", getErrorTranslation(error3, t2));
      console.error(error3);
    }
  };
  trackErrorImplementation = showError;
  const contextValue = {
    showConnectionError,
    showError,
    showNotification,
    notifications
  };
  return /* @__PURE__ */ React.createElement(NotificationsContext.Provider, { value: contextValue }, props.children);
}
async function createAccountInstance(keyStore2, keyID) {
  const publicData = await keyStore2.getPublicKeyData(keyID);
  const account2 = {
    cosignerOf: publicData.cosignerOf,
    id: keyID,
    name: publicData.name,
    publicKey: publicData.publicKey,
    requiresPassword: publicData.password,
    testnet: publicData.testnet,
    get accountID() {
      return account2.cosignerOf || account2.publicKey;
    },
    async getPrivateKey(password) {
      const requiresPassword = publicData.password;
      if (password === null && requiresPassword) {
        throw CustomError(
          "PasswordRequiredError",
          `Account ${publicData.name} is password-protected, but no password was passed.`,
          { accountName: publicData.name }
        );
      }
      try {
        const privateData = await keyStore2.getPrivateKeyData(keyID, password || "");
        return privateData.privateKey;
      } catch (error3) {
        console.debug("Decrypting private key data failed. Assuming wrong password:", error3);
        throw WrongPasswordError();
      }
    },
    async signTransaction(transaction2, password) {
      const requiresPassword = publicData.password;
      if (password === null && requiresPassword) {
        throw CustomError(
          "PasswordRequiredError",
          `Account ${publicData.name} is password-protected, but no password was passed.`,
          { accountName: publicData.name }
        );
      }
      return keyStore2.signTransaction(account2.id, transaction2, password || "");
    }
  };
  return account2;
}
async function createAccountInKeyStore(accounts, accountData) {
  if (accounts.some((someAccount) => someAccount.name.toLowerCase() === accountData.name.toLowerCase())) {
    throw CustomError("ExistingAccountError", "An account with that name does already exist.");
  }
  const id = accountData.id || createNextID(accounts);
  const keyStore2 = await getKeyStore();
  await keyStore2.saveKey(
    id,
    accountData.password || "",
    { privateKey: accountData.keypair.secret() },
    {
      cosignerOf: accountData.cosignerOf,
      name: accountData.name,
      password: accountData.password !== null,
      publicKey: accountData.keypair.publicKey(),
      testnet: accountData.testnet
    }
  );
  return createAccountInstance(keyStore2, id);
}
function createNextID(accounts) {
  const highestID = accounts.reduce(
    (highestIdSoFar, someAccount) => parseInt(someAccount.id, 10) > highestIdSoFar ? parseInt(someAccount.id, 10) : highestIdSoFar,
    0
  );
  return String(highestID + 1);
}
function getInitialNetwork(accounts) {
  const testnetAccounts = accounts.filter((account2) => account2.testnet);
  return testnetAccounts.length > 0 && testnetAccounts.length === accounts.length ? "testnet" : "mainnet";
}
const initialAccounts = [];
const AccountsContext = React.createContext({
  accounts: initialAccounts,
  networkSwitch: "mainnet",
  changePassword: () => Promise.reject(new Error("AccountsProvider not yet ready.")),
  createAccount: () => {
    throw new Error("AccountsProvider not yet ready.");
  },
  deleteAccount: () => Promise.reject(new Error("AccountsProvider not yet ready.")),
  removePassword: () => Promise.reject(new Error("AccountsProvider not yet ready.")),
  renameAccount: () => Promise.reject(new Error("AccountsProvider not yet ready.")),
  toggleNetwork: () => void 0
});
function AccountsProvider(props) {
  const [accounts, setAccounts] = React.useState(initialAccounts);
  const [networkSwitch, setNetworkSwitch] = React.useState("mainnet");
  React.useEffect(() => {
    const keyStore2 = getKeyStore();
    try {
      keyStore2.getKeyIDs().then(async (keyIDs) => {
        const loadedAccounts = await Promise.all(keyIDs.map((keyID) => createAccountInstance(keyStore2, keyID)));
        setAccounts(loadedAccounts);
        setNetworkSwitch(getInitialNetwork(loadedAccounts));
      }).catch(trackError);
    } catch (error3) {
      trackError(error3);
    }
    const unsubscribe2 = () => void 0;
    return unsubscribe2;
  }, []);
  const createAccount = async (accountData) => {
    const account2 = await createAccountInKeyStore(accounts, accountData);
    setAccounts((prevAccounts) => [...prevAccounts, account2]);
    return account2;
  };
  const updateAccountInStore = (updatedAccount) => {
    setAccounts(
      (prevAccounts) => prevAccounts.map((account2) => account2.id === updatedAccount.id ? updatedAccount : account2)
    );
  };
  const renameAccount = async (accountID, newName) => {
    const keyStore2 = await getKeyStore();
    await keyStore2.savePublicKeyData(accountID, {
      ...await keyStore2.getPublicKeyData(accountID),
      name: newName
    });
    updateAccountInStore(await createAccountInstance(keyStore2, accountID));
  };
  const deleteAccount = async (accountID) => {
    const keyStore2 = await getKeyStore();
    await keyStore2.removeKey(accountID);
    setAccounts((prevAccounts) => prevAccounts.filter((account2) => account2.id !== accountID));
  };
  const changePassword = async (accountID, prevPassword, nextPassword) => {
    const keyStore2 = await getKeyStore();
    let privateKeyData;
    const publicKeyData = await keyStore2.getPublicKeyData(accountID);
    try {
      privateKeyData = await keyStore2.getPrivateKeyData(accountID, prevPassword);
    } catch (error3) {
      console.debug("Decrypting private key data failed. Assuming wrong password:", error3);
      throw WrongPasswordError();
    }
    await keyStore2.saveKey(accountID, nextPassword, privateKeyData, { ...publicKeyData, password: true });
    updateAccountInStore(await createAccountInstance(keyStore2, accountID));
  };
  const removePassword = async (accountID, prevPassword) => {
    const keyStore2 = await getKeyStore();
    let privateKeyData;
    const publicKeyData = await keyStore2.getPublicKeyData(accountID);
    try {
      privateKeyData = await keyStore2.getPrivateKeyData(accountID, prevPassword);
    } catch (error3) {
      console.debug("Decrypting private key data failed. Assuming wrong password:", error3);
      throw WrongPasswordError();
    }
    await keyStore2.saveKey(accountID, "", privateKeyData, { ...publicKeyData, password: false });
    updateAccountInStore(await createAccountInstance(keyStore2, accountID));
  };
  const toggleNetwork = () => {
    setNetworkSwitch((prevNetwork) => prevNetwork === "mainnet" ? "testnet" : "mainnet");
  };
  const contextValue = {
    accounts,
    networkSwitch,
    changePassword,
    createAccount,
    deleteAccount,
    removePassword,
    renameAccount,
    toggleNetwork
  };
  return /* @__PURE__ */ React.createElement(AccountsContext.Provider, { value: contextValue }, props.children);
}
var lodash_debounce;
var hasRequiredLodash_debounce;
function requireLodash_debounce() {
  if (hasRequiredLodash_debounce) return lodash_debounce;
  hasRequiredLodash_debounce = 1;
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max, nativeMin = Math.min;
  var now2 = function() {
    return root.Date.now();
  };
  function debounce2(func, wait, options2) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject2(options2)) {
      leading = !!options2.leading;
      maxing = "maxWait" in options2;
      maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options2 ? !!options2.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now2();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now2());
    }
    function debounced() {
      var time = now2(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  lodash_debounce = debounce2;
  return lodash_debounce;
}
var lodash_debounceExports = requireLodash_debounce();
const debounce$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(lodash_debounceExports);
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator) return iterator;
  hasRequiredIterator = 1;
  iterator = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist;
var hasRequiredYallist;
function requireYallist() {
  if (hasRequiredYallist) return yallist;
  hasRequiredYallist = 1;
  yallist = Yallist;
  Yallist.Node = Node2;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist();
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
        self2.push(arguments[i2]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node2) {
    if (node2.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node2.next;
    var prev = node2.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node2 === this.head) {
      this.head = next;
    }
    if (node2 === this.tail) {
      this.tail = prev;
    }
    node2.list.length--;
    node2.next = null;
    node2.prev = null;
    node2.list = null;
  };
  Yallist.prototype.unshiftNode = function(node2) {
    if (node2 === this.head) {
      return;
    }
    if (node2.list) {
      node2.list.removeNode(node2);
    }
    var head = this.head;
    node2.list = this;
    node2.next = head;
    if (head) {
      head.prev = node2;
    }
    this.head = node2;
    if (!this.tail) {
      this.tail = node2;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node2) {
    if (node2 === this.tail) {
      return;
    }
    if (node2.list) {
      node2.list.removeNode(node2);
    }
    var tail = this.tail;
    node2.list = this;
    node2.prev = tail;
    if (tail) {
      tail.next = node2;
    }
    this.tail = node2;
    if (!this.head) {
      this.head = node2;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
      push(this, arguments[i2]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
      unshift(this, arguments[i2]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i2 = 0; walker !== null; i2++) {
      fn.call(thisp, walker.value, i2, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
      fn.call(thisp, walker.value, i2, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i2 = 0, walker = this.head; walker !== null && i2 < n; i2++) {
      walker = walker.next;
    }
    if (i2 === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i2 = 0, walker = this.tail; walker !== null && i2 < n; i2++) {
      walker = walker.prev;
    }
    if (i2 === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial2) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial2;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i2 = 0; walker !== null; i2++) {
      acc = fn(acc, walker.value, i2);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial2) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial2;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i2 = this.length - 1; walker !== null; i2--) {
      acc = fn(acc, walker.value, i2);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr2 = new Array(this.length);
    for (var i2 = 0, walker = this.head; walker !== null; i2++) {
      arr2[i2] = walker.value;
      walker = walker.next;
    }
    return arr2;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr2 = new Array(this.length);
    for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
      arr2[i2] = walker.value;
      walker = walker.prev;
    }
    return arr2;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++) {
      walker = walker.next;
    }
    for (; walker !== null && i2 < to; i2++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
      walker = walker.prev;
    }
    for (; walker !== null && i2 > from; i2--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function push(self2, item) {
    self2.tail = new Node2(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node2(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node2(value, prev, next, list) {
    if (!(this instanceof Node2)) {
      return new Node2(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    requireIterator()(Yallist);
  } catch (er) {
  }
  return yallist;
}
var lruCache;
var hasRequiredLruCache;
function requireLruCache() {
  if (hasRequiredLruCache) return lruCache;
  hasRequiredLruCache = 1;
  const Yallist = requireYallist();
  const MAX = Symbol("max");
  const LENGTH = Symbol("length");
  const LENGTH_CALCULATOR = Symbol("lengthCalculator");
  const ALLOW_STALE = Symbol("allowStale");
  const MAX_AGE = Symbol("maxAge");
  const DISPOSE = Symbol("dispose");
  const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  const LRU_LIST = Symbol("lruList");
  const CACHE = Symbol("cache");
  const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  const naiveLength = () => 1;
  class LRUCache2 {
    constructor(options2) {
      if (typeof options2 === "number")
        options2 = { max: options2 };
      if (!options2)
        options2 = {};
      if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
        throw new TypeError("max must be a non-negative number");
      this[MAX] = options2.max || Infinity;
      const lc = options2.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options2.stale || false;
      if (options2.maxAge && typeof options2.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options2.maxAge || 0;
      this[DISPOSE] = options2.dispose;
      this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
      this.reset();
    }
    // resize the cache when the max changes.
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = /* @__PURE__ */ new Map();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key2, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now2 = maxAge ? Date.now() : 0;
      const len2 = this[LENGTH_CALCULATOR](value, key2);
      if (this[CACHE].has(key2)) {
        if (len2 > this[MAX]) {
          del(this, this[CACHE].get(key2));
          return false;
        }
        const node2 = this[CACHE].get(key2);
        const item = node2.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key2, item.value);
        }
        item.now = now2;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len2 - item.length;
        item.length = len2;
        this.get(key2);
        trim(this);
        return true;
      }
      const hit = new Entry(key2, value, len2, now2, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key2, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key2, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key2) {
      if (!this[CACHE].has(key2)) return false;
      const hit = this[CACHE].get(key2).value;
      return !isStale(this, hit);
    }
    get(key2) {
      return get3(this, key2, true);
    }
    peek(key2) {
      return get3(this, key2, false);
    }
    pop() {
      const node2 = this[LRU_LIST].tail;
      if (!node2)
        return null;
      del(this, node2);
      return node2.value;
    }
    del(key2) {
      del(this, this[CACHE].get(key2));
    }
    load(arr2) {
      this.reset();
      const now2 = Date.now();
      for (let l = arr2.length - 1; l >= 0; l--) {
        const hit = arr2[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now2;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key2) => get3(this, key2, false));
    }
  }
  const get3 = (self2, key2, doUse) => {
    const node2 = self2[CACHE].get(key2);
    if (node2) {
      const hit = node2.value;
      if (isStale(self2, hit)) {
        del(self2, node2);
        if (!self2[ALLOW_STALE])
          return void 0;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node2.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node2);
        }
      }
      return hit.value;
    }
  };
  const isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  const trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  const del = (self2, node2) => {
    if (node2) {
      const hit = node2.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node2);
    }
  };
  class Entry {
    constructor(key2, value, length, now2, maxAge) {
      this.key = key2;
      this.value = value;
      this.length = length;
      this.now = now2;
      this.maxAge = maxAge || 0;
    }
  }
  const forEachStep = (self2, fn, node2, thisp) => {
    let hit = node2.value;
    if (isStale(self2, hit)) {
      del(self2, node2);
      if (!self2[ALLOW_STALE])
        hit = void 0;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  lruCache = LRUCache2;
  return lruCache;
}
var lruCacheExports = requireLruCache();
const LRUCache = /* @__PURE__ */ getDefaultExportFromCjs$1(lruCacheExports);
function useDebouncedState(initial2, delay = 50) {
  const currentCallGroupTimeoutRef = React.useRef(void 0);
  const updateQueueRef = React.useRef(void 0);
  const [state2, setState] = React.useState(initial2);
  const debouncedSetState = React.useCallback(
    (update2) => {
      const applyUpdateQueue = (previous, queue2) => {
        return queue2.reduce(
          (intermediate, queuedUpdate) => typeof queuedUpdate === "function" ? queuedUpdate(intermediate) : queuedUpdate,
          previous
        );
      };
      if (currentCallGroupTimeoutRef.current) {
        updateQueueRef.current.push(update2);
      } else {
        currentCallGroupTimeoutRef.current = setTimeout(() => {
          if (updateQueueRef.current) {
            const queue2 = updateQueueRef.current;
            setState((prev) => applyUpdateQueue(prev, queue2));
          }
          currentCallGroupTimeoutRef.current = void 0;
          updateQueueRef.current = void 0;
        }, delay);
        updateQueueRef.current = [];
        setState(update2);
      }
    },
    [delay]
  );
  React.useEffect(() => {
    const onUnmount = () => {
      if (currentCallGroupTimeoutRef.current) {
        clearTimeout(currentCallGroupTimeoutRef.current);
      }
    };
    return onUnmount;
  }, []);
  return [state2, debouncedSetState];
}
function useDeferredState(initial2, delay) {
  const [deferredState, setDeferredState] = React.useState(initial2);
  const [state2, setState] = React.useState(initial2);
  const setDeferred = React.useCallback(
    (update2) => {
      setState(update2);
      setTimeout(() => setDeferredState(update2), delay);
    },
    [delay]
  );
  return [deferredState, state2, setDeferred];
}
function useForceRerender() {
  const [, setCounter] = React.useState(0);
  const forceRerender = () => setCounter((counter) => counter++);
  return forceRerender;
}
const initialLoadingState = {
  type: "initial"
};
function useLoadingState(options2 = {}) {
  const [loadingState, setLoadingState] = React.useState();
  if (loadingState && loadingState.type === "rejected" && options2.throwOnError) {
    throw loadingState.error;
  }
  const handlePromise = React.useCallback(async (arg) => {
    try {
      const promise2 = typeof arg === "function" ? arg() : arg;
      setLoadingState({
        type: "pending",
        promise: promise2
      });
      const result = await promise2;
      setLoadingState({
        type: "resolved",
        result
      });
    } catch (error3) {
      setLoadingState({
        type: "rejected",
        error: error3
      });
    }
  }, []);
  return [loadingState || initialLoadingState, handlePromise];
}
function useOnlineStatus() {
  const [isOnline, setOnlineStatus] = React.useState(window.navigator.onLine);
  const setOffline = () => setOnlineStatus(false);
  const setOnline = () => setOnlineStatus(true);
  React.useEffect(() => {
    window.addEventListener("offline", setOffline);
    window.addEventListener("online", setOnline);
  }, []);
  return {
    isOnline
  };
}
function useSingleton(init2) {
  const isInitializedRef = React.useRef(false);
  const valueRef = React.useRef();
  if (!isInitializedRef.current) {
    valueRef.current = init2();
    isInitializedRef.current = true;
  }
  return valueRef.current;
}
function useCachingContext(cache2) {
  const [, setUpdateCounter] = React.useState(0);
  const forceRerender = debounce$1(() => setUpdateCounter((ctr2) => ctr2 + 1), 50);
  const contextValue = React.useMemo(
    () => ({
      cache: cache2,
      delete(key2) {
        cache2.del(key2);
        forceRerender();
      },
      store(key2, value, maxAge) {
        cache2.set(key2, value, maxAge);
        forceRerender();
      }
    }),
    [cache2, forceRerender]
  );
  return contextValue;
}
const emptyContextValue = {
  cache: new LRUCache(),
  delete: () => void 0,
  store: () => void 0
};
const SigningKeyCacheContext = React.createContext(emptyContextValue);
const StellarAddressCacheContext = React.createContext(emptyContextValue);
const StellarAddressReverseCacheContext = React.createContext(
  emptyContextValue
);
const WebAuthTokenCacheContext = React.createContext(emptyContextValue);
function SigningKeyCachingProvider(props) {
  const cache2 = useSingleton(
    () => new LRUCache({
      max: 100
    })
  );
  const contextValue = useCachingContext(cache2);
  return /* @__PURE__ */ React.createElement(SigningKeyCacheContext.Provider, { value: contextValue }, props.children);
}
function StellarAddressesCachingProvider(props) {
  const cache2 = useSingleton(
    () => new LRUCache({
      max: 1e3,
      maxAge: 10 * 60 * 1e3
      // 10 mins
    })
  );
  const contextValue = useCachingContext(cache2);
  return /* @__PURE__ */ React.createElement(StellarAddressCacheContext.Provider, { value: contextValue }, props.children);
}
function StellarAddressesReverseCachingProvider(props) {
  const cache2 = useSingleton(
    () => new LRUCache({
      max: 1e3,
      maxAge: 60 * 60 * 1e3
      // 60 mins (long TTL, since reverse lookup is purely informational)
    })
  );
  const contextValue = useCachingContext(cache2);
  return /* @__PURE__ */ React.createElement(StellarAddressReverseCacheContext.Provider, { value: contextValue }, props.children);
}
function WebAuthCachingProvider(props) {
  const cache2 = useSingleton(
    () => new LRUCache({
      max: 100
    })
  );
  const contextValue = useCachingContext(cache2);
  return /* @__PURE__ */ React.createElement(WebAuthTokenCacheContext.Provider, { value: contextValue }, props.children);
}
function CachingProviders(props) {
  return /* @__PURE__ */ React.createElement(SigningKeyCachingProvider, null, /* @__PURE__ */ React.createElement(StellarAddressesCachingProvider, null, /* @__PURE__ */ React.createElement(StellarAddressesReverseCachingProvider, null, /* @__PURE__ */ React.createElement(WebAuthCachingProvider, null, props.children))));
}
function isBiometricAuthAvailable() {
  return call(Messages.BioAuthAvailable);
}
function testBiometricAuth(message) {
  return new Promise(async (resolve2, reject) => {
    if (window.confirm(message)) {
      const error3 = await call(Messages.TestBioAuth);
      if (error3) {
        reject(error3);
      } else {
        resolve2();
      }
    } else {
      reject(CustomError("BioAuthTestCanceledError", "Biometric authentication canceled"));
    }
  });
}
const implementation = {
  loadIgnoredSignatureRequestHashes: () => call(Messages.ReadIgnoredSignatureRequestHashes),
  saveIgnoredSignatureRequestHashes: (updatedSignatureRequestHashes) => call(Messages.StoreIgnoredSignatureRequestHashes, updatedSignatureRequestHashes),
  loadSettings: () => call(Messages.ReadSettings),
  saveSettings: (settingsUpdate) => call(Messages.StoreSettings, settingsUpdate)
};
const loadIgnoredSignatureRequestHashes = implementation.loadIgnoredSignatureRequestHashes;
const saveIgnoredSignatureRequestHashes = implementation.saveIgnoredSignatureRequestHashes;
const loadSettings = implementation.loadSettings;
const saveSettings = implementation.saveSettings;
let updateStarted = false;
let updateDownloaded = false;
const updater = {
  isUpdateAvailable: () => call(Messages.CheckUpdateAvailability),
  isUpdateStarted: () => updateStarted,
  isUpdateDownloaded: () => updateDownloaded,
  startUpdate: async () => {
    updateStarted = true;
    const result = await call(Messages.StartUpdate);
    updateStarted = false;
    updateDownloaded = true;
    return result;
  }
};
function getUpdater() {
  return updater;
}
const initialSettings = {
  agreedToTermsAt: void 0,
  biometricLock: false,
  hideMemos: false,
  initialized: false,
  multisignature: false,
  testnet: false,
  showDust: false,
  showClaimableBalanceTxs: false,
  trustedServices: []
};
const initialIgnoredSignatureRequests = [];
const multiSignatureCoordinator = "v1.multisig.satoshipay.io";
const SettingsContext = React.createContext({
  agreedToTermsAt: initialSettings.agreedToTermsAt,
  biometricLock: initialSettings.biometricLock,
  biometricAvailability: { available: false, enrolled: false },
  confirmToC: () => void 0,
  hideMemos: initialSettings.hideMemos,
  ignoreSignatureRequest: () => void 0,
  ignoredSignatureRequests: initialIgnoredSignatureRequests,
  initialized: false,
  language: void 0,
  multiSignature: initialSettings.multisignature,
  multiSignatureCoordinator,
  setLanguage: () => void 0,
  setSetting: () => void 0,
  showDust: false,
  showClaimableBalanceTxs: false,
  showTestnet: initialSettings.testnet,
  toggleBiometricLock: () => void 0,
  toggleMultiSignature: () => void 0,
  toggleTestnet: () => void 0,
  toggleHideMemos: () => void 0,
  toggleShowDust: () => void 0,
  toggleShowClaimableBalanceTxs: () => void 0,
  trustedServices: initialSettings.trustedServices,
  updateAvailable: false
});
function SettingsProvider(props) {
  const [ignoredSignatureRequests, setIgnoredSignatureRequests] = React.useState(initialIgnoredSignatureRequests);
  const [settings2, setSettings] = React.useState(initialSettings);
  const [updateAvailable, setUpdateAvailable] = React.useState(false);
  const [biometricAvailability, setBiometricAvailability] = React.useState({
    available: false,
    enrolled: false
  });
  const forceRerender = useForceRerender();
  const { t: t2 } = useTranslation();
  React.useEffect(() => {
    Promise.all([loadIgnoredSignatureRequestHashes(), loadSettings()]).then(([loadedSignatureReqHashes, loadedSettings]) => {
      setIgnoredSignatureRequests(loadedSignatureReqHashes);
      setSettings((prev) => ({ ...prev, ...loadedSettings, initialized: true }));
    }).catch(trackError);
    isBiometricAuthAvailable().then(setBiometricAvailability);
    getUpdater().isUpdateAvailable().then(setUpdateAvailable);
    const unsubscribe2 = () => void 0;
    return unsubscribe2;
  }, []);
  const ignoreSignatureRequest = (signatureRequestHash) => {
    if (ignoredSignatureRequests.indexOf(signatureRequestHash) === -1) {
      const updatedSignatureRequestHashes = [...ignoredSignatureRequests, signatureRequestHash];
      saveIgnoredSignatureRequestHashes(updatedSignatureRequestHashes);
      setIgnoredSignatureRequests(updatedSignatureRequestHashes);
    }
  };
  const updateSettings = (update2) => {
    try {
      const updatedSettings = {
        ...settings2,
        ...update2
      };
      setSettings(updatedSettings);
      saveSettings(updatedSettings);
    } catch (error3) {
      trackError(error3);
    }
  };
  const confirmToC = () => updateSettings({ agreedToTermsAt: (/* @__PURE__ */ new Date()).toISOString() });
  const toggleMultiSignature = () => updateSettings({ multisignature: !settings2.multisignature });
  const toggleTestnet = () => updateSettings({ testnet: !settings2.testnet });
  const toggleHideMemos = () => updateSettings({ hideMemos: !settings2.hideMemos });
  const toggleShowDust = () => updateSettings({ showDust: !settings2.showDust });
  const toggleShowClaimableBalanceTxs = () => updateSettings({ showClaimableBalanceTxs: !settings2.showClaimableBalanceTxs });
  const setLanguage = (language) => {
    if (language) {
      localStorage.setItem("i18nextLng", language);
    } else {
      localStorage.removeItem("i18nextLng");
    }
    forceRerender();
  };
  const setSetting = (key2, value) => {
    const partial = {};
    partial[key2] = value;
    updateSettings(partial);
  };
  const toggleBiometricLock = () => {
    const message = settings2.biometricLock ? t2("app-settings.settings.biometric-lock.prompt.disable") : t2("app-settings.settings.biometric-lock.prompt.enable");
    testBiometricAuth(message).then(() => updateSettings({ biometricLock: !settings2.biometricLock })).catch(trackError);
  };
  const contextValue = {
    agreedToTermsAt: settings2.agreedToTermsAt,
    biometricLock: settings2.biometricLock,
    biometricAvailability,
    confirmToC,
    hideMemos: settings2.hideMemos,
    ignoreSignatureRequest,
    ignoredSignatureRequests,
    initialized: settings2.initialized,
    language: localStorage.getItem("i18nextLng") || void 0,
    multiSignature: settings2.multisignature,
    multiSignatureCoordinator,
    setLanguage,
    setSetting,
    showTestnet: settings2.testnet,
    showDust: settings2.showDust,
    showClaimableBalanceTxs: settings2.showClaimableBalanceTxs,
    toggleBiometricLock,
    toggleMultiSignature,
    toggleTestnet,
    toggleHideMemos,
    toggleShowDust,
    toggleShowClaimableBalanceTxs,
    trustedServices: settings2.trustedServices,
    updateAvailable
  };
  return /* @__PURE__ */ React.createElement(SettingsContext.Provider, { value: contextValue }, props.children);
}
const multisigCoordinatorResolutionCache = /* @__PURE__ */ new Map();
const multisigCoordinatorResolutionPending = /* @__PURE__ */ new Map();
async function resolveMultiSignatureCoordinator(domain) {
  if (multisigCoordinatorResolutionCache.has(domain)) {
    return multisigCoordinatorResolutionCache.get(domain);
  } else if (multisigCoordinatorResolutionPending.has(domain)) {
    return multisigCoordinatorResolutionPending.get(domain);
  } else {
    const { netWorker: netWorker2 } = await workers;
    const allowHttp = domain.startsWith("localhost:") && false;
    const pending = netWorker2.fetchStellarToml(domain, { allowHttp, timeout: 1e4 }).then(
      (toml2) => {
        const resolved = toml2 == null ? void 0 : toml2.MULTISIG_ENDPOINT;
        if (!resolved) {
          throw CustomError("MultiSigServiceNotLocatable", `Multi-signature service cannot be located: ${domain}`, {
            domain
          });
        }
        multisigCoordinatorResolutionCache.set(domain, resolved);
        multisigCoordinatorResolutionPending.delete(domain);
        return resolved;
      },
      (error3) => {
        multisigCoordinatorResolutionPending.delete(domain);
        throw error3;
      }
    );
    multisigCoordinatorResolutionPending.set(domain, pending);
    return pending;
  }
}
var DP = 20, RM = 1, MAX_DP = 1e6, MAX_POWER = 1e6, NE = -7, PE = 21, NAME = "[big.js] ", INVALID = NAME + "Invalid ", INVALID_DP = INVALID + "decimal places", INVALID_RM = INVALID + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P = {}, UNDEFINED$1 = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function _Big_() {
  function Big2(n) {
    var x = this;
    if (!(x instanceof Big2)) return n === UNDEFINED$1 ? _Big_() : new Big2(n);
    if (n instanceof Big2) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      parse(x, n);
    }
    x.constructor = Big2;
  }
  Big2.prototype = P;
  Big2.DP = DP;
  Big2.RM = RM;
  Big2.NE = NE;
  Big2.PE = PE;
  Big2.version = "5.2.2";
  return Big2;
}
function parse(x, n) {
  var e, i2, nl;
  if (n === 0 && 1 / n < 0) n = "-0";
  else if (!NUMERIC.test(n += "")) throw Error(INVALID + "number");
  x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
  if ((e = n.indexOf(".")) > -1) n = n.replace(".", "");
  if ((i2 = n.search(/e/i)) > 0) {
    if (e < 0) e = i2;
    e += +n.slice(i2 + 1);
    n = n.substring(0, i2);
  } else if (e < 0) {
    e = n.length;
  }
  nl = n.length;
  for (i2 = 0; i2 < nl && n.charAt(i2) == "0"; ) ++i2;
  if (i2 == nl) {
    x.c = [x.e = 0];
  } else {
    for (; nl > 0 && n.charAt(--nl) == "0"; ) ;
    x.e = e - i2 - 1;
    x.c = [];
    for (e = 0; i2 <= nl; ) x.c[e++] = +n.charAt(i2++);
  }
  return x;
}
function round(x, dp, rm, more) {
  var xc = x.c, i2 = x.e + dp + 1;
  if (i2 < xc.length) {
    if (rm === 1) {
      more = xc[i2] >= 5;
    } else if (rm === 2) {
      more = xc[i2] > 5 || xc[i2] == 5 && (more || i2 < 0 || xc[i2 + 1] !== UNDEFINED$1 || xc[i2 - 1] & 1);
    } else if (rm === 3) {
      more = more || !!xc[0];
    } else {
      more = false;
      if (rm !== 0) throw Error(INVALID_RM);
    }
    if (i2 < 1) {
      xc.length = 1;
      if (more) {
        x.e = -dp;
        xc[0] = 1;
      } else {
        xc[0] = x.e = 0;
      }
    } else {
      xc.length = i2--;
      if (more) {
        for (; ++xc[i2] > 9; ) {
          xc[i2] = 0;
          if (!i2--) {
            ++x.e;
            xc.unshift(1);
          }
        }
      }
      for (i2 = xc.length; !xc[--i2]; ) xc.pop();
    }
  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
    throw Error(INVALID_RM);
  }
  return x;
}
function stringify(x, id, n, k) {
  var e, s, Big2 = x.constructor, z = !x.c[0];
  if (n !== UNDEFINED$1) {
    if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
      throw Error(id == 3 ? INVALID + "precision" : INVALID_DP);
    }
    x = new Big2(x);
    n = k - x.e;
    if (x.c.length > ++k) round(x, n, Big2.RM);
    if (id == 2) k = x.e + n + 1;
    for (; x.c.length < k; ) x.c.push(0);
  }
  e = x.e;
  s = x.c.join("");
  n = s.length;
  if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big2.NE || e >= Big2.PE)) {
    s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    for (; ++e; ) s = "0" + s;
    s = "0." + s;
  } else if (e > 0) {
    if (++e > n) for (e -= n; e--; ) s += "0";
    else if (e < n) s = s.slice(0, e) + "." + s.slice(e);
  } else if (n > 1) {
    s = s.charAt(0) + "." + s.slice(1);
  }
  return x.s < 0 && (!z || id == 4) ? "-" + s : s;
}
P.abs = function() {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};
P.cmp = function(y) {
  var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i2 = x.s, j = y.s, k = x.e, l = y.e;
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i2;
  if (i2 != j) return i2;
  isneg = i2 < 0;
  if (k != l) return k > l ^ isneg ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i2 = -1; ++i2 < j; ) {
    if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ isneg ? 1 : -1;
  }
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};
P.div = function(y) {
  var x = this, Big2 = x.constructor, a = x.c, b = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP);
  if (!b[0]) throw Error(DIV_BY_ZERO);
  if (!a[0]) return new Big2(k * 0);
  var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1;
  q.s = k;
  k = d < 0 ? 0 : d;
  bz.unshift(0);
  for (; rl++ < bl; ) r.push(0);
  do {
    for (n = 0; n < 10; n++) {
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl; ) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }
      if (cmp < 0) {
        for (bt = rl == bl ? b : bz; rl; ) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri]; ) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }
        for (; !r[0]; ) r.shift();
      } else {
        break;
      }
    }
    qc[qi++] = cmp ? n : ++n;
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];
  } while ((ai++ < al || r[0] !== UNDEFINED$1) && k--);
  if (!qc[0] && qi != 1) {
    qc.shift();
    q.e--;
  }
  if (qi > d) round(q, dp, Big2.RM, r[0] !== UNDEFINED$1);
  return q;
};
P.eq = function(y) {
  return !this.cmp(y);
};
P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.gte = function(y) {
  return this.cmp(y) > -1;
};
P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.minus = P.sub = function(y) {
  var i2, j, t2, xlty, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }
  var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
  if (!xc[0] || !yc[0]) {
    return yc[0] ? (y.s = -b, y) : new Big2(xc[0] ? x : 0);
  }
  if (a = xe - ye) {
    if (xlty = a < 0) {
      a = -a;
      t2 = xc;
    } else {
      ye = xe;
      t2 = yc;
    }
    t2.reverse();
    for (b = a; b--; ) t2.push(0);
    t2.reverse();
  } else {
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;
    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }
  if (xlty) {
    t2 = xc;
    xc = yc;
    yc = t2;
    y.s = -y.s;
  }
  if ((b = (j = yc.length) - (i2 = xc.length)) > 0) for (; b--; ) xc[i2++] = 0;
  for (b = i2; j > a; ) {
    if (xc[--j] < yc[j]) {
      for (i2 = j; i2 && !xc[--i2]; ) xc[i2] = 9;
      --xc[i2];
      xc[j] += 10;
    }
    xc[j] -= yc[j];
  }
  for (; xc[--b] === 0; ) xc.pop();
  for (; xc[0] === 0; ) {
    xc.shift();
    --ye;
  }
  if (!xc[0]) {
    y.s = 1;
    xc = [ye = 0];
  }
  y.c = xc;
  y.e = ye;
  return y;
};
P.mod = function(y) {
  var ygtx, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
  if (!y.c[0]) throw Error(DIV_BY_ZERO);
  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;
  if (ygtx) return new Big2(x);
  a = Big2.DP;
  b = Big2.RM;
  Big2.DP = Big2.RM = 0;
  x = x.div(y);
  Big2.DP = a;
  Big2.RM = b;
  return this.minus(x.times(y));
};
P.plus = P.add = function(y) {
  var t2, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
  if (a != b) {
    y.s = -b;
    return x.minus(y);
  }
  var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
  if (!xc[0] || !yc[0]) return yc[0] ? y : new Big2(xc[0] ? x : a * 0);
  xc = xc.slice();
  if (a = xe - ye) {
    if (a > 0) {
      ye = xe;
      t2 = yc;
    } else {
      a = -a;
      t2 = xc;
    }
    t2.reverse();
    for (; a--; ) t2.push(0);
    t2.reverse();
  }
  if (xc.length - yc.length < 0) {
    t2 = yc;
    yc = xc;
    xc = t2;
  }
  a = yc.length;
  for (b = 0; a; xc[a] %= 10) b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;
  if (b) {
    xc.unshift(b);
    ++ye;
  }
  for (a = xc.length; xc[--a] === 0; ) xc.pop();
  y.c = xc;
  y.e = ye;
  return y;
};
P.pow = function(n) {
  var x = this, one = new x.constructor(1), y = one, isneg = n < 0;
  if (n !== ~~n || n < -1e6 || n > MAX_POWER) throw Error(INVALID + "exponent");
  if (isneg) n = -n;
  for (; ; ) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }
  return isneg ? one.div(y) : y;
};
P.round = function(dp, rm) {
  var Big2 = this.constructor;
  if (dp === UNDEFINED$1) dp = 0;
  else if (dp !== ~~dp || dp < -1e6 || dp > MAX_DP) throw Error(INVALID_DP);
  return round(new Big2(this), dp, rm === UNDEFINED$1 ? Big2.RM : rm);
};
P.sqrt = function() {
  var r, c, t2, x = this, Big2 = x.constructor, s = x.s, e = x.e, half = new Big2(0.5);
  if (!x.c[0]) return new Big2(x);
  if (s < 0) throw Error(NAME + "No square root");
  s = Math.sqrt(x + "");
  if (s === 0 || s === 1 / 0) {
    c = x.c.join("");
    if (!(c.length + e & 1)) c += "0";
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big2((s == 1 / 0 ? "1e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
  } else {
    r = new Big2(s);
  }
  e = r.e + (Big2.DP += 4);
  do {
    t2 = r;
    r = half.times(t2.plus(x.div(t2)));
  } while (t2.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
  return round(r, Big2.DP -= 4, Big2.RM);
};
P.times = P.mul = function(y) {
  var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b = yc.length, i2 = x.e, j = y.e;
  y.s = x.s == y.s ? 1 : -1;
  if (!xc[0] || !yc[0]) return new Big2(y.s * 0);
  y.e = i2 + j;
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }
  for (c = new Array(j = a + b); j--; ) c[j] = 0;
  for (i2 = b; i2--; ) {
    b = 0;
    for (j = a + i2; j > i2; ) {
      b = c[j] + yc[i2] * xc[j - i2 - 1] + b;
      c[j--] = b % 10;
      b = b / 10 | 0;
    }
    c[j] = (c[j] + b) % 10;
  }
  if (b) ++y.e;
  else c.shift();
  for (i2 = c.length; !c[--i2]; ) c.pop();
  y.c = c;
  return y;
};
P.toExponential = function(dp) {
  return stringify(this, 1, dp, dp);
};
P.toFixed = function(dp) {
  return stringify(this, 2, dp, this.e + dp);
};
P.toPrecision = function(sd) {
  return stringify(this, 3, sd, sd - 1);
};
P.toString = function() {
  return stringify(this);
};
P.valueOf = P.toJSON = function() {
  return stringify(this, 4);
};
var Big = _Big_();
const MAX_INT64 = "9223372036854775807";
const SDF_FRIENDBOT_HREF = "https://friendbot.stellar.org/{?addr}";
const dedupe = (array2) => Array.from(new Set(array2));
const BASE_RESERVE = 0.5;
function getAllSources(tx) {
  return dedupe([
    tx.source,
    ...tx.operations.map((operation2) => operation2.source).filter((source) => Boolean(source))
  ]);
}
function isNotFoundError(error3) {
  return error3 && error3 instanceof Error && error3.message === "Request failed with status code 404" || error3.response && error3.response.status === 404;
}
function balancelineToAsset(balanceline) {
  return balanceline.asset_type === "native" ? libExports.Asset.native() : new libExports.Asset(balanceline.asset_code, balanceline.asset_issuer);
}
function parseAssetID(assetID) {
  if (assetID === "XLM") {
    return libExports.Asset.native();
  } else {
    const [issuer, code2] = assetID.split(":");
    return new libExports.Asset(code2, issuer);
  }
}
function stringifyAssetToReadableString(asset2) {
  if (asset2 instanceof libExports.Asset) {
    return asset2.isNative() ? "XLM" : asset2.getCode();
  } else {
    return `Liquidity Pool '${asset2.assetA.code} <-> ${asset2.assetB.code}'`;
  }
}
function stringifyAsset(assetOrTrustline) {
  if (assetOrTrustline instanceof libExports.Asset) {
    const asset2 = assetOrTrustline;
    return asset2.isNative() ? "XLM" : `${asset2.getIssuer()}:${asset2.getCode()}`;
  } else {
    const line = assetOrTrustline;
    return line.asset_type === "native" ? "XLM" : `${line.asset_issuer}:${line.asset_code}`;
  }
}
async function friendbotTopup(horizonURL, publicKey) {
  const horizonMetadata = await (await fetch(horizonURL)).json();
  const templatedFriendbotHref = horizonMetadata._links.friendbot.href || SDF_FRIENDBOT_HREF;
  const friendBotHref = templatedFriendbotHref.replace(/\{\?.*/, "");
  const response2 = await fetch(friendBotHref + `?addr=${publicKey}`);
  return response2.json();
}
function getAccountMinimumBalance(accountData) {
  return Big(2).add(accountData.subentry_count).mul(BASE_RESERVE);
}
function getSpendableBalance(accountMinimumBalance, balanceLine) {
  if (balanceLine !== void 0) {
    const fullBalance = Big(balanceLine.balance);
    return balanceLine.asset_type === "native" ? fullBalance.minus(accountMinimumBalance).minus(balanceLine.selling_liabilities) : fullBalance.minus(balanceLine.selling_liabilities);
  } else {
    return Big(0);
  }
}
function getAssetsFromBalances(balances) {
  return balances.map(
    (balance) => balance.asset_type === "native" ? libExports.Asset.native() : new libExports.Asset(balance.asset_code, balance.asset_issuer)
  );
}
function findMatchingBalanceLine(balances, asset2) {
  if (!asset2) return void 0;
  return balances.find((balance) => balancelineToAsset(balance).equals(asset2));
}
function offerAssetToAsset(offerAsset) {
  return offerAsset.asset_type === "native" ? libExports.Asset.native() : new libExports.Asset(offerAsset.asset_code, offerAsset.asset_issuer);
}
function assetRecordToAsset(assetRecord) {
  return assetRecord.issuer === "native" ? libExports.Asset.native() : new libExports.Asset(assetRecord.code, assetRecord.issuer);
}
function trustlineLimitEqualsUnlimited(limit) {
  return String(limit).replace(".", "") === MAX_INT64;
}
var MultisigTransactionStatus = /* @__PURE__ */ ((MultisigTransactionStatus2) => {
  MultisigTransactionStatus2["failed"] = "failed";
  MultisigTransactionStatus2["pending"] = "pending";
  MultisigTransactionStatus2["ready"] = "ready";
  MultisigTransactionStatus2["submitted"] = "submitted";
  return MultisigTransactionStatus2;
})(MultisigTransactionStatus || {});
const SignatureDelegationContext = React.createContext({
  pendingSignatureRequests: [],
  subscribeToNewSignatureRequests: () => () => void 0
});
function useSignatureRequestSubscription(multiSignatureCoordinator2, accounts) {
  const accountPubKeys = React.useMemo(() => accounts.map((account2) => account2.publicKey), [accounts]);
  const { ignoredSignatureRequests } = React.useContext(SettingsContext);
  const subscribersRef = React.useRef({ newRequestSubscribers: [] });
  const [pendingTransactions, setPendingTransactions] = React.useState([]);
  React.useEffect(() => {
    if (accounts.length === 0) {
      return () => void 0;
    }
    let cancelled = false;
    let unsubscribe2 = () => {
      cancelled = true;
    };
    const setup = async () => {
      const { netWorker: netWorker2 } = await workers;
      const multiSignatureServiceURL = await resolveMultiSignatureCoordinator(multiSignatureCoordinator2);
      netWorker2.fetchTransactions(multiSignatureServiceURL, accountPubKeys).then((requests) => setPendingTransactions(requests.reverse())).catch(trackError);
      if (cancelled) {
        return;
      }
      const signatureRequests = netWorker2.subscribeToTransactions(multiSignatureServiceURL, accountPubKeys);
      const subscription = signatureRequests.subscribe((event) => {
        if (event.type === "transaction:added") {
          setPendingTransactions((prevPending) => [event.transaction, ...prevPending]);
          subscribersRef.current.newRequestSubscribers.forEach((subscriber) => subscriber(event.transaction));
        }
        if (event.type === "transaction:updated" && event.transaction.status === MultisigTransactionStatus.submitted) {
          setPendingTransactions((prevPending) => {
            const prev = prevPending.find((request2) => request2.hash !== event.transaction.hash);
            if (prev) {
              Object.assign(prev, event.transaction);
            }
            return prevPending.map((request2) => request2.hash === event.transaction.hash ? event.transaction : request2);
          });
        }
      });
      unsubscribe2 = () => subscription.unsubscribe();
    };
    setup().catch(trackError);
    return () => unsubscribe2();
  }, [accountPubKeys, accounts.length, multiSignatureCoordinator2]);
  const subscribeToNewSignatureRequests = (callback) => {
    subscribersRef.current.newRequestSubscribers.push(callback);
    const unsubscribe2 = () => {
      subscribersRef.current.newRequestSubscribers = subscribersRef.current.newRequestSubscribers.filter(
        (subscriber) => subscriber !== callback
      );
    };
    return unsubscribe2;
  };
  const filteredPendingSignatureRequests = pendingTransactions.filter(
    (signatureRequest) => ignoredSignatureRequests.indexOf(signatureRequest.hash) === -1
  );
  return {
    pendingSignatureRequests: filteredPendingSignatureRequests,
    subscribeToNewSignatureRequests
  };
}
function SignatureDelegationProvider(props) {
  const { accounts } = React.useContext(AccountsContext);
  const settings2 = React.useContext(SettingsContext);
  const contextValue = useSignatureRequestSubscription(settings2.multiSignatureCoordinator, accounts);
  return /* @__PURE__ */ React.createElement(SignatureDelegationContext.Provider, { value: contextValue }, props.children);
}
function FeatureFlaggedProvider(props) {
  const settings2 = React.useContext(SettingsContext);
  if (settings2.multiSignature) {
    return /* @__PURE__ */ React.createElement(SignatureDelegationProvider, { ...props });
  } else {
    const value = {
      pendingSignatureRequests: [],
      subscribeToNewSignatureRequests: () => () => void 0
    };
    return /* @__PURE__ */ React.createElement(SignatureDelegationContext.Provider, { value }, props.children);
  }
}
const createEmptyAccountData = (accountID) => ({
  account_id: accountID,
  balances: [],
  data_attr: {},
  flags: {
    auth_immutable: false,
    auth_required: false,
    auth_revocable: false,
    auth_clawback_enabled: false
  },
  id: accountID,
  paging_token: "",
  signers: [],
  subentry_count: 0,
  thresholds: {
    low_threshold: 0,
    med_threshold: 0,
    high_threshold: 0
  }
});
function mapSuspendables(array2, mapper, options2 = {}) {
  const pendingSuspenses = [];
  const rejections = [];
  const result = array2.map((element, index2) => {
    try {
      return mapper(element, index2);
    } catch (thrown) {
      if (thrown && typeof thrown.then === "function") {
        pendingSuspenses.push(thrown);
      } else {
        throw thrown;
      }
    }
  });
  if (pendingSuspenses.length > 0) {
    throw options2.ignoreSingleErrors ? Promise.all([
      ...pendingSuspenses.map(
        (promise2) => promise2.catch((error3) => {
          rejections.push(error3);
        })
      )
    ]).then((results) => {
      if (rejections.length > 0 && rejections.length === array2.length) {
        throw rejections[0];
      } else {
        return results;
      }
    }) : Promise.all(pendingSuspenses);
  }
  return result;
}
const hasSymbols = () => typeof Symbol === "function";
const hasSymbol = (name) => hasSymbols() && Boolean(Symbol[name]);
const getSymbol = (name) => hasSymbol(name) ? Symbol[name] : "@@" + name;
if (!hasSymbol("asyncIterator")) {
  Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");
}
const SymbolIterator = getSymbol("iterator");
const SymbolObservable = getSymbol("observable");
const SymbolSpecies = getSymbol("species");
function getMethod(obj, key2) {
  const value = obj[key2];
  if (value == null) {
    return void 0;
  }
  if (typeof value !== "function") {
    throw new TypeError(value + " is not a function");
  }
  return value;
}
function getSpecies(obj) {
  let ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x) {
  return x instanceof Observable;
}
function hostReportError(error3) {
  if (hostReportError.log) {
    hostReportError.log(error3);
  } else {
    setTimeout(() => {
      throw error3;
    }, 0);
  }
}
function enqueue(fn) {
  Promise.resolve().then(() => {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}
function cleanupSubscription(subscription) {
  const cleanup = subscription._cleanup;
  if (cleanup === void 0) {
    return;
  }
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      const unsubscribe2 = getMethod(cleanup, "unsubscribe");
      if (unsubscribe2) {
        unsubscribe2.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  const queue2 = subscription._queue;
  if (!queue2) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (const item of queue2) {
    notifySubscription(subscription, item.type, item.value);
    if (subscription._state === "closed") {
      break;
    }
  }
}
function notifySubscription(subscription, type2, value) {
  subscription._state = "running";
  const observer = subscription._observer;
  try {
    const m = observer ? getMethod(observer, type2) : void 0;
    switch (type2) {
      case "next":
        if (m)
          m.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m)
          m.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m)
          m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }
  if (subscription._state === "closed") {
    cleanupSubscription(subscription);
  } else if (subscription._state === "running") {
    subscription._state = "ready";
  }
}
function onNotify(subscription, type2, value) {
  if (subscription._state === "closed") {
    return;
  }
  if (subscription._state === "buffering") {
    subscription._queue = subscription._queue || [];
    subscription._queue.push({ type: type2, value });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{ type: type2, value }];
    enqueue(() => flushSubscription(subscription));
    return;
  }
  notifySubscription(subscription, type2, value);
}
class Subscription {
  constructor(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    const subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }
    if (this._state === "initializing") {
      this._state = "ready";
    }
  }
  get closed() {
    return this._state === "closed";
  }
  unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  }
}
class SubscriptionObserver {
  constructor(subscription) {
    this._subscription = subscription;
  }
  get closed() {
    return this._subscription._state === "closed";
  }
  next(value) {
    onNotify(this._subscription, "next", value);
  }
  error(value) {
    onNotify(this._subscription, "error", value);
  }
  complete() {
    onNotify(this._subscription, "complete");
  }
}
class Observable {
  constructor(subscriber) {
    if (!(this instanceof Observable)) {
      throw new TypeError("Observable cannot be called as a function");
    }
    if (typeof subscriber !== "function") {
      throw new TypeError("Observable initializer must be a function");
    }
    this._subscriber = subscriber;
  }
  subscribe(nextOrObserver, onError, onComplete) {
    if (typeof nextOrObserver !== "object" || nextOrObserver === null) {
      nextOrObserver = {
        next: nextOrObserver,
        error: onError,
        complete: onComplete
      };
    }
    return new Subscription(nextOrObserver, this._subscriber);
  }
  pipe(first, ...mappers) {
    let intermediate = this;
    for (const mapper of [first, ...mappers]) {
      intermediate = mapper(intermediate);
    }
    return intermediate;
  }
  tap(nextOrObserver, onError, onComplete) {
    const tapObserver = typeof nextOrObserver !== "object" || nextOrObserver === null ? {
      next: nextOrObserver,
      error: onError,
      complete: onComplete
    } : nextOrObserver;
    return new Observable((observer) => {
      return this.subscribe({
        next(value) {
          tapObserver.next && tapObserver.next(value);
          observer.next(value);
        },
        error(error3) {
          tapObserver.error && tapObserver.error(error3);
          observer.error(error3);
        },
        complete() {
          tapObserver.complete && tapObserver.complete();
          observer.complete();
        },
        start(subscription) {
          tapObserver.start && tapObserver.start(subscription);
        }
      });
    });
  }
  forEach(fn) {
    return new Promise((resolve2, reject) => {
      if (typeof fn !== "function") {
        reject(new TypeError(fn + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve2();
      }
      const subscription = this.subscribe({
        next(value) {
          try {
            fn(value, done);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
    });
  }
  map(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies(this);
    return new C((observer) => this.subscribe({
      next(value) {
        let propagatedValue = value;
        try {
          propagatedValue = fn(value);
        } catch (e) {
          return observer.error(e);
        }
        observer.next(propagatedValue);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    }));
  }
  filter(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies(this);
    return new C((observer) => this.subscribe({
      next(value) {
        try {
          if (!fn(value))
            return;
        } catch (e) {
          return observer.error(e);
        }
        observer.next(value);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    }));
  }
  reduce(fn, seed) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies(this);
    const hasSeed = arguments.length > 1;
    let hasValue2 = false;
    let acc = seed;
    return new C((observer) => this.subscribe({
      next(value) {
        const first = !hasValue2;
        hasValue2 = true;
        if (!first || hasSeed) {
          try {
            acc = fn(acc, value);
          } catch (e) {
            return observer.error(e);
          }
        } else {
          acc = value;
        }
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        if (!hasValue2 && !hasSeed) {
          return observer.error(new TypeError("Cannot reduce an empty sequence"));
        }
        observer.next(acc);
        observer.complete();
      }
    }));
  }
  concat(...sources) {
    const C = getSpecies(this);
    return new C((observer) => {
      let subscription;
      let index2 = 0;
      function startNext(next) {
        subscription = next.subscribe({
          next(v) {
            observer.next(v);
          },
          error(e) {
            observer.error(e);
          },
          complete() {
            if (index2 === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C.from(sources[index2++]));
            }
          }
        });
      }
      startNext(this);
      return () => {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  }
  flatMap(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies(this);
    return new C((observer) => {
      const subscriptions = [];
      const outer = this.subscribe({
        next(value) {
          let normalizedValue;
          if (fn) {
            try {
              normalizedValue = fn(value);
            } catch (e) {
              return observer.error(e);
            }
          } else {
            normalizedValue = value;
          }
          const inner = C.from(normalizedValue).subscribe({
            next(innerValue) {
              observer.next(innerValue);
            },
            error(e) {
              observer.error(e);
            },
            complete() {
              const i2 = subscriptions.indexOf(inner);
              if (i2 >= 0)
                subscriptions.splice(i2, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error(e) {
          observer.error(e);
        },
        complete() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0) {
          observer.complete();
        }
      }
      return () => {
        subscriptions.forEach((s) => s.unsubscribe());
        outer.unsubscribe();
      };
    });
  }
  [SymbolObservable]() {
    return this;
  }
  static from(x) {
    const C = typeof this === "function" ? this : Observable;
    if (x == null) {
      throw new TypeError(x + " is not an object");
    }
    const observableMethod = getMethod(x, SymbolObservable);
    if (observableMethod) {
      const observable = observableMethod.call(x);
      if (Object(observable) !== observable) {
        throw new TypeError(observable + " is not an object");
      }
      if (isObservable(observable) && observable.constructor === C) {
        return observable;
      }
      return new C((observer) => observable.subscribe(observer));
    }
    if (hasSymbol("iterator")) {
      const iteratorMethod = getMethod(x, SymbolIterator);
      if (iteratorMethod) {
        return new C((observer) => {
          enqueue(() => {
            if (observer.closed)
              return;
            for (const item of iteratorMethod.call(x)) {
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x)) {
      return new C((observer) => {
        enqueue(() => {
          if (observer.closed)
            return;
          for (const item of x) {
            observer.next(item);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x + " is not observable");
  }
  static of(...items) {
    const C = typeof this === "function" ? this : Observable;
    return new C((observer) => {
      enqueue(() => {
        if (observer.closed)
          return;
        for (const item of items) {
          observer.next(item);
          if (observer.closed)
            return;
        }
        observer.complete();
      });
    });
  }
  static get [SymbolSpecies]() {
    return this;
  }
}
if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}
function unsubscribe(subscription) {
  if (typeof subscription === "function") {
    subscription();
  } else if (subscription && typeof subscription.unsubscribe === "function") {
    subscription.unsubscribe();
  }
}
class MulticastSubject extends Observable {
  constructor() {
    super((observer) => {
      this._observers.add(observer);
      return () => this._observers.delete(observer);
    });
    this._observers = /* @__PURE__ */ new Set();
  }
  next(value) {
    for (const observer of this._observers) {
      observer.next(value);
    }
  }
  error(error3) {
    for (const observer of this._observers) {
      observer.error(error3);
    }
  }
  complete() {
    for (const observer of this._observers) {
      observer.complete();
    }
  }
}
function multicast(coldObservable) {
  const subject = new MulticastSubject();
  let sourceSubscription;
  let subscriberCount = 0;
  return new Observable((observer) => {
    if (!sourceSubscription) {
      sourceSubscription = coldObservable.subscribe(subject);
    }
    const subscription = subject.subscribe(observer);
    subscriberCount++;
    return () => {
      subscriberCount--;
      subscription.unsubscribe();
      if (subscriberCount === 0) {
        unsubscribe(sourceSubscription);
        sourceSubscription = void 0;
      }
    };
  });
}
function max(strings, leftpad) {
  {
    const maxStringLength = Math.max(0, ...strings.map((str) => str.length));
    strings = strings.map((str) => str.padStart(maxStringLength, leftpad));
  }
  return strings.reduce((maxValue, thisValue) => {
    return maxValue === void 0 || thisValue > maxValue ? thisValue : maxValue;
  }, void 0);
}
function createCache(createCacheKey, isDataNewer = () => true) {
  const values2 = /* @__PURE__ */ new Map();
  const fetchs = /* @__PURE__ */ new Map();
  const errors2 = /* @__PURE__ */ new Map();
  const observables = /* @__PURE__ */ new Map();
  const cache2 = {
    clear() {
      values2.clear();
    },
    get(selector) {
      return values2.get(createCacheKey(selector));
    },
    has(selector) {
      return values2.has(createCacheKey(selector));
    },
    set(selector, value, force = false) {
      const cacheKey = createCacheKey(selector);
      const cached = values2.get(cacheKey);
      if (!value) {
        throw Error(
          "Trying to set a cache item value to something falsy. This will break `cache.get() || cache.suspend()` calls to the cache."
        );
      }
      if (!cached || isDataNewer(cached, value) || force) {
        values2.set(cacheKey, value);
      }
    },
    suspend(selector, fetcher) {
      const cacheKey = createCacheKey(selector);
      let loading = fetchs.get(cacheKey);
      if (errors2.has(cacheKey)) {
        throw errors2.get(cacheKey);
      }
      if (!loading) {
        loading = fetcher().then(
          (value) => {
            cache2.set(selector, value);
            return value;
          },
          (error3) => {
            errors2.set(cacheKey, error3);
            trackError(error3);
            throw error3;
          }
        );
        fetchs.set(cacheKey, loading);
      }
      throw loading;
    },
    observe(selector, observe) {
      const cacheKey = createCacheKey(selector);
      const cached = observables.get(cacheKey);
      if (cached) {
        return cached;
      } else {
        const multicasted = multicast(observe());
        observables.set(cacheKey, multicasted);
        return multicasted;
      }
    }
  };
  return cache2;
}
function createAccountCacheKey([horizonURLs, accountID]) {
  return `${horizonURLs.map((url2) => `${url2}:`)}${accountID}`;
}
function createAssetPairCacheKey([horizonURLs, selling, buying]) {
  return `${horizonURLs.map((url2) => `${url2}:`)}${stringifyAsset(selling)}:${stringifyAsset(buying)}`;
}
function areTransactionsNewer(prev, next) {
  const prevMaxTimestamp = (prev ? max(
    prev.transactions.map((tx) => tx.created_at),
    "0"
  ) : void 0) || "";
  const nextMaxTimestamp = max(
    next.transactions.map((tx) => tx.created_at),
    "0"
  ) || "";
  return !prev || nextMaxTimestamp > prevMaxTimestamp;
}
function areOffersNewer(prev, next) {
  const prevMaxTimestamp = (prev ? max(
    prev.offers.map((tx) => tx.last_modified_time),
    "0"
  ) : void 0) || "";
  const nextMaxTimestamp = max(
    next.offers.map((tx) => tx.last_modified_time),
    "0"
  ) || "";
  return !prev || nextMaxTimestamp > prevMaxTimestamp;
}
const accountDataCache = createCache(
  createAccountCacheKey
);
const accountHomeDomainCache = createCache(createAccountCacheKey);
const accountOpenOrdersCache = createCache(
  createAccountCacheKey,
  areOffersNewer
);
const accountTransactionsCache = createCache(createAccountCacheKey, areTransactionsNewer);
const orderbookCache = createCache(createAssetPairCacheKey);
const stellarTomlCache = createCache((domain) => domain);
const transferInfosCache = createCache((domain) => domain);
const tickerAssetsCache = createCache(
  (testnet) => testnet ? "testnet" : "pubnet"
);
const wellKnownAccountsCache = createCache(
  (testnet) => testnet ? "testnet" : "pubnet"
);
function resetNetworkCaches() {
  accountDataCache.clear();
  accountOpenOrdersCache.clear();
  accountTransactionsCache.clear();
  orderbookCache.clear();
}
function sweepStaleIndexItems(sortedIndex) {
  for (let i2 = 0; i2 < sortedIndex.length; i2++) {
    if (sortedIndex[i2].expiresAt > Date.now()) {
      return sortedIndex.slice(i2);
    }
  }
  return [];
}
function createPersistentCache(namespace, options2 = {}) {
  const LocalStorageIndexKey = () => `caches.index:${namespace}`;
  const LocalStorageItemKey = (key2) => `caches.values:${namespace}.${key2}`;
  let index2 = JSON.parse(localStorage.getItem(LocalStorageIndexKey()) || "[]");
  index2.sort((a, b) => (a.expiresAt || Number.POSITIVE_INFINITY) - (b.expiresAt || Number.POSITIVE_INFINITY));
  index2 = sweepStaleIndexItems(index2);
  return {
    delete(key2) {
      index2 = index2.filter((item) => item.key !== key2);
      localStorage.removeItem(LocalStorageItemKey(key2));
      localStorage.setItem(LocalStorageIndexKey(), JSON.stringify(index2));
    },
    keys() {
      return index2.map((item) => item.key);
    },
    read(key2) {
      const item = index2.find((someItem) => someItem.key === key2);
      if (!item || item.expiresAt <= Date.now()) {
        return null;
      }
      const value = localStorage.getItem(LocalStorageItemKey(key2));
      return value ? JSON.parse(value) : null;
    },
    save(key2, value, expiresInMs) {
      index2 = sweepStaleIndexItems(index2);
      if (value === void 0) {
        throw Error("Cannot cache an undefined value");
      }
      const expiresIn = expiresInMs || options2.expiresIn || 0;
      const expiresAt = expiresIn ? Date.now() + expiresIn : 0;
      const newIndexItem = {
        expiresAt,
        key: key2
      };
      index2 = index2.filter((item) => item.key !== key2);
      if (expiresAt === 0) {
        index2.push(newIndexItem);
      } else {
        const firstIndexExpiringLater = index2.findIndex((item) => item.expiresAt > expiresAt || item.expiresAt === 0);
        index2 = firstIndexExpiringLater === -1 ? [...index2, newIndexItem] : [...index2.slice(0, firstIndexExpiringLater), newIndexItem, ...index2.slice(firstIndexExpiringLater)];
      }
      if (options2.maxItems && index2.length >= options2.maxItems) {
        index2 = index2.slice(-options2.maxItems);
      }
      try {
        localStorage.setItem(LocalStorageItemKey(key2), JSON.stringify(value));
        localStorage.setItem(LocalStorageIndexKey(), JSON.stringify(index2));
      } catch (error3) {
        console.error("Could not save item in local storage: ", value, error3);
      }
    }
  };
}
const isPublicKey = (str) => Boolean(str.match(/^G[A-Z0-9]{55}$/));
const isMuxedAddress = (str) => Boolean(str.match(/^M[A-Z0-9]{68}$/));
const isStellarAddress = (str) => Boolean(str.match(/^[^\*> \t\n\r]+\*[^\*\.> \t\n\r]+\.[^\*> \t\n\r]+$/));
async function lookupFederationRecord(stellarAddress, lookupCache, reverseLookupCache) {
  const { netWorker: netWorker2 } = await workers;
  const cached = lookupCache.get(stellarAddress);
  if (cached) {
    return cached;
  }
  let resolved;
  try {
    resolved = await netWorker2.resolveStellarAddress(stellarAddress);
  } catch (error3) {
    if (error3 && error3.request && !error3.response) {
      throw CustomError(
        "StellarAddressRequestFailedError",
        `Request for resolving the stellar address failed: ${stellarAddress}`,
        {
          address: stellarAddress
        }
      );
    } else if (isNotFoundError(error3)) {
      throw CustomError("StellarAddressNotFoundError", `Stellar address not found: ${stellarAddress}`, {
        address: stellarAddress
      });
    } else {
      throw error3;
    }
  }
  lookupCache.set(stellarAddress, resolved);
  reverseLookupCache.set(resolved.account_id, stellarAddress);
  return resolved;
}
let netWorker;
function useNetWorker() {
  if (netWorker) {
    return netWorker;
  } else {
    throw workers.then((initializedWorkers) => {
      netWorker = initializedWorkers.netWorker;
    });
  }
}
function useHorizon(testnet = false) {
  const horizonURLs = useHorizonURLs(testnet);
  const horizonURL = horizonURLs[0];
  return testnet ? new libExports.Server(horizonURL) : new libExports.Server(horizonURL);
}
function useHorizonURLs(testnet = false) {
  const stellar = React.useContext(StellarContext);
  if (stellar.isSelectionPending) {
    throw stellar.pendingSelection;
  }
  const horizonURLs = testnet ? stellar.testnetHorizonURLs : stellar.pubnetHorizonURLs;
  return horizonURLs;
}
function useFederationLookup() {
  const lookup9 = React.useContext(StellarAddressCacheContext);
  const reverseLookup = React.useContext(StellarAddressReverseCacheContext);
  return {
    lookupFederationRecord(stellarAddress) {
      return lookupFederationRecord(stellarAddress, lookup9.cache, reverseLookup.cache);
    },
    lookupStellarAddress(publicKey) {
      return reverseLookup.cache.get(publicKey);
    }
  };
}
function useWebAuth() {
  const signingKeys = React.useContext(SigningKeyCacheContext);
  const webauthTokens = React.useContext(WebAuthTokenCacheContext);
  const createCacheKey = React.useCallback(
    (endpointURL, localPublicKey) => `${endpointURL}:${localPublicKey}`,
    []
  );
  return {
    async fetchChallenge(endpointURL, serviceSigningKey, localPublicKey, network2) {
      const { netWorker: netWorker2 } = await workers;
      const challenge = await netWorker2.fetchWebAuthChallenge(endpointURL, serviceSigningKey, localPublicKey, network2);
      return new libExports.Transaction(challenge, network2);
    },
    async fetchWebAuthData(horizonURL, issuerAccountID) {
      const { netWorker: netWorker2 } = await workers;
      const metadata = await netWorker2.fetchWebAuthData(horizonURL, issuerAccountID);
      if (metadata && metadata.signingKey) {
        signingKeys.store(metadata.signingKey, metadata.domain);
      }
      return metadata;
    },
    getCachedAuthToken(endpointURL, localPublicKey) {
      return webauthTokens.cache.get(createCacheKey(endpointURL, localPublicKey));
    },
    async postResponse(endpointURL, transaction2, testnet) {
      const { netWorker: netWorker2 } = await workers;
      const manageDataOperation = transaction2.operations.find((operation2) => operation2.type === "manageData");
      const localPublicKey = manageDataOperation ? manageDataOperation.source : void 0;
      const network2 = testnet ? libExports.Networks.TESTNET : libExports.Networks.PUBLIC;
      const txXdr = transaction2.toEnvelope().toXDR().toString("base64");
      const { authToken, decoded } = await netWorker2.postWebAuthResponse(endpointURL, txXdr, network2);
      if (localPublicKey) {
        const maxAge = decoded.exp ? Number.parseInt(decoded.exp, 10) * 1e3 - Date.now() - 6e4 : void 0;
        webauthTokens.store(createCacheKey(endpointURL, localPublicKey), authToken, maxAge);
      }
      return authToken;
    }
  };
}
const stellarTomlPersistentCache = createPersistentCache("stellar.toml", {
  expiresIn: 24 * 60 * 6e4,
  maxItems: 50
});
function useStellarToml(domain) {
  if (!domain) {
    return void 0;
  }
  const fetchStellarTomlData = async () => {
    const { netWorker: netWorker2 } = await workers;
    const stellarTomlData = await netWorker2.fetchStellarToml(domain);
    stellarTomlPersistentCache.save(domain, stellarTomlData || null);
    return [true, stellarTomlData];
  };
  const cached = stellarTomlCache.get(domain);
  if (cached && cached[0]) {
    return cached[1];
  }
  return stellarTomlPersistentCache.read(domain) || stellarTomlCache.suspend(domain, fetchStellarTomlData);
}
function useAccountData(accountID, testnet) {
  const horizonURLs = useHorizonURLs(testnet);
  const netWorker2 = useNetWorker();
  const selector = [horizonURLs, accountID];
  const cached = accountDataCache.get(selector);
  const prepare2 = (account2) => account2 ? {
    ...account2,
    balances: account2.balances.filter(
      (balance) => balance.asset_type !== "liquidity_pool_shares"
    ),
    data_attr: account2.data
  } : createEmptyAccountData(accountID);
  if (!cached) {
    accountDataCache.suspend(selector, () => netWorker2.fetchAccountData(horizonURLs, accountID).then(prepare2));
  }
  return cached || createEmptyAccountData(accountID);
}
const homeDomainCachePubnet = createPersistentCache("home_domain:pubnet", { expiresIn: 24 * 60 * 6e4 });
const homeDomainCacheTestnet = createPersistentCache("home_domain:testnet", { expiresIn: 24 * 60 * 6e4 });
function useAccountHomeDomains(accountIDs, testnet, allowIncompleteResult) {
  const horizonURLs = useHorizonURLs(testnet);
  const netWorker2 = useNetWorker();
  const [, setRerenderCounter] = React.useState(0);
  const forceRerender = () => setRerenderCounter((counter) => counter + 1);
  const fetchHomeDomain = async (accountID) => {
    const accountData = await netWorker2.fetchAccountData(horizonURLs, accountID);
    const homeDomain = accountData ? accountData.home_domain : void 0;
    if (homeDomain) {
      (testnet ? homeDomainCacheTestnet : homeDomainCachePubnet).save(accountID, homeDomain || null);
    }
    if (allowIncompleteResult) {
      forceRerender();
    }
    return homeDomain ? [homeDomain] : [];
  };
  try {
    return mapSuspendables(accountIDs, (accountID) => {
      const selector = [horizonURLs, accountID];
      return (accountHomeDomainCache.get(selector) || accountHomeDomainCache.suspend(selector, () => fetchHomeDomain(accountID)))[0];
    });
  } catch (thrown) {
    if (allowIncompleteResult && thrown && typeof thrown.then === "function") {
      const persistentlyCached = accountIDs.map(
        (accountID) => (testnet ? homeDomainCacheTestnet : homeDomainCachePubnet).read(accountID)
      );
      if (persistentlyCached.every((element) => typeof element === "string" && element)) {
        return persistentlyCached;
      }
    }
    throw thrown;
  }
}
function useAccountHomeDomain(accountID, testnet, allowIncompleteResult) {
  return useAccountHomeDomains(accountID ? [accountID] : [], testnet, allowIncompleteResult)[0];
}
function useAccountHomeDomainSafe(accountID, testnet, allowIncompleteResult) {
  const homeDomain = useAccountHomeDomain(accountID, testnet, allowIncompleteResult);
  const stellarToml = useStellarToml(homeDomain);
  const matchesIssuingAccount = stellarToml && (stellarToml.CURRENCIES || []).some((currency) => currency.issuer === accountID);
  const matchesSigningKey = stellarToml && (stellarToml.SIGNING_KEY === accountID || stellarToml.URI_REQUEST_SIGNING_KEY === accountID);
  return homeDomain && (matchesIssuingAccount || matchesSigningKey) ? homeDomain : void 0;
}
function useAssetMetadata(asset2, testnet) {
  const assetCode = !asset2 || asset2.isNative() ? void 0 : asset2.getCode();
  const issuerAccountID = !asset2 || asset2.isNative() ? void 0 : asset2.getIssuer();
  const homeDomain = useAccountHomeDomain(issuerAccountID, testnet, true);
  const stellarTomlData = useStellarToml(homeDomain);
  if (stellarTomlData && stellarTomlData["CURRENCIES"] && Array.isArray(stellarTomlData["CURRENCIES"])) {
    const assetMetadata = stellarTomlData["CURRENCIES"].find(
      (currency) => currency.code === assetCode && currency.issuer === issuerAccountID
    );
    return assetMetadata;
  } else {
    return void 0;
  }
}
function withDecodedTx(tx, network2) {
  const decoded = libExports.TransactionBuilder.fromXDR(tx.envelope_xdr, network2);
  return {
    ...tx,
    decodedTx: decoded instanceof libExports.FeeBumpTransaction ? decoded.innerTransaction : decoded
  };
}
function useDataSubscriptions(reducer, items) {
  const unfinishedFetches = [];
  const [, setRefreshCounter] = useDebouncedState(0, 100);
  const currentDataSets = mapSuspendables(items, (item) => item.get());
  if (unfinishedFetches.length > 0) {
    throw unfinishedFetches.length === 1 ? unfinishedFetches[0] : Promise.all(unfinishedFetches);
  }
  React.useEffect(() => {
    items.map((item) => {
      return item.observe().subscribe({
        next(update2) {
          item.set(reducer(item.get(), update2));
          setRefreshCounter((counter) => counter + 1);
        },
        error(error3) {
          console.error(error3);
        }
      });
    });
    return () => {
    };
  }, [reducer, items, setRefreshCounter]);
  return currentDataSets;
}
function useDataSubscription(reducer, get3, set3, observe) {
  const items = React.useMemo(() => [{ get: get3, set: set3, observe }], [get3, set3, observe]);
  return useDataSubscriptions(reducer, items)[0];
}
function applyAccountDataUpdate(prev, next) {
  return next;
}
function useLiveAccountDataSet(accountIDs, testnet) {
  const horizonURLs = useHorizonURLs(testnet);
  const netWorker2 = useNetWorker();
  const items = React.useMemo(
    () => accountIDs.map((accountID) => {
      const selector = [horizonURLs, accountID];
      const prepare2 = (account2) => {
        return account2 ? {
          ...account2,
          balances: account2.balances.filter(
            (balance) => balance.asset_type !== "liquidity_pool_shares"
          ),
          data_attr: account2.data
        } : createEmptyAccountData(accountID);
      };
      return {
        get() {
          return accountDataCache.get(selector) || accountDataCache.suspend(selector, () => netWorker2.fetchAccountData(horizonURLs, accountID).then(prepare2));
        },
        set(updated) {
          accountDataCache.set(selector, updated);
        },
        observe() {
          return accountDataCache.observe(
            selector,
            () => netWorker2.subscribeToAccount(horizonURLs, accountID).map(prepare2)
          );
        }
      };
    }),
    [accountIDs, horizonURLs, netWorker2]
  );
  return useDataSubscriptions(applyAccountDataUpdate, items);
}
function useLiveAccountData(accountID, testnet) {
  return useLiveAccountDataSet([accountID], testnet)[0];
}
function applyAccountOffersUpdate(prev, next) {
  return { olderOffersAvailable: prev.olderOffersAvailable, offers: next };
}
function useLiveAccountOffers(accountID, testnet) {
  const horizonURLs = useHorizonURLs(testnet);
  const netWorker2 = useNetWorker();
  const { get: get3, set: set3, observe } = React.useMemo(() => {
    const selector = [horizonURLs, accountID];
    const limit = 10;
    return {
      get() {
        return accountOpenOrdersCache.get(selector) || accountOpenOrdersCache.suspend(selector, async () => {
          const page = await netWorker2.fetchAccountOpenOrders(horizonURLs, accountID, { limit, order: "desc" });
          const offers = page._embedded.records;
          return {
            olderOffersAvailable: offers.length === limit,
            offers
          };
        });
      },
      set(updated) {
        const olderOffersAvailable = updated.offers.length === limit;
        accountOpenOrdersCache.set(selector, { ...updated, olderOffersAvailable });
      },
      observe() {
        return netWorker2.subscribeToOpenOrders(horizonURLs, accountID);
      }
    };
  }, [accountID, horizonURLs, netWorker2]);
  return useDataSubscription(applyAccountOffersUpdate, get3, set3, observe);
}
function useOlderOffers(accountID, testnet) {
  const forceRerender = useForceRerender();
  const horizonURLs = useHorizonURLs(testnet);
  const netWorker2 = useNetWorker();
  const fetchMoreOffers = React.useCallback(
    async function fetchMoreOffers2() {
      var _a;
      let fetched;
      const selector = [horizonURLs, accountID];
      const history = accountOpenOrdersCache.get(selector);
      const limit = 10;
      const prevOffers = (history == null ? void 0 : history.offers) || [];
      fetched = await (prevOffers.length > 0 ? netWorker2.fetchAccountOpenOrders(horizonURLs, accountID, {
        cursor: prevOffers[prevOffers.length - 1].paging_token,
        limit,
        order: "desc"
      }) : netWorker2.fetchAccountOpenOrders(horizonURLs, accountID, {
        limit,
        order: "desc"
      }));
      const fetchedOffers = fetched._embedded.records;
      accountOpenOrdersCache.set(
        selector,
        {
          // not an accurate science right now…
          olderOffersAvailable: fetchedOffers.length === limit,
          offers: [...((_a = accountOpenOrdersCache.get(selector)) == null ? void 0 : _a.offers) || [], ...fetchedOffers]
        },
        true
      );
      forceRerender();
    },
    [accountID, forceRerender, horizonURLs, netWorker2]
  );
  return fetchMoreOffers;
}
function useLiveAccountEffects(accounts, handler) {
  const netWorker2 = useNetWorker();
  const mainnetHorizonURLs = useHorizonURLs(false);
  const testnetHorizonURLs = useHorizonURLs(true);
  React.useEffect(() => {
    const subscriptions = accounts.map((account2) => {
      const horizonURLs = account2.testnet ? testnetHorizonURLs : mainnetHorizonURLs;
      const observable = netWorker2.subscribeToAccountEffects(horizonURLs, account2.accountID);
      const subscription = observable.subscribe((effect) => effect && handler(account2, effect));
      return subscription;
    });
    return () => subscriptions.forEach((subscription) => subscription.unsubscribe());
  }, [accounts, handler, mainnetHorizonURLs, netWorker2, testnetHorizonURLs]);
}
function applyOrderbookUpdate(prev, next) {
  return next;
}
function useLiveOrderbook(selling, buying, testnet) {
  const horizonURLs = useHorizonURLs(testnet);
  const netWorker2 = useNetWorker();
  const { get: get3, set: set3, observe } = React.useMemo(() => {
    const selector = [horizonURLs, selling, buying];
    return {
      get() {
        return orderbookCache.get(selector) || orderbookCache.suspend(
          selector,
          () => netWorker2.fetchOrderbookRecord(horizonURLs, stringifyAsset(selling), stringifyAsset(buying))
        );
      },
      set(updated) {
        orderbookCache.set(selector, updated);
      },
      observe() {
        return netWorker2.subscribeToOrderbook(horizonURLs, stringifyAsset(selling), stringifyAsset(buying));
      }
    };
  }, [stringifyAsset(buying), horizonURLs, netWorker2, stringifyAsset(selling)]);
  return useDataSubscription(applyOrderbookUpdate, get3, set3, observe);
}
const txsMatch = (a, b) => {
  return a.source_account === b.source_account && a.source_account_sequence === b.source_account_sequence;
};
function applyAccountTransactionsUpdate(network2) {
  return (prev, update2) => {
    return prev.transactions.some((tx) => txsMatch(tx, update2)) ? prev : {
      ...prev,
      transactions: [withDecodedTx(update2, network2), ...prev.transactions]
    };
  };
}
function useLiveRecentTransactions(accountID, testnet, refetchKey = 0) {
  const horizonURLs = useHorizonURLs(testnet);
  const netWorker2 = useNetWorker();
  const network2 = testnet ? libExports.Networks.TESTNET : libExports.Networks.PUBLIC;
  const { get: get3, set: set3, observe } = React.useMemo(() => {
    const limit = 15;
    const selector = [horizonURLs, accountID];
    return {
      get() {
        return accountTransactionsCache.get(selector) || accountTransactionsCache.suspend(selector, async () => {
          const page = await netWorker2.fetchAccountTransactions(horizonURLs, accountID, {
            emptyOn404: true,
            limit,
            order: "desc"
          });
          const transactions2 = page._embedded.records;
          return {
            // not an accurate science right now…
            olderTransactionsAvailable: transactions2.length === limit,
            transactions: transactions2.map((tx) => withDecodedTx(tx, network2))
          };
        });
      },
      set(updated) {
        accountTransactionsCache.set(selector, updated);
      },
      observe() {
        return netWorker2.subscribeToAccountTransactions(horizonURLs, accountID);
      }
    };
  }, [accountID, horizonURLs, netWorker2, refetchKey]);
  return useDataSubscription(applyAccountTransactionsUpdate(network2), get3, set3, observe);
}
function useOlderTransactions(accountID, testnet) {
  const forceRerender = useForceRerender();
  const horizonURLs = useHorizonURLs(testnet);
  const netWorker2 = useNetWorker();
  const network2 = testnet ? libExports.Networks.TESTNET : libExports.Networks.PUBLIC;
  const fetchMoreTransactions = React.useCallback(
    async function fetchMoreTransactions2() {
      let fetched;
      const selector = [horizonURLs, accountID];
      const history = accountTransactionsCache.get(selector);
      const limit = 15;
      const prevTransactions = (history == null ? void 0 : history.transactions) || [];
      if (prevTransactions.length > 0) {
        try {
          fetched = await netWorker2.fetchAccountTransactions(horizonURLs, accountID, {
            emptyOn404: true,
            emptyOn410: true,
            cursor: prevTransactions[prevTransactions.length - 1].paging_token,
            limit: 15,
            order: "desc"
          });
        } catch (e) {
          fetched = { _embedded: { records: [] } };
        }
      } else {
        fetched = await netWorker2.fetchAccountTransactions(horizonURLs, accountID, {
          emptyOn404: true,
          emptyOn410: true,
          limit,
          order: "desc"
        });
      }
      const fetchedTransactions = fetched._embedded.records;
      const transactions2 = fetchedTransactions.filter((record) => !prevTransactions.some((prevTx) => txsMatch(prevTx, record))).map((tx) => withDecodedTx(tx, network2));
      accountTransactionsCache.set(
        selector,
        {
          // not an accurate science right now…
          olderTransactionsAvailable: fetchedTransactions.length === limit,
          transactions: [...prevTransactions, ...transactions2]
        },
        true
      );
      forceRerender();
      return transactions2;
    },
    [accountID, forceRerender, horizonURLs, netWorker2]
  );
  return fetchMoreTransactions;
}
function useNetworkCacheReset() {
  return resetNetworkCaches;
}
const initialHorizonSelection = (async () => {
  const { netWorker: netWorker2 } = await workers;
  const pubnetHorizonURLs = Array.from(
    new Set(
      await Promise.all([
        "https://horizon.stellar.org",
        netWorker2.checkHorizonOrFailover("https://horizon.stellarx.com", "https://horizon.stellar.org"),
        netWorker2.checkHorizonOrFailover("https://horizon.stellar.lobstr.co", "https://horizon.stellar.org")
      ])
    )
  );
  const testnetHorizonURLs = ["https://horizon-testnet.stellar.org"];
  return Promise.all([pubnetHorizonURLs, testnetHorizonURLs]);
})();
initialHorizonSelection.catch(trackError);
const initialValues$3 = {
  isSelectionPending: true,
  pendingSelection: initialHorizonSelection,
  pubnetHorizonURLs: ["https://horizon.stellar.org"],
  testnetHorizonURLs: ["https://stellar-horizon-testnet.satoshipay.io/"]
};
const StellarContext = React.createContext(initialValues$3);
function StellarProvider(props) {
  const [contextValue, setContextValue] = React.useState(initialValues$3);
  const resetNetworkCaches2 = useNetworkCacheReset();
  React.useEffect(() => {
    let cancelled = false;
    const init2 = async () => {
      const { netWorker: netWorker2 } = await workers;
      setContextValue((prevState) => ({ ...prevState, pendingSelection: initialHorizonSelection }));
      const [pubnetHorizonURLs, testnetHorizonURLs] = await initialHorizonSelection;
      if (!cancelled) {
        setContextValue((prevState) => ({
          isSelectionPending: false,
          pendingSelection: prevState.pendingSelection,
          pubnetHorizonURLs: pubnetHorizonURLs !== prevState.pubnetHorizonURLs ? pubnetHorizonURLs : prevState.pubnetHorizonURLs,
          testnetHorizonURLs: testnetHorizonURLs !== prevState.testnetHorizonURLs ? testnetHorizonURLs : prevState.testnetHorizonURLs
        }));
        if (pubnetHorizonURLs !== initialValues$3.pubnetHorizonURLs || testnetHorizonURLs !== initialValues$3.testnetHorizonURLs) {
          await netWorker2.resetAllSubscriptions();
          resetNetworkCaches2();
        }
        console.debug(`Selected horizon servers:`, { pubnetHorizonURLs, testnetHorizonURLs });
      }
    };
    if (navigator.onLine !== false) {
      init2().catch(trackError);
    }
    const unsubscribe2 = () => {
      cancelled = true;
    };
    return unsubscribe2;
  }, [resetNetworkCaches2]);
  return /* @__PURE__ */ React.createElement(StellarContext.Provider, { value: contextValue }, props.children);
}
class ReplacementsParser {
  static parse(str) {
    if (!str) {
      return [];
    }
    const [txReplaceStr, hintsStr] = str.split(ReplacementsParser.TXN_HINT_SEPARATOR);
    const hintParts = hintsStr.split(ReplacementsParser.LIST_SEPARATOR);
    const hintsMap = /* @__PURE__ */ new Map();
    hintParts.map((part) => part.split(ReplacementsParser.ID_SEPARATOR)).forEach(([id, hint]) => hintsMap.set(id, hint));
    const txReplacmentParts = txReplaceStr.split(ReplacementsParser.LIST_SEPARATOR);
    const replacements = txReplacmentParts.map((part) => part.split(ReplacementsParser.ID_SEPARATOR)).map(([path2, id]) => ({ id, path: path2, hint: hintsMap.get(id) }));
    return replacements;
  }
  static toString(replacements) {
    if (!replacements || replacements.length === 0) {
      return "";
    }
    const txns = replacements.map((r) => `${r.path}${ReplacementsParser.ID_SEPARATOR}${r.id}`).join(ReplacementsParser.LIST_SEPARATOR);
    const hintMap = /* @__PURE__ */ new Map();
    for (const r of replacements) {
      hintMap.set(r.id, r.hint);
    }
    const hints = Array.from(hintMap.entries()).map(([id, hint]) => `${id}${ReplacementsParser.ID_SEPARATOR}${hint}`).join(ReplacementsParser.LIST_SEPARATOR);
    return `${txns}${ReplacementsParser.TXN_HINT_SEPARATOR}${hints}`;
  }
}
ReplacementsParser.TXN_HINT_SEPARATOR = ";";
ReplacementsParser.ID_SEPARATOR = ":";
ReplacementsParser.LIST_SEPARATOR = ",";
var StellarUriType;
(function(StellarUriType2) {
  StellarUriType2["Transaction"] = "tx";
  StellarUriType2["Pay"] = "pay";
})(StellarUriType || (StellarUriType = {}));
class StellarUri {
  constructor(uri2) {
    this.uri = typeof uri2 === "string" ? new URL(uri2) : new URL(uri2.toString());
  }
  /**
   * Gets the operation type of the URI.
   *
   */
  get operation() {
    return this.uri.pathname;
  }
  /**
   * Gets the callback for this URI.
   *
   * Note: This returns the callback *without* the 'url:' prefix that may be present in the callback.
   *
   * Optional.
   */
  get callback() {
    const callback = this.getParam("callback");
    if (callback && callback.startsWith("url:")) {
      return callback.replace("url:", "");
    }
    return callback;
  }
  /**
   * Sets the callback for this URI.
   *
   * Note: You may set it with or without the 'url:' prefix. If the prefix is not present it will added in the final URI string.
   *
   * Optional.
   */
  set callback(callback) {
    if (callback !== void 0) {
      if (callback.startsWith("url:")) {
        this.setParam("callback", callback);
      } else {
        this.setParam("callback", `url:${callback}`);
      }
    } else {
      this.setParam("callback", void 0);
    }
  }
  /**
   * Gets the network passphrase of the Stellar network to use for this request.
   *
   * If this is not set, the Stellar public network should be assumed.
   *
   * Optional.
   */
  get networkPassphrase() {
    return this.getParam("network_passphrase");
  }
  /**
   * Sets the network passphrase of the Stellar network to use for this request.
   *
   * Optional.
   */
  set networkPassphrase(networkPassphrase) {
    this.setParam("network_passphrase", networkPassphrase);
  }
  /**
   * Returns whether or not the network_passphase for this URI indicates that it is on the public network.
   *
   * This is true if network_passphrase is not set or if it's set to the public network's passphrase.
   */
  get isPublicNetwork() {
    return !this.networkPassphrase || this.networkPassphrase === libExports.Networks.PUBLIC;
  }
  /**
   * Sets the network_passphrase to be the passphrase of the public network.
   */
  usePublicNetwork() {
    this.networkPassphrase = libExports.Networks.PUBLIC;
  }
  /**
   * Returns whether or not the network_passphase for this URI indicates that it is on the test network.
   */
  get isTestNetwork() {
    return this.networkPassphrase === libExports.Networks.TESTNET;
  }
  /**
   * Sets the network_passphrase to be the passphrase of the test network.
   */
  useTestNetwork() {
    this.networkPassphrase = libExports.Networks.TESTNET;
  }
  /**
   * Gets which public key you want the URI handler to sign for.
   *
   * Optional.
   */
  get pubkey() {
    return this.getParam("pubkey");
  }
  /**
   * Sets which public key you want the URI handler to sign for.
   *
   * Optional.
   */
  set pubkey(pubkey) {
    this.setParam("pubkey", pubkey);
  }
  /**
   * Gets the message to show to the user.
   *
   * Optional.
   */
  get msg() {
    return this.getParam("msg");
  }
  /**
   * Sets the message to show to the user.
   * This must be 300 characters or less.
   *
   * Optional.
   */
  set msg(msg) {
    if (msg && msg.length > 300) {
      throw new Error(`'msg' should be no longer than 300 characters.`);
    }
    this.setParam("msg", msg);
  }
  /**
   * Gets the fully qualified domain name that specifies the originating domain of the URI request.
   *
   * Wallets must validate the URI request against the included signature before they display the origin_domain to the user.
   */
  get originDomain() {
    return this.getParam("origin_domain");
  }
  /**
   * Sets the fully qualified domain name that specifies the originating domain of the URI request.
   */
  set originDomain(originDomain) {
    this.setParam("origin_domain", originDomain);
  }
  /**
   * A signature of the hash of the URI request (excluding the signature field and value itself).
   *
   * Wallets should use the URI_REQUEST_SIGNING_KEY specified in the domain's stellar.toml file to validate this signature.
   * If the verification fails, wallets must alert the user.
   *
   * @see https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0007.md#request-signing
   */
  get signature() {
    return this.getParam("signature");
  }
  /**
   * Signs the URI with the given keypair.
   * This should be the last step done before generating the URI string, otherwise the signature will be invalid for the URI.
   *
   * @param keypair The keypair (including secret key), used to sign the request. This should be the keypair found in the URI_REQUEST_SIGNING_KEY field of the origin domains' stellar.toml.
   */
  addSignature(keypair2) {
    const payload = this.createSignaturePayload();
    const signature2 = keypair2.sign(payload).toString("base64");
    this.setParam("signature", signature2);
    return signature2;
  }
  /**
   * Verifies a that the signature added to the URI is valid.
   *
   * Returns true if the signature is valid for the current URI and origin domain, or if there is no origin domain and signature.
   * Returns false if signature verification fails, or if there is a problem looking up the stellar.toml associated with the origin domain.
   */
  async verifySignature() {
    const originDomain = this.originDomain;
    const signature2 = this.signature;
    if (!originDomain && !signature2) {
      return true;
    }
    if (!originDomain || !signature2) {
      return false;
    }
    try {
      const toml2 = await libExports.StellarTomlResolver.resolve(originDomain);
      const signingKey = toml2.URI_REQUEST_SIGNING_KEY;
      if (!signingKey) {
        return false;
      }
      const keypair2 = libExports.Keypair.fromPublicKey(signingKey);
      const payload = this.createSignaturePayload();
      return keypair2.verify(payload, Buffer.from(signature2, "base64"));
    } catch (e) {
      return false;
    }
  }
  /**
   * Sets the "replace" key, which is a list of fields in the transaction that needs to be replaced.
   *
   * @param replacements A list of replacements to set.
   */
  setReplacements(replacements) {
    if (replacements.length === 0) {
      this.setParam("replace");
    } else {
      this.setParam("replace", ReplacementsParser.toString(replacements));
    }
  }
  /**
   * Gets a list of fields in the transaction that need to be replaced.
   */
  getReplacements() {
    return ReplacementsParser.parse(this.getParam("replace"));
  }
  /**
   * Adds an additional replacement.
   *
   * @param replacement The replacement to add.
   */
  addReplacement(replacement) {
    const replacements = this.getReplacements();
    replacements.push(replacement);
    this.setReplacements(replacements);
  }
  /**
   * Removes all replacements with the given identifier.
   *
   * @param id The identifier to remove.
   */
  removeReplacement(id) {
    const replacements = this.getReplacements().filter((r) => r.id !== id);
    this.setReplacements(replacements);
  }
  /**
   * Returns the URI as a string.
   */
  toString() {
    return this.uri.toString();
  }
  getParam(key2) {
    return this.uri.searchParams.get(key2) || void 0;
  }
  setParam(key2, value) {
    if (value === void 0) {
      this.uri.searchParams.delete(key2);
    } else {
      this.uri.searchParams.set(key2, value);
    }
  }
  createSignaturePayload() {
    let data = this.uri.toString();
    const signature2 = this.signature;
    if (signature2) {
      data = data.replace(`&signature=${encodeURIComponent(signature2)}`, "");
    }
    return Buffer.concat([
      Buffer.alloc(35),
      Buffer.alloc(1, 4),
      Buffer.from("stellar.sep.7 - URI Scheme" + data)
    ]);
  }
}
var bignumberExports = requireBignumber();
const BigNumber = /* @__PURE__ */ getDefaultExportFromCjs$1(bignumberExports);
const MAX_INT = (1 << 31 >>> 0) - 1;
function best_r(rawNumber) {
  let number = new BigNumber(rawNumber);
  let a;
  let f;
  const fractions = [
    [new BigNumber(0), new BigNumber(1)],
    [new BigNumber(1), new BigNumber(0)]
  ];
  let i2 = 2;
  while (true) {
    if (number.gt(MAX_INT)) {
      break;
    }
    a = number.floor();
    f = number.sub(a);
    const h = a.mul(fractions[i2 - 1][0]).add(fractions[i2 - 2][0]);
    const k = a.mul(fractions[i2 - 1][1]).add(fractions[i2 - 2][1]);
    if (h.gt(MAX_INT) || k.gt(MAX_INT)) {
      break;
    }
    fractions.push([h, k]);
    if (f.eq(0)) {
      break;
    }
    number = new BigNumber(1).div(f);
    i2 += 1;
  }
  const [n, d] = fractions[fractions.length - 1];
  if (n.isZero() || d.isZero()) {
    throw new Error("Couldn't find approximation");
  }
  return [n.toNumber(), d.toNumber()];
}
function set$1(obj, path2, value) {
  if (Object(obj) !== obj)
    return obj;
  if (!Array.isArray(path2))
    path2 = path2.toString().match(/[^.[\]]+/g) || [];
  path2.slice(0, -1).reduce(
    (a, c, i2) => Object(a[c]) === a[c] ? (
      // Yes: then follow that path
      a[c]
    ) : (
      // No: create the key. Is the next key a potential array-index?
      a[c] = Math.abs(path2[i2 + 1]) >> 0 === +path2[i2 + 1] ? [] : {}
    ),
    // No: assign a new plain object
    obj
  )[path2[path2.length - 1]] = value;
  return obj;
}
function upperSnakeCase(str) {
  if (!str)
    return "";
  return String(str).replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, "").replace(/([a-z])([A-Z])/g, (_m, a, b) => a + "_" + b.toLowerCase()).replace(/[^A-Za-z0-9]+|_+/g, "_").toUpperCase();
}
function toTxrep(transaction2) {
  const lines = [];
  addLine("tx.sourceAccount", transaction2.source, lines);
  addLine("tx.fee", transaction2.fee, lines);
  addLine("tx.seqNum", transaction2.sequence, lines);
  addTimeBounds(transaction2.timeBounds, lines);
  addMemo(transaction2.memo, lines);
  addOperations(transaction2.operations, lines);
  addLine("tx.ext.v", 0, lines);
  addSignatures(transaction2.signatures, lines);
  return lines.join("\n");
}
function addLine(key2, value, lines) {
  if (value !== void 0) {
    lines.push(`${key2}: ${value}`);
  }
}
function addTimeBounds(timeBounds, lines) {
  if (timeBounds != null) {
    addLine("tx.timeBounds._present", true, lines);
    addLine("tx.timeBounds.minTime", timeBounds.minTime, lines);
    addLine("tx.timeBounds.maxTime", timeBounds.maxTime, lines);
  } else {
    addLine("tx.timeBounds._present", false, lines);
  }
}
function addMemo(memo2, lines) {
  switch (memo2.type) {
    case "none":
      addLine("tx.memo.type", "MEMO_NONE", lines);
      return;
    case "text":
      addLine("tx.memo.type", "MEMO_TEXT", lines);
      addLine("tx.memo.text", JSON.stringify(memo2.value.toString("utf-8")), lines);
      return;
    case "id":
      addLine("tx.memo.type", "MEMO_ID", lines);
      addLine("tx.memo.id", memo2.value, lines);
      return;
    case "hash":
      addLine("tx.memo.type", "MEMO_HASH", lines);
      addLine("tx.memo.hash", toOpaque(memo2.value), lines);
      return;
    case "return":
      addLine("tx.memo.type", "MEMO_RETURN", lines);
      addLine("tx.memo.retHash", toOpaque(memo2.value), lines);
      return;
  }
}
function addOperations(operations2, lines) {
  addLine("tx.operations.len", operations2.length, lines);
  operations2.forEach((operation2, i2) => {
    addOperation(operation2, i2, lines);
  });
}
function addOperation(operation2, i2, lines) {
  const prefix2 = `tx.operations[${i2}]`;
  const addOpLine = (k, v) => addLine(`${prefix2}.${k}`, v, lines);
  if (operation2.source) {
    addOpLine("sourceAccount._present", true);
    addOpLine("sourceAccount", operation2.source);
  } else {
    addOpLine("sourceAccount._present", false);
  }
  const type2 = upperSnakeCase(operation2.type);
  addOpLine("body.type", type2);
  const addBodyLine = (k, v, optional = false) => {
    const key2 = `body.${operation2.type}Op.${k}`;
    if (optional) {
      const present = v !== null && v !== void 0;
      addOpLine(`${key2}._present`, present);
      if (present) {
        addOpLine(key2, v);
      }
    } else {
      addOpLine(key2, v);
    }
  };
  switch (operation2.type) {
    case "createAccount":
      addCreateAccountOperation(operation2, addBodyLine);
      return;
    case "payment":
      addPaymentOperation(operation2, addBodyLine);
      return;
    case "pathPaymentStrictReceive":
      addPathPaymentStrictReceiveOp(operation2, addBodyLine);
      return;
    case "pathPaymentStrictSend":
      addPathPaymentStrictSendOp(operation2, addBodyLine);
      return;
    case "manageSellOffer":
      addManageSellOfferOp(operation2, addBodyLine);
      return;
    case "createPassiveSellOffer":
      addCreatePassiveSellOfferOp(operation2, addBodyLine);
      return;
    case "setOptions":
      addSetOptionsOp(operation2, addBodyLine);
      return;
    case "changeTrust":
      addChangeTrustOp(operation2, addBodyLine);
      return;
    case "allowTrust":
      addAllowTrustOp(operation2, addBodyLine);
      return;
    case "accountMerge":
      addAccountMergeOp(operation2, addOpLine);
      return;
    case "manageData":
      addManageDataOp(operation2, addBodyLine);
      return;
    case "bumpSequence":
      addBumpSequenceOp(operation2, addBodyLine);
      return;
    case "manageBuyOffer":
      addManageBuyOfferOp(operation2, addBodyLine);
      return;
    default:
      throw Error(`${operation2.type} is not implemented`);
  }
}
function addCreateAccountOperation(operation2, addBodyLine) {
  addBodyLine("destination", operation2.destination);
  addBodyLine("startingBalance", toAmount$1(operation2.startingBalance));
}
function addPaymentOperation(operation2, addBodyLine) {
  addBodyLine("destination", operation2.destination);
  addBodyLine("asset", toAsset$1(operation2.asset));
  addBodyLine("amount", toAmount$1(operation2.amount));
}
function addPathPaymentStrictReceiveOp(operation2, addBodyLine) {
  addBodyLine("sendAsset", toAsset$1(operation2.sendAsset));
  addBodyLine("sendMax", toAmount$1(operation2.sendMax));
  addBodyLine("destination", operation2.destination);
  addBodyLine("destAsset", toAsset$1(operation2.destAsset));
  addBodyLine("destAmount", toAmount$1(operation2.destAmount));
  addBodyLine("path.len", operation2.path.length);
  operation2.path.forEach((asset2, i2) => {
    addBodyLine(`path[${i2}]`, toAsset$1(asset2));
  });
}
function addPathPaymentStrictSendOp(operation2, addBodyLine) {
  addBodyLine("sendAsset", toAsset$1(operation2.sendAsset));
  addBodyLine("sendAmount", toAmount$1(operation2.sendAmount));
  addBodyLine("destination", operation2.destination);
  addBodyLine("destAsset", toAsset$1(operation2.destAsset));
  addBodyLine("destMin", toAmount$1(operation2.destMin));
  addBodyLine("path.len", operation2.path.length);
  operation2.path.forEach((asset2, i2) => {
    addBodyLine(`path[${i2}]`, toAsset$1(asset2));
  });
}
function addManageSellOfferOp(operation2, addBodyLine) {
  addBodyLine("selling", toAsset$1(operation2.selling));
  addBodyLine("buying", toAsset$1(operation2.buying));
  addBodyLine("amount", toAmount$1(operation2.amount));
  addPrice(operation2.price, addBodyLine);
  addBodyLine("offerID", operation2.offerId);
}
function addCreatePassiveSellOfferOp(operation2, addBodyLine) {
  addBodyLine("selling", toAsset$1(operation2.selling));
  addBodyLine("buying", toAsset$1(operation2.buying));
  addBodyLine("amount", toAmount$1(operation2.amount));
  addPrice(operation2.price, addBodyLine);
}
function addSetOptionsOp(operation2, addBodyLine) {
  addBodyLine("inflationDest", operation2.inflationDest, true);
  addBodyLine("clearFlags", operation2.clearFlags, true);
  addBodyLine("setFlags", operation2.setFlags, true);
  addBodyLine("masterWeight", operation2.masterWeight, true);
  addBodyLine("lowThreshold", operation2.lowThreshold, true);
  addBodyLine("medThreshold", operation2.medThreshold, true);
  addBodyLine("highThreshold", operation2.highThreshold, true);
  addBodyLine("homeDomain", toString(operation2.homeDomain), true);
  addSigner(operation2.signer, addBodyLine);
}
function addPrice(price, addBodyLine) {
  const [n, d] = best_r(price);
  addBodyLine("price.n", n);
  addBodyLine("price.d", d);
}
function addSigner(signer, addBodyLine) {
  addBodyLine("signer._present", !!signer);
  if (signer) {
    if (signer.ed25519PublicKey) {
      addBodyLine("signer.key", signer.ed25519PublicKey);
    } else if (signer.preAuthTx) {
      addBodyLine("signer.key", libExports.StrKey.encodePreAuthTx(signer.preAuthTx));
    } else if (signer.sha256Hash) {
      addBodyLine("signer.key", libExports.StrKey.encodeSha256Hash(signer.sha256Hash));
    }
    addBodyLine("signer.weight", signer.weight);
  }
}
function addChangeTrustOp(operation2, addBodyLine) {
  addBodyLine("line", toAsset$1(operation2.line));
  if (operation2.limit) {
    addBodyLine("limit", toAmount$1(operation2.limit));
  }
}
function addAllowTrustOp(operation2, addBodyLine) {
  addBodyLine("trustor", operation2.trustor);
  addBodyLine("asset", operation2.assetCode);
  addBodyLine("authorize", operation2.authorize);
}
function addAccountMergeOp(operation2, addOpLine) {
  addOpLine("body.destination", operation2.destination);
}
function addManageDataOp(operation2, addBodyLine) {
  addBodyLine("dataName", toString(operation2.name));
  addBodyLine("dataValue._present", !!operation2.value);
  if (operation2.value) {
    addBodyLine("dataValue", toOpaque(operation2.value));
  }
}
function addBumpSequenceOp(operation2, addBodyLine) {
  addBodyLine("bumpTo", operation2.bumpTo);
}
function addManageBuyOfferOp(operation2, addBodyLine) {
  addBodyLine("selling", toAsset$1(operation2.selling));
  addBodyLine("buying", toAsset$1(operation2.buying));
  addBodyLine("buyAmount", toAmount$1(operation2.buyAmount));
  addPrice(operation2.price, addBodyLine);
  addBodyLine("offerID", operation2.offerId);
}
function addSignatures(signatures, lines) {
  addLine("signatures.len", signatures.length, lines);
  signatures.forEach((signature2, i2) => {
    addSignature(signature2, i2, lines);
  });
}
function addSignature(signature2, i2, lines) {
  const prefix2 = `signatures[${i2}]`;
  addLine(`${prefix2}.hint`, toOpaque(signature2.hint()), lines);
  addLine(`${prefix2}.signature`, toOpaque(signature2.signature()), lines);
}
function toAsset$1(asset2) {
  if (asset2.isNative()) {
    return "XLM";
  }
  return `${asset2.code}:${asset2.issuer}`;
}
function toAmount$1(amount) {
  return new BigNumber(amount).times(1e7);
}
function toString(value) {
  return JSON.stringify(value);
}
function toOpaque(value) {
  return value.toString("hex");
}
function toTransaction(txrep, networkPassphrase) {
  const obj = toObj(txrep);
  const account2 = new libExports.Account(obj.tx.sourceAccount, obj.tx.seqNum);
  account2.sequence = account2.sequence.add(-1);
  const opts = {
    memo: toMemo(obj.tx.memo),
    fee: toFee(obj.tx.fee),
    timebounds: toTimebounds(obj.tx.timeBounds),
    networkPassphrase
  };
  const builder = new libExports.TransactionBuilder(account2, opts);
  if (!opts.timebounds) {
    builder.setTimeout(libExports.TimeoutInfinite);
  }
  for (const operation2 of obj.tx.operations) {
    builder.addOperation(toOperation(operation2));
  }
  const transaction2 = builder.build();
  if (obj.signatures) {
    for (const signature2 of obj.signatures) {
      transaction2.signatures.push(toSignature(signature2));
    }
  }
  return transaction2;
}
function toObj(txrep) {
  const obj = {};
  const fields = txrep.split("\n").map((line) => line.trim()).filter((l) => !!l).map(parseLine);
  fields.forEach(({ path: path2, value }) => {
    if (!path2 || !isMetaAttribute(path2)) {
      set$1(obj, path2, value);
    }
  });
  return obj;
}
function isMetaAttribute(path2) {
  const paths = path2.split(".");
  const field = paths[paths.length - 1];
  return field === "len" || field.startsWith("_");
}
function parseLine(line) {
  const [path2, remainingLine] = getPath$2(line);
  const [value, comment] = getValue(remainingLine);
  return { path: path2, value: parseValue(value), comment };
}
function getPath$2(line) {
  const colonPos = line.indexOf(":");
  const path2 = line.slice(0, colonPos).trim();
  const rest = line.slice(colonPos + 1).trim();
  return [path2, rest];
}
function getValue(line) {
  if (line[0] === '"') {
    return getStringValue(line);
  } else {
    return getNonStringValue(line);
  }
}
function getStringValue(line) {
  let value = '"';
  let inEscapeSequence = false;
  let i2 = 1;
  for (; i2 < line.length; ++i2) {
    const char = line[i2];
    if (inEscapeSequence) {
      if (char === "n") {
        value += "\n";
      } else {
        value += char;
      }
      inEscapeSequence = false;
    } else if (char === "\\") {
      inEscapeSequence = true;
    } else if (char === '"') {
      value += char;
      break;
    } else {
      value += char;
    }
  }
  return [value.trim(), line.slice(i2 + 1).trim()];
}
function getNonStringValue(line) {
  const spacePos = line.indexOf(" ");
  if (spacePos === -1) {
    return [line.trim(), ""];
  } else {
    const value = line.slice(0, spacePos);
    const rest = line.slice(spacePos);
    return [value.trim(), rest.trim()];
  }
}
function parseValue(value) {
  if (value.startsWith('"') && value.endsWith('"')) {
    return value.slice(1, -1);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function toFee(value) {
  return value;
}
function toOperation({ sourceAccount, body }) {
  switch (body.type) {
    case "CREATE_ACCOUNT":
      return toCreateAccountOperation(body.createAccountOp, sourceAccount);
    case "PAYMENT":
      return toPaymentOperation(body.paymentOp, sourceAccount);
    case "PATH_PAYMENT_STRICT_RECEIVE":
      return toPathPaymentStrictReceive(body.pathPaymentStrictReceiveOp, sourceAccount);
    case "PATH_PAYMENT_STRICT_SEND":
      return toPathPaymentStrictSend(body.pathPaymentStrictSendOp, sourceAccount);
    case "MANAGE_SELL_OFFER":
      return toManageSellOffer(body.manageSellOfferOp, sourceAccount);
    case "CREATE_PASSIVE_SELL_OFFER":
      return toCreatePassiveSellOffer(body.createPassiveSellOfferOp, sourceAccount);
    case "SET_OPTIONS":
      return toSetOptions(body.setOptionsOp, sourceAccount);
    case "CHANGE_TRUST":
      return toChangeTrust(body.changeTrustOp, sourceAccount);
    case "ALLOW_TRUST":
      return toAllowTrust(body.allowTrustOp, sourceAccount);
    case "ACCOUNT_MERGE":
      return toAccountMerge(body, sourceAccount);
    case "MANAGE_DATA":
      return toManageData(body.manageDataOp, sourceAccount);
    case "BUMP_SEQUENCE":
      return toBumpSequence(body.bumpSequenceOp, sourceAccount);
    case "MANAGE_BUY_OFFER":
      return toManageBuyOffer(body.manageBuyOfferOp, sourceAccount);
    default:
      throw new Error("Not implemented");
  }
}
function toCreateAccountOperation(op, source) {
  const { destination, startingBalance } = op;
  return libExports.Operation.createAccount({
    destination,
    startingBalance: toAmount(startingBalance),
    source
  });
}
function toPaymentOperation(op, source) {
  const { asset: asset2, destination, amount } = op;
  return libExports.Operation.payment({
    destination,
    asset: toAsset(asset2),
    amount: toAmount(amount),
    source
  });
}
function toPathPaymentStrictReceive(op, source) {
  const { sendAsset, destAsset, sendMax, destination, destAmount, path: path2 } = op;
  return libExports.Operation.pathPaymentStrictReceive({
    sendAsset: toAsset(sendAsset),
    sendMax: toAmount(sendMax),
    destination,
    destAsset: toAsset(destAsset),
    destAmount: toAmount(destAmount),
    path: path2 && path2.map(toAsset),
    source
  });
}
function toPathPaymentStrictSend(op, source) {
  const { sendAsset, sendAmount, destAsset, destination, destMin, path: path2 } = op;
  return libExports.Operation.pathPaymentStrictSend({
    sendAsset: toAsset(sendAsset),
    sendAmount: toAmount(sendAmount),
    destination,
    destAsset: toAsset(destAsset),
    destMin: toAmount(destMin),
    path: path2 && path2.map(toAsset),
    source
  });
}
function toManageSellOffer(op, source) {
  const { selling, buying, amount, price, offerID } = op;
  return libExports.Operation.manageSellOffer({
    selling: toAsset(selling),
    buying: toAsset(buying),
    amount: toAmount(amount),
    price: toPrice(price),
    offerId: offerID,
    source
  });
}
function toManageBuyOffer(op, source) {
  const { selling, buying, buyAmount, price, offerID } = op;
  return libExports.Operation.manageBuyOffer({
    selling: toAsset(selling),
    buying: toAsset(buying),
    buyAmount: toAmount(buyAmount),
    price: toPrice(price),
    offerId: offerID,
    source
  });
}
function toCreatePassiveSellOffer(op, source) {
  const { selling, buying, amount, price } = op;
  return libExports.Operation.createPassiveSellOffer({
    selling: toAsset(selling),
    buying: toAsset(buying),
    amount: toAmount(amount),
    price: toPrice(price),
    source
  });
}
function toSetOptions(op = {}, source) {
  const { inflationDest, clearFlags, setFlags, masterWeight, lowThreshold, medThreshold, highThreshold, homeDomain, signer } = op;
  let signerOptions;
  if (signer) {
    switch (signer.key.charAt(0)) {
      case "G":
        signerOptions = {
          ed25519PublicKey: signer.key,
          weight: signer.weight
        };
        break;
      case "X":
        signerOptions = {
          sha256Hash: libExports.StrKey.decodeSha256Hash(signer.key),
          weight: signer.weight
        };
        break;
      case "T":
        signerOptions = {
          preAuthTx: libExports.StrKey.decodePreAuthTx(signer.key),
          weight: signer.weight
        };
        break;
    }
  }
  return libExports.Operation.setOptions({
    inflationDest,
    clearFlags,
    setFlags,
    masterWeight,
    lowThreshold,
    medThreshold,
    highThreshold,
    homeDomain,
    signer: signerOptions,
    source
  });
}
function toChangeTrust(op, source) {
  const { line, limit } = op;
  return libExports.Operation.changeTrust({
    asset: toAsset(line),
    limit: limit && toAmount(limit),
    source
  });
}
function toAllowTrust(op, source) {
  const { trustor, asset: asset2, authorize } = op;
  return libExports.Operation.allowTrust({
    trustor,
    authorize: toBoolInt(authorize),
    assetCode: asset2,
    source
  });
}
function toAccountMerge(op, source) {
  const { destination } = op;
  return libExports.Operation.accountMerge({
    destination,
    source
  });
}
function toManageData(op, source) {
  const { dataName, dataValue } = op;
  const value = Buffer.from(dataValue, "hex");
  return libExports.Operation.manageData({ name: dataName, value, source });
}
function toBumpSequence(op, source) {
  const { bumpTo } = op;
  return libExports.Operation.bumpSequence({
    bumpTo,
    source
  });
}
function toSignature(sig) {
  const hint = Buffer.from(sig.hint, "hex");
  const signature2 = Buffer.from(sig.signature, "hex");
  return new libExports.xdr.DecoratedSignature({ hint, signature: signature2 });
}
function toAsset(value) {
  if (!value) {
    return void 0;
  }
  if (value === "XLM") {
    return libExports.Asset.native();
  }
  if (value === "native") {
    return libExports.Asset.native();
  }
  const [code2, issuer] = value.split(":");
  return new libExports.Asset(code2, issuer);
}
function toMemo(memo2) {
  switch (memo2.type) {
    case "MEMO_TEXT":
      return libExports.Memo.text(memo2.text);
    case "MEMO_ID":
      return libExports.Memo.id(memo2.id);
    case "MEMO_HASH":
      return libExports.Memo.hash(memo2.hash);
    case "MEMO_RETURN":
      return libExports.Memo.return(memo2.retHash);
    default:
      return libExports.Memo.none();
  }
}
function toTimebounds(timeBounds) {
  if (!timeBounds) {
    return void 0;
  }
  const { minTime, maxTime } = timeBounds;
  return { minTime, maxTime };
}
function toAmount(amount) {
  return new BigNumber(amount).div(1e7).toFixed(7);
}
function toPrice({ n, d }) {
  return {
    n: Number(n),
    d: Number(d)
  };
}
function toBoolInt(v) {
  if (v === null || v === void 0) {
    return 0;
  }
  return Number(v);
}
class TransactionStellarUri extends StellarUri {
  static forTransaction(transaction2) {
    const uri2 = new TransactionStellarUri();
    uri2.xdr = transaction2.toEnvelope().toXDR().toString("base64");
    uri2.networkPassphrase = transaction2.networkPassphrase;
    return uri2;
  }
  constructor(uri2) {
    super(uri2 ? uri2 : new URL("web+stellar:tx"));
  }
  /**
   * Creates a deep clone of the TransactionStellarUri
   */
  clone() {
    return new TransactionStellarUri(this.uri);
  }
  /**
   * Creates a Stellar Transaction from the URI's XDR and networkPassphrase
   */
  getTransaction() {
    return new libExports.Transaction(this.xdr, this.networkPassphrase || libExports.Networks.PUBLIC);
  }
  /**
   * Gets the transaction XDR.
   *
   * Required.
   */
  get xdr() {
    return this.getParam("xdr");
  }
  /**
   * Sets the transaction XDR.
   *
   * Required.
   */
  set xdr(xdr) {
    this.setParam("xdr", xdr);
  }
  /**
   * Performs any replacements specified and returns a new instance of TransactionStellarUri with the resulting XDR.
   *
   * @param replacements The replacements to perform.
   */
  replace(replacements) {
    const passphrase = this.isPublicNetwork ? libExports.Networks.PUBLIC : this.networkPassphrase;
    const tx = this.getTransaction();
    let txrep = toTxrep(tx);
    const newUri = this.clone();
    const replacementTargets = this.getReplacements();
    for (const [id, value] of Object.entries(replacements)) {
      replacementTargets.filter((r) => r.id === id).forEach(({ path: path2 }) => {
        txrep += `
tx.${path2}: ${value}`;
      });
      newUri.removeReplacement(id);
    }
    const newTx = toTransaction(txrep, passphrase);
    newUri.xdr = newTx.toEnvelope().toXDR().toString("base64");
    return newUri;
  }
}
class PayStellarUri extends StellarUri {
  /**
   * Creates a PayStellarUri instance and sets the given destination.
   *
   * @param destination A valid account ID or payment address.
   */
  static forDestination(destination) {
    const uri2 = new PayStellarUri();
    uri2.destination = destination;
    return uri2;
  }
  constructor(uri2) {
    super(uri2 ? uri2 : new URL("web+stellar:pay"));
  }
  /**
   * Creates a deep clone of the PayStellarUri
   */
  clone() {
    return new PayStellarUri(this.uri);
  }
  /**
   * Gets the destination of the payment request, which is a valid account ID or payment address.
   *
   * Required.
   */
  get destination() {
    return this.getParam("destination");
  }
  /**
   * Sets the destination of the payment request, which is a valid account ID or payment address.
   *
   * Required.
   */
  set destination(destination) {
    this.setParam("destination", destination);
  }
  /**
   * Gets the amount that destination will receive.
   *
   * Optional.
   */
  get amount() {
    return this.getParam("amount");
  }
  /**
   * Sets the amount that destination will receive.
   *
   * Optional.
   */
  set amount(amount) {
    this.setParam("destination", amount);
  }
  /**
   * Gets the asset code the destination will receive.
   *
   * Optional.
   */
  get assetCode() {
    return this.getParam("asset_code");
  }
  /**
   * Sets the asset code the destination will receive.
   *
   * Optional.
   */
  set assetCode(assetCode) {
    this.setParam("asset_code", assetCode);
  }
  /**
   * Gets the account ID of asset issuer the destination will receive
   *
   * Optional.
   */
  get assetIssuer() {
    return this.getParam("asset_issuer");
  }
  /**
   * Sets the account ID of asset issuer the destination will receive
   *
   * Optional.
   */
  set assetIssuer(assetIssuer) {
    this.setParam("asset_issuer", assetIssuer);
  }
  /**
   * Gets the memo to be included in the payment / path payment.
   * Memos of type MEMO_HASH and MEMO_RETURN should be base64 encoded.
   *
   * Optional.
   */
  get memo() {
    return this.getParam("memo");
  }
  /**
   * Sets the memo to be included in the payment / path payment.
   * Memos of type MEMO_HASH and MEMO_RETURN should be base64 encoded.
   *
   * Optional.
   */
  set memo(memo2) {
    this.setParam("memo", memo2);
  }
  /**
   * Gets the type of the memo.
   *
   * Optional.
   */
  get memoType() {
    return this.getParam("memo_type");
  }
  /**
   * Sets the type of the memo.
   *
   * Optional.
   */
  set memoType(memoType) {
    this.setParam("memo_type", memoType);
  }
}
function parseStellarUri(uri2) {
  if (!isStellarUri(uri2)) {
    throw new Error('Stellar URIs must start with "web+stellar:"');
  }
  const url2 = new URL(uri2);
  const type2 = url2.pathname;
  switch (url2.pathname) {
    case StellarUriType.Transaction:
      return new TransactionStellarUri(url2);
    case StellarUriType.Pay:
      return new PayStellarUri(url2);
    default:
      throw new Error(`Stellar URI type ${type2} is not currently supported.`);
  }
}
function isStellarUri(uri2) {
  return !!uri2 && (uri2.startsWith("web+stellar:tx") || uri2.startsWith("web+stellar:pay"));
}
function subscribeToDeepLinkURLs(callback) {
  return subscribeToMessages(Messages.DeepLinkURL, callback);
}
function isDefaultProtocolClient() {
  return call(Messages.IsDefaultProtocolClient);
}
function isDifferentHandlerInstalled() {
  return call(Messages.IsDifferentHandlerInstalled);
}
function setAsDefaultProtocolClient() {
  return call(Messages.SetAsDefaultProtocolClient);
}
async function verifyTransactionRequest(request2, options2 = {}) {
  const parsedURI = parseStellarUri(request2);
  const isSignatureValid = await parsedURI.verifySignature();
  if (!isSignatureValid) {
    if (parsedURI.isTestNetwork && options2.allowUnsafeTestnetURIs) ;
    else {
      throw CustomError("StellarUriVerificationError", i18next.t("stellar-uri-verification-error"));
    }
  }
  if (parsedURI.callback) {
    try {
      const callbackURI = new URL(parsedURI.callback);
      if (!["http:", "https:"].includes(callbackURI.protocol)) {
        throw new Error("Unsupported schema");
      }
    } catch (e) {
      throw CustomError(
        "StellarUriVerificationError",
        i18next.t("stellar-uri-callback-format-error", { reason: e.message || "" })
      );
    }
  }
  return parsedURI;
}
const allowUnsafeTestnetURIs = Boolean(void 0);
const initialValues$2 = {
  uri: null,
  clearURI: () => void 0
};
const TransactionRequestContext = React.createContext(initialValues$2);
function TransactionRequestProvider(props) {
  const [uri2, setURI] = React.useState(null);
  const { t: t2 } = useTranslation();
  const clearURI = React.useCallback(() => setURI(null), []);
  const verifyStellarURI = React.useCallback(async (incomingURI) => {
    try {
      const parsedURI = await verifyTransactionRequest(incomingURI, { allowUnsafeTestnetURIs });
      if (parsedURI.operation === StellarUriType.Transaction) {
        const txURI = parsedURI;
        txURI.getTransaction();
      }
      setURI(parsedURI);
    } catch (error3) {
      trackError(error3);
    }
  }, []);
  React.useEffect(() => {
    const unsubscribe2 = subscribeToDeepLinkURLs(async (incomingURI) => {
      const url2 = new URL(incomingURI);
      switch (url2.pathname) {
        case StellarUriType.Transaction:
        case StellarUriType.Pay:
          verifyStellarURI(incomingURI);
          break;
        default:
          trackError(
            CustomError(
              "UnexpectedStellarUriTypeError",
              t2("unexpected-stellar-uri-type-error", `Incoming uri ${incomingURI} does not match any expected type.`, {
                incomingURI
              })
            )
          );
          break;
      }
    });
    return unsubscribe2;
  }, [verifyStellarURI]);
  return /* @__PURE__ */ React.createElement(TransactionRequestContext.Provider, { value: { uri: uri2, clearURI } }, props.children);
}
var styles$y = function styles22(theme2) {
  var elevations = {};
  theme2.shadows.forEach(function(shadow, index2) {
    elevations["elevation".concat(index2)] = {
      boxShadow: shadow
    };
  });
  return _extends$1({
    /* Styles applied to the root element. */
    root: {
      backgroundColor: theme2.palette.background.paper,
      color: theme2.palette.text.primary,
      transition: theme2.transitions.create("box-shadow")
    },
    /* Styles applied to the root element if `square={false}`. */
    rounded: {
      borderRadius: theme2.shape.borderRadius
    }
  }, elevations);
};
var Paper = React.forwardRef(function Paper2(props, ref2) {
  var classes = props.classes, classNameProp = props.className, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _props$square = props.square, square = _props$square === void 0 ? false : _props$square, _props$elevation = props.elevation, elevation = _props$elevation === void 0 ? 1 : _props$elevation, other = _objectWithoutProperties(props, ["classes", "className", "component", "square", "elevation"]);
  useTheme();
  var className = clsx(classes.root, classes["elevation".concat(elevation)], classNameProp, !square && classes.rounded);
  return React.createElement(Component, _extends$1({
    className,
    ref: ref2
  }, other));
});
const Paper$1 = withStyles(styles$y, {
  name: "MuiPaper"
})(Paper);
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs$1(reactDomExports);
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var parentGroup = context2;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref3, prevState) {
    var nextIn = _ref3.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      var node2 = ReactDOM.findDOMNode(this);
      if (nextStatus === ENTERING) {
        this.performEnter(node2, mounting);
      } else {
        this.performExit(node2);
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(node2, mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(node2);
      });
      return;
    }
    this.props.onEnter(node2, appearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(node2, appearing);
      _this2.onTransitionEnd(node2, enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(node2, appearing);
        });
      });
    });
  };
  _proto.performExit = function performExit(node2) {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(node2);
      });
      return;
    }
    this.props.onExit(node2);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(node2);
      _this3.onTransitionEnd(node2, timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(node2);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(node2, timeout2, handler) {
    this.setNextCallback(handler);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      this.props.addEndListener(node2, this.nextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children, childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]);
    delete childProps.in;
    delete childProps.mountOnEnter;
    delete childProps.unmountOnExit;
    delete childProps.appear;
    delete childProps.enter;
    delete childProps.exit;
    delete childProps.timeout;
    delete childProps.addEndListener;
    delete childProps.onEnter;
    delete childProps.onEntering;
    delete childProps.onEntered;
    delete childProps.onExit;
    delete childProps.onExiting;
    delete childProps.onExited;
    if (typeof children === "function") {
      return React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, children(status, childProps));
    }
    var child = React.Children.only(children);
    return (
      // allows for nested Transitions
      React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, React.cloneElement(child, childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = 0;
Transition.EXITED = 1;
Transition.ENTERING = 2;
Transition.ENTERED = 3;
Transition.EXITING = 4;
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) reactExports.Children.map(children, function(c) {
    return c;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key2) {
    return key2 in next ? next[key2] : prev[key2];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key2) {
    var child = children[key2];
    if (!reactExports.isValidElement(child)) return;
    var hasPrev = key2 in prevChildMapping;
    var hasNext = key2 in nextChildMapping;
    var prevChild = prevChildMapping[key2];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key2] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref3) {
    var prevChildMapping = _ref3.children, handleExited = _ref3.handleExited, firstRender = _ref3.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state2) {
        var children = _extends$1({}, state2.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, React.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
var reflow = function reflow2(node2) {
  return node2.scrollTop;
};
function getTransitionProps(props, options2) {
  var timeout = props.timeout, _props$style = props.style, style2 = _props$style === void 0 ? {} : _props$style;
  return {
    duration: style2.transitionDuration || typeof timeout === "number" ? timeout : timeout[options2.mode] || 0,
    delay: style2.transitionDelay
  };
}
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2) {
    ref2.current = value;
  }
}
function useForkRef(refA, refB) {
  return React.useMemo(function() {
    if (refA == null && refB == null) {
      return null;
    }
    return function(refValue) {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
}
var styles$x = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
var defaultTimeout$1 = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
var Fade = React.forwardRef(function Fade2(props, ref2) {
  var children = props.children, inProp = props.in, onEnter = props.onEnter, onExit = props.onExit, style2 = props.style, _props$timeout = props.timeout, timeout = _props$timeout === void 0 ? defaultTimeout$1 : _props$timeout, other = _objectWithoutProperties(props, ["children", "in", "onEnter", "onExit", "style", "timeout"]);
  var theme2 = useTheme();
  var handleRef = useForkRef(children.ref, ref2);
  var handleEnter = function handleEnter2(node2, isAppearing) {
    reflow(node2);
    var transitionProps = getTransitionProps({
      style: style2,
      timeout
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  var handleExit = function handleExit2(node2) {
    var transitionProps = getTransitionProps({
      style: style2,
      timeout
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  };
  return React.createElement(Transition, _extends$1({
    appear: true,
    in: inProp,
    onEnter: handleEnter,
    onExit: handleExit,
    timeout
  }, other), function(state2, childProps) {
    return React.cloneElement(children, _extends$1({
      style: _extends$1({
        opacity: 0,
        visibility: state2 === "exited" && !inProp ? "hidden" : void 0
      }, styles$x[state2], {}, style2, {}, children.props.style),
      ref: handleRef
    }, childProps));
  });
});
var styles$w = {
  /* Styles applied to the root element. */
  root: {
    zIndex: -1,
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    // Remove grey highlight
    WebkitTapHighlightColor: "transparent",
    // Disable scroll capabilities.
    touchAction: "none"
  },
  /* Styles applied to the root element if `invisible={true}`. */
  invisible: {
    backgroundColor: "transparent"
  }
};
var Backdrop = React.forwardRef(function Backdrop2(props, ref2) {
  var children = props.children, classes = props.classes, className = props.className, _props$invisible = props.invisible, invisible = _props$invisible === void 0 ? false : _props$invisible, open = props.open, transitionDuration = props.transitionDuration, other = _objectWithoutProperties(props, ["children", "classes", "className", "invisible", "open", "transitionDuration"]);
  return React.createElement(Fade, _extends$1({
    in: open,
    timeout: transitionDuration
  }, other), React.createElement("div", {
    className: clsx(classes.root, className, invisible && classes.invisible),
    "aria-hidden": true,
    ref: ref2
  }, children));
});
const Backdrop$1 = withStyles(styles$w, {
  name: "MuiBackdrop"
})(Backdrop);
var useEnhancedEffect$7 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
function useEventCallback(fn) {
  var ref2 = React.useRef(fn);
  useEnhancedEffect$7(function() {
    ref2.current = fn;
  });
  return React.useCallback(function(event) {
    return (0, ref2.current)(event);
  }, []);
}
var useEnhancedEffect$6 = typeof window !== "undefined" && true ? React.useLayoutEffect : React.useEffect;
function NoSsr(props) {
  var children = props.children, _props$defer = props.defer, defer2 = _props$defer === void 0 ? false : _props$defer, _props$fallback = props.fallback, fallback = _props$fallback === void 0 ? null : _props$fallback;
  var _React$useState = React.useState(false), mountedState = _React$useState[0], setMountedState = _React$useState[1];
  useEnhancedEffect$6(function() {
    if (!defer2) {
      setMountedState(true);
    }
  }, [defer2]);
  React.useEffect(function() {
    if (defer2) {
      setMountedState(true);
    }
  }, [defer2]);
  return React.createElement(React.Fragment, null, mountedState ? children : fallback);
}
var hadKeyboardEvent = true;
var hadFocusVisibleRecently = false;
var hadFocusVisibleRecentlyTimeout = null;
var inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  var type2 = node2.type, tagName = node2.tagName;
  if (tagName === "INPUT" && inputTypesWhitelist[type2] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown() {
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(ownerDocument2) {
  ownerDocument2.addEventListener("keydown", handleKeyDown, true);
  ownerDocument2.addEventListener("mousedown", handlePointerDown, true);
  ownerDocument2.addEventListener("pointerdown", handlePointerDown, true);
  ownerDocument2.addEventListener("touchstart", handlePointerDown, true);
  ownerDocument2.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  var target = event.target;
  try {
    return target.matches(":focus-visible");
  } catch (error3) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function handleBlurVisible() {
  hadFocusVisibleRecently = true;
  window.clearTimeout(hadFocusVisibleRecentlyTimeout);
  hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
    hadFocusVisibleRecently = false;
    window.clearTimeout(hadFocusVisibleRecentlyTimeout);
  }, 100);
}
function useIsFocusVisible() {
  var ref2 = React.useCallback(function(instance) {
    var node2 = ReactDOM.findDOMNode(instance);
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  return {
    isFocusVisible,
    onBlurVisible: handleBlurVisible,
    ref: ref2
  };
}
var useEnhancedEffect$5 = typeof window === "undefined" ? React.useEffect : React.useLayoutEffect;
function Ripple(props) {
  var classes = props.classes, _props$pulsate = props.pulsate, pulsate = _props$pulsate === void 0 ? false : _props$pulsate, rippleX = props.rippleX, rippleY = props.rippleY, rippleSize = props.rippleSize, inProp = props.in, _props$onExited = props.onExited, onExited = _props$onExited === void 0 ? function() {
  } : _props$onExited, timeout = props.timeout;
  var _React$useState = React.useState(false), leaving = _React$useState[0], setLeaving = _React$useState[1];
  var rippleClassName = clsx(classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  var rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  var childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  var handleExited = useEventCallback(onExited);
  useEnhancedEffect$5(function() {
    if (!inProp) {
      setLeaving(true);
      var timeoutId = setTimeout(handleExited, timeout);
      return function() {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [handleExited, inProp, timeout]);
  return React.createElement("span", {
    className: rippleClassName,
    style: rippleStyles
  }, React.createElement("span", {
    className: childClassName
  }));
}
var DURATION = 550;
var DELAY_RIPPLE = 80;
var styles$v = function styles23(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      overflow: "hidden",
      pointerEvents: "none",
      position: "absolute",
      zIndex: 0,
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderRadius: "inherit"
    },
    /* Styles applied to the internal `Ripple` components `ripple` class. */
    ripple: {
      opacity: 0,
      position: "absolute"
    },
    /* Styles applied to the internal `Ripple` components `rippleVisible` class. */
    rippleVisible: {
      opacity: 0.3,
      transform: "scale(1)",
      animation: "$enter ".concat(DURATION, "ms ").concat(theme2.transitions.easing.easeInOut)
    },
    /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */
    ripplePulsate: {
      animationDuration: "".concat(theme2.transitions.duration.shorter, "ms")
    },
    /* Styles applied to the internal `Ripple` components `child` class. */
    child: {
      opacity: 1,
      display: "block",
      width: "100%",
      height: "100%",
      borderRadius: "50%",
      backgroundColor: "currentColor"
    },
    /* Styles applied to the internal `Ripple` components `childLeaving` class. */
    childLeaving: {
      opacity: 0,
      animation: "$exit ".concat(DURATION, "ms ").concat(theme2.transitions.easing.easeInOut)
    },
    /* Styles applied to the internal `Ripple` components `childPulsate` class. */
    childPulsate: {
      position: "absolute",
      left: 0,
      top: 0,
      animation: "$pulsate 2500ms ".concat(theme2.transitions.easing.easeInOut, " 200ms infinite")
    },
    "@keyframes enter": {
      "0%": {
        transform: "scale(0)",
        opacity: 0.1
      },
      "100%": {
        transform: "scale(1)",
        opacity: 0.3
      }
    },
    "@keyframes exit": {
      "0%": {
        opacity: 1
      },
      "100%": {
        opacity: 0
      }
    },
    "@keyframes pulsate": {
      "0%": {
        transform: "scale(1)"
      },
      "50%": {
        transform: "scale(0.92)"
      },
      "100%": {
        transform: "scale(1)"
      }
    }
  };
};
var TouchRipple = React.forwardRef(function TouchRipple2(props, ref2) {
  var _props$center = props.center, centerProp = _props$center === void 0 ? false : _props$center, classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["center", "classes", "className"]);
  var _React$useState = React.useState([]), ripples = _React$useState[0], setRipples = _React$useState[1];
  var nextKey = React.useRef(0);
  var rippleCallback = React.useRef(null);
  React.useEffect(function() {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  var ignoringMouseDown = React.useRef(false);
  var startTimer = React.useRef(null);
  var startTimerCommit = React.useRef(null);
  var container = React.useRef(null);
  React.useEffect(function() {
    return function() {
      clearTimeout(startTimer.current);
    };
  }, []);
  var startCommit = React.useCallback(function(params) {
    var pulsate2 = params.pulsate, rippleX = params.rippleX, rippleY = params.rippleY, rippleSize = params.rippleSize, cb = params.cb;
    setRipples(function(oldRipples) {
      return [].concat(_toConsumableArray(oldRipples), [React.createElement(Ripple, {
        key: nextKey.current,
        classes,
        timeout: DURATION,
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize
      })]);
    });
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  var start = React.useCallback(function() {
    var event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var cb = arguments.length > 2 ? arguments[2] : void 0;
    var _options$pulsate = options2.pulsate, pulsate2 = _options$pulsate === void 0 ? false : _options$pulsate, _options$center = options2.center, center = _options$center === void 0 ? centerProp || options2.pulsate : _options$center, _options$fakeElement = options2.fakeElement, fakeElement = _options$fakeElement === void 0 ? false : _options$fakeElement;
    if (event.type === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if (event.type === "touchstart") {
      ignoringMouseDown.current = true;
    }
    var element = fakeElement ? null : container.current;
    var rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    var rippleX;
    var rippleY;
    var rippleSize;
    if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
      var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * Math.pow(rect.width, 2) + Math.pow(rect.height, 2)) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      var sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      var sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(Math.pow(sizeX, 2) + Math.pow(sizeY, 2));
    }
    if (event.touches) {
      startTimerCommit.current = function() {
        startCommit({
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb
        });
      };
      startTimer.current = setTimeout(function() {
        if (startTimerCommit.current) {
          startTimerCommit.current();
          startTimerCommit.current = null;
        }
      }, DELAY_RIPPLE);
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }
  }, [centerProp, startCommit]);
  var pulsate = React.useCallback(function() {
    start({}, {
      pulsate: true
    });
  }, [start]);
  var stop = React.useCallback(function(event, cb) {
    clearTimeout(startTimer.current);
    if (event.type === "touchend" && startTimerCommit.current) {
      event.persist();
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(function() {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples(function(oldRipples) {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb;
  }, []);
  React.useImperativeHandle(ref2, function() {
    return {
      pulsate,
      start,
      stop
    };
  }, [pulsate, start, stop]);
  return React.createElement("span", _extends$1({
    className: clsx(classes.root, className),
    ref: container
  }, other), React.createElement(TransitionGroup, {
    component: null,
    exit: true
  }, ripples));
});
function withMuiName(Component) {
  Component.muiName = "MuiTouchRipple";
  return Component;
}
const TouchRipple$1 = withStyles(styles$v, {
  flip: false,
  name: "MuiTouchRipple"
})(withMuiName(React.memo(TouchRipple)));
var styles$u = {
  /* Styles applied to the root element. */
  root: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    // Remove grey highlight
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    "-moz-appearance": "none",
    // Reset
    "-webkit-appearance": "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    "&$disabled": {
      pointerEvents: "none",
      // Disable link interactions
      cursor: "default"
    }
  },
  /* Pseudo-class applied to the root element if `disabled={true}`. */
  disabled: {},
  /* Pseudo-class applied to the root element if keyboard focused. */
  focusVisible: {}
};
var ButtonBase = React.forwardRef(function ButtonBase2(props, ref2) {
  var action2 = props.action, buttonRefProp = props.buttonRef, _props$centerRipple = props.centerRipple, centerRipple = _props$centerRipple === void 0 ? false : _props$centerRipple, children = props.children, classes = props.classes, className = props.className, _props$component = props.component, component = _props$component === void 0 ? "button" : _props$component, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableRipple = props.disableRipple, disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple, _props$disableTouchRi = props.disableTouchRipple, disableTouchRipple = _props$disableTouchRi === void 0 ? false : _props$disableTouchRi, _props$focusRipple = props.focusRipple, focusRipple = _props$focusRipple === void 0 ? false : _props$focusRipple, focusVisibleClassName = props.focusVisibleClassName, onBlur = props.onBlur, onClick = props.onClick, onFocus = props.onFocus, onFocusVisible = props.onFocusVisible, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, onMouseDown = props.onMouseDown, onMouseLeave = props.onMouseLeave, onMouseUp = props.onMouseUp, onTouchEnd = props.onTouchEnd, onTouchMove = props.onTouchMove, onTouchStart = props.onTouchStart, onDragLeave = props.onDragLeave, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, TouchRippleProps = props.TouchRippleProps, _props$type = props.type, type2 = _props$type === void 0 ? "button" : _props$type, other = _objectWithoutProperties(props, ["action", "buttonRef", "centerRipple", "children", "classes", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "onDragLeave", "tabIndex", "TouchRippleProps", "type"]);
  var buttonRef = React.useRef(null);
  function getButtonNode() {
    return ReactDOM.findDOMNode(buttonRef.current);
  }
  var rippleRef = React.useRef(null);
  var _React$useState = React.useState(false), focusVisible = _React$useState[0], setFocusVisible = _React$useState[1];
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  var _useIsFocusVisible = useIsFocusVisible(), isFocusVisible2 = _useIsFocusVisible.isFocusVisible, onBlurVisible = _useIsFocusVisible.onBlurVisible, focusVisibleRef = _useIsFocusVisible.ref;
  React.useImperativeHandle(action2, function() {
    return {
      focusVisible: function focusVisible2() {
        setFocusVisible(true);
        buttonRef.current.focus();
      }
    };
  }, []);
  React.useEffect(function() {
    if (focusVisible && focusRipple && !disableRipple) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible]);
  function useRippleHandler(rippleAction, eventCallback) {
    var skipRippleAction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : disableTouchRipple;
    return useEventCallback(function(event) {
      if (eventCallback) {
        eventCallback(event);
      }
      var ignore = event.defaultPrevented || skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  var handleMouseDown = useRippleHandler("start", onMouseDown);
  var handleDragLeave = useRippleHandler("stop", onDragLeave);
  var handleMouseUp = useRippleHandler("stop", onMouseUp);
  var handleMouseLeave = useRippleHandler("stop", function(event) {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  var handleTouchStart = useRippleHandler("start", onTouchStart);
  var handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  var handleTouchMove = useRippleHandler("stop", onTouchMove);
  var handleBlur = useRippleHandler("stop", function(event) {
    if (focusVisible) {
      onBlurVisible(event);
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  var handleFocus = useEventCallback(function(event) {
    if (disabled) {
      return;
    }
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible2(event)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  var keydownRef = React.useRef(false);
  var handleKeyDown2 = useEventCallback(function(event) {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      event.persist();
      rippleRef.current.stop(event, function() {
        rippleRef.current.start(event);
      });
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    var button = getButtonNode();
    if (event.target === event.currentTarget && component && component !== "button" && (event.key === " " || event.key === "Enter") && !(button.tagName === "A" && button.href)) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  var handleKeyUp = useEventCallback(function(event) {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible) {
      keydownRef.current = false;
      event.persist();
      rippleRef.current.stop(event, function() {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  });
  var ComponentProp = component;
  if (ComponentProp === "button" && other.href) {
    ComponentProp = "a";
  }
  var buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type2;
    buttonProps.disabled = disabled;
  } else {
    if (ComponentProp !== "a" || !other.href) {
      buttonProps.role = "button";
    }
    buttonProps["aria-disabled"] = disabled;
  }
  var handleUserRef = useForkRef(buttonRefProp, ref2);
  var handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
  var handleRef = useForkRef(handleUserRef, handleOwnRef);
  return React.createElement(ComponentProp, _extends$1({
    className: clsx(classes.root, className, focusVisible && [classes.focusVisible, focusVisibleClassName], disabled && classes.disabled),
    onBlur: handleBlur,
    onClick,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex
  }, buttonProps, other), children, !disableRipple && !disabled ? React.createElement(NoSsr, null, React.createElement(TouchRipple$1, _extends$1({
    ref: rippleRef,
    center: centerRipple
  }, TouchRippleProps))) : null);
});
const ButtonBase$1 = withStyles(styles$u, {
  name: "MuiButtonBase"
})(ButtonBase);
var styles$t = function styles24(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      margin: 0
    },
    /* Styles applied to the root element if `variant="body2"`. */
    body2: theme2.typography.body2,
    /* Styles applied to the root element if `variant="body1"`. */
    body1: theme2.typography.body1,
    /* Styles applied to the root element if `variant="caption"`. */
    caption: theme2.typography.caption,
    /* Styles applied to the root element if `variant="button"`. */
    button: theme2.typography.button,
    /* Styles applied to the root element if `variant="h1"`. */
    h1: theme2.typography.h1,
    /* Styles applied to the root element if `variant="h2"`. */
    h2: theme2.typography.h2,
    /* Styles applied to the root element if `variant="h3"`. */
    h3: theme2.typography.h3,
    /* Styles applied to the root element if `variant="h4"`. */
    h4: theme2.typography.h4,
    /* Styles applied to the root element if `variant="h5"`. */
    h5: theme2.typography.h5,
    /* Styles applied to the root element if `variant="h6"`. */
    h6: theme2.typography.h6,
    /* Styles applied to the root element if `variant="subtitle1"`. */
    subtitle1: theme2.typography.subtitle1,
    /* Styles applied to the root element if `variant="subtitle2"`. */
    subtitle2: theme2.typography.subtitle2,
    /* Styles applied to the root element if `variant="overline"`. */
    overline: theme2.typography.overline,
    /* Styles applied to the root element if `variant="srOnly"`. Only accessible to screen readers. */
    srOnly: {
      position: "absolute",
      height: 1,
      width: 1,
      overflow: "hidden"
    },
    /* Styles applied to the root element if `align="left"`. */
    alignLeft: {
      textAlign: "left"
    },
    /* Styles applied to the root element if `align="center"`. */
    alignCenter: {
      textAlign: "center"
    },
    /* Styles applied to the root element if `align="right"`. */
    alignRight: {
      textAlign: "right"
    },
    /* Styles applied to the root element if `align="justify"`. */
    alignJustify: {
      textAlign: "justify"
    },
    /* Styles applied to the root element if `nowrap={true}`. */
    noWrap: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    },
    /* Styles applied to the root element if `gutterBottom={true}`. */
    gutterBottom: {
      marginBottom: "0.35em"
    },
    /* Styles applied to the root element if `paragraph={true}`. */
    paragraph: {
      marginBottom: 16
    },
    /* Styles applied to the root element if `color="inherit"`. */
    colorInherit: {
      color: "inherit"
    },
    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      color: theme2.palette.primary.main
    },
    /* Styles applied to the root element if `color="secondary"`. */
    colorSecondary: {
      color: theme2.palette.secondary.main
    },
    /* Styles applied to the root element if `color="textPrimary"`. */
    colorTextPrimary: {
      color: theme2.palette.text.primary
    },
    /* Styles applied to the root element if `color="textSecondary"`. */
    colorTextSecondary: {
      color: theme2.palette.text.secondary
    },
    /* Styles applied to the root element if `color="error"`. */
    colorError: {
      color: theme2.palette.error.main
    },
    /* Styles applied to the root element if `display="inline"`. */
    displayInline: {
      display: "inline"
    },
    /* Styles applied to the root element if `display="block"`. */
    displayBlock: {
      display: "block"
    }
  };
};
var defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p"
};
var Typography = React.forwardRef(function Typography2(props, ref2) {
  var _props$align = props.align, align = _props$align === void 0 ? "inherit" : _props$align, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "initial" : _props$color, component = props.component, _props$display = props.display, display = _props$display === void 0 ? "initial" : _props$display, _props$gutterBottom = props.gutterBottom, gutterBottom = _props$gutterBottom === void 0 ? false : _props$gutterBottom, _props$noWrap = props.noWrap, noWrap = _props$noWrap === void 0 ? false : _props$noWrap, _props$paragraph = props.paragraph, paragraph = _props$paragraph === void 0 ? false : _props$paragraph, _props$variant = props.variant, variant = _props$variant === void 0 ? "body1" : _props$variant, _props$variantMapping = props.variantMapping, variantMapping = _props$variantMapping === void 0 ? defaultVariantMapping : _props$variantMapping, other = _objectWithoutProperties(props, ["align", "classes", "className", "color", "component", "display", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"]);
  var Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  return React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, variant !== "inherit" && classes[variant], color !== "initial" && classes["color".concat(capitalize(color))], noWrap && classes.noWrap, gutterBottom && classes.gutterBottom, paragraph && classes.paragraph, align !== "inherit" && classes["align".concat(capitalize(align))], display !== "initial" && classes["display".concat(capitalize(display))]),
    ref: ref2
  }, other));
});
const Typography$1 = withStyles(styles$t, {
  name: "MuiTypography"
})(Typography);
var styles$s = function styles25(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: "currentColor",
      flexShrink: 0,
      fontSize: theme2.typography.pxToRem(24),
      transition: theme2.transitions.create("fill", {
        duration: theme2.transitions.duration.shorter
      })
    },
    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      color: theme2.palette.primary.main
    },
    /* Styles applied to the root element if `color="secondary"`. */
    colorSecondary: {
      color: theme2.palette.secondary.main
    },
    /* Styles applied to the root element if `color="action"`. */
    colorAction: {
      color: theme2.palette.action.active
    },
    /* Styles applied to the root element if `color="error"`. */
    colorError: {
      color: theme2.palette.error.main
    },
    /* Styles applied to the root element if `color="disabled"`. */
    colorDisabled: {
      color: theme2.palette.action.disabled
    },
    /* Styles applied to the root element if `fontSize="inherit"`. */
    fontSizeInherit: {
      fontSize: "inherit"
    },
    /* Styles applied to the root element if `fontSize="small"`. */
    fontSizeSmall: {
      fontSize: theme2.typography.pxToRem(20)
    },
    /* Styles applied to the root element if `fontSize="large"`. */
    fontSizeLarge: {
      fontSize: theme2.typography.pxToRem(35)
    }
  };
};
var SvgIcon$1 = React.forwardRef(function SvgIcon2(props, ref2) {
  var children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "inherit" : _props$color, _props$component = props.component, Component = _props$component === void 0 ? "svg" : _props$component, _props$fontSize = props.fontSize, fontSize = _props$fontSize === void 0 ? "default" : _props$fontSize, htmlColor = props.htmlColor, titleAccess = props.titleAccess, _props$viewBox = props.viewBox, viewBox = _props$viewBox === void 0 ? "0 0 24 24" : _props$viewBox, other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "fontSize", "htmlColor", "titleAccess", "viewBox"]);
  return React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, color !== "inherit" && classes["color".concat(capitalize(color))], fontSize !== "default" && classes["fontSize".concat(capitalize(fontSize))]),
    focusable: "false",
    viewBox,
    color: htmlColor,
    "aria-hidden": titleAccess ? "false" : "true",
    role: titleAccess ? "img" : "presentation",
    ref: ref2
  }, other), children, titleAccess ? React.createElement("title", null, titleAccess) : null);
});
SvgIcon$1.muiName = "SvgIcon";
const SvgIcon$2 = withStyles(styles$s, {
  name: "MuiSvgIcon"
})(SvgIcon$1);
const SvgIcon = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: SvgIcon$2
}, Symbol.toStringTag, { value: "Module" }));
function createSvgIcon$1(path2, displayName) {
  var Component = React.memo(React.forwardRef(function(props, ref2) {
    return React.createElement(SvgIcon$2, _extends$1({}, props, {
      ref: ref2
    }), path2);
  }));
  Component.muiName = SvgIcon$2.muiName;
  return Component;
}
var styles$r = function styles26(theme2) {
  return {
    /* Styles applied to the root element. */
    root: _extends$1({}, theme2.typography.button, {
      boxSizing: "border-box",
      minWidth: 64,
      padding: "6px 16px",
      borderRadius: theme2.shape.borderRadius,
      color: theme2.palette.text.primary,
      transition: theme2.transitions.create(["background-color", "box-shadow", "border"], {
        duration: theme2.transitions.duration.short
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: fade(theme2.palette.text.primary, theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        },
        "&$disabled": {
          backgroundColor: "transparent"
        }
      },
      "&$disabled": {
        color: theme2.palette.action.disabled
      }
    }),
    /* Styles applied to the span element that wraps the children. */
    label: {
      width: "100%",
      // Ensure the correct width for iOS Safari
      display: "inherit",
      alignItems: "inherit",
      justifyContent: "inherit"
    },
    /* Styles applied to the root element if `variant="text"`. */
    text: {
      padding: "6px 8px"
    },
    /* Styles applied to the root element if `variant="text"` and `color="primary"`. */
    textPrimary: {
      color: theme2.palette.primary.main,
      "&:hover": {
        backgroundColor: fade(theme2.palette.primary.main, theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    /* Styles applied to the root element if `variant="text"` and `color="secondary"`. */
    textSecondary: {
      color: theme2.palette.secondary.main,
      "&:hover": {
        backgroundColor: fade(theme2.palette.secondary.main, theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    /* Styles applied to the root element if `variant="outlined"`. */
    outlined: {
      padding: "5px 15px",
      border: "1px solid ".concat(theme2.palette.type === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"),
      "&$disabled": {
        border: "1px solid ".concat(theme2.palette.action.disabled)
      }
    },
    /* Styles applied to the root element if `variant="outlined"` and `color="primary"`. */
    outlinedPrimary: {
      color: theme2.palette.primary.main,
      border: "1px solid ".concat(fade(theme2.palette.primary.main, 0.5)),
      "&:hover": {
        border: "1px solid ".concat(theme2.palette.primary.main),
        backgroundColor: fade(theme2.palette.primary.main, theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    /* Styles applied to the root element if `variant="outlined"` and `color="secondary"`. */
    outlinedSecondary: {
      color: theme2.palette.secondary.main,
      border: "1px solid ".concat(fade(theme2.palette.secondary.main, 0.5)),
      "&:hover": {
        border: "1px solid ".concat(theme2.palette.secondary.main),
        backgroundColor: fade(theme2.palette.secondary.main, theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      "&$disabled": {
        border: "1px solid ".concat(theme2.palette.action.disabled)
      }
    },
    /* Styles applied to the root element if `variant="contained"`. */
    contained: {
      color: theme2.palette.getContrastText(theme2.palette.grey[300]),
      backgroundColor: theme2.palette.grey[300],
      boxShadow: theme2.shadows[2],
      "&:hover": {
        backgroundColor: theme2.palette.grey.A100,
        boxShadow: theme2.shadows[4],
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          boxShadow: theme2.shadows[2],
          backgroundColor: theme2.palette.grey[300]
        },
        "&$disabled": {
          backgroundColor: theme2.palette.action.disabledBackground
        }
      },
      "&$focusVisible": {
        boxShadow: theme2.shadows[6]
      },
      "&:active": {
        boxShadow: theme2.shadows[8]
      },
      "&$disabled": {
        color: theme2.palette.action.disabled,
        boxShadow: theme2.shadows[0],
        backgroundColor: theme2.palette.action.disabledBackground
      }
    },
    /* Styles applied to the root element if `variant="contained"` and `color="primary"`. */
    containedPrimary: {
      color: theme2.palette.primary.contrastText,
      backgroundColor: theme2.palette.primary.main,
      "&:hover": {
        backgroundColor: theme2.palette.primary.dark,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme2.palette.primary.main
        }
      }
    },
    /* Styles applied to the root element if `variant="contained"` and `color="secondary"`. */
    containedSecondary: {
      color: theme2.palette.secondary.contrastText,
      backgroundColor: theme2.palette.secondary.main,
      "&:hover": {
        backgroundColor: theme2.palette.secondary.dark,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme2.palette.secondary.main
        }
      }
    },
    /* Pseudo-class applied to the ButtonBase root element if the button is keyboard focused. */
    focusVisible: {},
    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Styles applied to the root element if `color="inherit"`. */
    colorInherit: {
      color: "inherit",
      borderColor: "currentColor"
    },
    /* Styles applied to the root element if `size="small"` and `variant="text"`. */
    textSizeSmall: {
      padding: "4px 5px",
      fontSize: theme2.typography.pxToRem(13)
    },
    /* Styles applied to the root element if `size="large"` and `variant="text"`. */
    textSizeLarge: {
      padding: "8px 11px",
      fontSize: theme2.typography.pxToRem(15)
    },
    /* Styles applied to the root element if `size="small"` and `variant="outlined"`. */
    outlinedSizeSmall: {
      padding: "3px 9px",
      fontSize: theme2.typography.pxToRem(13)
    },
    /* Styles applied to the root element if `size="large"` and `variant="outlined"`. */
    outlinedSizeLarge: {
      padding: "7px 21px",
      fontSize: theme2.typography.pxToRem(15)
    },
    /* Styles applied to the root element if `size="small"` and `variant="contained"`. */
    containedSizeSmall: {
      padding: "4px 10px",
      fontSize: theme2.typography.pxToRem(13)
    },
    /* Styles applied to the root element if `size="large"` and `variant="contained"`. */
    containedSizeLarge: {
      padding: "8px 22px",
      fontSize: theme2.typography.pxToRem(15)
    },
    /* Styles applied to the root element if `size="small"`. */
    sizeSmall: {},
    /* Styles applied to the root element if `size="large"`. */
    sizeLarge: {},
    /* Styles applied to the root element if `fullWidth={true}`. */
    fullWidth: {
      width: "100%"
    },
    /* Styles applied to the startIcon element if supplied. */
    startIcon: {
      display: "inherit",
      marginRight: 8,
      marginLeft: -4
    },
    /* Styles applied to the endIcon element if supplied. */
    endIcon: {
      display: "inherit",
      marginRight: -4,
      marginLeft: 8
    },
    /* Styles applied to the icon element if supplied and `size="small"`. */
    iconSizeSmall: {
      "& > *:first-child": {
        fontSize: 18
      }
    },
    /* Styles applied to the icon element if supplied and `size="medium"`. */
    iconSizeMedium: {
      "& > *:first-child": {
        fontSize: 20
      }
    },
    /* Styles applied to the icon element if supplied and `size="large"`. */
    iconSizeLarge: {
      "& > *:first-child": {
        fontSize: 22
      }
    }
  };
};
var Button = React.forwardRef(function Button2(props, ref2) {
  var children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "default" : _props$color, _props$component = props.component, component = _props$component === void 0 ? "button" : _props$component, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableFocusRi = props.disableFocusRipple, disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi, endIconProp = props.endIcon, focusVisibleClassName = props.focusVisibleClassName, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, startIconProp = props.startIcon, _props$type = props.type, type2 = _props$type === void 0 ? "button" : _props$type, _props$variant = props.variant, variant = _props$variant === void 0 ? "text" : _props$variant, other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "disabled", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"]);
  var startIcon = startIconProp && React.createElement("span", {
    className: clsx(classes.startIcon, classes["iconSize".concat(capitalize(size))])
  }, startIconProp);
  var endIcon = endIconProp && React.createElement("span", {
    className: clsx(classes.endIcon, classes["iconSize".concat(capitalize(size))])
  }, endIconProp);
  return React.createElement(ButtonBase$1, _extends$1({
    className: clsx(classes.root, classes[variant], className, color === "inherit" ? classes.colorInherit : color !== "default" && classes["".concat(variant).concat(capitalize(color))], size !== "medium" && [classes["".concat(variant, "Size").concat(capitalize(size))], classes["size".concat(capitalize(size))]], disabled && classes.disabled, fullWidth && classes.fullWidth),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref: ref2,
    type: type2
  }, other), React.createElement("span", {
    className: classes.label
  }, startIcon, children, endIcon));
});
const Button$1 = withStyles(styles$r, {
  name: "MuiButton"
})(Button);
var FormControlContext = React.createContext();
function useFormControl$1() {
  return React.useContext(FormControlContext);
}
function useFormControl() {
  return React.useContext(FormControlContext);
}
var styles$q = function styles27(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      textAlign: "center",
      flex: "0 0 auto",
      fontSize: theme2.typography.pxToRem(24),
      padding: 12,
      borderRadius: "50%",
      overflow: "visible",
      // Explicitly set the default value to solve a bug on IE 11.
      color: theme2.palette.action.active,
      transition: theme2.transitions.create("background-color", {
        duration: theme2.transitions.duration.shortest
      }),
      "&:hover": {
        backgroundColor: fade(theme2.palette.action.active, theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      "&$disabled": {
        backgroundColor: "transparent",
        color: theme2.palette.action.disabled
      }
    },
    /* Styles applied to the root element if `edge="start"`. */
    edgeStart: {
      marginLeft: -12,
      "$sizeSmall&": {
        marginLeft: -3
      }
    },
    /* Styles applied to the root element if `edge="end"`. */
    edgeEnd: {
      marginRight: -12,
      "$sizeSmall&": {
        marginRight: -3
      }
    },
    /* Styles applied to the root element if `color="inherit"`. */
    colorInherit: {
      color: "inherit"
    },
    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      color: theme2.palette.primary.main,
      "&:hover": {
        backgroundColor: fade(theme2.palette.primary.main, theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    /* Styles applied to the root element if `color="secondary"`. */
    colorSecondary: {
      color: theme2.palette.secondary.main,
      "&:hover": {
        backgroundColor: fade(theme2.palette.secondary.main, theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Styles applied to the root element if `size="small"`. */
    sizeSmall: {
      padding: 3,
      fontSize: theme2.typography.pxToRem(18)
    },
    /* Styles applied to the children container element. */
    label: {
      width: "100%",
      display: "flex",
      alignItems: "inherit",
      justifyContent: "inherit"
    }
  };
};
var IconButton = React.forwardRef(function IconButton2(props, ref2) {
  var _props$edge = props.edge, edge = _props$edge === void 0 ? false : _props$edge, children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "default" : _props$color, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableFocusRi = props.disableFocusRipple, disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, other = _objectWithoutProperties(props, ["edge", "children", "classes", "className", "color", "disabled", "disableFocusRipple", "size"]);
  return React.createElement(ButtonBase$1, _extends$1({
    className: clsx(classes.root, className, color !== "default" && classes["color".concat(capitalize(color))], disabled && classes.disabled, {
      small: classes["size".concat(capitalize(size))]
    }[size], {
      start: classes.edgeStart,
      end: classes.edgeEnd
    }[edge]),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    ref: ref2
  }, other), React.createElement("span", {
    className: classes.label
  }, children));
});
const IconButton$1 = withStyles(styles$q, {
  name: "MuiIconButton"
})(IconButton);
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function getContainer$1(container) {
  container = typeof container === "function" ? container() : container;
  return ReactDOM.findDOMNode(container);
}
var useEnhancedEffect$4 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var Portal = React.forwardRef(function Portal2(props, ref2) {
  var children = props.children, container = props.container, _props$disablePortal = props.disablePortal, disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal, onRendered = props.onRendered;
  var _React$useState = React.useState(null), mountNode = _React$useState[0], setMountNode = _React$useState[1];
  var handleRef = useForkRef(children.ref, ref2);
  useEnhancedEffect$4(function() {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect$4(function() {
    if (mountNode && !disablePortal) {
      setRef(ref2, mountNode);
      return function() {
        setRef(ref2, null);
      };
    }
    return void 0;
  }, [ref2, mountNode, disablePortal]);
  useEnhancedEffect$4(function() {
    if (onRendered && (mountNode || disablePortal)) {
      onRendered();
    }
  }, [onRendered, mountNode, disablePortal]);
  if (disablePortal) {
    React.Children.only(children);
    return React.cloneElement(children, {
      ref: handleRef
    });
  }
  return mountNode ? ReactDOM.createPortal(children, mountNode) : mountNode;
});
function createChainedFunction() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  return funcs.reduce(function(acc, func) {
    if (func == null) {
      return acc;
    }
    return function chainedFunction() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, function() {
  });
}
function getScrollbarSize() {
  var scrollDiv = document.createElement("div");
  scrollDiv.style.width = "99px";
  scrollDiv.style.height = "99px";
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  var scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarSize;
}
function ownerWindow(node2) {
  var doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function isOverflowing(container) {
  var doc = ownerDocument(container);
  if (doc.body === container) {
    var win = ownerWindow(doc);
    return win.innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(node2, show) {
  if (show) {
    node2.setAttribute("aria-hidden", "true");
  } else {
    node2.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(node2) {
  return parseInt(window.getComputedStyle(node2)["padding-right"], 10) || 0;
}
var BLACKLIST = ["template", "script", "style"];
function isHideable(node2) {
  return node2.nodeType === 1 && BLACKLIST.indexOf(node2.tagName.toLowerCase()) === -1;
}
function siblings(container, mount, currentNode, nodesToExclude, callback) {
  var blacklist = [mount, currentNode].concat(_toConsumableArray(nodesToExclude));
  [].forEach.call(container.children, function(node2) {
    if (blacklist.indexOf(node2) === -1 && isHideable(node2)) {
      callback(node2);
    }
  });
}
function ariaHiddenSiblings(container, mountNode, currentNode) {
  var nodesToExclude = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  var show = arguments.length > 4 ? arguments[4] : void 0;
  siblings(container, mountNode, currentNode, nodesToExclude, function(node2) {
    return ariaHidden(node2, show);
  });
}
function findIndexOf(containerInfo, callback) {
  var idx = -1;
  containerInfo.some(function(item, index2) {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  var restoreStyle = {};
  var style2 = {};
  var restorePaddings = [];
  var fixedNodes;
  if (!props.disableScrollLock) {
    restoreStyle.overflow = containerInfo.container.style.overflow;
    restoreStyle["padding-right"] = containerInfo.container.style.paddingRight;
    style2.overflow = "hidden";
    if (isOverflowing(containerInfo.container)) {
      var scrollbarSize = getScrollbarSize();
      style2["padding-right"] = "".concat(getPaddingRight(containerInfo.container) + scrollbarSize, "px");
      fixedNodes = ownerDocument(containerInfo.container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedNodes, function(node2) {
        restorePaddings.push(node2.style.paddingRight);
        node2.style.paddingRight = "".concat(getPaddingRight(node2) + scrollbarSize, "px");
      });
    }
  }
  Object.keys(style2).forEach(function(key2) {
    containerInfo.container.style[key2] = style2[key2];
  });
  var restore = function restore2() {
    if (fixedNodes) {
      [].forEach.call(fixedNodes, function(node2, i2) {
        if (restorePaddings[i2]) {
          node2.style.paddingRight = restorePaddings[i2];
        } else {
          node2.style.removeProperty("padding-right");
        }
      });
    }
    Object.keys(restoreStyle).forEach(function(key2) {
      if (restoreStyle[key2]) {
        containerInfo.container.style.setProperty(key2, restoreStyle[key2]);
      } else {
        containerInfo.container.style.removeProperty(key2);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  var hiddenSiblings = [];
  [].forEach.call(container.children, function(node2) {
    if (node2.getAttribute && node2.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(node2);
    }
  });
  return hiddenSiblings;
}
var ModalManager = /* @__PURE__ */ function() {
  function ModalManager2() {
    _classCallCheck(this, ModalManager2);
    this.modals = [];
    this.containers = [];
  }
  _createClass(ModalManager2, [{
    key: "add",
    value: function add(modal, container) {
      var modalIndex = this.modals.indexOf(modal);
      if (modalIndex !== -1) {
        return modalIndex;
      }
      modalIndex = this.modals.length;
      this.modals.push(modal);
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, false);
      }
      var hiddenSiblingNodes = getHiddenSiblings(container);
      ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);
      var containerIndex = findIndexOf(this.containers, function(item) {
        return item.container === container;
      });
      if (containerIndex !== -1) {
        this.containers[containerIndex].modals.push(modal);
        return modalIndex;
      }
      this.containers.push({
        modals: [modal],
        container,
        restore: null,
        hiddenSiblingNodes
      });
      return modalIndex;
    }
  }, {
    key: "mount",
    value: function mount(modal, props) {
      var containerIndex = findIndexOf(this.containers, function(item) {
        return item.modals.indexOf(modal) !== -1;
      });
      var containerInfo = this.containers[containerIndex];
      if (!containerInfo.restore) {
        containerInfo.restore = handleContainer(containerInfo, props);
      }
    }
  }, {
    key: "remove",
    value: function remove3(modal) {
      var modalIndex = this.modals.indexOf(modal);
      if (modalIndex === -1) {
        return modalIndex;
      }
      var containerIndex = findIndexOf(this.containers, function(item) {
        return item.modals.indexOf(modal) !== -1;
      });
      var containerInfo = this.containers[containerIndex];
      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
      this.modals.splice(modalIndex, 1);
      if (containerInfo.modals.length === 0) {
        if (containerInfo.restore) {
          containerInfo.restore();
        }
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, true);
        }
        ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);
        this.containers.splice(containerIndex, 1);
      } else {
        var nextTop = containerInfo.modals[containerInfo.modals.length - 1];
        if (nextTop.modalRef) {
          ariaHidden(nextTop.modalRef, false);
        }
      }
      return modalIndex;
    }
  }, {
    key: "isTopModal",
    value: function isTopModal(modal) {
      return !!this.modals.length && this.modals[this.modals.length - 1] === modal;
    }
  }]);
  return ModalManager2;
}();
function TrapFocus(props) {
  var children = props.children, _props$disableAutoFoc = props.disableAutoFocus, disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$disableEnforce = props.disableEnforceFocus, disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce, _props$disableRestore = props.disableRestoreFocus, disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore, getDoc = props.getDoc, isEnabled = props.isEnabled, open = props.open;
  var ignoreNextEnforceFocus = React.useRef();
  var sentinelStart = React.useRef(null);
  var sentinelEnd = React.useRef(null);
  var nodeToRestore = React.useRef();
  var rootRef = React.useRef(null);
  var handleOwnRef = React.useCallback(function(instance) {
    rootRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var handleRef = useForkRef(children.ref, handleOwnRef);
  React.useMemo(function() {
    if (!open || typeof window === "undefined") {
      return;
    }
    nodeToRestore.current = getDoc().activeElement;
  }, [open]);
  React.useEffect(function() {
    if (!open) {
      return;
    }
    var doc = ownerDocument(rootRef.current);
    if (!disableAutoFocus && rootRef.current && !rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", -1);
      }
      rootRef.current.focus();
    }
    var contain = function contain2() {
      if (disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootRef.current && !rootRef.current.contains(doc.activeElement)) {
        rootRef.current.focus();
      }
    };
    var loopFocus = function loopFocus2(event) {
      if (disableEnforceFocus || !isEnabled() || event.keyCode !== 9) {
        return;
      }
      if (doc.activeElement === rootRef.current) {
        ignoreNextEnforceFocus.current = true;
        if (event.shiftKey) {
          sentinelEnd.current.focus();
        } else {
          sentinelStart.current.focus();
        }
      }
    };
    doc.addEventListener("focus", contain, true);
    doc.addEventListener("keydown", loopFocus, true);
    var interval2 = setInterval(function() {
      contain();
    }, 50);
    return function() {
      clearInterval(interval2);
      doc.removeEventListener("focus", contain, true);
      doc.removeEventListener("keydown", loopFocus, true);
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open]);
  return React.createElement(React.Fragment, null, React.createElement("div", {
    tabIndex: 0,
    ref: sentinelStart,
    "data-test": "sentinelStart"
  }), React.cloneElement(children, {
    ref: handleRef
  }), React.createElement("div", {
    tabIndex: 0,
    ref: sentinelEnd,
    "data-test": "sentinelEnd"
  }));
}
var styles$p = {
  /* Styles applied to the root element. */
  root: {
    zIndex: -1,
    position: "fixed",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    // Remove grey highlight
    WebkitTapHighlightColor: "transparent",
    // Disable scroll capabilities.
    touchAction: "none"
  },
  /* Styles applied to the root element if `invisible={true}`. */
  invisible: {
    backgroundColor: "transparent"
  }
};
var SimpleBackdrop = React.forwardRef(function SimpleBackdrop2(props, ref2) {
  var _props$invisible = props.invisible, invisible = _props$invisible === void 0 ? false : _props$invisible, open = props.open, other = _objectWithoutProperties(props, ["invisible", "open"]);
  return open ? React.createElement("div", _extends$1({
    "aria-hidden": true,
    ref: ref2
  }, other, {
    style: _extends$1({}, styles$p.root, {}, invisible ? styles$p.invisible : {}, {}, other.style)
  })) : null;
});
function getContainer(container) {
  container = typeof container === "function" ? container() : container;
  return ReactDOM.findDOMNode(container);
}
function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty("in") : false;
}
var defaultManager = new ModalManager();
var styles$o = function styles28(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      position: "fixed",
      zIndex: theme2.zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0
    },
    /* Styles applied to the root element if the `Modal` has exited. */
    hidden: {
      visibility: "hidden"
    }
  };
};
var Modal = React.forwardRef(function Modal2(inProps, ref2) {
  var theme2 = useTheme$1();
  var props = getThemeProps({
    name: "MuiModal",
    props: _extends$1({}, inProps),
    theme: theme2
  });
  var _props$BackdropCompon = props.BackdropComponent, BackdropComponent = _props$BackdropCompon === void 0 ? SimpleBackdrop : _props$BackdropCompon, BackdropProps = props.BackdropProps, children = props.children, _props$closeAfterTran = props.closeAfterTransition, closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran, container = props.container, _props$disableAutoFoc = props.disableAutoFocus, disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$disableBackdro = props.disableBackdropClick, disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro, _props$disableEnforce = props.disableEnforceFocus, disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce, _props$disableEscapeK = props.disableEscapeKeyDown, disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK, _props$disablePortal = props.disablePortal, disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal, _props$disableRestore = props.disableRestoreFocus, disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore, _props$disableScrollL = props.disableScrollLock, disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL, _props$hideBackdrop = props.hideBackdrop, hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop, _props$keepMounted = props.keepMounted, keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted, _props$manager = props.manager, manager = _props$manager === void 0 ? defaultManager : _props$manager, onBackdropClick = props.onBackdropClick, onClose = props.onClose, onEscapeKeyDown = props.onEscapeKeyDown, onRendered = props.onRendered, open = props.open, other = _objectWithoutProperties(props, ["BackdropComponent", "BackdropProps", "children", "closeAfterTransition", "container", "disableAutoFocus", "disableBackdropClick", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onEscapeKeyDown", "onRendered", "open"]);
  var _React$useState = React.useState(true), exited = _React$useState[0], setExited = _React$useState[1];
  var modal = React.useRef({});
  var mountNodeRef = React.useRef(null);
  var modalRef = React.useRef(null);
  var handleRef = useForkRef(modalRef, ref2);
  var hasTransition = getHasTransition(props);
  var getDoc = function getDoc2() {
    return ownerDocument(mountNodeRef.current);
  };
  var getModal = function getModal2() {
    modal.current.modalRef = modalRef.current;
    modal.current.mountNode = mountNodeRef.current;
    return modal.current;
  };
  var handleMounted = function handleMounted2() {
    manager.mount(getModal(), {
      disableScrollLock
    });
    modalRef.current.scrollTop = 0;
  };
  var handleOpen = useEventCallback(function() {
    var resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  var isTopModal = React.useCallback(function() {
    return manager.isTopModal(getModal());
  }, [manager]);
  var handlePortalRef = useEventCallback(function(node2) {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (onRendered) {
      onRendered();
    }
    if (open && isTopModal()) {
      handleMounted();
    } else {
      ariaHidden(modalRef.current, true);
    }
  });
  var handleClose = React.useCallback(function() {
    manager.remove(getModal());
  }, [manager]);
  React.useEffect(function() {
    return function() {
      handleClose();
    };
  }, [handleClose]);
  React.useEffect(function() {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  var handleEnter = function handleEnter2() {
    setExited(false);
  };
  var handleExited = function handleExited2() {
    setExited(true);
    if (closeAfterTransition) {
      handleClose();
    }
  };
  var handleBackdropClick = function handleBackdropClick2(event) {
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (!disableBackdropClick && onClose) {
      onClose(event, "backdropClick");
    }
  };
  var handleKeyDown2 = function handleKeyDown22(event) {
    if (event.key !== "Escape" || !isTopModal()) {
      return;
    }
    event.stopPropagation();
    if (onEscapeKeyDown) {
      onEscapeKeyDown(event);
    }
    if (!disableEscapeKeyDown && onClose) {
      onClose(event, "escapeKeyDown");
    }
  };
  var inlineStyle = styles$o(theme2 || {
    zIndex: zIndex$1
  });
  var childProps = {};
  if (children.tabIndex === void 0) {
    childProps.tabIndex = children.tabIndex || "-1";
  }
  if (hasTransition) {
    childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
    childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
  }
  return React.createElement(Portal, {
    ref: handlePortalRef,
    container,
    disablePortal
  }, React.createElement("div", _extends$1({
    ref: handleRef,
    onKeyDown: handleKeyDown2,
    role: "presentation"
  }, other, {
    style: _extends$1({}, inlineStyle.root, {}, !open && exited ? inlineStyle.hidden : {}, {}, other.style)
  }), hideBackdrop ? null : React.createElement(BackdropComponent, _extends$1({
    open,
    onClick: handleBackdropClick
  }, BackdropProps)), React.createElement(TrapFocus, {
    disableEnforceFocus,
    disableAutoFocus,
    disableRestoreFocus,
    getDoc,
    isEnabled: isTopModal,
    open
  }, React.cloneElement(children, childProps))));
});
var styles$n = function styles29(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      "@media print": {
        // Use !important to override the Modal inline-style.
        position: "absolute !important"
      }
    },
    /* Styles applied to the container element if `scroll="paper"`. */
    scrollPaper: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    },
    /* Styles applied to the container element if `scroll="body"`. */
    scrollBody: {
      overflowY: "auto",
      overflowX: "hidden",
      textAlign: "center",
      "&:after": {
        content: '""',
        display: "inline-block",
        verticalAlign: "middle",
        height: "100%",
        width: "0"
      }
    },
    /* Styles applied to the container element. */
    container: {
      height: "100%",
      "@media print": {
        height: "auto"
      },
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    },
    /* Styles applied to the `Paper` component. */
    paper: {
      margin: 48,
      position: "relative",
      overflowY: "auto",
      // Fix IE 11 issue, to remove at some point.
      "@media print": {
        overflowY: "visible",
        boxShadow: "none"
      }
    },
    /* Styles applied to the `Paper` component if `scroll="paper"`. */
    paperScrollPaper: {
      display: "flex",
      flexDirection: "column",
      maxHeight: "calc(100% - 96px)"
    },
    /* Styles applied to the `Paper` component if `scroll="body"`. */
    paperScrollBody: {
      display: "inline-block",
      verticalAlign: "middle",
      textAlign: "left"
      // 'initial' doesn't work on IE 11
    },
    /* Styles applied to the `Paper` component if `maxWidth=false`. */
    paperWidthFalse: {
      maxWidth: "calc(100% - 96px)"
    },
    /* Styles applied to the `Paper` component if `maxWidth="xs"`. */
    paperWidthXs: {
      maxWidth: Math.max(theme2.breakpoints.values.xs, 444),
      "&$paperScrollBody": _defineProperty$1({}, theme2.breakpoints.down(Math.max(theme2.breakpoints.values.xs, 444) + 48 * 2), {
        maxWidth: "calc(100% - 96px)"
      })
    },
    /* Styles applied to the `Paper` component if `maxWidth="sm"`. */
    paperWidthSm: {
      maxWidth: theme2.breakpoints.values.sm,
      "&$paperScrollBody": _defineProperty$1({}, theme2.breakpoints.down(theme2.breakpoints.values.sm + 48 * 2), {
        maxWidth: "calc(100% - 96px)"
      })
    },
    /* Styles applied to the `Paper` component if `maxWidth="md"`. */
    paperWidthMd: {
      maxWidth: theme2.breakpoints.values.md,
      "&$paperScrollBody": _defineProperty$1({}, theme2.breakpoints.down(theme2.breakpoints.values.md + 48 * 2), {
        maxWidth: "calc(100% - 96px)"
      })
    },
    /* Styles applied to the `Paper` component if `maxWidth="lg"`. */
    paperWidthLg: {
      maxWidth: theme2.breakpoints.values.lg,
      "&$paperScrollBody": _defineProperty$1({}, theme2.breakpoints.down(theme2.breakpoints.values.lg + 48 * 2), {
        maxWidth: "calc(100% - 96px)"
      })
    },
    /* Styles applied to the `Paper` component if `maxWidth="xl"`. */
    paperWidthXl: {
      maxWidth: theme2.breakpoints.values.xl,
      "&$paperScrollBody": _defineProperty$1({}, theme2.breakpoints.down(theme2.breakpoints.values.xl + 48 * 2), {
        maxWidth: "calc(100% - 96px)"
      })
    },
    /* Styles applied to the `Paper` component if `fullWidth={true}`. */
    paperFullWidth: {
      width: "calc(100% - 96px)"
    },
    /* Styles applied to the `Paper` component if `fullScreen={true}`. */
    paperFullScreen: {
      margin: 0,
      width: "100%",
      maxWidth: "100%",
      height: "100%",
      maxHeight: "none",
      borderRadius: 0,
      "&$paperScrollBody": {
        margin: 0,
        maxWidth: "100%"
      }
    }
  };
};
var defaultTransitionDuration = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
var Dialog = React.forwardRef(function Dialog2(props, ref2) {
  var BackdropProps = props.BackdropProps, children = props.children, classes = props.classes, className = props.className, _props$disableBackdro = props.disableBackdropClick, disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro, _props$disableEscapeK = props.disableEscapeKeyDown, disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK, _props$fullScreen = props.fullScreen, fullScreen = _props$fullScreen === void 0 ? false : _props$fullScreen, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$maxWidth = props.maxWidth, maxWidth = _props$maxWidth === void 0 ? "sm" : _props$maxWidth, onBackdropClick = props.onBackdropClick, onClose = props.onClose, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onEscapeKeyDown = props.onEscapeKeyDown, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, open = props.open, _props$PaperComponent = props.PaperComponent, PaperComponent = _props$PaperComponent === void 0 ? Paper$1 : _props$PaperComponent, _props$PaperProps = props.PaperProps, PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps, _props$scroll = props.scroll, scroll = _props$scroll === void 0 ? "paper" : _props$scroll, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Fade : _props$TransitionComp, _props$transitionDura = props.transitionDuration, transitionDuration = _props$transitionDura === void 0 ? defaultTransitionDuration : _props$transitionDura, TransitionProps = props.TransitionProps, other = _objectWithoutProperties(props, ["BackdropProps", "children", "classes", "className", "disableBackdropClick", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "onEnter", "onEntered", "onEntering", "onEscapeKeyDown", "onExit", "onExited", "onExiting", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"]);
  var mouseDownTarget = React.useRef();
  var handleMouseDown = function handleMouseDown2(event) {
    mouseDownTarget.current = event.target;
  };
  var handleBackdropClick = function handleBackdropClick2(event) {
    if (event.target !== event.currentTarget) {
      return;
    }
    if (event.target !== mouseDownTarget.current) {
      return;
    }
    mouseDownTarget.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (!disableBackdropClick && onClose) {
      onClose(event, "backdropClick");
    }
  };
  return React.createElement(Modal, _extends$1({
    className: clsx(classes.root, className),
    BackdropComponent: Backdrop$1,
    BackdropProps: _extends$1({
      transitionDuration
    }, BackdropProps),
    closeAfterTransition: true,
    disableBackdropClick,
    disableEscapeKeyDown,
    onEscapeKeyDown,
    onClose,
    open,
    ref: ref2
  }, other), React.createElement(TransitionComponent, _extends$1({
    appear: true,
    in: open,
    timeout: transitionDuration,
    onEnter,
    onEntering,
    onEntered,
    onExit,
    onExiting,
    onExited,
    role: "none presentation"
  }, TransitionProps), React.createElement("div", {
    className: clsx(classes.container, classes["scroll".concat(capitalize(scroll))]),
    onClick: handleBackdropClick,
    onMouseDown: handleMouseDown
  }, React.createElement(PaperComponent, _extends$1({
    elevation: 24,
    role: "dialog"
  }, PaperProps, {
    className: clsx(classes.paper, classes["paperScroll".concat(capitalize(scroll))], classes["paperWidth".concat(capitalize(String(maxWidth)))], PaperProps.className, fullScreen && classes.paperFullScreen, fullWidth && classes.paperFullWidth)
  }), children))));
});
const Dialog$1 = withStyles(styles$n, {
  name: "MuiDialog"
})(Dialog);
var styles$m = {
  /* Styles applied to the root element. */
  root: {
    display: "flex",
    alignItems: "center",
    padding: 8,
    justifyContent: "flex-end",
    flex: "0 0 auto"
  },
  /* Styles applied to the root element if `disableSpacing={false}`. */
  spacing: {
    "& > * + *": {
      marginLeft: 8
    }
  }
};
var DialogActions = React.forwardRef(function DialogActions2(props, ref2) {
  var _props$disableSpacing = props.disableSpacing, disableSpacing = _props$disableSpacing === void 0 ? false : _props$disableSpacing, classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["disableSpacing", "classes", "className"]);
  return React.createElement("div", _extends$1({
    className: clsx(classes.root, className, !disableSpacing && classes.spacing),
    ref: ref2
  }, other));
});
const DialogActions$1 = withStyles(styles$m, {
  name: "MuiDialogActions"
})(DialogActions);
var styles$l = function styles210(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      flex: "1 1 auto",
      WebkitOverflowScrolling: "touch",
      // Add iOS momentum scrolling.
      overflowY: "auto",
      padding: "8px 24px",
      "&:first-child": {
        // dialog without title
        paddingTop: 20
      }
    },
    /* Styles applied to the root element if `dividers={true}`. */
    dividers: {
      padding: "16px 24px",
      borderTop: "1px solid ".concat(theme2.palette.divider),
      borderBottom: "1px solid ".concat(theme2.palette.divider)
    }
  };
};
var DialogContent = React.forwardRef(function DialogContent2(props, ref2) {
  var classes = props.classes, className = props.className, _props$dividers = props.dividers, dividers = _props$dividers === void 0 ? false : _props$dividers, other = _objectWithoutProperties(props, ["classes", "className", "dividers"]);
  return React.createElement("div", _extends$1({
    className: clsx(classes.root, className, dividers && classes.dividers),
    ref: ref2
  }, other));
});
const DialogContent$1 = withStyles(styles$l, {
  name: "MuiDialogContent"
})(DialogContent);
var styles$k = {
  /* Styles applied to the root element. */
  root: {
    margin: 0,
    padding: "16px 24px",
    flex: "0 0 auto"
  }
};
var DialogTitle = React.forwardRef(function DialogTitle2(props, ref2) {
  var children = props.children, classes = props.classes, className = props.className, _props$disableTypogra = props.disableTypography, disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra, other = _objectWithoutProperties(props, ["children", "classes", "className", "disableTypography"]);
  return React.createElement("div", _extends$1({
    className: clsx(classes.root, className),
    ref: ref2
  }, other), disableTypography ? children : React.createElement(Typography$1, {
    component: "h2",
    variant: "h6"
  }, children));
});
const DialogTitle$1 = withStyles(styles$k, {
  name: "MuiDialogTitle"
})(DialogTitle);
function debounce(func) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 166;
  var timeout;
  function debounced() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var that = this;
    var later = function later2() {
      func.apply(that, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = function() {
    clearTimeout(timeout);
  };
  return debounced;
}
function getTranslateValue(direction, node2) {
  var rect = node2.getBoundingClientRect();
  var transform2;
  if (node2.fakeTransform) {
    transform2 = node2.fakeTransform;
  } else {
    var computedStyle = window.getComputedStyle(node2);
    transform2 = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
  }
  var offsetX = 0;
  var offsetY = 0;
  if (transform2 && transform2 !== "none" && typeof transform2 === "string") {
    var transformValues = transform2.split("(")[1].split(")")[0].split(",");
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }
  if (direction === "left") {
    return "translateX(".concat(window.innerWidth, "px) translateX(-").concat(rect.left - offsetX, "px)");
  }
  if (direction === "right") {
    return "translateX(-".concat(rect.left + rect.width - offsetX, "px)");
  }
  if (direction === "up") {
    return "translateY(".concat(window.innerHeight, "px) translateY(-").concat(rect.top - offsetY, "px)");
  }
  return "translateY(-".concat(rect.top + rect.height - offsetY, "px)");
}
function setTranslateValue(direction, node2) {
  var transform2 = getTranslateValue(direction, node2);
  if (transform2) {
    node2.style.webkitTransform = transform2;
    node2.style.transform = transform2;
  }
}
var defaultTimeout = {
  enter: duration.enteringScreen,
  exit: duration.leavingScreen
};
var Slide = React.forwardRef(function Slide2(props, ref2) {
  var children = props.children, _props$direction = props.direction, direction = _props$direction === void 0 ? "down" : _props$direction, inProp = props.in, onEnter = props.onEnter, onEntering = props.onEntering, onExit = props.onExit, onExited = props.onExited, style2 = props.style, _props$timeout = props.timeout, timeout = _props$timeout === void 0 ? defaultTimeout : _props$timeout, other = _objectWithoutProperties(props, ["children", "direction", "in", "onEnter", "onEntering", "onExit", "onExited", "style", "timeout"]);
  var theme2 = useTheme();
  var childrenRef = React.useRef(null);
  var handleOwnRef = React.useCallback(function(instance) {
    childrenRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var handleRefIntermediary = useForkRef(children.ref, handleOwnRef);
  var handleRef = useForkRef(handleRefIntermediary, ref2);
  var handleEnter = function handleEnter2(_23, isAppearing) {
    var node2 = childrenRef.current;
    setTranslateValue(direction, node2);
    reflow(node2);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  var handleEntering = function handleEntering2(_23, isAppearing) {
    var node2 = childrenRef.current;
    var transitionProps = getTransitionProps({
      timeout,
      style: style2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("-webkit-transform", _extends$1({}, transitionProps, {
      easing: theme2.transitions.easing.easeOut
    }));
    node2.style.transition = theme2.transitions.create("transform", _extends$1({}, transitionProps, {
      easing: theme2.transitions.easing.easeOut
    }));
    node2.style.webkitTransform = "none";
    node2.style.transform = "none";
    if (onEntering) {
      onEntering(node2, isAppearing);
    }
  };
  var handleExit = function handleExit2() {
    var node2 = childrenRef.current;
    var transitionProps = getTransitionProps({
      timeout,
      style: style2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("-webkit-transform", _extends$1({}, transitionProps, {
      easing: theme2.transitions.easing.sharp
    }));
    node2.style.transition = theme2.transitions.create("transform", _extends$1({}, transitionProps, {
      easing: theme2.transitions.easing.sharp
    }));
    setTranslateValue(direction, node2);
    if (onExit) {
      onExit(node2);
    }
  };
  var handleExited = function handleExited2() {
    var node2 = childrenRef.current;
    node2.style.webkitTransition = "";
    node2.style.transition = "";
    if (onExited) {
      onExited(node2);
    }
  };
  var updatePosition = React.useCallback(function() {
    if (childrenRef.current) {
      setTranslateValue(direction, childrenRef.current);
    }
  }, [direction]);
  React.useEffect(function() {
    if (!inProp && direction !== "down" && direction !== "right") {
      var handleResize = debounce(function() {
        if (childrenRef.current) {
          setTranslateValue(direction, childrenRef.current);
        }
      });
      window.addEventListener("resize", handleResize);
      return function() {
        handleResize.clear();
        window.removeEventListener("resize", handleResize);
      };
    }
    return void 0;
  }, [direction, inProp]);
  React.useEffect(function() {
    if (!inProp) {
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return React.createElement(Transition, _extends$1({
    onEnter: handleEnter,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    appear: true,
    in: inProp,
    timeout
  }, other), function(state2, childProps) {
    return React.cloneElement(children, _extends$1({
      ref: handleRef,
      style: _extends$1({
        visibility: state2 === "exited" && !inProp ? "hidden" : void 0
      }, style2, {}, children.props.style)
    }, childProps));
  });
});
function formControlState(_ref3) {
  var props = _ref3.props, states = _ref3.states, muiFormControl = _ref3.muiFormControl;
  return states.reduce(function(acc, state2) {
    acc[state2] = props[state2];
    if (muiFormControl) {
      if (typeof props[state2] === "undefined") {
        acc[state2] = muiFormControl[state2];
      }
    }
    return acc;
  }, {});
}
function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}
var useEnhancedEffect$3 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var styles$j = {
  /* Styles applied to the shadow textarea element. */
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
var TextareaAutosize = React.forwardRef(function TextareaAutosize2(props, ref2) {
  var onChange = props.onChange, rows = props.rows, rowsMax = props.rowsMax, style2 = props.style, value = props.value, other = _objectWithoutProperties(props, ["onChange", "rows", "rowsMax", "style", "value"]);
  var _React$useRef = React.useRef(value != null), isControlled = _React$useRef.current;
  var inputRef = React.useRef(null);
  var handleRef = useForkRef(ref2, inputRef);
  var shadowRef = React.useRef(null);
  var _React$useState = React.useState({}), state2 = _React$useState[0], setState = _React$useState[1];
  var syncHeight = React.useCallback(function() {
    var input = inputRef.current;
    var computedStyle = window.getComputedStyle(input);
    var inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    var boxSizing = computedStyle["box-sizing"];
    var padding = getStyleValue(computedStyle, "padding-bottom") + getStyleValue(computedStyle, "padding-top");
    var border = getStyleValue(computedStyle, "border-bottom-width") + getStyleValue(computedStyle, "border-top-width");
    var innerHeight = inputShallow.scrollHeight - padding;
    inputShallow.value = "x";
    var singleRowHeight = inputShallow.scrollHeight - padding;
    var outerHeight = innerHeight;
    if (rows != null) {
      outerHeight = Math.max(Number(rows) * singleRowHeight, outerHeight);
    }
    if (rowsMax != null) {
      outerHeight = Math.min(Number(rowsMax) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    var outerHeightStyle = outerHeight + (boxSizing === "border-box" ? padding + border : 0);
    var overflow = Math.abs(outerHeight - innerHeight) <= 1;
    setState(function(prevState) {
      if (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow) {
        return {
          overflow,
          outerHeightStyle
        };
      }
      return prevState;
    });
  }, [rows, rowsMax, props.placeholder]);
  React.useEffect(function() {
    var handleResize = debounce(function() {
      syncHeight();
    });
    window.addEventListener("resize", handleResize);
    return function() {
      handleResize.clear();
      window.removeEventListener("resize", handleResize);
    };
  }, [syncHeight]);
  useEnhancedEffect$3(function() {
    syncHeight();
  });
  var handleChange = function handleChange2(event) {
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return React.createElement(React.Fragment, null, React.createElement("textarea", _extends$1({
    value,
    onChange: handleChange,
    ref: handleRef,
    rows: rows || 1,
    style: _extends$1({
      height: state2.outerHeightStyle,
      // Need a large enough different to allow scrolling.
      // This prevents infinite rendering loop.
      overflow: state2.overflow ? "hidden" : null
    }, style2)
  }, other)), React.createElement("textarea", {
    "aria-hidden": true,
    className: props.className,
    readOnly: true,
    ref: shadowRef,
    tabIndex: -1,
    style: _extends$1({}, styles$j.shadow, {}, style2)
  }));
});
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj) {
  var SSR = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}
var styles$i = function styles211(theme2) {
  var light2 = theme2.palette.type === "light";
  var placeholder = {
    color: "currentColor",
    opacity: light2 ? 0.42 : 0.5,
    transition: theme2.transitions.create("opacity", {
      duration: theme2.transitions.duration.shorter
    })
  };
  var placeholderHidden = {
    opacity: "0 !important"
  };
  var placeholderVisible = {
    opacity: light2 ? 0.42 : 0.5
  };
  return {
    /* Styles applied to the root element. */
    root: {
      // Mimics the default input display property used by browsers for an input.
      fontFamily: theme2.typography.fontFamily,
      color: theme2.palette.text.primary,
      fontSize: theme2.typography.pxToRem(16),
      lineHeight: "1.1875em",
      // Reset (19px), match the native input line-height
      boxSizing: "border-box",
      // Prevent padding issue with fullWidth.
      position: "relative",
      cursor: "text",
      display: "inline-flex",
      alignItems: "center",
      "&$disabled": {
        color: theme2.palette.text.disabled,
        cursor: "default"
      }
    },
    /* Styles applied to the root element if the component is a descendant of `FormControl`. */
    formControl: {},
    /* Styles applied to the root element if the component is focused. */
    focused: {},
    /* Styles applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Styles applied to the root element if `startAdornment` is provided. */
    adornedStart: {},
    /* Styles applied to the root element if `endAdornment` is provided. */
    adornedEnd: {},
    /* Styles applied to the root element if `error={true}`. */
    error: {},
    /* Styles applied to the `input` element if `margin="dense"`. */
    marginDense: {},
    /* Styles applied to the root element if `multiline={true}`. */
    multiline: {
      padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
      "&$marginDense": {
        paddingTop: 4 - 1
      }
    },
    /* Styles applied to the root element if `fullWidth={true}`. */
    fullWidth: {
      width: "100%"
    },
    /* Styles applied to the `input` element. */
    input: {
      font: "inherit",
      color: "currentColor",
      padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
      border: 0,
      boxSizing: "content-box",
      background: "none",
      height: "1.1875em",
      // Reset (19px), match the native input line-height
      margin: 0,
      // Reset for Safari
      // Remove grey highlight
      WebkitTapHighlightColor: "transparent",
      display: "block",
      // Make the flex item shrink with Firefox
      minWidth: 0,
      width: "100%",
      // Fix IE 11 width issue
      animationName: "$auto-fill-cancel",
      "&::-webkit-input-placeholder": placeholder,
      "&::-moz-placeholder": placeholder,
      // Firefox 19+
      "&:-ms-input-placeholder": placeholder,
      // IE 11
      "&::-ms-input-placeholder": placeholder,
      // Edge
      "&:focus": {
        outline: 0
      },
      // Reset Firefox invalid required input style
      "&:invalid": {
        boxShadow: "none"
      },
      "&::-webkit-search-decoration": {
        // Remove the padding when type=search.
        "-webkit-appearance": "none"
      },
      // Show and hide the placeholder logic
      "label[data-shrink=false] + $formControl &": {
        "&::-webkit-input-placeholder": placeholderHidden,
        "&::-moz-placeholder": placeholderHidden,
        // Firefox 19+
        "&:-ms-input-placeholder": placeholderHidden,
        // IE 11
        "&::-ms-input-placeholder": placeholderHidden,
        // Edge
        "&:focus::-webkit-input-placeholder": placeholderVisible,
        "&:focus::-moz-placeholder": placeholderVisible,
        // Firefox 19+
        "&:focus:-ms-input-placeholder": placeholderVisible,
        // IE 11
        "&:focus::-ms-input-placeholder": placeholderVisible
        // Edge
      },
      "&$disabled": {
        opacity: 1
        // Reset iOS opacity
      },
      "&:-webkit-autofill": {
        animationDuration: "5000s",
        animationName: "$auto-fill"
      }
    },
    "@keyframes auto-fill": {
      from: {}
    },
    "@keyframes auto-fill-cancel": {
      from: {}
    },
    /* Styles applied to the `input` element if `margin="dense"`. */
    inputMarginDense: {
      paddingTop: 4 - 1
    },
    /* Styles applied to the `input` element if `select={true}`. */
    inputSelect: {
      paddingRight: 24
    },
    /* Styles applied to the `input` element if `multiline={true}`. */
    inputMultiline: {
      height: "auto",
      resize: "none",
      padding: 0
    },
    /* Styles applied to the `input` element if `type="search"`. */
    inputTypeSearch: {
      // Improve type search style.
      "-moz-appearance": "textfield",
      "-webkit-appearance": "textfield"
    },
    /* Styles applied to the `input` element if `startAdornment` is provided. */
    inputAdornedStart: {},
    /* Styles applied to the `input` element if `endAdornment` is provided. */
    inputAdornedEnd: {},
    /* Styles applied to the `input` element if `hiddenLabel={true}`. */
    inputHiddenLabel: {}
  };
};
var useEnhancedEffect$2 = typeof window === "undefined" ? React.useEffect : React.useLayoutEffect;
var InputBase = React.forwardRef(function InputBase2(props, ref2) {
  var ariaDescribedby = props["aria-describedby"], autoComplete = props.autoComplete, autoFocus = props.autoFocus, classes = props.classes, classNameProp = props.className, defaultValue = props.defaultValue, disabled = props.disabled, endAdornment = props.endAdornment;
  props.error;
  var _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, id = props.id, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? "input" : _props$inputComponent, _props$inputProps = props.inputProps;
  _props$inputProps = _props$inputProps === void 0 ? {} : _props$inputProps;
  var inputPropsClassName = _props$inputProps.className, inputPropsProp = _objectWithoutProperties(_props$inputProps, ["className"]), inputRefProp = props.inputRef;
  props.margin;
  var _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onClick = props.onClick, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, placeholder = props.placeholder, readOnly = props.readOnly, renderSuffix = props.renderSuffix, rows = props.rows, rowsMax = props.rowsMax, _props$select = props.select, select = _props$select === void 0 ? false : _props$select, startAdornment = props.startAdornment, _props$type = props.type, type2 = _props$type === void 0 ? "text" : _props$type, value = props.value, other = _objectWithoutProperties(props, ["aria-describedby", "autoComplete", "autoFocus", "classes", "className", "defaultValue", "disabled", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "rowsMax", "select", "startAdornment", "type", "value"]);
  var _React$useRef = React.useRef(value != null), isControlled = _React$useRef.current;
  var inputRef = React.useRef();
  var handleInputRefWarning = React.useCallback(function(instance) {
  }, []);
  var handleInputPropsRefProp = useForkRef(inputPropsProp.ref, handleInputRefWarning);
  var handleInputRefProp = useForkRef(inputRefProp, handleInputPropsRefProp);
  var handleInputRef = useForkRef(inputRef, handleInputRefProp);
  var _React$useState = React.useState(false), focused = _React$useState[0], setFocused = _React$useState[1];
  var muiFormControl = useFormControl$1();
  var fcs = formControlState({
    props,
    muiFormControl,
    states: ["disabled", "error", "hiddenLabel", "margin", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  React.useEffect(function() {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  var onFilled = muiFormControl && muiFormControl.onFilled;
  var onEmpty = muiFormControl && muiFormControl.onEmpty;
  var checkDirty = React.useCallback(function(obj) {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect$2(function() {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  var handleFocus = function handleFocus2(event) {
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    if (onFocus) {
      onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  var handleBlur = function handleBlur2(event) {
    if (onBlur) {
      onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  var handleChange = function handleChange2(event) {
    if (!isControlled) {
      var element = event.target || inputRef.current;
      if (element == null) {
        throw new TypeError("Material-UI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://material-ui.com/r/input-component-ref-interface for more info.");
      }
      checkDirty({
        value: element.value
      });
    }
    if (onChange) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      onChange.apply(void 0, [event].concat(args));
    }
  };
  React.useEffect(function() {
    checkDirty(inputRef.current);
  }, []);
  var handleClick = function handleClick2(event) {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  var InputComponent = inputComponent;
  var inputProps = _extends$1({}, inputPropsProp, {
    ref: handleInputRef
  });
  if (typeof InputComponent !== "string") {
    inputProps = _extends$1({
      // Rename ref to inputRef as we don't know the
      // provided `inputComponent` structure.
      inputRef: handleInputRef,
      type: type2
    }, inputProps, {
      ref: null
    });
  } else if (multiline) {
    if (rows && !rowsMax) {
      InputComponent = "textarea";
    } else {
      inputProps = _extends$1({
        rows,
        rowsMax
      }, inputProps);
      InputComponent = TextareaAutosize;
    }
  } else {
    inputProps = _extends$1({
      type: type2
    }, inputProps);
  }
  var handleAutoFill = function handleAutoFill2(event) {
    checkDirty(event.animationName.indexOf("auto-fill-cancel") !== -1 ? inputRef.current : {
      value: "x"
    });
  };
  return React.createElement("div", _extends$1({
    className: clsx(classes.root, classNameProp, fcs.disabled && classes.disabled, fcs.error && classes.error, fullWidth && classes.fullWidth, fcs.focused && classes.focused, muiFormControl && classes.formControl, multiline && classes.multiline, startAdornment && classes.adornedStart, endAdornment && classes.adornedEnd, {
      dense: classes.marginDense
    }[fcs.margin]),
    onClick: handleClick,
    ref: ref2
  }, other), startAdornment, React.createElement(FormControlContext.Provider, {
    value: null
  }, React.createElement(InputComponent, _extends$1({
    "aria-invalid": fcs.error,
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className: clsx(classes.input, inputPropsClassName, fcs.disabled && classes.disabled, multiline && classes.inputMultiline, select && classes.inputSelect, fcs.hiddenLabel && classes.inputHiddenLabel, startAdornment && classes.inputAdornedStart, endAdornment && classes.inputAdornedEnd, {
      search: classes.inputTypeSearch
    }[type2], {
      dense: classes.inputMarginDense
    }[fcs.margin]),
    defaultValue,
    disabled: fcs.disabled,
    id,
    onAnimationStart: handleAutoFill,
    name,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    required: fcs.required,
    rows,
    value
  }, inputProps))), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, fcs, {
    startAdornment
  })) : null);
});
const InputBase$1 = withStyles(styles$i, {
  name: "MuiInputBase"
})(InputBase);
var styles$h = function styles212(theme2) {
  var light2 = theme2.palette.type === "light";
  var bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  var backgroundColor = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.09)";
  return {
    /* Styles applied to the root element. */
    root: {
      position: "relative",
      backgroundColor,
      borderTopLeftRadius: theme2.shape.borderRadius,
      borderTopRightRadius: theme2.shape.borderRadius,
      transition: theme2.transitions.create("background-color", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      "&:hover": {
        backgroundColor: light2 ? "rgba(0, 0, 0, 0.13)" : "rgba(255, 255, 255, 0.13)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor
        }
      },
      "&$focused": {
        backgroundColor: light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.09)"
      },
      "&$disabled": {
        backgroundColor: light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)"
      }
    },
    /* Styles applied to the root element if `disableUnderline={false}`. */
    underline: {
      "&:after": {
        borderBottom: "2px solid ".concat(theme2.palette.primary[light2 ? "dark" : "light"]),
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        position: "absolute",
        right: 0,
        transform: "scaleX(0)",
        transition: theme2.transitions.create("transform", {
          duration: theme2.transitions.duration.shorter,
          easing: theme2.transitions.easing.easeOut
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      "&$focused:after": {
        transform: "scaleX(1)"
      },
      "&$error:after": {
        borderBottomColor: theme2.palette.error.main,
        transform: "scaleX(1)"
        // error is always underlined in red
      },
      "&:before": {
        borderBottom: "1px solid ".concat(bottomLineColor),
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
        content: '"\\00a0"',
        position: "absolute",
        right: 0,
        transition: theme2.transitions.create("border-bottom-color", {
          duration: theme2.transitions.duration.shorter
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      "&:hover:before": {
        borderBottom: "1px solid ".concat(theme2.palette.text.primary)
      },
      "&$disabled:before": {
        borderBottomStyle: "dotted"
      }
    },
    /* Styles applied to the root element if the component is focused. */
    focused: {},
    /* Styles applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Styles applied to the root element if `startAdornment` is provided. */
    adornedStart: {
      paddingLeft: 12
    },
    /* Styles applied to the root element if `endAdornment` is provided. */
    adornedEnd: {
      paddingRight: 12
    },
    /* Styles applied to the root element if `error={true}`. */
    error: {},
    /* Styles applied to the `input` element if `margin="dense"`. */
    marginDense: {},
    /* Styles applied to the root element if `multiline={true}`. */
    multiline: {
      padding: "27px 12px 10px",
      "&$marginDense": {
        paddingTop: 23,
        paddingBottom: 6
      }
    },
    /* Styles applied to the `input` element. */
    input: {
      padding: "27px 12px 10px"
    },
    /* Styles applied to the `input` element if `margin="dense"`. */
    inputMarginDense: {
      paddingTop: 23,
      paddingBottom: 6
    },
    /* Styles applied to the `input` if in `<FormControl hiddenLabel />`. */
    inputHiddenLabel: {
      paddingTop: 18,
      paddingBottom: 19,
      "&$inputMarginDense": {
        paddingTop: 10,
        paddingBottom: 11
      }
    },
    /* Styles applied to the `input` element if `select={true}`. */
    inputSelect: {
      paddingRight: 24
    },
    /* Styles applied to the `input` element if `multiline={true}`. */
    inputMultiline: {
      padding: 0
    },
    /* Styles applied to the `input` element if `startAdornment` is provided. */
    inputAdornedStart: {
      paddingLeft: 0
    },
    /* Styles applied to the `input` element if `endAdornment` is provided. */
    inputAdornedEnd: {
      paddingRight: 0
    }
  };
};
var FilledInput = React.forwardRef(function FilledInput2(props, ref2) {
  var disableUnderline = props.disableUnderline, classes = props.classes, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? "input" : _props$inputComponent, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, _props$type = props.type, type2 = _props$type === void 0 ? "text" : _props$type, other = _objectWithoutProperties(props, ["disableUnderline", "classes", "fullWidth", "inputComponent", "multiline", "type"]);
  return React.createElement(InputBase$1, _extends$1({
    classes: _extends$1({}, classes, {
      root: clsx(classes.root, !disableUnderline && classes.underline),
      underline: null
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type: type2
  }, other));
});
FilledInput.muiName = "Input";
const FilledInput$1 = withStyles(styles$h, {
  name: "MuiFilledInput"
})(FilledInput);
function isMuiElement(element, muiNames) {
  return React.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
}
var styles$g = {
  /* Styles applied to the root element. */
  root: {
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    // Reset fieldset default style.
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top"
    // Fix alignment issue on Safari.
  },
  /* Styles applied to the root element if `margin="normal"`. */
  marginNormal: {
    marginTop: 16,
    marginBottom: 8
  },
  /* Styles applied to the root element if `margin="dense"`. */
  marginDense: {
    marginTop: 8,
    marginBottom: 4
  },
  /* Styles applied to the root element if `fullWidth={true}`. */
  fullWidth: {
    width: "100%"
  }
};
var FormControl = React.forwardRef(function FormControl2(props, ref2) {
  var children = props.children, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$error = props.error, error3 = _props$error === void 0 ? false : _props$error, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$hiddenLabel = props.hiddenLabel, hiddenLabel = _props$hiddenLabel === void 0 ? false : _props$hiddenLabel, _props$margin = props.margin, margin = _props$margin === void 0 ? "none" : _props$margin, _props$required = props.required, required = _props$required === void 0 ? false : _props$required, _props$variant = props.variant, variant = _props$variant === void 0 ? "standard" : _props$variant, other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "disabled", "error", "fullWidth", "hiddenLabel", "margin", "required", "variant"]);
  var _React$useState = React.useState(function() {
    var initialAdornedStart = false;
    if (children) {
      React.Children.forEach(children, function(child) {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        var input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  }), adornedStart = _React$useState[0];
  var _React$useState2 = React.useState(function() {
    var initialFilled = false;
    if (children) {
      React.Children.forEach(children, function(child) {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  }), filled = _React$useState2[0], setFilled = _React$useState2[1];
  var _React$useState3 = React.useState(false), focused = _React$useState3[0], setFocused = _React$useState3[1];
  if (disabled && focused) {
    setFocused(false);
  }
  var registerEffect;
  var onFilled = React.useCallback(function() {
    setFilled(true);
  }, []);
  var onEmpty = React.useCallback(function() {
    setFilled(false);
  }, []);
  var childContext = {
    adornedStart,
    disabled,
    error: error3,
    filled,
    focused,
    hiddenLabel,
    margin,
    onBlur: function onBlur() {
      setFocused(false);
    },
    onEmpty,
    onFilled,
    onFocus: function onFocus() {
      setFocused(true);
    },
    registerEffect,
    required,
    variant
  };
  return React.createElement(FormControlContext.Provider, {
    value: childContext
  }, React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, margin !== "none" && classes["margin".concat(capitalize(margin))], fullWidth && classes.fullWidth),
    ref: ref2
  }, other), children));
});
const FormControl$1 = withStyles(styles$g, {
  name: "MuiFormControl"
})(FormControl);
var styles$f = function styles213(theme2) {
  return {
    /* Styles applied to the root element. */
    root: _extends$1({
      color: theme2.palette.text.secondary
    }, theme2.typography.caption, {
      textAlign: "left",
      marginTop: 8,
      lineHeight: "1em",
      minHeight: "1em",
      margin: 0,
      "&$disabled": {
        color: theme2.palette.text.disabled
      },
      "&$error": {
        color: theme2.palette.error.main
      }
    }),
    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},
    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Styles applied to the root element if `margin="dense"`. */
    marginDense: {
      marginTop: 4
    },
    /* Styles applied to the root element if `variant="filled"` or `variant="outlined"`. */
    contained: {
      margin: "8px 14px 0"
    },
    /* Pseudo-class applied to the root element if `focused={true}`. */
    focused: {},
    /* Pseudo-class applied to the root element if `filled={true}`. */
    filled: {},
    /* Pseudo-class applied to the root element if `required={true}`. */
    required: {}
  };
};
var FormHelperText = React.forwardRef(function FormHelperText2(props, ref2) {
  var classes = props.classes, classNameProp = props.className, _props$component = props.component, Component = _props$component === void 0 ? "p" : _props$component;
  props.disabled;
  props.error;
  props.filled;
  props.focused;
  props.margin;
  props.required;
  props.variant;
  var other = _objectWithoutProperties(props, ["classes", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"]);
  var muiFormControl = useFormControl();
  var fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "margin", "disabled", "error", "filled", "focused", "required"]
  });
  return React.createElement(Component, _extends$1({
    className: clsx(classes.root, (fcs.variant === "filled" || fcs.variant === "outlined") && classes.contained, classNameProp, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required, {
      dense: classes.marginDense
    }[fcs.margin]),
    ref: ref2
  }, other));
});
const FormHelperText$1 = withStyles(styles$f, {
  name: "MuiFormHelperText"
})(FormHelperText);
var styles$e = function styles214(theme2) {
  return {
    /* Styles applied to the root element. */
    root: _extends$1({
      color: theme2.palette.text.secondary
    }, theme2.typography.body1, {
      lineHeight: 1,
      padding: 0,
      "&$focused": {
        color: theme2.palette.primary[theme2.palette.type === "light" ? "dark" : "light"]
      },
      "&$disabled": {
        color: theme2.palette.text.disabled
      },
      "&$error": {
        color: theme2.palette.error.main
      }
    }),
    /* Pseudo-class applied to the root element if `focused={true}`. */
    focused: {},
    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},
    /* Pseudo-class applied to the root element if `filled={true}`. */
    filled: {},
    /* Pseudo-class applied to the root element if `required={true}`. */
    required: {},
    /* Styles applied to the asterisk element. */
    asterisk: {
      "&$error": {
        color: theme2.palette.error.main
      }
    }
  };
};
var FormLabel = React.forwardRef(function FormLabel2(props, ref2) {
  var children = props.children, classes = props.classes, classNameProp = props.className, _props$component = props.component, Component = _props$component === void 0 ? "label" : _props$component;
  props.disabled;
  props.error;
  props.filled;
  props.focused;
  props.required;
  var other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "disabled", "error", "filled", "focused", "required"]);
  var muiFormControl = useFormControl();
  var fcs = formControlState({
    props,
    muiFormControl,
    states: ["required", "focused", "disabled", "error", "filled"]
  });
  return React.createElement(Component, _extends$1({
    className: clsx(classes.root, classNameProp, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required),
    ref: ref2
  }, other), children, fcs.required && React.createElement("span", {
    className: clsx(classes.asterisk, fcs.error && classes.error)
  }, " ", "*"));
});
const FormLabel$1 = withStyles(styles$e, {
  name: "MuiFormLabel"
})(FormLabel);
function getScale(value) {
  return "scale(".concat(value, ", ").concat(Math.pow(value, 2), ")");
}
var styles$d = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
var Grow = React.forwardRef(function Grow2(props, ref2) {
  var children = props.children, inProp = props.in, onEnter = props.onEnter, onExit = props.onExit, style2 = props.style, _props$timeout = props.timeout, timeout = _props$timeout === void 0 ? "auto" : _props$timeout, other = _objectWithoutProperties(props, ["children", "in", "onEnter", "onExit", "style", "timeout"]);
  var timer = React.useRef();
  var autoTimeout = React.useRef();
  var handleRef = useForkRef(children.ref, ref2);
  var theme2 = useTheme();
  var handleEnter = function handleEnter2(node2, isAppearing) {
    reflow(node2);
    var _getTransitionProps = getTransitionProps({
      style: style2,
      timeout
    }, {
      mode: "enter"
    }), transitionDuration = _getTransitionProps.duration, delay = _getTransitionProps.delay;
    var duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme2.transitions.create("transform", {
      duration: duration2 * 0.666,
      delay
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  var handleExit = function handleExit2(node2) {
    var _getTransitionProps2 = getTransitionProps({
      style: style2,
      timeout
    }, {
      mode: "exit"
    }), transitionDuration = _getTransitionProps2.duration, delay = _getTransitionProps2.delay;
    var duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme2.transitions.create("transform", {
      duration: duration2 * 0.666,
      delay: delay || duration2 * 0.333
    })].join(",");
    node2.style.opacity = "0";
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  };
  var addEndListener = function addEndListener2(_23, next) {
    if (timeout === "auto") {
      timer.current = setTimeout(next, autoTimeout.current || 0);
    }
  };
  React.useEffect(function() {
    return function() {
      clearTimeout(timer.current);
    };
  }, []);
  return React.createElement(Transition, _extends$1({
    appear: true,
    in: inProp,
    onEnter: handleEnter,
    onExit: handleExit,
    addEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other), function(state2, childProps) {
    return React.cloneElement(children, _extends$1({
      style: _extends$1({
        opacity: 0,
        transform: getScale(0.75),
        visibility: state2 === "exited" && !inProp ? "hidden" : void 0
      }, styles$d[state2], {}, style2, {}, children.props.style),
      ref: handleRef
    }, childProps));
  });
});
Grow.muiSupportAuto = true;
var hydrationCompleted = false;
function useMediaQuery(queryInput) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var theme2 = useTheme$1();
  var props = getThemeProps({
    theme: theme2,
    name: "MuiUseMediaQuery",
    props: {}
  });
  var query = typeof queryInput === "function" ? queryInput(theme2) : queryInput;
  query = query.replace(/^@media( ?)/m, "");
  var supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  var _props$options = _extends$1({}, props, {}, options2), _props$options$defaul = _props$options.defaultMatches, defaultMatches = _props$options$defaul === void 0 ? false : _props$options$defaul, _props$options$noSsr = _props$options.noSsr, noSsr = _props$options$noSsr === void 0 ? false : _props$options$noSsr, _props$options$ssrMat = _props$options.ssrMatchMedia, ssrMatchMedia = _props$options$ssrMat === void 0 ? null : _props$options$ssrMat;
  var _React$useState = React.useState(function() {
    if ((hydrationCompleted || noSsr) && supportMatchMedia) {
      return window.matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  }), match = _React$useState[0], setMatch = _React$useState[1];
  React.useEffect(function() {
    var active = true;
    hydrationCompleted = true;
    if (!supportMatchMedia) {
      return void 0;
    }
    var queryList = window.matchMedia(query);
    var updateMatch = function updateMatch2() {
      if (active) {
        setMatch(queryList.matches);
      }
    };
    updateMatch();
    queryList.addListener(updateMatch);
    return function() {
      active = false;
      queryList.removeListener(updateMatch);
    };
  }, [query, supportMatchMedia]);
  return match;
}
var styles$c = function styles215(theme2) {
  var light2 = theme2.palette.type === "light";
  var bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return {
    /* Styles applied to the root element. */
    root: {
      position: "relative"
    },
    /* Styles applied to the root element if the component is a descendant of `FormControl`. */
    formControl: {
      "label + &": {
        marginTop: 16
      }
    },
    /* Styles applied to the root element if the component is focused. */
    focused: {},
    /* Styles applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Styles applied to the root element if `disableUnderline={false}`. */
    underline: {
      "&:after": {
        borderBottom: "2px solid ".concat(theme2.palette.primary[light2 ? "dark" : "light"]),
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        position: "absolute",
        right: 0,
        transform: "scaleX(0)",
        transition: theme2.transitions.create("transform", {
          duration: theme2.transitions.duration.shorter,
          easing: theme2.transitions.easing.easeOut
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      "&$focused:after": {
        transform: "scaleX(1)"
      },
      "&$error:after": {
        borderBottomColor: theme2.palette.error.main,
        transform: "scaleX(1)"
        // error is always underlined in red
      },
      "&:before": {
        borderBottom: "1px solid ".concat(bottomLineColor),
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
        content: '"\\00a0"',
        position: "absolute",
        right: 0,
        transition: theme2.transitions.create("border-bottom-color", {
          duration: theme2.transitions.duration.shorter
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      "&:hover:not($disabled):before": {
        borderBottom: "2px solid ".concat(theme2.palette.text.primary),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          borderBottom: "1px solid ".concat(bottomLineColor)
        }
      },
      "&$disabled:before": {
        borderBottomStyle: "dotted"
      }
    },
    /* Styles applied to the root element if `error={true}`. */
    error: {},
    /* Styles applied to the root element if `multiline={true}`. */
    multiline: {},
    /* Styles applied to the root element if `fullWidth={true}`. */
    fullWidth: {},
    /* Styles applied to the `input` element. */
    input: {},
    /* Styles applied to the `input` element if `margin="dense"`. */
    inputMarginDense: {},
    /* Styles applied to the `input` element if `multiline={true}`. */
    inputMultiline: {},
    /* Styles applied to the `input` element if `type="search"`. */
    inputTypeSearch: {}
  };
};
var Input = React.forwardRef(function Input2(props, ref2) {
  var disableUnderline = props.disableUnderline, classes = props.classes, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? "input" : _props$inputComponent, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, _props$type = props.type, type2 = _props$type === void 0 ? "text" : _props$type, other = _objectWithoutProperties(props, ["disableUnderline", "classes", "fullWidth", "inputComponent", "multiline", "type"]);
  return React.createElement(InputBase$1, _extends$1({
    classes: _extends$1({}, classes, {
      root: clsx(classes.root, !disableUnderline && classes.underline),
      underline: null
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type: type2
  }, other));
});
Input.muiName = "Input";
const Input$1 = withStyles(styles$c, {
  name: "MuiInput"
})(Input);
var styles$b = {
  /* Styles applied to the root element. */
  root: {
    display: "flex",
    height: "0.01em",
    // Fix IE 11 flexbox alignment. To remove at some point.
    maxHeight: "2em",
    alignItems: "center"
  },
  /* Styles applied to the root element if `variant="filled"`. */
  filled: {
    "&$positionStart:not($hiddenLabel)": {
      marginTop: 16
    }
  },
  /* Styles applied to the root element if `position="start"`. */
  positionStart: {
    marginRight: 8
  },
  /* Styles applied to the root element if `position="end"`. */
  positionEnd: {
    marginLeft: 8
  },
  /* Styles applied to the root element if `disablePointerEvents=true`. */
  disablePointerEvents: {
    pointerEvents: "none"
  },
  /* Styles applied if the adornment is used inside <FormControl hiddenLabel />. */
  hiddenLabel: {},
  /* Styles applied if the adornment is used inside <FormControl margin="dense" />. */
  marginDense: {}
};
var InputAdornment = React.forwardRef(function InputAdornment2(props, ref2) {
  var children = props.children, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _props$disablePointer = props.disablePointerEvents, disablePointerEvents = _props$disablePointer === void 0 ? false : _props$disablePointer, _props$disableTypogra = props.disableTypography, disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra, position = props.position, variantProp = props.variant, other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"]);
  var muiFormControl = useFormControl$1() || {};
  var variant = variantProp;
  if (variantProp && muiFormControl.variant) ;
  if (muiFormControl && !variant) {
    variant = muiFormControl.variant;
  }
  return React.createElement(FormControlContext.Provider, {
    value: null
  }, React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, disablePointerEvents && classes.disablePointerEvents, muiFormControl.hiddenLabel && classes.hiddenLabel, {
      filled: classes.filled
    }[variant], {
      start: classes.positionStart,
      end: classes.positionEnd
    }[position], {
      dense: classes.marginDense
    }[muiFormControl.margin]),
    ref: ref2
  }, other), typeof children === "string" && !disableTypography ? React.createElement(Typography$1, {
    color: "textSecondary"
  }, children) : children));
});
const InputAdornment$1 = withStyles(styles$b, {
  name: "MuiInputAdornment"
})(InputAdornment);
var styles$a = function styles216(theme2) {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "block",
      transformOrigin: "top left"
    },
    /* Pseudo-class applied to the root element if `focused={true}`. */
    focused: {},
    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},
    /* Pseudo-class applied to the root element if `required={true}`. */
    required: {},
    /* Pseudo-class applied to the asterisk element. */
    asterisk: {},
    /* Styles applied to the root element if the component is a descendant of `FormControl`. */
    formControl: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 24px) scale(1)"
    },
    /* Styles applied to the root element if `margin="dense"`. */
    marginDense: {
      // Compensation for the `Input.inputDense` style.
      transform: "translate(0, 21px) scale(1)"
    },
    /* Styles applied to the `input` element if `shrink={true}`. */
    shrink: {
      transform: "translate(0, 1.5px) scale(0.75)",
      transformOrigin: "top left"
    },
    /* Styles applied to the `input` element if `disableAnimation={false}`. */
    animated: {
      transition: theme2.transitions.create(["color", "transform"], {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      })
    },
    /* Styles applied to the root element if `variant="filled"`. */
    filled: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 20px) scale(1)",
      "&$marginDense": {
        transform: "translate(12px, 17px) scale(1)"
      },
      "&$shrink": {
        transform: "translate(12px, 10px) scale(0.75)",
        "&$marginDense": {
          transform: "translate(12px, 7px) scale(0.75)"
        }
      }
    },
    /* Styles applied to the root element if `variant="outlined"`. */
    outlined: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 20px) scale(1)",
      "&$marginDense": {
        transform: "translate(14px, 12px) scale(1)"
      },
      "&$shrink": {
        transform: "translate(14px, -6px) scale(0.75)"
      }
    }
  };
};
var InputLabel = React.forwardRef(function InputLabel2(props, ref2) {
  var classes = props.classes, className = props.className, _props$disableAnimati = props.disableAnimation, disableAnimation = _props$disableAnimati === void 0 ? false : _props$disableAnimati;
  props.margin;
  var shrinkProp = props.shrink;
  props.variant;
  var other = _objectWithoutProperties(props, ["classes", "className", "disableAnimation", "margin", "shrink", "variant"]);
  var muiFormControl = useFormControl();
  var shrink = shrinkProp;
  if (typeof shrink === "undefined" && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  var fcs = formControlState({
    props,
    muiFormControl,
    states: ["margin", "variant"]
  });
  return React.createElement(FormLabel$1, _extends$1({
    "data-shrink": shrink,
    className: clsx(classes.root, className, muiFormControl && classes.formControl, !disableAnimation && classes.animated, shrink && classes.shrink, {
      dense: classes.marginDense
    }[fcs.margin], {
      filled: classes.filled,
      outlined: classes.outlined
    }[fcs.variant]),
    classes: {
      focused: classes.focused,
      disabled: classes.disabled,
      error: classes.error,
      required: classes.required,
      asterisk: classes.asterisk
    },
    ref: ref2
  }, other));
});
const InputLabel$1 = withStyles(styles$a, {
  name: "MuiInputLabel"
})(InputLabel);
var ListContext = React.createContext({});
var styles$9 = {
  /* Styles applied to the root element. */
  root: {
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative"
  },
  /* Styles applied to the root element if `disablePadding={false}`. */
  padding: {
    paddingTop: 8,
    paddingBottom: 8
  },
  /* Styles applied to the root element if dense. */
  dense: {},
  /* Styles applied to the root element if a `subheader` is provided. */
  subheader: {
    paddingTop: 0
  }
};
var List = React.forwardRef(function List2(props, ref2) {
  var children = props.children, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "ul" : _props$component, _props$dense = props.dense, dense = _props$dense === void 0 ? false : _props$dense, _props$disablePadding = props.disablePadding, disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding, subheader = props.subheader, other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "dense", "disablePadding", "subheader"]);
  var context2 = React.useMemo(function() {
    return {
      dense
    };
  }, [dense]);
  return React.createElement(ListContext.Provider, {
    value: context2
  }, React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader),
    ref: ref2
  }, other), subheader, children));
});
const List$1 = withStyles(styles$9, {
  name: "MuiList"
})(List);
var styles$8 = function styles217(theme2) {
  return {
    /* Styles applied to the (normally root) `component` element. May be wrapped by a `container`. */
    root: {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      width: "100%",
      boxSizing: "border-box",
      textAlign: "left",
      paddingTop: 8,
      paddingBottom: 8,
      "&$focusVisible": {
        backgroundColor: theme2.palette.action.selected
      },
      "&$selected, &$selected:hover": {
        backgroundColor: theme2.palette.action.selected
      },
      "&$disabled": {
        opacity: 0.5
      }
    },
    /* Styles applied to the `container` element if `children` includes `ListItemSecondaryAction`. */
    container: {
      position: "relative"
    },
    /* Pseudo-class applied to the `component`'s `focusVisibleClassName` prop if `button={true}`. */
    focusVisible: {},
    /* Styles applied to the `component` element if dense. */
    dense: {
      paddingTop: 4,
      paddingBottom: 4
    },
    /* Styles applied to the `component` element if `alignItems="flex-start"`. */
    alignItemsFlexStart: {
      alignItems: "flex-start"
    },
    /* Pseudo-class applied to the inner `component` element if `disabled={true}`. */
    disabled: {},
    /* Styles applied to the inner `component` element if `divider={true}`. */
    divider: {
      borderBottom: "1px solid ".concat(theme2.palette.divider),
      backgroundClip: "padding-box"
    },
    /* Styles applied to the inner `component` element if `disableGutters={false}`. */
    gutters: {
      paddingLeft: 16,
      paddingRight: 16
    },
    /* Styles applied to the inner `component` element if `button={true}`. */
    button: {
      transition: theme2.transitions.create("background-color", {
        duration: theme2.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: theme2.palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    /* Styles applied to the `component` element if `children` includes `ListItemSecondaryAction`. */
    secondaryAction: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    },
    /* Pseudo-class applied to the root element if `selected={true}`. */
    selected: {}
  };
};
var useEnhancedEffect$1 = typeof window === "undefined" ? React.useEffect : React.useLayoutEffect;
var ListItem = React.forwardRef(function ListItem2(props, ref2) {
  var _props$alignItems = props.alignItems, alignItems = _props$alignItems === void 0 ? "center" : _props$alignItems, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus, _props$button = props.button, button = _props$button === void 0 ? false : _props$button, childrenProp = props.children, classes = props.classes, className = props.className, componentProp = props.component, _props$ContainerCompo = props.ContainerComponent, ContainerComponent = _props$ContainerCompo === void 0 ? "li" : _props$ContainerCompo, _props$ContainerProps = props.ContainerProps;
  _props$ContainerProps = _props$ContainerProps === void 0 ? {} : _props$ContainerProps;
  var ContainerClassName = _props$ContainerProps.className, ContainerProps = _objectWithoutProperties(_props$ContainerProps, ["className"]), dense = props.dense, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableGutters = props.disableGutters, disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters, _props$divider = props.divider, divider = _props$divider === void 0 ? false : _props$divider, focusVisibleClassName = props.focusVisibleClassName, _props$selected = props.selected, selected = _props$selected === void 0 ? false : _props$selected, other = _objectWithoutProperties(props, ["alignItems", "autoFocus", "button", "children", "classes", "className", "component", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "divider", "focusVisibleClassName", "selected"]);
  var context2 = React.useContext(ListContext);
  var childContext = {
    dense: dense || context2.dense || false,
    alignItems
  };
  var listItemRef = React.useRef(null);
  useEnhancedEffect$1(function() {
    if (autoFocus) {
      if (listItemRef.current) {
        listItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  var children = React.Children.toArray(childrenProp);
  var hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
  var handleOwnRef = React.useCallback(function(instance) {
    listItemRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var handleRef = useForkRef(handleOwnRef, ref2);
  var componentProps = _extends$1({
    className: clsx(classes.root, className, childContext.dense && classes.dense, !disableGutters && classes.gutters, divider && classes.divider, disabled && classes.disabled, button && classes.button, alignItems !== "center" && classes.alignItemsFlexStart, hasSecondaryAction && classes.secondaryAction, selected && classes.selected),
    disabled
  }, other);
  var Component = componentProp || "li";
  if (button) {
    componentProps.component = componentProp || "div";
    componentProps.focusVisibleClassName = clsx(classes.focusVisible, focusVisibleClassName);
    Component = ButtonBase$1;
  }
  if (hasSecondaryAction) {
    Component = !componentProps.component && !componentProp ? "div" : Component;
    if (ContainerComponent === "li") {
      if (Component === "li") {
        Component = "div";
      } else if (componentProps.component === "li") {
        componentProps.component = "div";
      }
    }
    return React.createElement(ListContext.Provider, {
      value: childContext
    }, React.createElement(ContainerComponent, _extends$1({
      className: clsx(classes.container, ContainerClassName),
      ref: handleRef
    }, ContainerProps), React.createElement(Component, componentProps, children), children.pop()));
  }
  return React.createElement(ListContext.Provider, {
    value: childContext
  }, React.createElement(Component, _extends$1({
    ref: handleRef
  }, componentProps), children));
});
const ListItem$1 = withStyles(styles$8, {
  name: "MuiListItem"
})(ListItem);
var styles$7 = {
  /* Styles applied to the root element. */
  root: {
    flex: "1 1 auto",
    minWidth: 0,
    marginTop: 4,
    marginBottom: 4
  },
  /* Styles applied to the `Typography` components if primary and secondary are set. */
  multiline: {
    marginTop: 6,
    marginBottom: 6
  },
  /* Styles applied to the `Typography` components if dense. */
  dense: {},
  /* Styles applied to the root element if `inset={true}`. */
  inset: {
    paddingLeft: 56
  },
  /* Styles applied to the primary `Typography` component. */
  primary: {},
  /* Styles applied to the secondary `Typography` component. */
  secondary: {}
};
var ListItemText = React.forwardRef(function ListItemText2(props, ref2) {
  var children = props.children, classes = props.classes, className = props.className, _props$disableTypogra = props.disableTypography, disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra, _props$inset = props.inset, inset = _props$inset === void 0 ? false : _props$inset, primaryProp = props.primary, primaryTypographyProps = props.primaryTypographyProps, secondaryProp = props.secondary, secondaryTypographyProps = props.secondaryTypographyProps, other = _objectWithoutProperties(props, ["children", "classes", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"]);
  var _React$useContext = React.useContext(ListContext), dense = _React$useContext.dense;
  var primary = primaryProp != null ? primaryProp : children;
  if (primary != null && primary.type !== Typography$1 && !disableTypography) {
    primary = React.createElement(Typography$1, _extends$1({
      variant: dense ? "body2" : "body1",
      className: classes.primary,
      component: "span"
    }, primaryTypographyProps), primary);
  }
  var secondary = secondaryProp;
  if (secondary != null && secondary.type !== Typography$1 && !disableTypography) {
    secondary = React.createElement(Typography$1, _extends$1({
      variant: "body2",
      className: classes.secondary,
      color: "textSecondary"
    }, secondaryTypographyProps), secondary);
  }
  return React.createElement("div", _extends$1({
    className: clsx(classes.root, className, dense && classes.dense, inset && classes.inset, primary && secondary && classes.multiline),
    ref: ref2
  }, other), primary, secondary);
});
const ListItemText$1 = withStyles(styles$7, {
  name: "MuiListItemText"
})(ListItemText);
function getOffsetTop(rect, vertical) {
  var offset = 0;
  if (typeof vertical === "number") {
    offset = vertical;
  } else if (vertical === "center") {
    offset = rect.height / 2;
  } else if (vertical === "bottom") {
    offset = rect.height;
  }
  return offset;
}
function getOffsetLeft(rect, horizontal) {
  var offset = 0;
  if (typeof horizontal === "number") {
    offset = horizontal;
  } else if (horizontal === "center") {
    offset = rect.width / 2;
  } else if (horizontal === "right") {
    offset = rect.width;
  }
  return offset;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map(function(n) {
    return typeof n === "number" ? "".concat(n, "px") : n;
  }).join(" ");
}
function getScrollParent(parent2, child) {
  var element = child;
  var scrollTop = 0;
  while (element && element !== parent2) {
    element = element.parentNode;
    scrollTop += element.scrollTop;
  }
  return scrollTop;
}
function getAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
var styles$6 = {
  /* Styles applied to the root element */
  root: {},
  /* Styles applied to the `Paper` component. */
  paper: {
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }
};
var Popover = React.forwardRef(function Popover2(props, ref2) {
  var action2 = props.action, anchorEl = props.anchorEl, _props$anchorOrigin = props.anchorOrigin, anchorOrigin = _props$anchorOrigin === void 0 ? {
    vertical: "top",
    horizontal: "left"
  } : _props$anchorOrigin, anchorPosition = props.anchorPosition, _props$anchorReferenc = props.anchorReference, anchorReference = _props$anchorReferenc === void 0 ? "anchorEl" : _props$anchorReferenc, children = props.children, classes = props.classes, className = props.className, containerProp = props.container, _props$elevation = props.elevation, elevation = _props$elevation === void 0 ? 8 : _props$elevation, getContentAnchorEl = props.getContentAnchorEl, _props$marginThreshol = props.marginThreshold, marginThreshold = _props$marginThreshol === void 0 ? 16 : _props$marginThreshol, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, open = props.open, _props$PaperProps = props.PaperProps, PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps, _props$transformOrigi = props.transformOrigin, transformOrigin = _props$transformOrigi === void 0 ? {
    vertical: "top",
    horizontal: "left"
  } : _props$transformOrigi, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Grow : _props$TransitionComp, _props$transitionDura = props.transitionDuration, transitionDurationProp = _props$transitionDura === void 0 ? "auto" : _props$transitionDura, _props$TransitionProp = props.TransitionProps, TransitionProps = _props$TransitionProp === void 0 ? {} : _props$TransitionProp, other = _objectWithoutProperties(props, ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "classes", "className", "container", "elevation", "getContentAnchorEl", "marginThreshold", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"]);
  var paperRef = React.useRef();
  var getAnchorOffset = React.useCallback(function(contentAnchorOffset) {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    var resolvedAnchorEl = getAnchorEl(anchorEl);
    var containerWindow = ownerWindow(resolvedAnchorEl);
    var anchorElement = resolvedAnchorEl instanceof containerWindow.Element ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    var anchorRect = anchorElement.getBoundingClientRect();
    var anchorVertical = contentAnchorOffset === 0 ? anchorOrigin.vertical : "center";
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorVertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  var getContentAnchorOffset = React.useCallback(function(element) {
    var contentAnchorOffset = 0;
    if (getContentAnchorEl && anchorReference === "anchorEl") {
      var contentAnchorEl = getContentAnchorEl(element);
      if (contentAnchorEl && element.contains(contentAnchorEl)) {
        var scrollTop = getScrollParent(element, contentAnchorEl);
        contentAnchorOffset = contentAnchorEl.offsetTop + contentAnchorEl.clientHeight / 2 - scrollTop || 0;
      }
    }
    return contentAnchorOffset;
  }, [anchorOrigin.vertical, anchorReference, getContentAnchorEl]);
  var getTransformOrigin = React.useCallback(function(elemRect) {
    var contentAnchorOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical) + contentAnchorOffset,
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  var getPositioningStyle = React.useCallback(function(element) {
    var contentAnchorOffset = getContentAnchorOffset(element);
    var elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    var elemTransformOrigin = getTransformOrigin(elemRect, contentAnchorOffset);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    var anchorOffset = getAnchorOffset(contentAnchorOffset);
    var top = anchorOffset.top - elemTransformOrigin.vertical;
    var left = anchorOffset.left - elemTransformOrigin.horizontal;
    var bottom = top + elemRect.height;
    var right = left + elemRect.width;
    var containerWindow = ownerWindow(getAnchorEl(anchorEl));
    var heightThreshold = containerWindow.innerHeight - marginThreshold;
    var widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (top < marginThreshold) {
      var diff = top - marginThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (bottom > heightThreshold) {
      var _diff = bottom - heightThreshold;
      top -= _diff;
      elemTransformOrigin.vertical += _diff;
    }
    if (left < marginThreshold) {
      var _diff2 = left - marginThreshold;
      left -= _diff2;
      elemTransformOrigin.horizontal += _diff2;
    } else if (right > widthThreshold) {
      var _diff3 = right - widthThreshold;
      left -= _diff3;
      elemTransformOrigin.horizontal += _diff3;
    }
    return {
      top: "".concat(top, "px"),
      left: "".concat(left, "px"),
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getContentAnchorOffset, getTransformOrigin, marginThreshold]);
  var setPositioningStyles = React.useCallback(function(element) {
    var positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
  }, [getPositioningStyle]);
  var handleEntering = function handleEntering2(element, isAppearing) {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles(element);
  };
  var handlePaperRef = React.useCallback(function(instance) {
    paperRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var updatePosition = React.useMemo(function() {
    if (!open) {
      return void 0;
    }
    return debounce(function() {
      setPositioningStyles(paperRef.current);
    });
  }, [open, setPositioningStyles]);
  React.useImperativeHandle(action2, function() {
    return open ? {
      updatePosition
    } : null;
  }, [open, updatePosition]);
  React.useEffect(function() {
    if (!updatePosition) {
      return void 0;
    }
    window.addEventListener("resize", updatePosition);
    return function() {
      window.removeEventListener("resize", updatePosition);
      updatePosition.clear();
    };
  }, [updatePosition]);
  var transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  var container = containerProp || (anchorEl ? ownerDocument(getAnchorEl(anchorEl)).body : void 0);
  return React.createElement(Modal, _extends$1({
    container,
    open,
    ref: ref2,
    BackdropProps: {
      invisible: true
    },
    className: clsx(classes.root, className)
  }, other), React.createElement(TransitionComponent, _extends$1({
    appear: true,
    in: open,
    onEnter,
    onEntered,
    onExit,
    onExited,
    onExiting,
    timeout: transitionDuration
  }, TransitionProps, {
    onEntering: createChainedFunction(handleEntering, TransitionProps.onEntering)
  }), React.createElement(Paper$1, _extends$1({
    elevation,
    ref: handlePaperRef
  }, PaperProps, {
    className: clsx(classes.paper, PaperProps.className)
  }), children)));
});
const Popover$1 = withStyles(styles$6, {
  name: "MuiPopover"
})(Popover);
function nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  var text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  if (text === void 0) {
    return false;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus(list, currentFocus, disableListWrap, traversalFunction, textCriteria) {
  var wrappedOnce = false;
  var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    if (!nextFocus.hasAttribute("tabindex") || nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true" || !textCriteriaMatches(nextFocus, textCriteria)) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
var useEnhancedEffect = typeof window === "undefined" ? React.useEffect : React.useLayoutEffect;
var MenuList = React.forwardRef(function MenuList2(props, ref2) {
  var actions2 = props.actions, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus, _props$autoFocusItem = props.autoFocusItem, autoFocusItem = _props$autoFocusItem === void 0 ? false : _props$autoFocusItem, children = props.children, className = props.className, onKeyDown = props.onKeyDown, _props$disableListWra = props.disableListWrap, disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra, _props$variant = props.variant, variant = _props$variant === void 0 ? "selectedMenu" : _props$variant, other = _objectWithoutProperties(props, ["actions", "autoFocus", "autoFocusItem", "children", "className", "onKeyDown", "disableListWrap", "variant"]);
  var listRef = React.useRef(null);
  var textCriteriaRef = React.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(function() {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  React.useImperativeHandle(actions2, function() {
    return {
      adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme2) {
        var noExplicitWidth = !listRef.current.style.width;
        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
          var scrollbarSize = "".concat(getScrollbarSize(), "px");
          listRef.current.style[theme2.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
          listRef.current.style.width = "calc(100% + ".concat(scrollbarSize, ")");
        }
        return listRef.current;
      }
    };
  }, []);
  var handleKeyDown2 = function handleKeyDown22(event) {
    var list = listRef.current;
    var key2 = event.key;
    var currentFocus = ownerDocument(list).activeElement;
    if (key2 === "ArrowDown") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, nextItem);
    } else if (key2 === "ArrowUp") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, previousItem);
    } else if (key2 === "Home") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, nextItem);
    } else if (key2 === "End") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, previousItem);
    } else if (key2.length === 1) {
      var criteria = textCriteriaRef.current;
      var lowerKey = key2.toLowerCase();
      var currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      var keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  var handleOwnRef = React.useCallback(function(instance) {
    listRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var handleRef = useForkRef(handleOwnRef, ref2);
  var activeItemIndex = -1;
  React.Children.forEach(children, function(child, index2) {
    if (!React.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  var items = React.Children.map(children, function(child, index2) {
    if (index2 === activeItemIndex) {
      var newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      if (newChildProps !== null) {
        return React.cloneElement(child, newChildProps);
      }
    }
    return child;
  });
  return React.createElement(List$1, _extends$1({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown2,
    tabIndex: autoFocus ? 0 : -1
  }, other), items);
});
var RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
var LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
var styles$5 = {
  /* Styles applied to the `Paper` component. */
  paper: {
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tapable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: "calc(100% - 96px)",
    // Add iOS momentum scrolling.
    WebkitOverflowScrolling: "touch"
  },
  /* Styles applied to the `List` component via `MenuList`. */
  list: {
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }
};
var Menu = React.forwardRef(function Menu2(props, ref2) {
  var _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, children = props.children, classes = props.classes, _props$disableAutoFoc = props.disableAutoFocusItem, disableAutoFocusItem = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$MenuListProps = props.MenuListProps, MenuListProps = _props$MenuListProps === void 0 ? {} : _props$MenuListProps, onClose = props.onClose, onEntering = props.onEntering, open = props.open, _props$PaperProps = props.PaperProps, PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps, PopoverClasses = props.PopoverClasses, _props$transitionDura = props.transitionDuration, transitionDuration = _props$transitionDura === void 0 ? "auto" : _props$transitionDura, _props$variant = props.variant, variant = _props$variant === void 0 ? "selectedMenu" : _props$variant, other = _objectWithoutProperties(props, ["autoFocus", "children", "classes", "disableAutoFocusItem", "MenuListProps", "onClose", "onEntering", "open", "PaperProps", "PopoverClasses", "transitionDuration", "variant"]);
  var theme2 = useTheme();
  var autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  var menuListActionsRef = React.useRef(null);
  var contentAnchorRef = React.useRef(null);
  var getContentAnchorEl = function getContentAnchorEl2() {
    return contentAnchorRef.current;
  };
  var handleEntering = function handleEntering2(element, isAppearing) {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, theme2);
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  var handleListKeyDown = function handleListKeyDown2(event) {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  var activeItemIndex = -1;
  React.Children.map(children, function(child, index2) {
    if (!React.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant !== "menu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  var items = React.Children.map(children, function(child, index2) {
    if (index2 === activeItemIndex) {
      return React.cloneElement(child, {
        ref: function ref22(instance) {
          contentAnchorRef.current = ReactDOM.findDOMNode(instance);
          setRef(child.ref, instance);
        }
      });
    }
    return child;
  });
  return React.createElement(Popover$1, _extends$1({
    getContentAnchorEl,
    classes: PopoverClasses,
    onClose,
    onEntering: handleEntering,
    anchorOrigin: theme2.direction === "rtl" ? RTL_ORIGIN : LTR_ORIGIN,
    transformOrigin: theme2.direction === "rtl" ? RTL_ORIGIN : LTR_ORIGIN,
    PaperProps: _extends$1({}, PaperProps, {
      classes: _extends$1({}, PaperProps.classes, {
        root: classes.paper
      })
    }),
    open,
    ref: ref2,
    transitionDuration
  }, other), React.createElement(MenuList, _extends$1({
    onKeyDown: handleListKeyDown,
    actions: menuListActionsRef,
    autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
    autoFocusItem,
    variant
  }, MenuListProps, {
    className: clsx(classes.list, MenuListProps.className)
  }), items));
});
const Menu$1 = withStyles(styles$5, {
  name: "MuiMenu"
})(Menu);
var NativeSelectInput = React.forwardRef(function NativeSelectInput2(props, ref2) {
  var classes = props.classes, className = props.className, disabled = props.disabled, IconComponent = props.IconComponent, inputRef = props.inputRef, _props$variant = props.variant, variant = _props$variant === void 0 ? "standard" : _props$variant, other = _objectWithoutProperties(props, ["classes", "className", "disabled", "IconComponent", "inputRef", "variant"]);
  return React.createElement(React.Fragment, null, React.createElement("select", _extends$1({
    className: clsx(
      classes.root,
      // TODO v5: merge root and select
      classes.select,
      classes[variant],
      className,
      disabled && classes.disabled
    ),
    disabled,
    ref: inputRef || ref2
  }, other)), props.multiple ? null : React.createElement(IconComponent, {
    className: clsx(classes.icon, classes["icon".concat(capitalize(variant))])
  }));
});
const ArrowDropDownIcon = createSvgIcon$1(React.createElement("path", {
  d: "M7 10l5 5 5-5z"
}));
var styles$4 = function styles218(theme2) {
  return {
    /* Styles applied to the select component `root` class. */
    root: {},
    /* Styles applied to the select component `select` class. */
    select: {
      "-moz-appearance": "none",
      // Reset
      "-webkit-appearance": "none",
      // Reset
      // When interacting quickly, the text can end up selected.
      // Native select can't be selected either.
      userSelect: "none",
      borderRadius: 0,
      // Reset
      minWidth: 16,
      // So it doesn't collapse.
      cursor: "pointer",
      "&:focus": {
        // Show that it's not an text input
        backgroundColor: theme2.palette.type === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)",
        borderRadius: 0
        // Reset Chrome style
      },
      // Remove IE 11 arrow
      "&::-ms-expand": {
        display: "none"
      },
      "&$disabled": {
        cursor: "default"
      },
      "&[multiple]": {
        height: "auto"
      },
      "&:not([multiple]) option, &:not([multiple]) optgroup": {
        backgroundColor: theme2.palette.background.paper
      }
    },
    /* Styles applied to the select component if `variant="filled"`. */
    filled: {},
    /* Styles applied to the select component if `variant="outlined"`. */
    outlined: {
      borderRadius: theme2.shape.borderRadius
    },
    /* Styles applied to the select component `selectMenu` class. */
    selectMenu: {
      height: "auto",
      // Reset
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    },
    /* Pseudo-class applied to the select component `disabled` class. */
    disabled: {},
    /* Styles applied to the icon component. */
    icon: {
      // We use a position absolute over a flexbox in order to forward the pointer events
      // to the input.
      position: "absolute",
      right: 0,
      top: "calc(50% - 12px)",
      // Center vertically
      color: theme2.palette.action.active,
      pointerEvents: "none"
      // Don't block pointer events on the select under the icon.
    },
    /* Styles applied to the icon component if `variant="filled"`. */
    iconFilled: {
      right: 7
    },
    /* Styles applied to the icon component if `variant="outlined"`. */
    iconOutlined: {
      right: 7
    }
  };
};
var defaultInput = React.createElement(Input$1, null);
var NativeSelect = React.forwardRef(function NativeSelect2(props, ref2) {
  var children = props.children, classes = props.classes, _props$IconComponent = props.IconComponent, IconComponent = _props$IconComponent === void 0 ? ArrowDropDownIcon : _props$IconComponent, _props$input = props.input, input = _props$input === void 0 ? defaultInput : _props$input, inputProps = props.inputProps;
  props.variant;
  var other = _objectWithoutProperties(props, ["children", "classes", "IconComponent", "input", "inputProps", "variant"]);
  var muiFormControl = useFormControl();
  var fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant"]
  });
  return React.cloneElement(input, _extends$1({
    // Most of the logic is implemented in `NativeSelectInput`.
    // The `Select` component is a simple API wrapper to expose something better to play with.
    inputComponent: NativeSelectInput,
    select: true,
    inputProps: _extends$1({
      children,
      classes,
      IconComponent,
      variant: fcs.variant,
      type: void 0
    }, inputProps, {}, input ? input.props.inputProps : {}),
    ref: ref2
  }, other));
});
NativeSelect.muiName = "Select";
withStyles(styles$4, {
  name: "MuiNativeSelect"
})(NativeSelect);
var styles$3 = function styles219(theme2) {
  var align = theme2.direction === "rtl" ? "right" : "left";
  return {
    /* Styles applied to the root element. */
    root: {
      position: "absolute",
      bottom: 0,
      right: 0,
      top: -5,
      left: 0,
      margin: 0,
      padding: 0,
      pointerEvents: "none",
      borderRadius: theme2.shape.borderRadius,
      borderStyle: "solid",
      borderWidth: 1,
      // Match the Input Label
      transition: theme2.transitions.create(["padding-".concat(align), "border-color", "border-width"], {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      })
    },
    /* Styles applied to the legend element. */
    legend: {
      textAlign: "left",
      padding: 0,
      lineHeight: "11px",
      transition: theme2.transitions.create("width", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      })
    }
  };
};
var NotchedOutline = React.forwardRef(function NotchedOutline2(props, ref2) {
  props.children;
  var classes = props.classes, className = props.className, labelWidthProp = props.labelWidth, notched = props.notched, style2 = props.style, other = _objectWithoutProperties(props, ["children", "classes", "className", "labelWidth", "notched", "style"]);
  var theme2 = useTheme();
  var align = theme2.direction === "rtl" ? "right" : "left";
  var labelWidth = labelWidthProp > 0 ? labelWidthProp * 0.75 + 8 : 0;
  return React.createElement("fieldset", _extends$1({
    "aria-hidden": true,
    style: _extends$1(_defineProperty$1({}, "padding".concat(capitalize(align)), 8 + (notched ? 0 : labelWidth / 2)), style2),
    className: clsx(classes.root, className),
    ref: ref2
  }, other), React.createElement("legend", {
    className: classes.legend,
    style: {
      // IE 11: fieldset with legend does not render
      // a border radius. This maintains consistency
      // by always having a legend rendered
      width: notched ? labelWidth : 0.01
    }
  }, React.createElement("span", {
    dangerouslySetInnerHTML: {
      __html: "&#8203;"
    }
  })));
});
const NotchedOutline$1 = withStyles(styles$3, {
  name: "PrivateNotchedOutline"
})(NotchedOutline);
var styles$2 = function styles220(theme2) {
  var borderColor = theme2.palette.type === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    /* Styles applied to the root element. */
    root: {
      position: "relative",
      "&:hover $notchedOutline": {
        borderColor: theme2.palette.text.primary
      },
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        "&:hover $notchedOutline": {
          borderColor
        }
      },
      "&$focused $notchedOutline": {
        borderColor: theme2.palette.primary.main,
        borderWidth: 2
      },
      "&$error $notchedOutline": {
        borderColor: theme2.palette.error.main
      },
      "&$disabled $notchedOutline": {
        borderColor: theme2.palette.action.disabled
      }
    },
    /* Styles applied to the root element if the component is focused. */
    focused: {},
    /* Styles applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Styles applied to the root element if `startAdornment` is provided. */
    adornedStart: {
      paddingLeft: 14
    },
    /* Styles applied to the root element if `endAdornment` is provided. */
    adornedEnd: {
      paddingRight: 14
    },
    /* Styles applied to the root element if `error={true}`. */
    error: {},
    /* Styles applied to the `input` element if `margin="dense"`. */
    marginDense: {},
    /* Styles applied to the root element if `multiline={true}`. */
    multiline: {
      padding: "18.5px 14px",
      "&$marginDense": {
        paddingTop: 10.5,
        paddingBottom: 10.5
      }
    },
    /* Styles applied to the `NotchedOutline` element. */
    notchedOutline: {
      borderColor
    },
    /* Styles applied to the `input` element. */
    input: {
      padding: "18.5px 14px"
    },
    /* Styles applied to the `input` element if `margin="dense"`. */
    inputMarginDense: {
      paddingTop: 10.5,
      paddingBottom: 10.5
    },
    /* Styles applied to the `input` element if `select={true}`. */
    inputSelect: {
      paddingRight: 24
    },
    /* Styles applied to the `input` element if `multiline={true}`. */
    inputMultiline: {
      padding: 0
    },
    /* Styles applied to the `input` element if `startAdornment` is provided. */
    inputAdornedStart: {
      paddingLeft: 0
    },
    /* Styles applied to the `input` element if `endAdornment` is provided. */
    inputAdornedEnd: {
      paddingRight: 0
    }
  };
};
var OutlinedInput = React.forwardRef(function OutlinedInput2(props, ref2) {
  var classes = props.classes, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? "input" : _props$inputComponent, _props$labelWidth = props.labelWidth, labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, notched = props.notched, _props$type = props.type, type2 = _props$type === void 0 ? "text" : _props$type, other = _objectWithoutProperties(props, ["classes", "fullWidth", "inputComponent", "labelWidth", "multiline", "notched", "type"]);
  return React.createElement(InputBase$1, _extends$1({
    renderSuffix: function renderSuffix(state2) {
      return React.createElement(NotchedOutline$1, {
        className: classes.notchedOutline,
        labelWidth,
        notched: typeof notched !== "undefined" ? notched : Boolean(state2.startAdornment || state2.filled || state2.focused)
      });
    },
    classes: _extends$1({}, classes, {
      root: clsx(classes.root, classes.underline),
      notchedOutline: null
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type: type2
  }, other));
});
OutlinedInput.muiName = "Input";
const OutlinedInput$1 = withStyles(styles$2, {
  name: "MuiOutlinedInput"
})(OutlinedInput);
function areEqualValues(a, b) {
  if (_typeof$2(b) === "object" && b !== null) {
    return a === b;
  }
  return String(a) === String(b);
}
function isEmpty(display) {
  return display == null || typeof display === "string" && !display.trim();
}
var SelectInput = React.forwardRef(function SelectInput2(props, ref2) {
  var autoFocus = props.autoFocus, autoWidth = props.autoWidth, children = props.children, classes = props.classes, className = props.className, disabled = props.disabled, displayEmpty = props.displayEmpty, IconComponent = props.IconComponent, inputRefProp = props.inputRef, _props$MenuProps = props.MenuProps, MenuProps = _props$MenuProps === void 0 ? {} : _props$MenuProps, multiple = props.multiple, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onClose = props.onClose, onFocus = props.onFocus, onOpen = props.onOpen, openProp = props.open, readOnly = props.readOnly, renderValue = props.renderValue;
  props.required;
  var SelectDisplayProps = props.SelectDisplayProps, tabIndexProp = props.tabIndex;
  props.type;
  var value = props.value, _props$variant = props.variant, variant = _props$variant === void 0 ? "standard" : _props$variant, other = _objectWithoutProperties(props, ["autoFocus", "autoWidth", "children", "classes", "className", "disabled", "displayEmpty", "IconComponent", "inputRef", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "required", "SelectDisplayProps", "tabIndex", "type", "value", "variant"]);
  var inputRef = React.useRef(null);
  var _React$useState = React.useState(null), displayNode = _React$useState[0], setDisplayNode = _React$useState[1];
  var _React$useRef = React.useRef(openProp != null), isOpenControlled = _React$useRef.current;
  var _React$useState2 = React.useState(), menuMinWidthState = _React$useState2[0], setMenuMinWidthState = _React$useState2[1];
  var _React$useState3 = React.useState(false), openState = _React$useState3[0], setOpenState = _React$useState3[1];
  var handleRef = useForkRef(ref2, inputRefProp);
  React.useImperativeHandle(handleRef, function() {
    return {
      focus: function focus() {
        displayNode.focus();
      },
      node: inputRef.current,
      value
    };
  }, [displayNode, value]);
  React.useEffect(function() {
    if (autoFocus && displayNode) {
      displayNode.focus();
    }
  }, [autoFocus, displayNode]);
  var update2 = function update22(open2, event) {
    if (open2) {
      if (onOpen) {
        onOpen(event);
      }
    } else {
      displayNode.focus();
      if (onClose) {
        onClose(event);
      }
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
      setOpenState(open2);
    }
  };
  var handleClick = function handleClick2(event) {
    update2(true, event);
  };
  var handleClose = function handleClose2(event) {
    update2(false, event);
  };
  var handleItemClick = function handleItemClick2(child) {
    return function(event) {
      if (!multiple) {
        update2(false, event);
      }
      if (onChange) {
        var newValue;
        if (multiple) {
          newValue = Array.isArray(value) ? _toConsumableArray(value) : [];
          var itemIndex = value.indexOf(child.props.value);
          if (itemIndex === -1) {
            newValue.push(child.props.value);
          } else {
            newValue.splice(itemIndex, 1);
          }
        } else {
          newValue = child.props.value;
        }
        event.persist();
        event.target = {
          value: newValue,
          name
        };
        onChange(event, child);
      }
    };
  };
  var handleKeyDown2 = function handleKeyDown22(event) {
    if (!readOnly) {
      var validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on MacOS, but it's recommended by
        // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html
        "Enter"
      ];
      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update2(true, event);
      }
    }
  };
  var open = displayNode !== null && (isOpenControlled ? openProp : openState);
  var handleBlur = function handleBlur2(event) {
    if (!open && onBlur) {
      event.persist();
      event.target = {
        value,
        name
      };
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  var display;
  var displaySingle;
  var displayMultiple = [];
  var computeDisplay = false;
  if (isFilled(props) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  var items = React.Children.map(children, function(child) {
    if (!React.isValidElement(child)) {
      return null;
    }
    var selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error("Material-UI: the `value` prop must be an array when using the `Select` component with `multiple`.");
      }
      selected = value.some(function(v) {
        return areEqualValues(v, child.props.value);
      });
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return React.cloneElement(child, {
      "aria-selected": selected ? "true" : void 0,
      onClick: handleItemClick(child),
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    display = multiple ? displayMultiple.join(", ") : displaySingle;
  }
  var menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = displayNode.clientWidth;
  }
  var tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  return React.createElement(React.Fragment, null, React.createElement("div", _extends$1({
    className: clsx(
      classes.root,
      // TODO v5: merge root and select
      classes.select,
      classes.selectMenu,
      classes[variant],
      className,
      disabled && classes.disabled
    ),
    ref: setDisplayNode,
    tabIndex,
    role: "button",
    "aria-expanded": open ? "true" : void 0,
    "aria-haspopup": "listbox",
    "aria-owns": open ? "menu-".concat(name || "") : void 0,
    onKeyDown: handleKeyDown2,
    onClick: disabled || readOnly ? null : handleClick,
    onBlur: handleBlur,
    onFocus,
    id: name ? "select-".concat(name) : void 0
  }, SelectDisplayProps), isEmpty(display) ? (
    // eslint-disable-next-line react/no-danger
    React.createElement("span", {
      dangerouslySetInnerHTML: {
        __html: "&#8203;"
      }
    })
  ) : display), React.createElement("input", _extends$1({
    value: Array.isArray(value) ? value.join(",") : value,
    name,
    ref: inputRef,
    type: "hidden",
    autoFocus
  }, other)), React.createElement(IconComponent, {
    className: clsx(classes.icon, classes["icon".concat(capitalize(variant))])
  }), React.createElement(Menu$1, _extends$1({
    id: "menu-".concat(name || ""),
    anchorEl: displayNode,
    open,
    onClose: handleClose
  }, MenuProps, {
    MenuListProps: _extends$1({
      role: "listbox",
      disableListWrap: true
    }, MenuProps.MenuListProps),
    PaperProps: _extends$1({}, MenuProps.PaperProps, {
      style: _extends$1({
        minWidth: menuMinWidth
      }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
    })
  }), items));
});
var styles$1 = styles$4;
var _ref = React.createElement(Input$1, null);
var _ref2 = React.createElement(FilledInput$1, null);
var Select = React.forwardRef(function Select2(props, ref2) {
  var _props$autoWidth = props.autoWidth, autoWidth = _props$autoWidth === void 0 ? false : _props$autoWidth, children = props.children, classes = props.classes, _props$displayEmpty = props.displayEmpty, displayEmpty = _props$displayEmpty === void 0 ? false : _props$displayEmpty, _props$IconComponent = props.IconComponent, IconComponent = _props$IconComponent === void 0 ? ArrowDropDownIcon : _props$IconComponent, input = props.input, inputProps = props.inputProps, MenuProps = props.MenuProps, _props$multiple = props.multiple, multiple = _props$multiple === void 0 ? false : _props$multiple, _props$native = props.native, native = _props$native === void 0 ? false : _props$native, onClose = props.onClose, onOpen = props.onOpen, open = props.open, renderValue = props.renderValue, SelectDisplayProps = props.SelectDisplayProps, _props$variant = props.variant, variantProps = _props$variant === void 0 ? "standard" : _props$variant, _props$labelWidth = props.labelWidth, labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth, other = _objectWithoutProperties(props, ["autoWidth", "children", "classes", "displayEmpty", "IconComponent", "input", "inputProps", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant", "labelWidth"]);
  var inputComponent = native ? NativeSelectInput : SelectInput;
  var muiFormControl = useFormControl();
  var fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant"]
  });
  var variant = fcs.variant || variantProps;
  var InputComponent = input || {
    standard: _ref,
    outlined: React.createElement(OutlinedInput$1, {
      labelWidth
    }),
    filled: _ref2
  }[variant];
  return React.cloneElement(InputComponent, _extends$1({
    // Most of the logic is implemented in `SelectInput`.
    // The `Select` component is a simple API wrapper to expose something better to play with.
    inputComponent,
    select: true,
    inputProps: _extends$1({
      children,
      IconComponent,
      variant,
      type: void 0,
      // We render a select. We can ignore the type provided by the `Input`.
      multiple
    }, native ? {} : {
      autoWidth,
      displayEmpty,
      MenuProps,
      onClose,
      onOpen,
      open,
      renderValue,
      SelectDisplayProps
    }, {}, inputProps, {
      classes: inputProps ? mergeClasses({
        baseClasses: classes,
        newClasses: inputProps.classes,
        Component: Select2
      }) : classes
    }, input ? input.props.inputProps : {}),
    ref: ref2
  }, other));
});
Select.muiName = "Select";
const Select$1 = withStyles(styles$1, {
  name: "MuiSelect"
})(Select);
var variantComponent = {
  standard: Input$1,
  filled: FilledInput$1,
  outlined: OutlinedInput$1
};
var styles = {
  /* Styles applied to the root element. */
  root: {}
};
var TextField = React.forwardRef(function TextField2(props, ref2) {
  var autoComplete = props.autoComplete, autoFocus = props.autoFocus, children = props.children, classes = props.classes, classNameProp = props.className, defaultValue = props.defaultValue, error3 = props.error, FormHelperTextProps = props.FormHelperTextProps, fullWidth = props.fullWidth, helperText = props.helperText, hiddenLabel = props.hiddenLabel, id = props.id, InputLabelProps = props.InputLabelProps, inputProps = props.inputProps, InputProps = props.InputProps, inputRef = props.inputRef, label = props.label, multiline = props.multiline, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onFocus = props.onFocus, placeholder = props.placeholder, _props$required = props.required, required = _props$required === void 0 ? false : _props$required, rows = props.rows, rowsMax = props.rowsMax, _props$select = props.select, select = _props$select === void 0 ? false : _props$select, SelectProps = props.SelectProps, type2 = props.type, value = props.value, _props$variant = props.variant, variant = _props$variant === void 0 ? "standard" : _props$variant, other = _objectWithoutProperties(props, ["autoComplete", "autoFocus", "children", "classes", "className", "defaultValue", "error", "FormHelperTextProps", "fullWidth", "helperText", "hiddenLabel", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "rowsMax", "select", "SelectProps", "type", "value", "variant"]);
  var _React$useState = React.useState(0), labelWidth = _React$useState[0], setLabelWidth = _React$useState[1];
  var labelRef = React.useRef(null);
  React.useEffect(function() {
    if (variant === "outlined") {
      var labelNode = ReactDOM.findDOMNode(labelRef.current);
      setLabelWidth(labelNode != null ? labelNode.offsetWidth : 0);
    }
  }, [variant, required, label]);
  var InputMore = {};
  if (variant === "outlined") {
    if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
      InputMore.notched = InputLabelProps.shrink;
    }
    InputMore.labelWidth = labelWidth;
  }
  var helperTextId = helperText && id ? "".concat(id, "-helper-text") : void 0;
  var InputComponent = variantComponent[variant];
  var InputElement = React.createElement(InputComponent, _extends$1({
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name,
    rows,
    rowsMax,
    type: type2,
    value,
    id,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps
  }, InputMore, InputProps));
  return React.createElement(FormControl$1, _extends$1({
    className: clsx(classes.root, classNameProp),
    error: error3,
    fullWidth,
    hiddenLabel,
    ref: ref2,
    required,
    variant
  }, other), label && React.createElement(InputLabel$1, _extends$1({
    htmlFor: id,
    ref: labelRef
  }, InputLabelProps), label), select ? React.createElement(Select$1, _extends$1({
    "aria-describedby": helperTextId,
    value,
    input: InputElement
  }, SelectProps), children) : InputElement, helperText && React.createElement(FormHelperText$1, _extends$1({
    id: helperTextId
  }, FormHelperTextProps), helperText));
});
const TextField$1 = withStyles(styles, {
  name: "MuiTextField"
})(TextField);
var createBreakpoints$1 = {};
var interopRequireDefault = { exports: {} };
var hasRequiredInteropRequireDefault;
function requireInteropRequireDefault() {
  if (hasRequiredInteropRequireDefault) return interopRequireDefault.exports;
  hasRequiredInteropRequireDefault = 1;
  (function(module) {
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : {
        "default": e
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(interopRequireDefault);
  return interopRequireDefault.exports;
}
var _extends = { exports: {} };
var hasRequired_extends;
function require_extends() {
  if (hasRequired_extends) return _extends.exports;
  hasRequired_extends = 1;
  (function(module) {
    function _extends2() {
      return module.exports = _extends2 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r in t2) ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
        }
        return n;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends2.apply(null, arguments);
    }
    module.exports = _extends2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_extends);
  return _extends.exports;
}
var objectWithoutProperties = { exports: {} };
var objectWithoutPropertiesLoose = { exports: {} };
var hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
  if (hasRequiredObjectWithoutPropertiesLoose) return objectWithoutPropertiesLoose.exports;
  hasRequiredObjectWithoutPropertiesLoose = 1;
  (function(module) {
    function _objectWithoutPropertiesLoose2(r, e) {
      if (null == r) return {};
      var t2 = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t2[n] = r[n];
      }
      return t2;
    }
    module.exports = _objectWithoutPropertiesLoose2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectWithoutPropertiesLoose);
  return objectWithoutPropertiesLoose.exports;
}
var hasRequiredObjectWithoutProperties;
function requireObjectWithoutProperties() {
  if (hasRequiredObjectWithoutProperties) return objectWithoutProperties.exports;
  hasRequiredObjectWithoutProperties = 1;
  (function(module) {
    var objectWithoutPropertiesLoose2 = requireObjectWithoutPropertiesLoose();
    function _objectWithoutProperties2(e, t2) {
      if (null == e) return {};
      var o, r, i2 = objectWithoutPropertiesLoose2(e, t2);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for (r = 0; r < n.length; r++) o = n[r], -1 === t2.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i2[o] = e[o]);
      }
      return i2;
    }
    module.exports = _objectWithoutProperties2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectWithoutProperties);
  return objectWithoutProperties.exports;
}
var hasRequiredCreateBreakpoints;
function requireCreateBreakpoints() {
  if (hasRequiredCreateBreakpoints) return createBreakpoints$1;
  hasRequiredCreateBreakpoints = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(createBreakpoints$1, "__esModule", {
    value: true
  });
  createBreakpoints$1.default = createBreakpoints2;
  createBreakpoints$1.keys = void 0;
  var _extends2 = _interopRequireDefault(require_extends());
  var _objectWithoutProperties2 = _interopRequireDefault(requireObjectWithoutProperties());
  var keys2 = ["xs", "sm", "md", "lg", "xl"];
  createBreakpoints$1.keys = keys2;
  function createBreakpoints2(breakpoints2) {
    var _breakpoints$values = breakpoints2.values, values2 = _breakpoints$values === void 0 ? {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1920
    } : _breakpoints$values, _breakpoints$unit = breakpoints2.unit, unit = _breakpoints$unit === void 0 ? "px" : _breakpoints$unit, _breakpoints$step = breakpoints2.step, step = _breakpoints$step === void 0 ? 5 : _breakpoints$step, other = (0, _objectWithoutProperties2.default)(breakpoints2, ["values", "unit", "step"]);
    function up(key2) {
      var value = typeof values2[key2] === "number" ? values2[key2] : key2;
      return "@media (min-width:".concat(value).concat(unit, ")");
    }
    function down(key2) {
      var endIndex = keys2.indexOf(key2) + 1;
      var upperbound = values2[keys2[endIndex]];
      if (endIndex === keys2.length) {
        return up("xs");
      }
      var value = typeof upperbound === "number" && endIndex > 0 ? upperbound : key2;
      return "@media (max-width:".concat(value - step / 100).concat(unit, ")");
    }
    function between(start, end) {
      var endIndex = keys2.indexOf(end) + 1;
      if (endIndex === keys2.length) {
        return up(start);
      }
      return "@media (min-width:".concat(values2[start]).concat(unit, ") and ") + "(max-width:".concat(values2[keys2[endIndex]] - step / 100).concat(unit, ")");
    }
    function only(key2) {
      return between(key2, key2);
    }
    function width(key2) {
      return values2[key2];
    }
    return (0, _extends2.default)({
      keys: keys2,
      values: values2,
      up,
      down,
      between,
      only,
      width
    }, other);
  }
  return createBreakpoints$1;
}
var createBreakpointsExports = /* @__PURE__ */ requireCreateBreakpoints();
const createBreakpoints = /* @__PURE__ */ getDefaultExportFromCjs$1(createBreakpointsExports);
var KeyboardArrowDown = {};
var createSvgIcon = {};
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(SvgIcon);
var hasRequiredCreateSvgIcon;
function requireCreateSvgIcon() {
  if (hasRequiredCreateSvgIcon) return createSvgIcon;
  hasRequiredCreateSvgIcon = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(createSvgIcon, "__esModule", {
    value: true
  });
  createSvgIcon.default = createSvgIcon$12;
  var _extends2 = _interopRequireDefault(require_extends());
  var _react = _interopRequireDefault(requireReact());
  var _SvgIcon = _interopRequireDefault(require$$3);
  function createSvgIcon$12(path2, displayName) {
    var Component = _react.default.memo(_react.default.forwardRef(function(props, ref2) {
      return _react.default.createElement(_SvgIcon.default, (0, _extends2.default)({
        ref: ref2
      }, props), path2);
    }));
    Component.muiName = _SvgIcon.default.muiName;
    return Component;
  }
  return createSvgIcon;
}
var hasRequiredKeyboardArrowDown;
function requireKeyboardArrowDown() {
  if (hasRequiredKeyboardArrowDown) return KeyboardArrowDown;
  hasRequiredKeyboardArrowDown = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(KeyboardArrowDown, "__esModule", {
    value: true
  });
  KeyboardArrowDown.default = void 0;
  var _react = _interopRequireDefault(requireReact());
  var _createSvgIcon = _interopRequireDefault(/* @__PURE__ */ requireCreateSvgIcon());
  var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
    d: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"
  }), "KeyboardArrowDown");
  KeyboardArrowDown.default = _default;
  return KeyboardArrowDown;
}
var KeyboardArrowDownExports = /* @__PURE__ */ requireKeyboardArrowDown();
const ArrowDownIcon = /* @__PURE__ */ getDefaultExportFromCjs$1(KeyboardArrowDownExports);
var amber$1 = {};
var hasRequiredAmber;
function requireAmber() {
  if (hasRequiredAmber) return amber$1;
  hasRequiredAmber = 1;
  Object.defineProperty(amber$1, "__esModule", {
    value: true
  });
  amber$1.default = void 0;
  var amber2 = {
    50: "#fff8e1",
    100: "#ffecb3",
    200: "#ffe082",
    300: "#ffd54f",
    400: "#ffca28",
    500: "#ffc107",
    600: "#ffb300",
    700: "#ffa000",
    800: "#ff8f00",
    900: "#ff6f00",
    A100: "#ffe57f",
    A200: "#ffd740",
    A400: "#ffc400",
    A700: "#ffab00"
  };
  var _default = amber2;
  amber$1.default = _default;
  return amber$1;
}
var amberExports = /* @__PURE__ */ requireAmber();
const amber = /* @__PURE__ */ getDefaultExportFromCjs$1(amberExports);
var lightBlue$1 = {};
var hasRequiredLightBlue;
function requireLightBlue() {
  if (hasRequiredLightBlue) return lightBlue$1;
  hasRequiredLightBlue = 1;
  Object.defineProperty(lightBlue$1, "__esModule", {
    value: true
  });
  lightBlue$1.default = void 0;
  var lightBlue2 = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea"
  };
  var _default = lightBlue2;
  lightBlue$1.default = _default;
  return lightBlue$1;
}
var lightBlueExports = /* @__PURE__ */ requireLightBlue();
const lightBlue = /* @__PURE__ */ getDefaultExportFromCjs$1(lightBlueExports);
var grey$1 = {};
var hasRequiredGrey;
function requireGrey() {
  if (hasRequiredGrey) return grey$1;
  hasRequiredGrey = 1;
  Object.defineProperty(grey$1, "__esModule", {
    value: true
  });
  grey$1.default = void 0;
  var grey2 = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#d5d5d5",
    A200: "#aaaaaa",
    A400: "#303030",
    A700: "#616161"
  };
  var _default = grey2;
  grey$1.default = _default;
  return grey$1;
}
var greyExports = /* @__PURE__ */ requireGrey();
const grey = /* @__PURE__ */ getDefaultExportFromCjs$1(greyExports);
const SlideUpTransition = React.forwardRef((props, ref2) => /* @__PURE__ */ React.createElement(Slide, { direction: "up", ref: ref2, ...props }));
const SlideLeftTransition = React.forwardRef((props, ref2) => /* @__PURE__ */ React.createElement(Slide, { direction: "left", ref: ref2, ...props }));
const brandColor = {
  dark: "#d6a400",
  main: "#ebbe2c",
  main15: "#ebbe2c26",
  light: "#f8e091"
};
const primaryBackground = "linear-gradient(to left bottom, #ebbe2c, #d6a400)";
const primaryBackgroundColor = "#f8ab5e";
const warningColor = amber["500"];
const breakpoints = createBreakpoints({});
const FullscreenDialogTransition = SlideLeftTransition;
const CompactDialogTransition = SlideUpTransition;
const isSmallScreen = window.innerWidth <= 600;
const theme = createMuiTheme$1({
  props: {
    MuiDialogActions: {
      // disableSpacing: true
    },
    MuiInputLabel: {
      required: false,
      shrink: true
    },
    MuiMenu: isSmallScreen ? {
      BackdropProps: {
        open: true
      },
      TransitionComponent: Fade,
      transitionDuration: 300,
      transformOrigin: {
        horizontal: "center",
        vertical: "center"
      }
    } : void 0,
    MuiSelect: {
      IconComponent: ArrowDownIcon
    }
  },
  overrides: {
    MuiButton: {
      root: {
        borderRadius: 8,
        boxShadow: "none",
        minHeight: 48,
        [breakpoints.down(600)]: {
          minHeight: 36
        }
      },
      contained: {
        backgroundColor: "white",
        boxShadow: "none",
        border: `none`,
        color: brandColor.dark,
        "&:hover": {
          backgroundColor: "#F8F8F8"
        },
        [breakpoints.down(600)]: {
          boxShadow: "0 8px 16px 0 rgba(0, 0, 0, 0.1)"
        }
      },
      containedPrimary: {
        "&$disabled": {
          backgroundColor: brandColor.main,
          border: "none",
          boxShadow: "none",
          color: "rgba(255, 255, 255, 0.7)"
        },
        "&:hover": {
          backgroundColor: "#ebbe2c"
        }
      },
      textPrimary: {
        color: brandColor.dark
      },
      outlinedSecondary: {
        backgroundColor: "transparent",
        borderColor: "rgba(255, 255, 255, 0.87)",
        boxShadow: "none",
        color: "white",
        "&:disabled": {
          opacity: 0.5
        },
        "&:hover": {
          backgroundColor: "rgba(255, 255, 255, 0.10)",
          borderColor: "white"
        }
      }
    },
    MuiCardContent: {
      root: {
        [breakpoints.down(600)]: {
          padding: 8
        }
      }
    },
    MuiDialog: {
      root: {
        WebkitOverflowScrolling: "touch"
      },
      paperFullScreen: {
        backgroundColor: "#fcfcfc",
        boxSizing: "border-box"
      }
    },
    MuiFormLabel: {
      root: {
        fontSize: 12,
        fontWeight: 600,
        textTransform: "uppercase",
        "&$focused": {
          color: "inherit !important"
        }
      }
    },
    MuiInput: {
      root: {
        lineHeight: "27px"
      },
      formControl: {
        "label + &": {
          marginTop: 12
        }
      },
      inputMultiline: {
        lineHeight: "24px"
      }
    },
    MuiInputBase: {
      root: {
        fontSize: 18,
        fontWeight: 300,
        [breakpoints.down(400)]: {
          fontSize: 16
        }
      }
    },
    MuiInputLabel: {
      formControl: {
        [breakpoints.down(600)]: {
          fontSize: "0.85rem"
        },
        [breakpoints.down(400)]: {
          fontSize: "0.75rem"
        }
      }
    },
    MuiLinearProgress: {
      colorPrimary: {
        backgroundColor: lightBlue["100"]
      },
      barColorPrimary: {
        backgroundColor: lightBlue.A200
      }
    },
    MuiList: {
      root: {
        paddingLeft: 8,
        paddingRight: 8,
        [breakpoints.down(600)]: {
          paddingLeft: 0,
          paddingRight: 0
        }
      }
    },
    MuiListItem: {
      root: {
        borderBottom: "1px solid rgba(0,0,0,0.04)",
        [breakpoints.down(600)]: {
          paddingLeft: 8,
          paddingRight: 8
        },
        "& + hr": {
          borderBottom: "none"
        }
      },
      button: {
        background: "#FFFFFF",
        boxShadow: "0 8px 12px 0 rgba(0, 0, 0, 0.1)",
        "&:focus:not($selected)": {
          backgroundColor: "#FFFFFF"
        },
        "&:hover": {
          backgroundColor: "#F8F8F8",
          [breakpoints.down(600)]: {
            backgroundColor: "#FFFFFF"
          }
        },
        "&:first-child": {
          borderTopLeftRadius: 8,
          borderTopRightRadius: 8
        },
        "&:last-child": {
          borderBottomLeftRadius: 8,
          borderBottomRightRadius: 8
        }
      }
    },
    MuiListItemText: {
      primary: {
        display: "block"
      }
    },
    MuiListSubheader: {
      root: {
        [breakpoints.down(600)]: {
          paddingLeft: 8,
          paddingRight: 8
        }
      },
      sticky: {
        background: "linear-gradient(to bottom, white 0%, white 70%, rgba(255, 255, 255, 0) 100%)"
      }
    },
    MuiMenu: {
      paper: {
        [breakpoints.down(600)]: {
          backgroundColor: "white",
          borderBottomLeftRadius: 0,
          borderBottomRightRadius: 0,
          bottom: "0 !important",
          left: "0 !important",
          right: "0 !important",
          top: "initial !important",
          maxWidth: "100vw",
          position: "fixed",
          // declaring these here because passing a className into MuiMenu-props does not work as the styles of that class are overridden several times
          "&": {
            // iOS 11
            paddingBottom: "constant(safe-area-inset-bottom)"
          },
          // iOS 12
          paddingBottom: "env(safe-area-inset-bottom)"
        }
      },
      list: {
        padding: 0
      }
    },
    MuiMenuItem: {
      root: {
        borderBottom: "none",
        [breakpoints.down(600)]: {
          fontSize: 20,
          padding: 16
        }
      }
    },
    MuiPaper: {
      rounded: {
        borderRadius: 8
      }
    },
    MuiSwitch: {
      colorSecondary: {
        color: grey[50],
        "&$checked": {
          color: grey[50]
        },
        "&$checked + $track": {
          backgroundColor: grey[50]
        }
      }
    },
    MuiTab: {
      root: {
        backgroundColor: "rgba(0, 0, 0, 0.1)",
        transition: "background-color 0.2s",
        "&$selected": {
          backgroundColor: brandColor.main,
          color: "white",
          "&:hover": {
            // Don't change color of already-selected tab
            backgroundColor: brandColor.main
          }
        },
        "&:hover": {
          backgroundColor: "rgba(0, 0, 0, 0.15)"
        }
      }
    },
    MuiTabs: {
      indicator: {
        backgroundColor: "rgba(255, 255, 255, 0)"
      }
    },
    MuiTypography: {
      h6: {
        fontWeight: 400
      }
    }
  },
  palette: {
    primary: {
      contrastText: "black",
      dark: brandColor.dark,
      main: brandColor.main,
      light: brandColor.light
    }
  },
  shape: {
    borderRadius: 8
  }
});
const MobileKeyboardOpenedSelector = () => `:not(*)`;
var Add = {};
var hasRequiredAdd;
function requireAdd() {
  if (hasRequiredAdd) return Add;
  hasRequiredAdd = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(Add, "__esModule", {
    value: true
  });
  Add.default = void 0;
  var _react = _interopRequireDefault(requireReact());
  var _createSvgIcon = _interopRequireDefault(/* @__PURE__ */ requireCreateSvgIcon());
  var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
  }), "Add");
  Add.default = _default;
  return Add;
}
var AddExports = /* @__PURE__ */ requireAdd();
const AddIcon = /* @__PURE__ */ getDefaultExportFromCjs$1(AddExports);
var makeStyles$1 = {};
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(esm);
var defaultTheme = {};
var createMuiTheme = {};
var defineProperty = { exports: {} };
var toPropertyKey = { exports: {} };
var _typeof = { exports: {} };
var hasRequired_typeof;
function require_typeof() {
  if (hasRequired_typeof) return _typeof.exports;
  hasRequired_typeof = 1;
  (function(module) {
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof);
  return _typeof.exports;
}
var toPrimitive = { exports: {} };
var hasRequiredToPrimitive;
function requireToPrimitive() {
  if (hasRequiredToPrimitive) return toPrimitive.exports;
  hasRequiredToPrimitive = 1;
  (function(module) {
    var _typeof2 = require_typeof()["default"];
    function toPrimitive2(t2, r) {
      if ("object" != _typeof2(t2) || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t2, r || "default");
        if ("object" != _typeof2(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t2);
    }
    module.exports = toPrimitive2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(toPrimitive);
  return toPrimitive.exports;
}
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  if (hasRequiredToPropertyKey) return toPropertyKey.exports;
  hasRequiredToPropertyKey = 1;
  (function(module) {
    var _typeof2 = require_typeof()["default"];
    var toPrimitive2 = requireToPrimitive();
    function toPropertyKey2(t2) {
      var i2 = toPrimitive2(t2, "string");
      return "symbol" == _typeof2(i2) ? i2 : i2 + "";
    }
    module.exports = toPropertyKey2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(toPropertyKey);
  return toPropertyKey.exports;
}
var hasRequiredDefineProperty;
function requireDefineProperty() {
  if (hasRequiredDefineProperty) return defineProperty.exports;
  hasRequiredDefineProperty = 1;
  (function(module) {
    var toPropertyKey2 = requireToPropertyKey();
    function _defineProperty2(e, r, t2) {
      return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
        value: t2,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t2, e;
    }
    module.exports = _defineProperty2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(defineProperty);
  return defineProperty.exports;
}
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(isPlainObject$1);
var createMixins = {};
var hasRequiredCreateMixins;
function requireCreateMixins() {
  if (hasRequiredCreateMixins) return createMixins;
  hasRequiredCreateMixins = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(createMixins, "__esModule", {
    value: true
  });
  createMixins.default = createMixins$12;
  var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
  var _extends3 = _interopRequireDefault(require_extends());
  function createMixins$12(breakpoints2, spacing, mixins) {
    var _toolbar;
    return (0, _extends3.default)({
      gutters: function gutters() {
        var styles3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return (0, _extends3.default)({
          paddingLeft: spacing(2),
          paddingRight: spacing(2)
        }, styles3, (0, _defineProperty2.default)({}, breakpoints2.up("sm"), (0, _extends3.default)({
          paddingLeft: spacing(3),
          paddingRight: spacing(3)
        }, styles3[breakpoints2.up("sm")])));
      },
      toolbar: (_toolbar = {
        minHeight: 56
      }, (0, _defineProperty2.default)(_toolbar, "".concat(breakpoints2.up("xs"), " and (orientation: landscape)"), {
        minHeight: 48
      }), (0, _defineProperty2.default)(_toolbar, breakpoints2.up("sm"), {
        minHeight: 64
      }), _toolbar)
    }, mixins);
  }
  return createMixins;
}
var createPalette = {};
var indigo = {};
var hasRequiredIndigo;
function requireIndigo() {
  if (hasRequiredIndigo) return indigo;
  hasRequiredIndigo = 1;
  Object.defineProperty(indigo, "__esModule", {
    value: true
  });
  indigo.default = void 0;
  var indigo$12 = {
    50: "#e8eaf6",
    100: "#c5cae9",
    200: "#9fa8da",
    300: "#7986cb",
    400: "#5c6bc0",
    500: "#3f51b5",
    600: "#3949ab",
    700: "#303f9f",
    800: "#283593",
    900: "#1a237e",
    A100: "#8c9eff",
    A200: "#536dfe",
    A400: "#3d5afe",
    A700: "#304ffe"
  };
  var _default = indigo$12;
  indigo.default = _default;
  return indigo;
}
var pink = {};
var hasRequiredPink;
function requirePink() {
  if (hasRequiredPink) return pink;
  hasRequiredPink = 1;
  Object.defineProperty(pink, "__esModule", {
    value: true
  });
  pink.default = void 0;
  var pink$12 = {
    50: "#fce4ec",
    100: "#f8bbd0",
    200: "#f48fb1",
    300: "#f06292",
    400: "#ec407a",
    500: "#e91e63",
    600: "#d81b60",
    700: "#c2185b",
    800: "#ad1457",
    900: "#880e4f",
    A100: "#ff80ab",
    A200: "#ff4081",
    A400: "#f50057",
    A700: "#c51162"
  };
  var _default = pink$12;
  pink.default = _default;
  return pink;
}
var red = {};
var hasRequiredRed;
function requireRed() {
  if (hasRequiredRed) return red;
  hasRequiredRed = 1;
  Object.defineProperty(red, "__esModule", {
    value: true
  });
  red.default = void 0;
  var red$12 = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
  };
  var _default = red$12;
  red.default = _default;
  return red;
}
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  Object.defineProperty(common, "__esModule", {
    value: true
  });
  common.default = void 0;
  var common$12 = {
    black: "#000",
    white: "#fff"
  };
  var _default = common$12;
  common.default = _default;
  return common;
}
var colorManipulator = {};
var hasRequiredColorManipulator;
function requireColorManipulator() {
  if (hasRequiredColorManipulator) return colorManipulator;
  hasRequiredColorManipulator = 1;
  Object.defineProperty(colorManipulator, "__esModule", {
    value: true
  });
  colorManipulator.hexToRgb = hexToRgb2;
  colorManipulator.rgbToHex = rgbToHex;
  colorManipulator.hslToRgb = hslToRgb2;
  colorManipulator.decomposeColor = decomposeColor2;
  colorManipulator.recomposeColor = recomposeColor2;
  colorManipulator.getContrastRatio = getContrastRatio2;
  colorManipulator.getLuminance = getLuminance2;
  colorManipulator.emphasize = emphasize2;
  colorManipulator.fade = fade2;
  colorManipulator.darken = darken2;
  colorManipulator.lighten = lighten2;
  function clamp2(value) {
    var min2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (value < min2) {
      return min2;
    }
    if (value > max2) {
      return max2;
    }
    return value;
  }
  function hexToRgb2(color) {
    color = color.substr(1);
    var re = new RegExp(".{1,".concat(color.length / 3, "}"), "g");
    var colors = color.match(re);
    if (colors && colors[0].length === 1) {
      colors = colors.map(function(n) {
        return n + n;
      });
    }
    return colors ? "rgb(".concat(colors.map(function(n) {
      return parseInt(n, 16);
    }).join(", "), ")") : "";
  }
  function intToHex(int2) {
    var hex = int2.toString(16);
    return hex.length === 1 ? "0".concat(hex) : hex;
  }
  function rgbToHex(color) {
    if (color.indexOf("#") === 0) {
      return color;
    }
    var _decomposeColor = decomposeColor2(color), values2 = _decomposeColor.values;
    return "#".concat(values2.map(function(n) {
      return intToHex(n);
    }).join(""));
  }
  function hslToRgb2(color) {
    color = decomposeColor2(color);
    var _color = color, values2 = _color.values;
    var h = values2[0];
    var s = values2[1] / 100;
    var l = values2[2] / 100;
    var a = s * Math.min(l, 1 - l);
    var f = function f2(n) {
      var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (n + h / 30) % 12;
      return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    };
    var type2 = "rgb";
    var rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
    if (color.type === "hsla") {
      type2 += "a";
      rgb.push(values2[3]);
    }
    return recomposeColor2({
      type: type2,
      values: rgb
    });
  }
  function decomposeColor2(color) {
    if (color.type) {
      return color;
    }
    if (color.charAt(0) === "#") {
      return decomposeColor2(hexToRgb2(color));
    }
    var marker = color.indexOf("(");
    var type2 = color.substring(0, marker);
    if (["rgb", "rgba", "hsl", "hsla"].indexOf(type2) === -1) {
      throw new Error(["Material-UI: unsupported `".concat(color, "` color."), "We support the following formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()."].join("\n"));
    }
    var values2 = color.substring(marker + 1, color.length - 1).split(",");
    values2 = values2.map(function(value) {
      return parseFloat(value);
    });
    return {
      type: type2,
      values: values2
    };
  }
  function recomposeColor2(color) {
    var type2 = color.type;
    var values2 = color.values;
    if (type2.indexOf("rgb") !== -1) {
      values2 = values2.map(function(n, i2) {
        return i2 < 3 ? parseInt(n, 10) : n;
      });
    } else if (type2.indexOf("hsl") !== -1) {
      values2[1] = "".concat(values2[1], "%");
      values2[2] = "".concat(values2[2], "%");
    }
    return "".concat(type2, "(").concat(values2.join(", "), ")");
  }
  function getContrastRatio2(foreground, background) {
    var lumA = getLuminance2(foreground);
    var lumB = getLuminance2(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  function getLuminance2(color) {
    color = decomposeColor2(color);
    var rgb = color.type === "hsl" ? decomposeColor2(hslToRgb2(color)).values : color.values;
    rgb = rgb.map(function(val) {
      val /= 255;
      return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
    });
    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
  }
  function emphasize2(color) {
    var coefficient = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.15;
    return getLuminance2(color) > 0.5 ? darken2(color, coefficient) : lighten2(color, coefficient);
  }
  function fade2(color, value) {
    color = decomposeColor2(color);
    value = clamp2(value);
    if (color.type === "rgb" || color.type === "hsl") {
      color.type += "a";
    }
    color.values[3] = value;
    return recomposeColor2(color);
  }
  function darken2(color, coefficient) {
    color = decomposeColor2(color);
    coefficient = clamp2(coefficient);
    if (color.type.indexOf("hsl") !== -1) {
      color.values[2] *= 1 - coefficient;
    } else if (color.type.indexOf("rgb") !== -1) {
      for (var i2 = 0; i2 < 3; i2 += 1) {
        color.values[i2] *= 1 - coefficient;
      }
    }
    return recomposeColor2(color);
  }
  function lighten2(color, coefficient) {
    color = decomposeColor2(color);
    coefficient = clamp2(coefficient);
    if (color.type.indexOf("hsl") !== -1) {
      color.values[2] += (100 - color.values[2]) * coefficient;
    } else if (color.type.indexOf("rgb") !== -1) {
      for (var i2 = 0; i2 < 3; i2 += 1) {
        color.values[i2] += (255 - color.values[i2]) * coefficient;
      }
    }
    return recomposeColor2(color);
  }
  return colorManipulator;
}
var hasRequiredCreatePalette;
function requireCreatePalette() {
  if (hasRequiredCreatePalette) return createPalette;
  hasRequiredCreatePalette = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(createPalette, "__esModule", {
    value: true
  });
  createPalette.default = createPalette$12;
  createPalette.dark = createPalette.light = void 0;
  var _extends2 = _interopRequireDefault(require_extends());
  var _objectWithoutProperties2 = _interopRequireDefault(requireObjectWithoutProperties());
  var _deepmerge = _interopRequireDefault(requireCjs());
  var _indigo = _interopRequireDefault(/* @__PURE__ */ requireIndigo());
  var _pink = _interopRequireDefault(/* @__PURE__ */ requirePink());
  var _grey = _interopRequireDefault(/* @__PURE__ */ requireGrey());
  var _red = _interopRequireDefault(/* @__PURE__ */ requireRed());
  var _common = _interopRequireDefault(/* @__PURE__ */ requireCommon());
  var _colorManipulator = /* @__PURE__ */ requireColorManipulator();
  var light2 = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.54)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)",
      // Text hints.
      hint: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: _common.default.white,
      default: _grey.default[50]
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.08)",
      hoverOpacity: 0.08,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.14)",
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)"
    }
  };
  createPalette.light = light2;
  var dark2 = {
    text: {
      primary: _common.default.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      hint: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: _grey.default[800],
      default: "#303030"
    },
    action: {
      active: _common.default.white,
      hover: "rgba(255, 255, 255, 0.1)",
      hoverOpacity: 0.1,
      selected: "rgba(255, 255, 255, 0.2)",
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)"
    }
  };
  createPalette.dark = dark2;
  function addLightOrDark2(intent, direction, shade, tonalOffset) {
    if (!intent[direction]) {
      if (intent.hasOwnProperty(shade)) {
        intent[direction] = intent[shade];
      } else if (direction === "light") {
        intent.light = (0, _colorManipulator.lighten)(intent.main, tonalOffset);
      } else if (direction === "dark") {
        intent.dark = (0, _colorManipulator.darken)(intent.main, tonalOffset * 1.5);
      }
    }
  }
  function createPalette$12(palette) {
    var _palette$primary = palette.primary, primary = _palette$primary === void 0 ? {
      light: _indigo.default[300],
      main: _indigo.default[500],
      dark: _indigo.default[700]
    } : _palette$primary, _palette$secondary = palette.secondary, secondary = _palette$secondary === void 0 ? {
      light: _pink.default.A200,
      main: _pink.default.A400,
      dark: _pink.default.A700
    } : _palette$secondary, _palette$error = palette.error, error3 = _palette$error === void 0 ? {
      light: _red.default[300],
      main: _red.default[500],
      dark: _red.default[700]
    } : _palette$error, _palette$type = palette.type, type2 = _palette$type === void 0 ? "light" : _palette$type, _palette$contrastThre = palette.contrastThreshold, contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre, _palette$tonalOffset = palette.tonalOffset, tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset, other = (0, _objectWithoutProperties2.default)(palette, ["primary", "secondary", "error", "type", "contrastThreshold", "tonalOffset"]);
    function getContrastText(background) {
      var contrastText = (0, _colorManipulator.getContrastRatio)(background, dark2.text.primary) >= contrastThreshold ? dark2.text.primary : light2.text.primary;
      return contrastText;
    }
    function augmentColor(color) {
      var mainShade = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 500;
      var lightShade = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300;
      var darkShade = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 700;
      color = (0, _extends2.default)({}, color);
      if (!color.main && color[mainShade]) {
        color.main = color[mainShade];
      }
      addLightOrDark2(color, "light", lightShade, tonalOffset);
      addLightOrDark2(color, "dark", darkShade, tonalOffset);
      if (!color.contrastText) {
        color.contrastText = getContrastText(color.main);
      }
      return color;
    }
    var types2 = {
      dark: dark2,
      light: light2
    };
    var paletteOutput = (0, _deepmerge.default)((0, _extends2.default)({
      // A collection of common colors.
      common: _common.default,
      // The palette type, can be light or dark.
      type: type2,
      // The colors used to represent primary interface elements for a user.
      primary: augmentColor(primary),
      // The colors used to represent secondary interface elements for a user.
      secondary: augmentColor(secondary, "A400", "A200", "A700"),
      // The colors used to represent interface elements that the user should be made aware of.
      error: augmentColor(error3),
      // The grey colors.
      grey: _grey.default,
      // Used by `getContrastText()` to maximize the contrast between the background and
      // the text.
      contrastThreshold,
      // Take a background color and return the color of the text to maximize the contrast.
      getContrastText,
      // Generate a rich color object.
      augmentColor,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset
    }, types2[type2]), other, {
      clone: false
      // No need to clone deep
    });
    return paletteOutput;
  }
  return createPalette;
}
var createTypography = {};
var hasRequiredCreateTypography;
function requireCreateTypography() {
  if (hasRequiredCreateTypography) return createTypography;
  hasRequiredCreateTypography = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(createTypography, "__esModule", {
    value: true
  });
  createTypography.default = createTypography$12;
  var _extends2 = _interopRequireDefault(require_extends());
  var _objectWithoutProperties2 = _interopRequireDefault(requireObjectWithoutProperties());
  var _deepmerge = _interopRequireDefault(requireCjs());
  function round2(value) {
    return Math.round(value * 1e5) / 1e5;
  }
  var caseAllCaps2 = {
    textTransform: "uppercase"
  };
  var defaultFontFamily2 = '"Roboto", "Helvetica", "Arial", sans-serif';
  function createTypography$12(palette, typography) {
    var _ref3 = typeof typography === "function" ? typography(palette) : typography, _ref$fontFamily = _ref3.fontFamily, fontFamily = _ref$fontFamily === void 0 ? defaultFontFamily2 : _ref$fontFamily, _ref$fontSize = _ref3.fontSize, fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize, _ref$fontWeightLight = _ref3.fontWeightLight, fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight, _ref$fontWeightRegula = _ref3.fontWeightRegular, fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula, _ref$fontWeightMedium = _ref3.fontWeightMedium, fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium, _ref$fontWeightBold = _ref3.fontWeightBold, fontWeightBold = _ref$fontWeightBold === void 0 ? 700 : _ref$fontWeightBold, _ref$htmlFontSize = _ref3.htmlFontSize, htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize, allVariants = _ref3.allVariants, pxToRem2 = _ref3.pxToRem, other = (0, _objectWithoutProperties2.default)(_ref3, ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"]);
    var coef = fontSize / 14;
    var pxToRem = pxToRem2 || function(size) {
      return "".concat(size / htmlFontSize * coef, "rem");
    };
    var buildVariant = function buildVariant2(fontWeight, size, lineHeight, letterSpacing, casing) {
      return (0, _extends2.default)({
        fontFamily,
        fontWeight,
        fontSize: pxToRem(size),
        // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
        lineHeight
      }, fontFamily === defaultFontFamily2 ? {
        letterSpacing: "".concat(round2(letterSpacing / size), "em")
      } : {}, {}, casing, {}, allVariants);
    };
    var variants = {
      h1: buildVariant(fontWeightLight, 96, 1, -1.5),
      h2: buildVariant(fontWeightLight, 60, 1, -0.5),
      h3: buildVariant(fontWeightRegular, 48, 1.04, 0),
      h4: buildVariant(fontWeightRegular, 34, 1.17, 0.25),
      h5: buildVariant(fontWeightRegular, 24, 1.33, 0),
      h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
      subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
      subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
      body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
      body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
      button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps2),
      caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
      overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps2)
    };
    return (0, _deepmerge.default)((0, _extends2.default)({
      htmlFontSize,
      pxToRem,
      round: round2,
      // TODO To remove in v5?
      fontFamily,
      fontSize,
      fontWeightLight,
      fontWeightRegular,
      fontWeightMedium,
      fontWeightBold
    }, variants), other, {
      clone: false
      // No need to clone deep
    });
  }
  return createTypography;
}
var shadows = {};
var hasRequiredShadows;
function requireShadows() {
  if (hasRequiredShadows) return shadows;
  hasRequiredShadows = 1;
  Object.defineProperty(shadows, "__esModule", {
    value: true
  });
  shadows.default = void 0;
  var shadowKeyUmbraOpacity2 = 0.2;
  var shadowKeyPenumbraOpacity2 = 0.14;
  var shadowAmbientShadowOpacity2 = 0.12;
  function createShadow2() {
    return ["".concat(arguments.length <= 0 ? void 0 : arguments[0], "px ").concat(arguments.length <= 1 ? void 0 : arguments[1], "px ").concat(arguments.length <= 2 ? void 0 : arguments[2], "px ").concat(arguments.length <= 3 ? void 0 : arguments[3], "px rgba(0,0,0,").concat(shadowKeyUmbraOpacity2, ")"), "".concat(arguments.length <= 4 ? void 0 : arguments[4], "px ").concat(arguments.length <= 5 ? void 0 : arguments[5], "px ").concat(arguments.length <= 6 ? void 0 : arguments[6], "px ").concat(arguments.length <= 7 ? void 0 : arguments[7], "px rgba(0,0,0,").concat(shadowKeyPenumbraOpacity2, ")"), "".concat(arguments.length <= 8 ? void 0 : arguments[8], "px ").concat(arguments.length <= 9 ? void 0 : arguments[9], "px ").concat(arguments.length <= 10 ? void 0 : arguments[10], "px ").concat(arguments.length <= 11 ? void 0 : arguments[11], "px rgba(0,0,0,").concat(shadowAmbientShadowOpacity2, ")")].join(",");
  }
  var shadows$12 = ["none", createShadow2(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow2(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow2(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow2(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow2(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow2(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow2(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow2(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow2(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow2(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow2(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow2(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow2(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow2(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow2(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow2(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow2(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow2(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow2(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow2(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow2(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow2(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow2(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow2(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
  var _default = shadows$12;
  shadows.default = _default;
  return shadows;
}
var shape = {};
var hasRequiredShape;
function requireShape() {
  if (hasRequiredShape) return shape;
  hasRequiredShape = 1;
  Object.defineProperty(shape, "__esModule", {
    value: true
  });
  shape.default = void 0;
  var shape$12 = {
    borderRadius: 4
  };
  var _default = shape$12;
  shape.default = _default;
  return shape;
}
var createSpacing = {};
var hasRequiredCreateSpacing;
function requireCreateSpacing() {
  if (hasRequiredCreateSpacing) return createSpacing;
  hasRequiredCreateSpacing = 1;
  Object.defineProperty(createSpacing, "__esModule", {
    value: true
  });
  createSpacing.default = createSpacing$12;
  function createSpacing$12() {
    var spacingInput = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;
    if (spacingInput.mui) {
      return spacingInput;
    }
    var transform2;
    if (typeof spacingInput === "function") {
      transform2 = spacingInput;
    } else {
      transform2 = function transform22(factor) {
        return spacingInput * factor;
      };
    }
    var spacing = function spacing2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args.length === 0) {
        return transform2(1);
      }
      if (args.length === 1) {
        return transform2(args[0]);
      }
      return args.map(function(factor) {
        var output2 = transform2(factor);
        return typeof output2 === "number" ? "".concat(output2, "px") : output2;
      }).join(" ");
    };
    Object.defineProperty(spacing, "unit", {
      get: function get3() {
        return spacingInput;
      }
    });
    spacing.mui = true;
    return spacing;
  }
  return createSpacing;
}
var transitions = {};
var hasRequiredTransitions;
function requireTransitions() {
  if (hasRequiredTransitions) return transitions;
  hasRequiredTransitions = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(transitions, "__esModule", {
    value: true
  });
  transitions.default = transitions.isNumber = transitions.isString = transitions.formatMs = transitions.duration = transitions.easing = void 0;
  var _objectWithoutProperties2 = _interopRequireDefault(requireObjectWithoutProperties());
  var easing2 = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  };
  transitions.easing = easing2;
  var duration2 = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  transitions.duration = duration2;
  var formatMs3 = function formatMs22(milliseconds) {
    return "".concat(Math.round(milliseconds), "ms");
  };
  transitions.formatMs = formatMs3;
  var isString2 = function isString22(value) {
    return typeof value === "string";
  };
  transitions.isString = isString2;
  var isNumber = function isNumber2(value) {
    return !isNaN(parseFloat(value));
  };
  transitions.isNumber = isNumber;
  var _default = {
    easing: easing2,
    duration: duration2,
    create: function create4() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["all"];
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _options$duration = options2.duration, durationOption = _options$duration === void 0 ? duration2.standard : _options$duration, _options$easing = options2.easing, easingOption = _options$easing === void 0 ? easing2.easeInOut : _options$easing, _options$delay = options2.delay, delay = _options$delay === void 0 ? 0 : _options$delay;
      (0, _objectWithoutProperties2.default)(options2, ["duration", "easing", "delay"]);
      return (Array.isArray(props) ? props : [props]).map(function(animatedProp) {
        return "".concat(animatedProp, " ").concat(typeof durationOption === "string" ? durationOption : formatMs3(durationOption), " ").concat(easingOption, " ").concat(typeof delay === "string" ? delay : formatMs3(delay));
      }).join(",");
    },
    getAutoHeightDuration: function getAutoHeightDuration2(height) {
      if (!height) {
        return 0;
      }
      var constant = height / 36;
      return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
    }
  };
  transitions.default = _default;
  return transitions;
}
var zIndex = {};
var hasRequiredZIndex;
function requireZIndex() {
  if (hasRequiredZIndex) return zIndex;
  hasRequiredZIndex = 1;
  Object.defineProperty(zIndex, "__esModule", {
    value: true
  });
  zIndex.default = void 0;
  var zIndex$12 = {
    mobileStepper: 1e3,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  var _default = zIndex$12;
  zIndex.default = _default;
  return zIndex;
}
var hasRequiredCreateMuiTheme;
function requireCreateMuiTheme() {
  if (hasRequiredCreateMuiTheme) return createMuiTheme;
  hasRequiredCreateMuiTheme = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(createMuiTheme, "__esModule", {
    value: true
  });
  createMuiTheme.default = void 0;
  _interopRequireDefault(requireDefineProperty());
  var _extends2 = _interopRequireDefault(require_extends());
  var _objectWithoutProperties2 = _interopRequireDefault(requireObjectWithoutProperties());
  var _deepmerge = _interopRequireDefault(requireCjs());
  var _isPlainObject = _interopRequireDefault(require$$5);
  var _createBreakpoints = _interopRequireDefault(/* @__PURE__ */ requireCreateBreakpoints());
  var _createMixins = _interopRequireDefault(/* @__PURE__ */ requireCreateMixins());
  var _createPalette = _interopRequireDefault(/* @__PURE__ */ requireCreatePalette());
  var _createTypography = _interopRequireDefault(/* @__PURE__ */ requireCreateTypography());
  var _shadows = _interopRequireDefault(/* @__PURE__ */ requireShadows());
  var _shape = _interopRequireDefault(/* @__PURE__ */ requireShape());
  var _createSpacing = _interopRequireDefault(/* @__PURE__ */ requireCreateSpacing());
  var _transitions = _interopRequireDefault(/* @__PURE__ */ requireTransitions());
  var _zIndex = _interopRequireDefault(/* @__PURE__ */ requireZIndex());
  function createMuiTheme$12() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _options$breakpoints = options2.breakpoints, breakpointsInput = _options$breakpoints === void 0 ? {} : _options$breakpoints, _options$mixins = options2.mixins, mixinsInput = _options$mixins === void 0 ? {} : _options$mixins, _options$palette = options2.palette, paletteInput = _options$palette === void 0 ? {} : _options$palette, shadowsInput = options2.shadows, spacingInput = options2.spacing, _options$typography = options2.typography, typographyInput = _options$typography === void 0 ? {} : _options$typography, other = (0, _objectWithoutProperties2.default)(options2, ["breakpoints", "mixins", "palette", "shadows", "spacing", "typography"]);
    var palette = (0, _createPalette.default)(paletteInput);
    var breakpoints2 = (0, _createBreakpoints.default)(breakpointsInput);
    var spacing = (0, _createSpacing.default)(spacingInput);
    var muiTheme = (0, _extends2.default)({
      breakpoints: breakpoints2,
      direction: "ltr",
      mixins: (0, _createMixins.default)(breakpoints2, spacing, mixinsInput),
      overrides: {},
      // Inject custom styles
      palette,
      props: {},
      // Inject custom props
      shadows: shadowsInput || _shadows.default,
      typography: (0, _createTypography.default)(palette, typographyInput),
      spacing
    }, (0, _deepmerge.default)({
      shape: _shape.default,
      transitions: _transitions.default,
      zIndex: _zIndex.default
    }, other, {
      isMergeableObject: _isPlainObject.default
    }));
    return muiTheme;
  }
  var _default = createMuiTheme$12;
  createMuiTheme.default = _default;
  return createMuiTheme;
}
var hasRequiredDefaultTheme;
function requireDefaultTheme() {
  if (hasRequiredDefaultTheme) return defaultTheme;
  hasRequiredDefaultTheme = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(defaultTheme, "__esModule", {
    value: true
  });
  defaultTheme.default = void 0;
  var _createMuiTheme = _interopRequireDefault(/* @__PURE__ */ requireCreateMuiTheme());
  var defaultTheme$12 = (0, _createMuiTheme.default)();
  var _default = defaultTheme$12;
  defaultTheme.default = _default;
  return defaultTheme;
}
var hasRequiredMakeStyles;
function requireMakeStyles() {
  if (hasRequiredMakeStyles) return makeStyles$1;
  hasRequiredMakeStyles = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(makeStyles$1, "__esModule", {
    value: true
  });
  makeStyles$1.default = void 0;
  var _extends2 = _interopRequireDefault(require_extends());
  var _styles = require$$2;
  var _defaultTheme = _interopRequireDefault(/* @__PURE__ */ requireDefaultTheme());
  function makeStyles2(stylesOrCreator) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return (0, _styles.makeStyles)(stylesOrCreator, (0, _extends2.default)({
      defaultTheme: _defaultTheme.default
    }, options2));
  }
  var _default = makeStyles2;
  makeStyles$1.default = _default;
  return makeStyles$1;
}
var makeStylesExports = /* @__PURE__ */ requireMakeStyles();
const makeStyles = /* @__PURE__ */ getDefaultExportFromCjs$1(makeStylesExports);
const useButtonListItemStyles = makeStyles({
  root: {
    backgroundColor: "rgba(0, 0, 0, 0.08)",
    borderRadius: 8,
    boxShadow: "none",
    height: 56,
    marginTop: 0,
    marginBottom: 0,
    [breakpoints.down(600)]: {
      height: 52
    },
    [breakpoints.down(350)]: {
      height: 48
    },
    "&:hover, &:focus": {
      "@media (hover: hover)": {
        backgroundColor: "rgba(0, 0, 0, 0.12) !important"
      },
      "@media (hover: none)": {
        backgroundColor: "rgba(0, 0, 0, 0.08) !important"
      }
    }
  },
  gutterBottom: {
    marginBottom: 16
  },
  textTypography: {
    alignItems: "center",
    display: "flex",
    justifyContent: "center",
    [breakpoints.down(400)]: {
      fontSize: 14
    }
  }
});
function ButtonListItem(props) {
  const classes = useButtonListItemStyles();
  return /* @__PURE__ */ React.createElement(
    ListItem$1,
    {
      button: true,
      className: `${classes.root} ${props.gutterBottom ? classes.gutterBottom : ""}`,
      onClick: props.onClick,
      style: props.style
    },
    /* @__PURE__ */ React.createElement(ListItemText$1, { classes: { primary: classes.textTypography } }, props.children)
  );
}
const ButtonListItem$1 = React.memo(ButtonListItem);
var KeyboardArrowLeft = {};
var hasRequiredKeyboardArrowLeft;
function requireKeyboardArrowLeft() {
  if (hasRequiredKeyboardArrowLeft) return KeyboardArrowLeft;
  hasRequiredKeyboardArrowLeft = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(KeyboardArrowLeft, "__esModule", {
    value: true
  });
  KeyboardArrowLeft.default = void 0;
  var _react = _interopRequireDefault(requireReact());
  var _createSvgIcon = _interopRequireDefault(/* @__PURE__ */ requireCreateSvgIcon());
  var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
    d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
  }), "KeyboardArrowLeft");
  KeyboardArrowLeft.default = _default;
  return KeyboardArrowLeft;
}
var KeyboardArrowLeftExports = /* @__PURE__ */ requireKeyboardArrowLeft();
const ArrowBackIcon = /* @__PURE__ */ getDefaultExportFromCjs$1(KeyboardArrowLeftExports);
function copyToClipboard(text) {
  return call(Messages.CopyToClipboard, text);
}
const useIsMobile = () => useMediaQuery("(max-width:600px)");
const useIsSmallMobile = () => useMediaQuery("(max-width:400px)");
function useClipboard() {
  const { showError, showNotification } = React.useContext(NotificationsContext);
  const { t: t2 } = useTranslation();
  return React.useMemo(
    () => ({
      async copyToClipboard(value, notificationMessage) {
        try {
          await copyToClipboard(value);
          const message = notificationMessage ? notificationMessage : t2("generic.user-interface.copied-to-clipboard");
          showNotification("info", message);
        } catch (error3) {
          showError(error3);
        }
      }
    }),
    [showError, showNotification, t2]
  );
}
function useDialogActions() {
  const [dialogActions, setDialogActions] = React.useState(null);
  const actionsRef = React.useMemo(
    () => ({
      element: dialogActions,
      update: setDialogActions
    }),
    [dialogActions]
  );
  return actionsRef;
}
function useRouter() {
  const routerContext = React.useContext(context);
  const [updateEnforcementState, setUpdateEnforcementState] = React.useState(0);
  const forceUpdate = () => setUpdateEnforcementState(updateEnforcementState + 1);
  if (!routerContext) {
    throw new Error("useRouter() hook can only be used within a react-router provider.");
  }
  React.useEffect(() => {
    const unsubscribe2 = routerContext.history.listen(() => forceUpdate());
    return unsubscribe2;
  }, [forceUpdate, routerContext]);
  return routerContext;
}
const removeNullValueProps = (object) => {
  return Object.keys(object).reduce((result, propKey) => {
    const propValue = object[propKey];
    return propValue !== null ? { ...result, [propKey]: propValue } : result;
  }, {});
};
const createSizingStyle = ({ width, height, minWidth, maxWidth, minHeight, maxHeight, padding }) => {
  return {
    padding,
    width,
    height,
    maxWidth,
    minWidth,
    maxHeight,
    minHeight
  };
};
const createFlexParentStyle = ({ alignItems, justifyContent, wrap }) => {
  if (justifyContent === "start") {
    justifyContent = "flex-start";
  }
  if (justifyContent === "end") {
    justifyContent = "flex-end";
  }
  if (alignItems === "start") {
    alignItems = "flex-start";
  }
  if (alignItems === "end") {
    alignItems = "flex-end";
  }
  return {
    alignItems,
    justifyContent,
    flexWrap: wrap
  };
};
const createFlexChildStyle = ({ alignSelf, basis, fixed, grow, order, shrink }) => {
  const style2 = {
    flexBasis: basis
  };
  if (typeof grow === "boolean") {
    style2.flexGrow = grow ? 1 : 0;
  }
  if (typeof grow === "number") {
    style2.flexGrow = grow;
  }
  if (typeof order !== "undefined") {
    style2.order = order;
  }
  if (typeof shrink === "boolean") {
    style2.flexShrink = shrink ? 1 : 0;
  }
  if (typeof shrink === "number") {
    style2.flexShrink = shrink;
  }
  if (fixed) {
    style2.flexGrow = 0;
    style2.flexShrink = 0;
  }
  if (alignSelf) {
    style2.alignSelf = alignSelf;
  }
  return style2;
};
function createTextStyle({ fontSize, fontWeight, textAlign }) {
  return {
    fontSize,
    fontWeight,
    textAlign
  };
}
const createBoxStyle = (styleProps) => {
  const { hidden = false, margin, overflow = "visible", overflowX, overflowY } = styleProps;
  const style2 = {
    boxSizing: "border-box",
    margin,
    overflow,
    overflowX,
    overflowY,
    ...hidden ? { display: "none" } : {},
    ...createSizingStyle(styleProps),
    ...createFlexParentStyle(styleProps),
    ...createFlexChildStyle(styleProps),
    ...createTextStyle(styleProps)
  };
  if (styleProps.display) {
    style2.display = styleProps.display;
  }
  if (styleProps.position) {
    style2.position = styleProps.position;
  }
  return removeNullValueProps(style2);
};
const Box = React.forwardRef(function Box2(props, ref2) {
  const { children, className, component, onClick, style: style2, ...styleProps } = props;
  const inlineStyle = { ...createBoxStyle(styleProps), ...style2 };
  const Component = component || "div";
  return /* @__PURE__ */ React.createElement(Component, { className, onClick, ref: ref2, style: inlineStyle }, children);
});
const HorizontalLayout = React.forwardRef(function HorizontalLayout2(props, ref2) {
  const { children, className, inline, style: style2, ...styleProps } = props;
  const effectiveStyle = {
    display: inline ? "inline-flex" : "flex",
    flexDirection: "row",
    width: "100%",
    ...createBoxStyle(styleProps),
    ...style2
  };
  return /* @__PURE__ */ React.createElement("div", { className, ref: ref2, style: effectiveStyle }, children);
});
const VerticalLayout = React.forwardRef(function VerticalLayout2(props, ref2) {
  const { children, className, inline, style: style2, ...styleProps } = props;
  const effectiveStyle = {
    display: inline ? "inline-flex" : "flex",
    flexDirection: "column",
    ...createBoxStyle(styleProps),
    ...style2
  };
  return /* @__PURE__ */ React.createElement("div", { className, ref: ref2, style: effectiveStyle }, children);
});
const BackButton = React.memo(function BackButton2(props) {
  const style2 = {
    padding: 6,
    fontSize: 32,
    ...props.style
  };
  return /* @__PURE__ */ React.createElement(IconButton$1, { color: "inherit", onClick: props.onClick, style: style2 }, /* @__PURE__ */ React.createElement(ArrowBackIcon, { style: { fontSize: 32 } }));
});
function MainTitle(props) {
  const isSmallScreen2 = useIsMobile();
  const isTitleOnSecondRow = isSmallScreen2 && props.actions && !props.hideBackButton;
  const backButtonStyle = React.useMemo(
    () => ({
      fontSize: 28,
      flexGrow: 0,
      flexShrink: 0,
      marginLeft: isSmallScreen2 ? -12 : -4,
      marginRight: 6
    }),
    [isSmallScreen2]
  );
  return /* @__PURE__ */ React.createElement(
    HorizontalLayout,
    {
      alignItems: "center",
      wrap: isSmallScreen2 && !props.nowrap ? props.hideBackButton ? "wrap-reverse" : "wrap" : "nowrap",
      style: { minHeight: isSmallScreen2 ? void 0 : 56, ...props.style }
    },
    props.hideBackButton ? null : /* @__PURE__ */ React.createElement(BackButton, { onClick: props.onBack, style: backButtonStyle }),
    /* @__PURE__ */ React.createElement(
      HorizontalLayout,
      {
        alignItems: "center",
        grow: isSmallScreen2 ? 1 : props.badges ? void 0 : 1,
        minWidth: isTitleOnSecondRow ? "100%" : void 0,
        maxWidth: "100%",
        order: isTitleOnSecondRow ? 4 : void 0
      },
      /* @__PURE__ */ React.createElement(
        Typography$1,
        {
          variant: "h5",
          color: props.titleColor,
          style: {
            flexGrow: 1,
            flexShrink: 1,
            fontSize: isSmallScreen2 ? 20 : 24,
            height: 48,
            lineHeight: "48px",
            marginRight: 12,
            minWidth: "40%",
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            ...props.titleStyle
          }
        },
        props.title
      ),
      props.badges
    ),
    /* @__PURE__ */ React.createElement(Box, { grow: Boolean(props.actions), style: { textAlign: "right" } }, props.actions)
  );
}
const storageKey = "sunce:favorites:mainnet";
const initialValues$1 = {
  savedAddresses: {},
  add: (address, label) => {
  },
  remove: (address) => {
  },
  bulkUpdate: (addresses) => {
  }
};
const SavedAddressesContext = React.createContext(initialValues$1);
function SavedAddressesProvider(props) {
  const [savedAddresses, setSavedAddresses] = React.useState(
    () => JSON.parse(localStorage.getItem(storageKey) || "{}")
  );
  const write = React.useCallback(
    (addresses) => localStorage.setItem(storageKey, JSON.stringify(addresses)),
    []
  );
  const bulkUpdate = React.useCallback(
    (addresses) => {
      write(addresses);
      setSavedAddresses(addresses);
    },
    [write]
  );
  const add = React.useCallback(
    (address, label) => {
      setSavedAddresses((addresses) => {
        const newAddresses = {
          ...addresses,
          [address]: { label }
        };
        write(newAddresses);
        return newAddresses;
      });
    },
    [write]
  );
  const remove3 = React.useCallback(
    (address) => {
      setSavedAddresses((addresses) => {
        const { [address]: _23, ...newAddresses } = addresses;
        write(newAddresses);
        return newAddresses;
      });
    },
    [write]
  );
  const context2 = {
    savedAddresses,
    add,
    remove: remove3,
    bulkUpdate
  };
  return /* @__PURE__ */ React.createElement(SavedAddressesContext.Provider, { value: context2 }, props.children);
}
function getDigitCounts(variant) {
  return variant === "short" ? {
    leading: 6,
    trailing: 6
  } : {
    leading: 4,
    trailing: 4
  };
}
function shortenName(name, intendedLength) {
  return name.length <= intendedLength ? name : name.substr(0, intendedLength - 3).trim() + "…" + name.substr(intendedLength - 3).substr(-3).trim();
}
const PublicKey = React.memo(function PublicKey2(props) {
  var _a;
  const { variant = "full" } = props;
  const digits = getDigitCounts(props.variant);
  const { accounts } = React.useContext(AccountsContext);
  const matchingLocalAccount = accounts.find(
    (account2) => account2.publicKey === props.publicKey && account2.testnet === props.testnet
  );
  const { savedAddresses } = React.useContext(SavedAddressesContext);
  const matchingSavedAccount = ((_a = savedAddresses[props.publicKey]) == null ? void 0 : _a.label) ? { name: savedAddresses[props.publicKey].label } : null;
  const matchedKnownAccount = matchingLocalAccount || matchingSavedAccount;
  const style2 = {
    display: "inline",
    fontSize: "inherit",
    fontWeight: "bold",
    userSelect: "text",
    WebkitUserSelect: "text",
    whiteSpace: variant !== "full" ? "pre" : void 0,
    ...props.style
  };
  if (props.publicKey.length !== 56) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, props.publicKey);
  } else if (!props.showRaw && matchedKnownAccount) {
    return /* @__PURE__ */ React.createElement(Typography$1, { component: "span", style: style2 }, matchedKnownAccount.name);
  } else {
    return /* @__PURE__ */ React.createElement(Typography$1, { component: "span", style: style2 }, props.variant === "full" || !props.variant ? props.publicKey : props.publicKey.substr(0, digits.leading) + "…" + props.publicKey.substr(-digits.trailing));
  }
});
const Address = React.memo(function Address2(props) {
  const { lookupStellarAddress } = useFederationLookup();
  const style2 = {
    userSelect: "text",
    WebkitUserSelect: "text",
    ...props.style
  };
  if (isPublicKey(props.address)) {
    const stellarAddress = lookupStellarAddress(props.address);
    if (stellarAddress) {
      const formattedStellarAddress = props.variant === "full" ? stellarAddress : shortenName(stellarAddress, props.variant === "shorter" ? 8 : 14);
      return /* @__PURE__ */ React.createElement("span", { style: style2 }, formattedStellarAddress, " (", /* @__PURE__ */ React.createElement(PublicKey, { publicKey: props.address, testnet: props.testnet, variant: "shorter" }), ")");
    } else {
      return /* @__PURE__ */ React.createElement(
        PublicKey,
        {
          publicKey: props.address,
          style: { fontWeight: "inherit" },
          testnet: props.testnet,
          variant: props.variant
        }
      );
    }
  } else {
    return props.variant === "short" ? /* @__PURE__ */ React.createElement("span", { style: style2 }, shortenName(props.address, 18)) : props.variant === "shorter" ? /* @__PURE__ */ React.createElement("span", { style: style2 }, shortenName(props.address, 14)) : /* @__PURE__ */ React.createElement("span", { style: style2 }, props.address);
  }
});
const ClickableAddress = React.memo(function ClickableAddress2(props) {
  return /* @__PURE__ */ React.createElement(ButtonBase$1, { onClick: props.onClick, style: { fontSize: "inherit", fontWeight: "inherit", textAlign: "inherit" } }, /* @__PURE__ */ React.createElement(Address, { ...props }), props.icon ? /* @__PURE__ */ React.createElement(React.Fragment, null, " ", props.icon) : null);
});
const CopyableAddress = React.memo(function CopyableAddress2(props) {
  const { onClick } = props;
  const clipboard = useClipboard();
  const handleClick = React.useCallback(() => {
    if (onClick) {
      onClick();
    }
    clipboard.copyToClipboard(props.address);
  }, [clipboard, onClick, props.address]);
  return /* @__PURE__ */ React.createElement(ClickableAddress, { ...props, onClick: handleClick });
});
var _Error = {};
var hasRequired_Error;
function require_Error() {
  if (hasRequired_Error) return _Error;
  hasRequired_Error = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(_Error, "__esModule", {
    value: true
  });
  _Error.default = void 0;
  var _react = _interopRequireDefault(requireReact());
  var _createSvgIcon = _interopRequireDefault(/* @__PURE__ */ requireCreateSvgIcon());
  var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"
  }), "Error");
  _Error.default = _default;
  return _Error;
}
var _ErrorExports = /* @__PURE__ */ require_Error();
const ErrorIcon = /* @__PURE__ */ getDefaultExportFromCjs$1(_ErrorExports);
const version = "1.4.1";
const pkg = {
  version
};
const buttonLabels = ["Oh no", "Drats!", "Nevermind", "Let's try this again", "Not my day"];
function ErrorBoundary(View) {
  return class ErrorComponent extends React.PureComponent {
    constructor() {
      super(...arguments);
      __publicField(this, "state", {
        error: null
      });
    }
    static getDerivedStateFromError(error3) {
      return { error: error3 };
    }
    componentDidCatch(error3, info) {
      console.error(`Component errored: ${error3.stack || error3}
${info.componentStack}`);
    }
    render() {
      const { error: error3 } = this.state;
      return error3 ? /* @__PURE__ */ React.createElement(View, { ...this.props, error: error3 }) : /* @__PURE__ */ React.createElement(React.Fragment, null, this.props.children);
    }
  };
}
const HideOnError = ErrorBoundary(function HideOnError2() {
  return /* @__PURE__ */ React.createElement(React.Fragment, null);
});
const InlineErrorBoundary = ErrorBoundary(function InlineErrorBoundary2(props) {
  const theme2 = useTheme();
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React.createElement(
    HorizontalLayout,
    {
      alignItems: "center",
      height: props.height,
      style: {
        background: fade(theme2.palette.error.main, 0.2),
        borderRadius: 8,
        color: theme2.palette.error.main,
        fontWeight: 600,
        padding: "8px 12px"
      }
    },
    /* @__PURE__ */ React.createElement(ErrorIcon, null),
    /* @__PURE__ */ React.createElement("span", { style: { marginLeft: 8 } }, getErrorTranslation(props.error, t2))
  );
});
const MainErrorBoundary = ErrorBoundary(function MainErrorBoundary2(props) {
  const refreshContent = React.useCallback(() => window.location.reload(), []);
  return /* @__PURE__ */ React.createElement(VerticalLayout, { alignItems: "center", grow: true, height: "100%", justifyContent: "center", padding: "40px", position: "relative" }, /* @__PURE__ */ React.createElement(Translation, null, (t2) => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Box, { textAlign: "center" }, /* @__PURE__ */ React.createElement(Typography$1, { variant: "h5" }, t2("generic.error.boundary.header")), /* @__PURE__ */ React.createElement(Typography$1, { style: { margin: "8px 0 24px", userSelect: "text" }, variant: "body2" }, getErrorTranslation(props.error, t2)), /* @__PURE__ */ React.createElement(Button$1, { color: "primary", onClick: refreshContent, variant: "contained" }, buttonLabels[Math.floor(Math.random() * buttonLabels.length)])), /* @__PURE__ */ React.createElement(Box, { style: { position: "absolute", bottom: 8, left: 0, width: "100%", opacity: 0.5 } }, /* @__PURE__ */ React.createElement(Typography$1, { align: "center", color: "textPrimary" }, t2("generic.error.boundary.contact-us"), " ", /* @__PURE__ */ React.createElement(
    "a",
    {
      href: "mailto:sunce@montelibero.org",
      style: { color: "inherit" },
      target: "_blank",
      rel: "noopener noreferrer"
    },
    "sunce@montelibero.org"
  )), /* @__PURE__ */ React.createElement(Typography$1, { align: "center", color: "textPrimary" }, "v", pkg.version)))));
});
function TopOfTopSection(props) {
  useIsMobile();
  {
    return null;
  }
}
function PageInset(props) {
  const isSmallScreen2 = useIsMobile();
  const padding = isSmallScreen2 ? "8px" : "8px 16px";
  return /* @__PURE__ */ React.createElement(Box, { padding, style: { position: "relative" } }, props.children);
}
const Section = React.memo(function Section2(props) {
  const background = props.brandColored ? primaryBackground : props.backgroundColor || "#fcfcfc";
  const isSmallScreen2 = useIsMobile();
  const padding = props.noPadding ? 0 : props.padding !== void 0 ? props.padding : 16;
  const style2 = {
    background,
    color: props.brandColored ? "black" : void 0,
    flexGrow: typeof props.grow === "number" ? props.grow : 1,
    flexShrink: typeof props.shrink === "number" ? props.shrink : void 0,
    minHeight: props.minHeight,
    overflowY: "hidden",
    position: "relative",
    zIndex: props.top ? void 0 : 1,
    ...props.style
  };
  const MaybeInset = props.pageInset ? PageInset : React.Fragment;
  return /* @__PURE__ */ React.createElement(Box, { ...props, component: "section", padding, style: style2 }, props.top ? /* @__PURE__ */ React.createElement(TopOfTopSection, { background }) : null, props.top && !isSmallScreen2 ? /* @__PURE__ */ React.createElement("div", { style: { width: "100%", padding: "4px 0 0", margin: 0 } }) : null, /* @__PURE__ */ React.createElement(MaybeInset, null, props.children));
});
const isRefStateObject = (thing) => thing && "element" in thing && typeof thing.update === "function";
function Background(props) {
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        opacity: 0.08,
        textAlign: "center",
        zIndex: -1
      }
    },
    props.children
  );
}
const useDialogBodyStyles = makeStyles$2({
  actions: {
    [MobileKeyboardOpenedSelector()]: {
      display: "none !important"
    }
  }
});
const topStyle = {
  flexGrow: 0,
  flexShrink: 0,
  position: "relative",
  width: "100%",
  zIndex: 1
};
function DialogBody(props) {
  const classes = useDialogBodyStyles();
  const isSmallScreen2 = useIsMobile();
  const actionsPosition = isSmallScreen2 ? "bottom" : props.actionsPosition || "after-content";
  const excessWidth = props.excessWidth || 0;
  const topContent = React.useMemo(() => props.top ? /* @__PURE__ */ React.createElement(Box, { style: topStyle }, props.top) : null, [props.top]);
  const actionsContent = React.useMemo(
    () => props.actions ? /* @__PURE__ */ React.createElement(
      Box,
      {
        basis: isSmallScreen2 && !props.preventActionsPlaceholder ? 80 : void 0,
        className: classes.actions,
        grow: 0,
        position: "relative",
        ref: isRefStateObject(props.actions) ? props.actions.update : void 0,
        shrink: 0,
        width: "100%"
      },
      isRefStateObject(props.actions) ? null : props.actions
    ) : null,
    [classes.actions, isSmallScreen2, props.actions, props.preventActionsPlaceholder]
  );
  const background = React.useMemo(
    () => props.background ? /* @__PURE__ */ React.createElement(Background, { opacity: 0.08 }, props.background) : null,
    [props.background]
  );
  return /* @__PURE__ */ React.createElement(MainErrorBoundary, null, /* @__PURE__ */ React.createElement(
    Section,
    {
      alignItems: "stretch",
      brandColored: props.brandColored,
      backgroundColor: props.backgroundColor,
      display: "flex",
      height: "100%",
      margin: "0 auto",
      maxWidth: props.noMaxWidth ? void 0 : 900,
      overflowX: "hidden",
      padding: isSmallScreen2 ? "12px 24px" : "24px 32px",
      style: { flexDirection: "column" },
      top: !props.preventNotchSpacing,
      width: "100%"
    },
    /* @__PURE__ */ React.createElement(React.Suspense, { fallback: /* @__PURE__ */ React.createElement(CircularProgress$1, { style: { alignSelf: "center", justifySelf: "center" } }) }, topContent, background, /* @__PURE__ */ React.createElement(
      VerticalLayout,
      {
        grow: props.fitToShrink ? 0 : 1,
        margin: `0 -${excessWidth}px`,
        maxHeight: "100%",
        overflowX: "hidden",
        overflowY: "auto",
        padding: `0 ${excessWidth}px`,
        position: "relative",
        shrink: true
      },
      props.children,
      actionsPosition === "after-content" ? actionsContent : null
    ), actionsPosition === "bottom" ? actionsContent : null)
  ));
}
const DialogBody$1 = React.memo(DialogBody);
var Close = {};
var hasRequiredClose;
function requireClose() {
  if (hasRequiredClose) return Close;
  hasRequiredClose = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(Close, "__esModule", {
    value: true
  });
  Close.default = void 0;
  var _react = _interopRequireDefault(requireReact());
  var _createSvgIcon = _interopRequireDefault(/* @__PURE__ */ requireCreateSvgIcon());
  var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
  }), "Close");
  Close.default = _default;
  return Close;
}
var CloseExports = /* @__PURE__ */ requireClose();
const CloseIcon = /* @__PURE__ */ getDefaultExportFromCjs$1(CloseExports);
var isUndefined = (val) => val === void 0;
var isNullOrUndefined = (value) => value === null || isUndefined(value);
var isArray = (value) => Array.isArray(value);
const isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);
var isHTMLElement = (value) => isObject(value) && value.nodeType === Node.ELEMENT_NODE;
const VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit"
};
const VALUE = "value";
const UNDEFINED = "undefined";
const EVENTS = {
  BLUR: "blur",
  CHANGE: "change",
  INPUT: "input"
};
const INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
const REGEX_IS_DEEP_PROP = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const REGEX_IS_PLAIN_PROP = /^\w*$/;
const REGEX_PROP_NAME = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
const REGEX_ESCAPE_CHAR = /\\(\\)?/g;
function attachEventListeners({ field, handleChange, isRadioOrCheckbox }) {
  const { ref: ref2 } = field;
  if (isHTMLElement(ref2) && ref2.addEventListener && handleChange) {
    ref2.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);
    ref2.addEventListener(EVENTS.BLUR, handleChange);
  }
}
var isKey = (value) => !isArray(value) && (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));
var stringToPath = (string2) => {
  const result = [];
  string2.replace(REGEX_PROP_NAME, (match, number, quote, string3) => {
    result.push(quote ? string3.replace(REGEX_ESCAPE_CHAR, "$1") : number || match);
  });
  return result;
};
function set(object, path2, value) {
  let index2 = -1;
  const tempPath = isKey(path2) ? [path2] : stringToPath(path2);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index2 < length) {
    const key2 = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key2];
      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(tempPath[index2 + 1]) ? [] : {};
    }
    object[key2] = newValue;
    object = object[key2];
  }
  return object;
}
var transformToNestObject = (data) => Object.entries(data).reduce((previous, [key2, value]) => {
  if (!isKey(key2)) {
    set(previous, key2, value);
    return previous;
  }
  return Object.assign(Object.assign({}, previous), { [key2]: value });
}, {});
var get = (obj, path2, defaultValue) => {
  const result = path2.split(/[,[\].]+?/).filter(Boolean).reduce((result2, key2) => isNullOrUndefined(result2) ? result2 : result2[key2], obj);
  return isUndefined(result) || result === obj ? obj[path2] || defaultValue : result;
};
var focusErrorField = (fields, fieldErrors) => {
  for (const key2 in fields) {
    if (get(fieldErrors, key2)) {
      const field = fields[key2];
      if (field) {
        if (isHTMLElement(field.ref) && field.ref.focus) {
          field.ref.focus();
          break;
        } else if (field.options) {
          field.options[0].ref.focus();
          break;
        }
      }
    }
  }
};
var removeAllEventListeners = (ref2, validateWithStateUpdate) => {
  if (isHTMLElement(ref2) && ref2.removeEventListener) {
    ref2.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);
    ref2.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);
    ref2.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);
  }
};
var isRadioInput = (element) => !!element && element.type === "radio";
var isCheckBoxInput = (element) => !!element && element.type === "checkbox";
function isDetached(element) {
  if (!element) {
    return true;
  }
  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {
    return false;
  }
  return isDetached(element.parentNode);
}
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}
function baseGet(object, path2) {
  const updatePath = isKey(path2) ? [path2] : castPath(path2);
  const length = path2.length;
  let index2 = 0;
  while (index2 < length) {
    object = isUndefined(object) ? index2++ : object[updatePath[index2++]];
  }
  return index2 == length ? object : void 0;
}
function baseSlice(array2, start, end) {
  let index2 = -1;
  let length = array2.length;
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start;
  const result = Array(length);
  while (++index2 < length) {
    result[index2] = array2[index2 + start];
  }
  return result;
}
function parent(object, path2) {
  return path2.length == 1 ? object : baseGet(object, baseSlice(path2, 0, -1));
}
function baseUnset(object, path2) {
  const updatePath = isKey(path2) ? [path2] : castPath(path2);
  const childObject = parent(object, updatePath);
  const key2 = updatePath[updatePath.length - 1];
  const result = !(childObject != null) || delete childObject[key2];
  let previousObjRef = void 0;
  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {
    let index2 = -1;
    let objectRef = void 0;
    const currentPaths = updatePath.slice(0, -(k + 1));
    const currentPathsLength = currentPaths.length - 1;
    if (k > 0) {
      previousObjRef = object;
    }
    while (++index2 < currentPaths.length) {
      const item = currentPaths[index2];
      objectRef = objectRef ? objectRef[item] : object[item];
      if (currentPathsLength === index2) {
        if (isObject(objectRef) && isEmptyObject(objectRef)) {
          previousObjRef ? delete previousObjRef[item] : delete object[item];
        } else if (isArray(objectRef) && !objectRef.filter((data) => isObject(data) && !isEmptyObject(data)).length) {
          if (previousObjRef) {
            delete previousObjRef[item];
          }
        }
      }
      previousObjRef = objectRef;
    }
  }
  return result;
}
function unset(object, paths) {
  paths.forEach((path2) => {
    baseUnset(object, path2);
  });
  return object;
}
function findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {
  if (!field) {
    return;
  }
  const { ref: ref2, ref: { name, type: type2 }, mutationWatcher } = field;
  if (!type2) {
    delete fields[name];
    return;
  }
  const fieldValue = fields[name];
  if ((isRadioInput(ref2) || isCheckBoxInput(ref2)) && fieldValue) {
    const { options: options2 } = fieldValue;
    if (isArray(options2) && options2.length) {
      options2.forEach(({ ref: ref3, mutationWatcher: mutationWatcher2 }, index2) => {
        if (ref3 && isDetached(ref3) || forceDelete) {
          removeAllEventListeners(ref3, handleChange);
          if (mutationWatcher2) {
            mutationWatcher2.disconnect();
          }
          unset(options2, [`[${index2}]`]);
        }
      });
      if (options2 && !options2.filter(Boolean).length) {
        delete fields[name];
      }
    } else {
      delete fields[name];
    }
  } else if (isDetached(ref2) || forceDelete) {
    removeAllEventListeners(ref2, handleChange);
    if (mutationWatcher) {
      mutationWatcher.disconnect();
    }
    delete fields[name];
  }
}
const defaultReturn = {
  isValid: false,
  value: ""
};
var getRadioValue = (options2) => isArray(options2) ? options2.reduce((previous, { ref: { checked, value } }) => checked ? {
  isValid: true,
  value
} : previous, defaultReturn) : defaultReturn;
var getMultipleSelectValue = (options2) => [...options2].filter(({ selected }) => selected).map(({ value }) => value);
var isFileInput = (element) => !!element && element.type === "file";
var isMultipleSelect = (element) => !!element && element.type === "select-multiple";
var isEmptyString = (value) => value === "";
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options2) => {
  if (isArray(options2)) {
    if (options2.length > 1) {
      const values2 = options2.filter(({ ref: { checked: checked2 } }) => checked2).map(({ ref: { value: value2 } }) => value2);
      return { value: values2, isValid: !!values2.length };
    }
    const { checked, value, attributes } = options2[0].ref;
    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || isEmptyString(value) ? validResult : { value, isValid: true } : validResult : defaultResult;
  }
  return defaultResult;
};
function getFieldValue(fields, ref2) {
  const { name, value } = ref2;
  const field = fields[name];
  if (isFileInput(ref2)) {
    return ref2.files;
  }
  if (isRadioInput(ref2)) {
    return field ? getRadioValue(field.options).value : "";
  }
  if (isMultipleSelect(ref2)) {
    return getMultipleSelectValue(ref2.options);
  }
  if (isCheckBoxInput(ref2)) {
    return field ? getCheckboxValue(field.options).value : false;
  }
  return value;
}
var isString = (value) => typeof value === "string";
var getFieldsValues = (fields, search) => {
  const output2 = {};
  const isSearchString = isString(search);
  const isSearchArray = isArray(search);
  const isNest = search && search.nest;
  for (const name in fields) {
    if (isUndefined(search) || isNest || isSearchString && name.startsWith(search) || isSearchArray && search.find((data) => name.startsWith(data))) {
      output2[name] = getFieldValue(fields, fields[name].ref);
    }
  }
  return output2;
};
var compareObject = (objectA = {}, objectB = {}) => Object.entries(objectA).reduce((previous, [key2, value]) => previous ? objectB[key2] && objectB[key2] === value : false, true);
var isSameError = (error3, { type: type2, types: types2, message }) => {
  return isObject(error3) && error3.type === type2 && error3.message === message && compareObject(error3.types, types2);
};
function shouldUpdateWithError({ errors: errors2, name, error: error3, validFields, fieldsWithValidation }) {
  const isFieldValid = isEmptyObject(error3);
  const isFormValid = isEmptyObject(errors2);
  const currentFieldError = get(error3, name);
  const existFieldError = get(errors2, name);
  if (isFieldValid && validFields.has(name) || existFieldError && existFieldError.isManual) {
    return false;
  }
  if (isFormValid !== isFieldValid || !isFormValid && !existFieldError || isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name)) {
    return true;
  }
  return currentFieldError && !isSameError(existFieldError, currentFieldError);
}
var isRegex = (value) => value instanceof RegExp;
var getValueAndMessage = (validationData) => {
  const isPureObject = isObject(validationData) && !isRegex(validationData);
  return {
    value: isPureObject ? validationData.value : validationData,
    message: isPureObject ? validationData.message : ""
  };
};
var isFunction = (value) => typeof value === "function";
var isBoolean = (value) => typeof value === "boolean";
function getValidateError(result, ref2, type2 = "validate") {
  const isStringValue = isString(result);
  if (isStringValue || isBoolean(result) && !result) {
    const message = isStringValue ? result : "";
    return {
      type: type2,
      message,
      ref: ref2
    };
  }
}
var appendErrors = (name, validateAllFieldCriteria, errors2, type2, message) => {
  if (!validateAllFieldCriteria) {
    return {};
  }
  const error3 = errors2[name];
  return Object.assign(Object.assign({}, error3), { types: Object.assign(Object.assign({}, error3 && error3.types ? error3.types : {}), { [type2]: message || true }) });
};
var validateField = async (fieldsRef, validateAllFieldCriteria, { ref: ref2, ref: { type: type2, value, name }, options: options2, required, maxLength, minLength, min: min2, max: max2, pattern, validate }) => {
  const fields = fieldsRef.current;
  const error3 = {};
  const isRadio = isRadioInput(ref2);
  const isCheckBox = isCheckBoxInput(ref2);
  const isRadioOrCheckbox = isRadio || isCheckBox;
  const isEmpty2 = isEmptyString(value);
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error3);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error3[name] = Object.assign({
      type: exceedMax ? maxType : minType,
      message,
      ref: ref2
    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));
    if (!validateAllFieldCriteria) {
      return error3;
    }
  };
  if (required && (!isRadio && !isCheckBox && (isEmpty2 || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options2).isValid || isRadio && !getRadioValue(options2).isValid)) {
    const { value: requiredValue, message: requiredMessage } = isString(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (requiredValue) {
      error3[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox ? fields[name].options[0].ref : ref2 }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));
      if (!validateAllFieldCriteria) {
        return error3;
      }
    }
  }
  if (!isNullOrUndefined(min2) || !isNullOrUndefined(max2)) {
    let exceedMax;
    let exceedMin;
    const { value: maxValue, message: maxMessage } = getValueAndMessage(max2);
    const { value: minValue, message: minMessage } = getValueAndMessage(min2);
    if (type2 === "number" || !type2 && !isNaN(value)) {
      const valueNumber = ref2.valueAsNumber || parseFloat(value);
      if (!isNullOrUndefined(maxValue)) {
        exceedMax = valueNumber > maxValue;
      }
      if (!isNullOrUndefined(minValue)) {
        exceedMin = valueNumber < minValue;
      }
    } else {
      const valueDate = ref2.valueAsDate || new Date(value);
      if (isString(maxValue)) {
        exceedMax = valueDate > new Date(maxValue);
      }
      if (isString(minValue)) {
        exceedMin = valueDate < new Date(minValue);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        return error3;
      }
    }
  }
  if (isString(value) && !isEmpty2 && (maxLength || minLength)) {
    const { value: maxLengthValue, message: maxLengthMessage } = getValueAndMessage(maxLength);
    const { value: minLengthValue, message: minLengthMessage } = getValueAndMessage(minLength);
    const inputLength = value.toString().length;
    const exceedMax = maxLength && inputLength > maxLengthValue;
    const exceedMin = minLength && inputLength < minLengthValue;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);
      if (!validateAllFieldCriteria) {
        return error3;
      }
    }
  }
  if (pattern && !isEmpty2) {
    const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !patternValue.test(value)) {
      error3[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref: ref2 }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));
      if (!validateAllFieldCriteria) {
        return error3;
      }
    }
  }
  if (validate) {
    const fieldValue = getFieldValue(fields, ref2);
    const validateRef = isRadioOrCheckbox && options2 ? options2[0].ref : ref2;
    if (isFunction(validate)) {
      const result = await validate(fieldValue);
      const validateError = getValidateError(result, validateRef);
      if (validateError) {
        error3[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));
        if (!validateAllFieldCriteria) {
          return error3;
        }
      }
    } else if (isObject(validate)) {
      const validateFunctions = Object.entries(validate);
      const validationResult = await new Promise((resolve2) => {
        validateFunctions.reduce(async (previous, [key2, validate2], index2) => {
          if (!isEmptyObject(await previous) && !validateAllFieldCriteria || !isFunction(validate2)) {
            return resolve2(previous);
          }
          let result;
          const validateResult = await validate2(fieldValue);
          const validateError = getValidateError(validateResult, validateRef, key2);
          if (validateError) {
            result = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key2, validateError.message));
            if (validateAllFieldCriteria) {
              error3[name] = result;
            }
          } else {
            result = previous;
          }
          return validateFunctions.length - 1 === index2 ? resolve2(result) : result;
        }, {});
      });
      if (!isEmptyObject(validationResult)) {
        error3[name] = Object.assign({ ref: validateRef }, validationResult);
        if (!validateAllFieldCriteria) {
          return error3;
        }
      }
    }
  }
  return error3;
};
const parseErrorSchema = (error3, validateAllFieldCriteria) => isArray(error3.inner) ? error3.inner.reduce((previous, { path: path2, message, type: type2 }) => Object.assign(Object.assign({}, previous), previous[path2] && validateAllFieldCriteria ? {
  [path2]: appendErrors(path2, validateAllFieldCriteria, previous, type2, message)
} : {
  [path2]: previous[path2] || Object.assign({
    message,
    type: type2
  }, validateAllFieldCriteria ? {
    types: { [type2]: message || true }
  } : {})
}), {}) : {
  [error3.path]: { message: error3.message, type: error3.type }
};
async function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context2) {
  if (validationResolver) {
    return validationResolver(data, context2);
  }
  try {
    return {
      values: await validationSchema.validate(data, {
        abortEarly: false,
        context: context2
      }),
      errors: {}
    };
  } catch (e) {
    return {
      values: {},
      errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria))
    };
  }
}
var getDefaultValue = (defaultValues, name, defaultValue) => isUndefined(defaultValues[name]) ? get(defaultValues, name, defaultValue) : defaultValues[name];
function flatArray(list) {
  return list.reduce((a, b) => a.concat(isArray(b) ? flatArray(b) : b), []);
}
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
const getPath = (path2, values2) => {
  const getInnerPath = (value, key2, isObject2) => {
    const pathWithIndex = isObject2 ? `${path2}.${key2}` : `${path2}[${key2}]`;
    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);
  };
  return isArray(values2) ? values2.map((value, key2) => getInnerPath(value, key2)) : Object.entries(values2).map(([key2, value]) => getInnerPath(value, key2, true));
};
var getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));
var assignWatchFields = (fieldValues, fieldName, watchFields, combinedDefaultValues, watchFieldArray) => {
  let value;
  watchFields.add(fieldName);
  if (isEmptyObject(fieldValues)) {
    value = watchFieldArray ? watchFieldArray : void 0;
  } else if (!isUndefined(fieldValues[fieldName])) {
    value = fieldValues[fieldName];
    watchFields.add(fieldName);
  } else {
    value = get(transformToNestObject(fieldValues), fieldName);
    if (isArray(watchFieldArray) && isArray(value) && value.length !== watchFieldArray.length) {
      value = watchFieldArray;
    }
    if (!isUndefined(value)) {
      getPath$1(fieldName, value).forEach((name) => watchFields.add(name));
    }
  }
  return isUndefined(value) ? isObject(combinedDefaultValues) ? getDefaultValue(combinedDefaultValues, fieldName) : combinedDefaultValues : value;
};
var skipValidation = ({ hasError, isBlurEvent, isOnSubmit, isReValidateOnSubmit, isOnBlur, isReValidateOnBlur, isSubmitted }) => isOnSubmit && isReValidateOnSubmit || isOnSubmit && !isSubmitted || isOnBlur && !isBlurEvent && !hasError || isReValidateOnBlur && !isBlurEvent && hasError || isReValidateOnSubmit && isSubmitted;
var getFieldValueByName = (fields, name) => {
  const results = transformToNestObject(getFieldsValues(fields));
  return name ? get(results, name, results) : results;
};
function getIsFieldsDifferent(referenceArray, differenceArray) {
  let isMatch = false;
  if (!isArray(referenceArray) || !isArray(differenceArray) || referenceArray.length !== differenceArray.length) {
    return true;
  }
  for (let i2 = 0; i2 < referenceArray.length; i2++) {
    if (isMatch) {
      break;
    }
    const dataA = referenceArray[i2];
    const dataB = differenceArray[i2];
    if (isUndefined(dataB) || Object.keys(dataA).length !== Object.keys(dataB).length) {
      isMatch = true;
      break;
    }
    for (const key2 in dataA) {
      if (dataA[key2] !== dataB[key2]) {
        isMatch = true;
        break;
      }
    }
  }
  return isMatch;
}
const isMatchFieldArrayName = (name, searchName) => name.startsWith(`${searchName}[`);
var isNameInFieldArray = (names, name) => [...names].reduce((prev, current) => isMatchFieldArrayName(name, current) ? true : prev, false);
var isFileListObject = (data) => typeof FileList !== UNDEFINED && data instanceof FileList;
function onDomRemove(element, onDetachCallback) {
  const observer = new MutationObserver(() => {
    if (isDetached(element)) {
      observer.disconnect();
      onDetachCallback();
    }
  });
  observer.observe(window.document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var modeChecker = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange
});
const { useRef, useState, useCallback, useEffect } = React$1;
function useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, validationResolver, validationContext, defaultValues = {}, submitFocusError = true, validateCriteriaMode } = {}) {
  const fieldsRef = useRef({});
  const validateAllFieldCriteria = validateCriteriaMode === "all";
  const errorsRef = useRef({});
  const touchedFieldsRef = useRef({});
  const watchFieldArrayRef = useRef({});
  const watchFieldsRef = useRef(/* @__PURE__ */ new Set());
  const dirtyFieldsRef = useRef(/* @__PURE__ */ new Set());
  const fieldsWithValidationRef = useRef(/* @__PURE__ */ new Set());
  const validFieldsRef = useRef(/* @__PURE__ */ new Set());
  const isValidRef = useRef(true);
  const defaultRenderValuesRef = useRef({});
  const defaultValuesRef = useRef(defaultValues);
  const isUnMount = useRef(false);
  const isWatchAllRef = useRef(false);
  const isSubmittedRef = useRef(false);
  const isDirtyRef = useRef(false);
  const submitCountRef = useRef(0);
  const isSubmittingRef = useRef(false);
  const handleChangeRef = useRef();
  const resetFieldArrayFunctionRef = useRef({});
  const validationContextRef = useRef(validationContext);
  const fieldArrayNamesRef = useRef(/* @__PURE__ */ new Set());
  const [, render] = useState();
  const { isOnBlur, isOnSubmit } = useRef(modeChecker(mode)).current;
  const isWindowUndefined = typeof window === UNDEFINED;
  const shouldValidateCallback = !!(validationSchema || validationResolver);
  const isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);
  const isProxyEnabled = isWeb && "Proxy" in window;
  const readFormStateRef = useRef({
    dirty: !isProxyEnabled,
    dirtyFields: !isProxyEnabled,
    isSubmitted: isOnSubmit,
    submitCount: !isProxyEnabled,
    touched: !isProxyEnabled,
    isSubmitting: !isProxyEnabled,
    isValid: !isProxyEnabled
  });
  const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit } = useRef(modeChecker(reValidateMode)).current;
  const reRender = useCallback(() => {
    if (!isUnMount.current) {
      render({});
    }
  }, []);
  const shouldRenderBaseOnError = useCallback((name, error3, shouldRender, skipReRender) => {
    let shouldReRender = shouldRender || shouldUpdateWithError({
      errors: errorsRef.current,
      error: error3,
      name,
      validFields: validFieldsRef.current,
      fieldsWithValidation: fieldsWithValidationRef.current
    });
    if (isEmptyObject(error3)) {
      if (fieldsWithValidationRef.current.has(name) || shouldValidateCallback) {
        validFieldsRef.current.add(name);
        shouldReRender = shouldReRender || get(errorsRef.current, name);
      }
      errorsRef.current = unset(errorsRef.current, [name]);
    } else {
      validFieldsRef.current.delete(name);
      shouldReRender = shouldReRender || !get(errorsRef.current, name);
      set(errorsRef.current, name, error3[name]);
    }
    if (shouldReRender && !skipReRender) {
      reRender();
      return true;
    }
  }, [reRender, shouldValidateCallback]);
  const setFieldValue = useCallback((field, rawValue) => {
    const ref2 = field.ref;
    const options2 = field.options;
    const { type: type2 } = ref2;
    const value = isWeb && isHTMLElement(ref2) && isNullOrUndefined(rawValue) ? "" : rawValue;
    if (isRadioInput(ref2) && options2) {
      options2.forEach(({ ref: radioRef }) => radioRef.checked = radioRef.value === value);
    } else if (isFileInput(ref2)) {
      if (isEmptyString(value) || isFileListObject(value)) {
        ref2.files = value;
      } else {
        ref2.value = value;
      }
    } else if (isMultipleSelect(ref2)) {
      [...ref2.options].forEach((selectRef) => selectRef.selected = value.includes(selectRef.value));
    } else if (isCheckBoxInput(ref2) && options2) {
      options2.length > 1 ? options2.forEach(({ ref: checkboxRef }) => checkboxRef.checked = value.includes(checkboxRef.value)) : options2[0].ref.checked = !!value;
    } else {
      ref2.value = value;
    }
    return !!type2;
  }, [isWeb]);
  const setDirty = (name) => {
    if (!fieldsRef.current[name] || !readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields) {
      return false;
    }
    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);
    const previousDirtyFieldsLength = dirtyFieldsRef.current.size;
    let isDirty = defaultRenderValuesRef.current[name] !== getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);
    if (isFieldArray) {
      const fieldArrayName = name.substring(0, name.indexOf("["));
      isDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));
    }
    const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !== isDirty;
    if (isDirty) {
      dirtyFieldsRef.current.add(name);
    } else {
      dirtyFieldsRef.current.delete(name);
    }
    isDirtyRef.current = isFieldArray ? isDirty : !!dirtyFieldsRef.current.size;
    return readFormStateRef.current.dirty ? isDirtyChanged : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;
  };
  const setDirtyAndTouchedFields = useCallback((fieldName) => {
    if (setDirty(fieldName) || !get(touchedFieldsRef.current, fieldName) && readFormStateRef.current.touched) {
      return !!set(touchedFieldsRef.current, fieldName, true);
    }
  }, []);
  const setInternalValueBatch = useCallback((name, value, parentFieldName) => {
    const isValueArray = isArray(value);
    for (const key2 in value) {
      const fieldName = `${parentFieldName || name}${isValueArray ? `[${key2}]` : `.${key2}`}`;
      if (isObject(value[key2])) {
        setInternalValueBatch(name, value[key2], fieldName);
      }
      const field = fieldsRef.current[fieldName];
      if (field) {
        setFieldValue(field, value[key2]);
        setDirtyAndTouchedFields(fieldName);
      }
    }
  }, [setFieldValue, setDirtyAndTouchedFields]);
  const setInternalValue = useCallback((name, value) => {
    const field = fieldsRef.current[name];
    if (field) {
      setFieldValue(field, value);
      const output2 = setDirtyAndTouchedFields(name);
      if (isBoolean(output2)) {
        return output2;
      }
    } else if (!isPrimitive(value)) {
      setInternalValueBatch(name, value);
    }
  }, [setDirtyAndTouchedFields, setFieldValue, setInternalValueBatch]);
  const executeValidation = useCallback(async (name, skipReRender) => {
    const field = fieldsRef.current[name];
    if (!field) {
      return false;
    }
    const error3 = await validateField(fieldsRef, validateAllFieldCriteria, field);
    shouldRenderBaseOnError(name, error3, false, skipReRender);
    return isEmptyObject(error3);
  }, [shouldRenderBaseOnError, validateAllFieldCriteria]);
  const executeSchemaValidation = useCallback(async (payload) => {
    const { errors: errors2 } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);
    const previousFormIsValid = isValidRef.current;
    isValidRef.current = isEmptyObject(errors2);
    if (isArray(payload)) {
      payload.forEach((name) => {
        const error3 = get(errors2, name);
        if (error3) {
          set(errorsRef.current, name, error3);
        } else {
          unset(errorsRef.current, [name]);
        }
      });
      reRender();
    } else {
      shouldRenderBaseOnError(payload, get(errors2, payload) ? { [payload]: get(errors2, payload) } : {}, previousFormIsValid !== isValidRef.current);
    }
    return isEmptyObject(errorsRef.current);
  }, [
    reRender,
    shouldRenderBaseOnError,
    validateAllFieldCriteria,
    validationResolver,
    validationSchema
  ]);
  const triggerValidation = useCallback(async (payload) => {
    const fields = payload || Object.keys(fieldsRef.current);
    if (shouldValidateCallback) {
      return executeSchemaValidation(fields);
    }
    if (isArray(fields)) {
      const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));
      reRender();
      return result.every(Boolean);
    }
    return await executeValidation(fields);
  }, [
    executeSchemaValidation,
    executeValidation,
    reRender,
    shouldValidateCallback
  ]);
  const isFieldWatched = (name) => {
    const preFixName = (name.match(/\w+/) || [])[0];
    return isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has(preFixName) && !isKey(name) && fieldArrayNamesRef.current.has(preFixName);
  };
  function setValue(names, valueOrShouldValidate, shouldValidate) {
    let shouldRender = false;
    const isMultiple = isArray(names);
    (isMultiple ? names : [names]).forEach((name) => {
      const isStringFieldName = isString(name);
      shouldRender = setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName ? valueOrShouldValidate : Object.values(name)[0]) || isMultiple ? true : isFieldWatched(name);
    });
    if (shouldRender || isMultiple) {
      reRender();
    }
    if (shouldValidate || isMultiple && valueOrShouldValidate) {
      triggerValidation(isMultiple ? void 0 : names);
    }
  }
  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async ({ type: type2, target }) => {
    const name = target ? target.name : "";
    const fields = fieldsRef.current;
    const errors2 = errorsRef.current;
    const field = fields[name];
    const currentError = get(errors2, name);
    let error3;
    if (!field) {
      return;
    }
    const isBlurEvent = type2 === EVENTS.BLUR;
    const shouldSkipValidation = skipValidation({
      hasError: !!currentError,
      isBlurEvent,
      isOnSubmit,
      isReValidateOnSubmit,
      isOnBlur,
      isReValidateOnBlur,
      isSubmitted: isSubmittedRef.current
    });
    const shouldUpdateDirty = setDirty(name);
    let shouldUpdateState = isFieldWatched(name) || shouldUpdateDirty;
    if (isBlurEvent && !get(touchedFieldsRef.current, name) && readFormStateRef.current.touched) {
      set(touchedFieldsRef.current, name, true);
      shouldUpdateState = true;
    }
    if (shouldSkipValidation) {
      return shouldUpdateState && reRender();
    }
    if (shouldValidateCallback) {
      const { errors: errors3 } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);
      const previousFormIsValid = isValidRef.current;
      isValidRef.current = isEmptyObject(errors3);
      error3 = get(errors3, name) ? { [name]: get(errors3, name) } : {};
      if (previousFormIsValid !== isValidRef.current) {
        shouldUpdateState = true;
      }
    } else {
      error3 = await validateField(fieldsRef, validateAllFieldCriteria, field);
    }
    if (!shouldRenderBaseOnError(name, error3) && shouldUpdateState) {
      reRender();
    }
  };
  const validateSchemaIsValid = useCallback(
    (values2 = {}) => {
      const fieldValues = isEmptyObject(defaultValuesRef.current) ? getFieldsValues(fieldsRef.current) : defaultValuesRef.current;
      validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values2)), validationResolver, validationContextRef.current).then(({ errors: errors2 }) => {
        const previousFormIsValid = isValidRef.current;
        isValidRef.current = isEmptyObject(errors2);
        if (previousFormIsValid !== isValidRef.current) {
          reRender();
        }
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [reRender, validateAllFieldCriteria, validationResolver]
  );
  const removeFieldEventListener = (field, forceDelete) => {
    if (!isUndefined(handleChangeRef.current) && field) {
      findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);
    }
  };
  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {
    if (!field || field && isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) && !forceDelete) {
      return;
    }
    removeFieldEventListener(field, forceDelete);
    const { name } = field.ref;
    errorsRef.current = unset(errorsRef.current, [name]);
    touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);
    defaultRenderValuesRef.current = unset(defaultRenderValuesRef.current, [
      name
    ]);
    [
      dirtyFieldsRef,
      fieldsWithValidationRef,
      validFieldsRef,
      watchFieldsRef
    ].forEach((data) => data.current.delete(name));
    if (readFormStateRef.current.isValid || readFormStateRef.current.touched) {
      reRender();
      if (shouldValidateCallback) {
        validateSchemaIsValid();
      }
    }
  }, [reRender, shouldValidateCallback, validateSchemaIsValid]);
  function clearError(name) {
    if (isUndefined(name)) {
      errorsRef.current = {};
    } else {
      unset(errorsRef.current, isArray(name) ? name : [name]);
    }
    reRender();
  }
  const setInternalError = ({ name, type: type2, types: types2, message, preventRender }) => {
    const field = fieldsRef.current[name];
    if (!isSameError(errorsRef.current[name], {
      type: type2,
      message,
      types: types2
    })) {
      set(errorsRef.current, name, {
        type: type2,
        types: types2,
        message,
        ref: field ? field.ref : {},
        isManual: true
      });
      if (!preventRender) {
        reRender();
      }
    }
  };
  function setError(name, type2 = "", message) {
    if (isString(name)) {
      setInternalError(Object.assign({ name }, isObject(type2) ? {
        types: type2,
        type: ""
      } : {
        type: type2,
        message
      }));
    } else if (isArray(name)) {
      name.forEach((error3) => setInternalError(Object.assign(Object.assign({}, error3), { preventRender: true })));
      reRender();
    }
  }
  function watch(fieldNames, defaultValue) {
    const combinedDefaultValues = isUndefined(defaultValue) ? isUndefined(defaultValuesRef.current) ? {} : defaultValuesRef.current : defaultValue;
    const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);
    const watchFields = watchFieldsRef.current;
    if (isString(fieldNames)) {
      return assignWatchFields(fieldValues, fieldNames, watchFields, combinedDefaultValues, fieldArrayNamesRef.current.has(fieldNames) ? watchFieldArrayRef.current[fieldNames] : void 0);
    }
    if (isArray(fieldNames)) {
      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) }), {});
    }
    isWatchAllRef.current = true;
    const result = !isEmptyObject(fieldValues) && fieldValues || defaultValue || defaultValuesRef.current;
    return fieldNames && fieldNames.nest ? transformToNestObject(result) : result;
  }
  function unregister(names) {
    if (!isEmptyObject(fieldsRef.current)) {
      (isArray(names) ? names : [names]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));
    }
  }
  function registerFieldsRef(ref2, validateOptions = {}) {
    if (!ref2.name) {
      return console.warn("Missing name @", ref2);
    }
    const { name, type: type2, value } = ref2;
    const fieldAttributes = Object.assign({ ref: ref2 }, validateOptions);
    const fields = fieldsRef.current;
    const isRadioOrCheckbox = isRadioInput(ref2) || isCheckBoxInput(ref2);
    let currentField = fields[name];
    let isEmptyDefaultValue = true;
    let isFieldArray = false;
    let defaultValue;
    if (isRadioOrCheckbox ? currentField && isArray(currentField.options) && currentField.options.find(({ ref: ref3 }) => value === ref3.value) : currentField) {
      fields[name] = Object.assign(Object.assign({}, currentField), validateOptions);
      return;
    }
    if (type2) {
      const mutationWatcher = onDomRemove(ref2, () => removeFieldEventListenerAndRef(fieldAttributes));
      currentField = isRadioOrCheckbox ? Object.assign({ options: [
        ...currentField && currentField.options || [],
        {
          ref: ref2,
          mutationWatcher
        }
      ], ref: { type: type2, name } }, validateOptions) : Object.assign(Object.assign({}, fieldAttributes), { mutationWatcher });
    } else {
      currentField = fieldAttributes;
    }
    fields[name] = currentField;
    if (!isEmptyObject(defaultValuesRef.current)) {
      defaultValue = getDefaultValue(defaultValuesRef.current, name);
      isEmptyDefaultValue = isUndefined(defaultValue);
      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);
      if (!isEmptyDefaultValue && !isFieldArray) {
        setFieldValue(currentField, defaultValue);
      }
    }
    if (shouldValidateCallback && !isFieldArray && readFormStateRef.current.isValid) {
      validateSchemaIsValid();
    } else if (!isEmptyObject(validateOptions)) {
      fieldsWithValidationRef.current.add(name);
      if (!isOnSubmit && readFormStateRef.current.isValid) {
        validateField(fieldsRef, validateAllFieldCriteria, currentField).then((error3) => {
          const previousFormIsValid = isValidRef.current;
          if (isEmptyObject(error3)) {
            validFieldsRef.current.add(name);
          } else {
            isValidRef.current = false;
          }
          if (previousFormIsValid !== isValidRef.current) {
            reRender();
          }
        });
      }
    }
    if (!defaultRenderValuesRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {
      defaultRenderValuesRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, currentField.ref) : defaultValue;
    }
    if (!type2) {
      return;
    }
    const fieldToAttachListener = isRadioOrCheckbox && currentField.options ? currentField.options[currentField.options.length - 1] : currentField;
    attachEventListeners({
      field: fieldToAttachListener,
      isRadioOrCheckbox,
      handleChange: handleChangeRef.current
    });
  }
  function register2(refOrValidationOptions, validationOptions) {
    if (isWindowUndefined) {
      return;
    }
    if (isString(refOrValidationOptions)) {
      registerFieldsRef({ name: refOrValidationOptions }, validationOptions);
      return;
    }
    if (isObject(refOrValidationOptions) && "name" in refOrValidationOptions) {
      registerFieldsRef(refOrValidationOptions, validationOptions);
      return;
    }
    return (ref2) => ref2 && registerFieldsRef(ref2, refOrValidationOptions);
  }
  const handleSubmit = useCallback((callback) => async (e) => {
    if (e) {
      e.preventDefault();
      e.persist();
    }
    let fieldErrors;
    let fieldValues;
    const fields = fieldsRef.current;
    if (readFormStateRef.current.isSubmitting) {
      isSubmittingRef.current = true;
      reRender();
    }
    try {
      if (shouldValidateCallback) {
        fieldValues = getFieldsValues(fields);
        const { errors: errors2, values: values2 } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);
        errorsRef.current = errors2;
        fieldErrors = errors2;
        fieldValues = values2;
      } else {
        const { errors: errors2, values: values2 } = await Object.values(fields).reduce(async (previous, field) => {
          if (!field) {
            return previous;
          }
          const resolvedPrevious = await previous;
          const { ref: ref2, ref: { name } } = field;
          if (!fields[name]) {
            return Promise.resolve(resolvedPrevious);
          }
          const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);
          if (fieldError[name]) {
            set(resolvedPrevious.errors, name, fieldError[name]);
            validFieldsRef.current.delete(name);
            return Promise.resolve(resolvedPrevious);
          }
          if (fieldsWithValidationRef.current.has(name)) {
            validFieldsRef.current.add(name);
          }
          resolvedPrevious.values[name] = getFieldValue(fields, ref2);
          return Promise.resolve(resolvedPrevious);
        }, Promise.resolve({
          errors: {},
          values: {}
        }));
        fieldErrors = errors2;
        fieldValues = values2;
      }
      if (isEmptyObject(fieldErrors)) {
        errorsRef.current = {};
        await callback(transformToNestObject(fieldValues), e);
      } else {
        if (submitFocusError && isWeb) {
          focusErrorField(fields, fieldErrors);
        }
        errorsRef.current = fieldErrors;
      }
    } finally {
      isSubmittedRef.current = true;
      isSubmittingRef.current = false;
      submitCountRef.current = submitCountRef.current + 1;
      reRender();
    }
  }, [
    isWeb,
    reRender,
    shouldValidateCallback,
    submitFocusError,
    validateAllFieldCriteria,
    validationResolver,
    validationSchema
  ]);
  const resetRefs = () => {
    errorsRef.current = {};
    fieldsRef.current = {};
    touchedFieldsRef.current = {};
    validFieldsRef.current = /* @__PURE__ */ new Set();
    fieldsWithValidationRef.current = /* @__PURE__ */ new Set();
    defaultRenderValuesRef.current = {};
    watchFieldsRef.current = /* @__PURE__ */ new Set();
    dirtyFieldsRef.current = /* @__PURE__ */ new Set();
    isWatchAllRef.current = false;
    isSubmittedRef.current = false;
    isDirtyRef.current = false;
    isValidRef.current = true;
    submitCountRef.current = 0;
  };
  const reset = (values2) => {
    if (isWeb) {
      for (const value of Object.values(fieldsRef.current)) {
        if (value && isHTMLElement(value.ref) && value.ref.closest) {
          try {
            value.ref.closest("form").reset();
            break;
          } catch (_a) {
          }
        }
      }
    }
    if (values2) {
      defaultValuesRef.current = values2;
    }
    Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());
    resetRefs();
    reRender();
  };
  const getValues = (payload) => {
    const fieldValues = getFieldsValues(fieldsRef.current);
    const outputValues = isEmptyObject(fieldValues) ? defaultValuesRef.current : fieldValues;
    return payload && payload.nest ? transformToNestObject(outputValues) : outputValues;
  };
  useEffect(() => () => {
    isUnMount.current = true;
    fieldsRef.current && Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));
  }, [removeFieldEventListenerAndRef]);
  if (!shouldValidateCallback) {
    isValidRef.current = validFieldsRef.current.size >= fieldsWithValidationRef.current.size && isEmptyObject(errorsRef.current);
  }
  const formState = {
    dirty: isDirtyRef.current,
    dirtyFields: dirtyFieldsRef.current,
    isSubmitted: isSubmittedRef.current,
    submitCount: submitCountRef.current,
    touched: touchedFieldsRef.current,
    isSubmitting: isSubmittingRef.current,
    isValid: isOnSubmit ? isSubmittedRef.current && isEmptyObject(errorsRef.current) : isValidRef.current
  };
  const control = Object.assign(Object.assign({
    register: register2,
    unregister,
    removeFieldEventListener,
    getValues,
    setValue,
    reRender,
    triggerValidation
  }, shouldValidateCallback ? { validateSchemaIsValid } : {}), {
    formState,
    mode: {
      isOnBlur,
      isOnSubmit
    },
    reValidateMode: {
      isReValidateOnBlur,
      isReValidateOnSubmit
    },
    errorsRef,
    touchedFieldsRef,
    fieldsRef,
    resetFieldArrayFunctionRef,
    validFieldsRef,
    fieldsWithValidationRef,
    watchFieldArrayRef,
    fieldArrayNamesRef,
    isDirtyRef,
    readFormStateRef,
    defaultValuesRef
  });
  return {
    watch,
    control,
    handleSubmit,
    setValue: useCallback(setValue, [
      reRender,
      setInternalValue,
      triggerValidation
    ]),
    triggerValidation,
    getValues: useCallback(getValues, []),
    reset: useCallback(reset, []),
    register: useCallback(register2, [
      defaultValuesRef.current,
      defaultRenderValuesRef.current,
      watchFieldArrayRef.current
    ]),
    unregister: useCallback(unregister, []),
    clearError: useCallback(clearError, []),
    setError: useCallback(setError, []),
    errors: errorsRef.current,
    formState: isProxyEnabled ? new Proxy(formState, {
      get: (obj, prop) => {
        if (prop in obj) {
          readFormStateRef.current[prop] = true;
          return obj[prop];
        }
        return {};
      }
    }) : formState
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __rest(s, e) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
}
const FormGlobalContext = reactExports.createContext(null);
function useFormContext() {
  const context2 = reactExports.useContext(FormGlobalContext);
  if (!isUndefined(context2))
    return context2;
  throw new Error("Missing FormContext");
}
var getInputValue = (event, isCheckboxInput) => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isCheckboxInput || isUndefined(event.target.value) ? event.target.checked : event.target.value;
const Controller = (_a) => {
  var { name, rules, as: InnerComponent, onBlur, onChange, onChangeName = VALIDATION_MODE.onChange, onBlurName = VALIDATION_MODE.onBlur, valueName, defaultValue, control } = _a, rest = __rest(_a, ["name", "rules", "as", "onBlur", "onChange", "onChangeName", "onBlurName", "valueName", "defaultValue", "control"]);
  const methods = useFormContext();
  const { defaultValuesRef, setValue, register: register2, unregister, errorsRef, removeFieldEventListener, triggerValidation, mode: { isOnSubmit, isOnBlur }, reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit }, formState: { isSubmitted }, fieldsRef, fieldArrayNamesRef } = control || methods.control;
  const [value, setInputStateValue] = reactExports.useState(isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue);
  const valueRef = reactExports.useRef(value);
  const isCheckboxInput = isBoolean(value);
  const shouldValidate = () => !skipValidation({
    hasError: !!get(errorsRef.current, name),
    isOnBlur,
    isOnSubmit,
    isReValidateOnBlur,
    isReValidateOnSubmit,
    isSubmitted
  });
  const commonTask = (event) => {
    const data = getInputValue(event, isCheckboxInput);
    setInputStateValue(data);
    valueRef.current = data;
    return data;
  };
  const eventWrapper = (event) => (...arg) => setValue(name, commonTask(event(arg)), shouldValidate());
  const handleChange = (event) => {
    const data = commonTask(event);
    setValue(name, data, shouldValidate());
  };
  const registerField = () => {
    if (isNameInFieldArray(fieldArrayNamesRef.current, name) && fieldsRef.current[name]) {
      removeFieldEventListener(fieldsRef.current[name], true);
    }
    register2(Object.defineProperty({ name }, VALUE, {
      set(data) {
        setInputStateValue(data);
        valueRef.current = data;
      },
      get() {
        return valueRef.current;
      }
    }), Object.assign({}, rules));
  };
  reactExports.useEffect(() => {
    if (!fieldsRef.current[name]) {
      registerField();
      setInputStateValue(isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue);
    }
  });
  reactExports.useEffect(() => {
    registerField();
    return () => {
      if (!isNameInFieldArray(fieldArrayNamesRef.current, name)) {
        unregister(name);
      }
    };
  }, [name]);
  const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;
  const props = Object.assign(Object.assign(Object.assign(Object.assign({ name }, rest), onChange ? { [onChangeName]: eventWrapper(onChange) } : { [onChangeName]: handleChange }), onBlur || shouldReValidateOnBlur ? {
    [onBlurName]: (...args) => {
      if (onBlur) {
        onBlur(args);
      }
      if (shouldReValidateOnBlur) {
        triggerValidation(name);
      }
    }
  } : {}), { [valueName || (isCheckboxInput ? "checked" : VALUE)]: value });
  return reactExports.isValidElement(InnerComponent) ? reactExports.cloneElement(InnerComponent, props) : reactExports.createElement(InnerComponent, props);
};
let nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");
function setupRerenderListener(elements) {
  return;
}
const Container = (props) => {
  return /* @__PURE__ */ React.createElement("span", { style: { display: "flex", alignItems: "center", height: 24, ...props.style } }, props.children);
};
const Icon = (props) => {
  return /* @__PURE__ */ React.createElement("span", { style: { display: "flex", alignItems: "center", flexGrow: 1, marginRight: 8 } }, props.children);
};
const Label = (props) => {
  return /* @__PURE__ */ React.createElement("span", { style: { display: "flex", alignItems: "center", flexGrow: 1, lineHeight: "100%" } }, props.children);
};
const ButtonIconLabel = (props) => {
  const loader = /* @__PURE__ */ React.createElement(CircularProgress$1, { size: "1.2em", style: { color: props.loaderColor || "inherit" } });
  return /* @__PURE__ */ React.createElement(Container, { style: props.style }, props.children || props.loading ? /* @__PURE__ */ React.createElement(Icon, null, props.loading ? loader : props.children) : null, /* @__PURE__ */ React.createElement(Label, null, props.label));
};
const closeIcon = /* @__PURE__ */ React.createElement(CloseIcon, null);
function MaybeIcon(props) {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ButtonIconLabel, { label: props.label, loading: props.loading }, props.icon));
}
const useActionButtonStyles = makeStyles$2((theme2) => ({
  inlineDialogActionsBox: {
    alignItems: "stretch",
    margin: "32px 0 0",
    padding: "8px 0",
    [breakpoints.down(600)]: {
      justifyContent: "center",
      marginLeft: -12,
      marginRight: -12
    }
  },
  mobileDialogActionsBox: {
    display: "flex",
    position: "fixed",
    left: 8,
    right: 8,
    bottom: 0,
    backgroundColor: "#fcfcfc",
    justifyContent: "flex-end",
    [MobileKeyboardOpenedSelector()]: {
      // For iOS keyboard: Viewport shrinks when keyboard opens. Make actions non-sticky then,
      // so they don't take too much screen space; making it consistent with other iOS apps.
      position: "static !important"
    }
  },
  mobileInlineSpacePlaceholder: {
    width: "100% !important",
    height: "88px !important",
    [MobileKeyboardOpenedSelector()]: {
      display: "none"
    }
  },
  common: {
    flexShrink: 0,
    maxHeight: 88,
    overflow: "hidden",
    transition: `max-height ${theme2.transitions.duration.standard}ms ${theme2.transitions.easing.easeInOut}`,
    zIndex: 1
  },
  hidden: {
    maxHeight: 0,
    paddingTop: 0,
    paddingBottom: 0
  },
  transparent: {
    background: "transparent"
  },
  actionButton: {
    "$inlineDialogActionsBox &": {
      boxShadow: "none",
      padding: "10px 20px"
    },
    "$mobileDialogActionsBox &": {
      flexBasis: "calc(100% - 24px)",
      flexGrow: 1,
      margin: 12,
      padding: 20,
      "&:not(:first-child)": {
        flexBasis: "calc(50% - 16px)",
        marginLeft: 6
      },
      "&:not(:last-child)": {
        flexBasis: "calc(50% - 16px)",
        marginRight: 6
      }
    }
  }
}));
function ActionButton(props) {
  const { type: type2 = "secondary" } = props;
  const classes = useActionButtonStyles();
  const isSmallScreen2 = useIsMobile();
  const autoVariant = !isSmallScreen2 && (props.type === "secondary" || !props.type) ? "text" : "contained";
  return /* @__PURE__ */ React.createElement(
    Button$1,
    {
      autoFocus: props.autoFocus,
      color: type2 === "primary" || type2 === "submit" ? "primary" : void 0,
      className: `${classes.actionButton} ${props.className || ""}`,
      disabled: props.disabled || props.loading,
      form: props.form,
      onClick: props.onClick,
      style: props.style,
      type: type2 === "submit" ? "submit" : void 0,
      variant: props.variant || autoVariant
    },
    /* @__PURE__ */ React.createElement(MaybeIcon, { icon: props.icon, label: props.children, loading: props.loading })
  );
}
function CloseButton(props) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React.createElement(ActionButton, { form: props.form, icon: closeIcon, onClick: props.onClick, type: "secondary" }, t2("generic.dialog-actions.close.label"));
}
const MobileDialogActionsBox = React.memo(
  React.forwardRef(function MobileDialogActionsBox2(props, ref2) {
    const classes = useActionButtonStyles();
    return /* @__PURE__ */ React.createElement(React.Fragment, null, props.smallDialog ? null : (
      // Placeholder to prevent other dialog content from being hidden below the actions box
      // Make sure its height matches the height of the actions box
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classes.common} ${classes.mobileInlineSpacePlaceholder} ${props.hidden ? classes.hidden : ""}`
        }
      )
    ), /* @__PURE__ */ React.createElement(
      "div",
      {
        className: [
          "iphone-notch-bottom-spacing",
          classes.common,
          classes.mobileDialogActionsBox,
          props.className || "",
          props.hidden ? classes.hidden : "",
          props.transparent ? classes.transparent : ""
        ].join(" "),
        ref: ref2
      },
      props.children
    ));
  })
);
const DialogActionsBox = React.memo(
  React.forwardRef(function DialogActionsBox2(props, ref2) {
    const classes = useActionButtonStyles();
    const isSmallScreen2 = useIsMobile();
    React.useEffect(() => {
      document.querySelectorAll(".dialog-body");
      const unsubscribe2 = setupRerenderListener();
      return unsubscribe2;
    }, []);
    if (isSmallScreen2 && !props.preventMobileActionsBox) {
      return /* @__PURE__ */ React.createElement(
        MobileDialogActionsBox,
        {
          className: props.className,
          hidden: props.hidden,
          ref: ref2,
          smallDialog: props.smallDialog,
          transparent: props.transparent
        },
        props.children
      );
    }
    return /* @__PURE__ */ React.createElement(
      DialogActions$1,
      {
        className: `${classes.common} ${classes.inlineDialogActionsBox} ${props.hidden ? classes.hidden : ""} ${props.className || ""}`,
        ref: ref2,
        style: props.desktopStyle
      },
      props.children
    );
  })
);
function ConfirmDialog(props) {
  const isSmallScreen2 = useIsMobile();
  return /* @__PURE__ */ React.createElement(Dialog$1, { open: props.open, onClose: props.onClose, TransitionComponent: CompactDialogTransition }, /* @__PURE__ */ React.createElement(DialogTitle$1, null, props.title), /* @__PURE__ */ React.createElement(DialogContent$1, { style: { paddingBottom: isSmallScreen2 ? 24 : void 0 } }, /* @__PURE__ */ React.createElement(Typography$1, { variant: "body2" }, props.children), /* @__PURE__ */ React.createElement(DialogActionsBox, { preventMobileActionsBox: true, smallDialog: true }, props.cancelButton, props.confirmButton)));
}
function SavedAddressDetailsDialog(props) {
  const { t: t2 } = useTranslation();
  const form = useForm({
    defaultValues: {
      address: props.address || "",
      label: props.label || ""
    }
  });
  const formID = React.useMemo(() => nanoid(), []);
  const handleFormSubmission = () => {
    const values2 = form.getValues();
    if (!values2.address) return;
    props.onSave(values2.address, values2.label);
  };
  return /* @__PURE__ */ React.createElement(DialogBody$1, { excessWidth: 12, top: /* @__PURE__ */ React.createElement(MainTitle, { onBack: props.onClose, title: props.label }) }, /* @__PURE__ */ React.createElement("form", { id: formID, noValidate: true, onSubmit: form.handleSubmit(handleFormSubmission) }, /* @__PURE__ */ React.createElement(
    TextField$1,
    {
      error: Boolean(form.errors.address),
      fullWidth: true,
      inputProps: {
        style: { textOverflow: "ellipsis" }
      },
      inputRef: form.register({
        required: t2("account.saved-address-details.validation.no-address"),
        validate: (value) => isPublicKey(value) || isMuxedAddress(value) || isStellarAddress(value) || t2("account.saved-address-details.validation.invalid-address")
      }),
      label: form.errors.address ? form.errors.address.message : t2("account.saved-address-details.address.label"),
      margin: "normal",
      name: "address",
      onChange: (event) => form.setValue("address", event.target.value.trim()),
      placeholder: t2("account.saved-address-details.address.placeholder")
    }
  ), /* @__PURE__ */ React.createElement(
    TextField$1,
    {
      error: Boolean(form.errors.label),
      fullWidth: true,
      label: form.errors.label ? form.errors.label.message : t2("account.saved-address-details.label.label"),
      margin: "normal",
      name: "label",
      inputRef: form.register({
        validate: {
          length: (value) => value.length <= 1024 || t2("account.saved-address-details.validation.label-too-long", { max: 1024 })
        }
      }),
      onChange: (event) => {
        form.setValue("label", event.target.value);
      },
      placeholder: t2("account.saved-address-details.label.label")
    }
  ), /* @__PURE__ */ React.createElement(DialogActionsBox, { desktopStyle: { marginTop: 64 } }, props.address && /* @__PURE__ */ React.createElement(
    ActionButton,
    {
      icon: /* @__PURE__ */ React.createElement(CloseIcon, null),
      onClick: () => props.onRemove(props.address || ""),
      style: { maxWidth: "none" },
      type: "secondary"
    },
    t2("account.saved-address-details.button.remove.label")
  ), /* @__PURE__ */ React.createElement(ActionButton, { form: formID, onClick: () => void 0, type: "submit" }, t2("account.saved-address-details.button.add.label")))));
}
const SavedAddressesDetailsDialog = React.memo(SavedAddressDetailsDialog);
var Search = {};
var hasRequiredSearch;
function requireSearch() {
  if (hasRequiredSearch) return Search;
  hasRequiredSearch = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(Search, "__esModule", {
    value: true
  });
  Search.default = void 0;
  var _react = _interopRequireDefault(requireReact());
  var _createSvgIcon = _interopRequireDefault(/* @__PURE__ */ requireCreateSvgIcon());
  var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
    d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
  }), "Search");
  Search.default = _default;
  return Search;
}
var SearchExports = /* @__PURE__ */ requireSearch();
const SearchIcon = /* @__PURE__ */ getDefaultExportFromCjs$1(SearchExports);
function patchComponentModule(mod) {
  return mod && "default" in mod && mod.default ? mod : { default: mod };
}
const ReactQRReader = React.lazy(() => __vitePreload(() => import("./index-DQ0kNnF8.js").then((n) => n.i), true ? [] : void 0).then(patchComponentModule));
function QRReader$2(props) {
  return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: /* @__PURE__ */ React.createElement(ViewLoading$1, null) }, /* @__PURE__ */ React.createElement(ReactQRReader, { ...props }));
}
const isFullscreenQRPreview$1 = false;
const webImpl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  QRReader: QRReader$2,
  isFullscreenQRPreview: isFullscreenQRPreview$1
}, Symbol.toStringTag, { value: "Module" }));
function getImplementation() {
  if (window.electron) {
    return webImpl;
  } else if (typeof window !== "undefined") {
    return webImpl;
  } else {
    throw new Error("There are no platform components for your platform.");
  }
}
const components = getImplementation();
const isFullscreenQRPreview = components.isFullscreenQRPreview;
const QRReader$1 = components.QRReader;
function QRImportDialog(props) {
  const { t: t2 } = useTranslation();
  if (isFullscreenQRPreview) {
    if (props.open) {
      props.onClose();
    }
    return props.open ? /* @__PURE__ */ React.createElement(QRReader$1, { onError: props.onError, onScan: props.onScan, style: { width: 256, height: 256 } }) : null;
  }
  return /* @__PURE__ */ React.createElement(Dialog$1, { open: props.open, onClose: props.onClose }, /* @__PURE__ */ React.createElement(DialogContent$1, { style: { paddingBottom: 8 } }, props.open ? /* @__PURE__ */ React.createElement(QRReader$1, { onError: props.onError, onScan: props.onScan, style: { width: 256, height: 256 } }) : null, /* @__PURE__ */ React.createElement(DialogActionsBox, null, /* @__PURE__ */ React.createElement(ActionButton, { onClick: props.onClose }, t2("generic.qr-reader.action.cancel")))));
}
function QRReaderIcon(props) {
  return /* @__PURE__ */ reactExports.createElement(SvgIcon$2, { viewBox: "0 0 24 20", ...props }, /* @__PURE__ */ reactExports.createElement("g", { stroke: "none", strokeWidth: "1", fillRule: "evenodd" }, /* @__PURE__ */ reactExports.createElement("g", { transform: "translate(-731.000000, -346.000000)" }, /* @__PURE__ */ reactExports.createElement("g", { transform: "translate(35.000000, 241.000000)" }, /* @__PURE__ */ reactExports.createElement("g", { transform: "translate(696.000000, 105.000000)" }, /* @__PURE__ */ reactExports.createElement("path", { d: "M2.18181818,2.22222222 L2.18181818,6.66666667 L4.36363636,6.66666667 L4.36363636,2.22222222 L8.72727273,2.22222222 L8.72727273,0 L4.36363636,0 C3.16363636,0 2.18181818,1 2.18181818,2.22222222 L2.18181818,2.22222222 Z M4.36363636,13.3333333 L2.18181818,13.3333333 L2.18181818,17.7777778 C2.18181818,19 3.16363636,20 4.36363636,20 L8.72727273,20 L8.72727273,17.7777778 L4.36363636,17.7777778 L4.36363636,13.3333333 L4.36363636,13.3333333 Z M19.6363636,17.7777778 L15.2727273,17.7777778 L15.2727273,20 L19.6363636,20 C20.8363636,20 21.8181818,19 21.8181818,17.7777778 L21.8181818,13.3333333 L19.6363636,13.3333333 L19.6363636,17.7777778 L19.6363636,17.7777778 Z M19.6363636,0 L15.2727273,0 L15.2727273,2.22222222 L19.6363636,2.22222222 L19.6363636,6.66666667 L21.8181818,6.66666667 L21.8181818,2.22222222 C21.8181818,1 20.8363636,0 19.6363636,0 L19.6363636,0 Z" }), /* @__PURE__ */ reactExports.createElement("rect", { fillRule: "nonzero", x: "0", y: "8.88888889", width: "24", height: "2.22222222" }))))));
}
const desktopQRIconStyle = { fontSize: 20 };
const mobileQRIconStyle = {};
const QRReader = React.memo(function QRReader2(props) {
  const { onScan } = props;
  const isTouchScreen = useMediaQuery("(hover: none)");
  const [isQRReaderOpen, setQRReaderOpen] = React.useState(false);
  const closeQRReader = React.useCallback(() => setQRReaderOpen(false), []);
  const openQRReader = React.useCallback(() => setQRReaderOpen(true), []);
  const handleQRScan = React.useCallback(
    (data) => {
      if (data) {
        onScan(data);
        closeQRReader();
      }
    },
    [closeQRReader, onScan]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(IconButton$1, { onClick: openQRReader, tabIndex: 99 }, /* @__PURE__ */ React.createElement(QRReaderIcon, { style: isTouchScreen ? mobileQRIconStyle : desktopQRIconStyle })), /* @__PURE__ */ React.createElement(QRImportDialog, { open: isQRReaderOpen, onClose: closeQRReader, onError: trackError, onScan: handleQRScan }));
});
const PriceInput = React.memo(function PriceInput2(props) {
  const { assetCode, assetStyle, readOnly, ...textfieldProps } = props;
  const InputField = readOnly ? ReadOnlyTextfield : TextField$1;
  return /* @__PURE__ */ React.createElement(
    InputField,
    {
      ...textfieldProps,
      inputProps: {
        pattern: "[0-9]*",
        inputMode: "decimal"
      },
      InputProps: {
        endAdornment: /* @__PURE__ */ React.createElement(
          InputAdornment$1,
          {
            disableTypography: true,
            position: "end",
            style: {
              pointerEvents: typeof assetCode === "string" ? "none" : void 0,
              ...assetStyle
            }
          },
          assetCode
        ),
        ...textfieldProps.InputProps
      },
      style: {
        pointerEvents: props.readOnly ? "none" : void 0,
        ...textfieldProps.style
      }
    }
  );
});
const useReadOnlyTextfieldStyles = makeStyles$2({
  root: {
    "&:focus": {
      outline: "none"
    },
    "&&, && > div": {
      color: "inherit"
    }
  }
});
const ReadOnlyTextfield = React.memo(function ReadOnlyTextfield2(props) {
  const { disableUnderline, multiline, ...textfieldProps } = props;
  const classes = useReadOnlyTextfieldStyles();
  const InputProps2 = {
    disableUnderline: disableUnderline === false ? false : true,
    multiline,
    disabled: true,
    readOnly: true,
    ...props.InputProps
  };
  return /* @__PURE__ */ React.createElement(
    TextField$1,
    {
      ...textfieldProps,
      className: `${classes.root} ${props.className || ""}`,
      tabIndex: -1,
      InputProps: InputProps2
    }
  );
});
const SearchField = React.memo(function SearchField2(props) {
  return /* @__PURE__ */ React.createElement(
    TextField$1,
    {
      fullWidth: true,
      variant: "outlined",
      ...props,
      InputProps: {
        endAdornment: /* @__PURE__ */ React.createElement(InputAdornment$1, { position: "end" }, /* @__PURE__ */ React.createElement(SearchIcon, null)),
        ...props.InputProps
      }
    }
  );
});
const SavedAddressesList = React.memo(function SavedAddressesList2(props) {
  const isSmallScreen2 = useIsMobile();
  const sortedList = React.useMemo(
    () => Object.keys(props.addresses).map((address) => ({ address, label: props.addresses[address].label })).sort((a, b) => a.label.localeCompare(b.label)),
    [props.addresses]
  );
  const filterSubstr = React.useMemo(() => (props.filterValue || "").toLocaleLowerCase(), [props.filterValue]);
  const filteredList = React.useMemo(
    () => sortedList.filter(
      ({ address, label }) => address.toLowerCase().includes(filterSubstr) || label.toLocaleLowerCase().includes(filterSubstr)
    ),
    [sortedList, filterSubstr]
  );
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React.createElement(React.Fragment, null, filteredList.map(({ address, label }) => {
    return /* @__PURE__ */ React.createElement(
      ListItem$1,
      {
        key: `saved-${address}`,
        button: Boolean(props.onClick),
        onClick: () => {
          return props.onClick(address);
        }
      },
      /* @__PURE__ */ React.createElement(
        ListItemText$1,
        {
          primary: label,
          secondary: /* @__PURE__ */ React.createElement(
            PublicKey,
            {
              publicKey: address,
              testnet: false,
              showRaw: true,
              variant: isSmallScreen2 ? "short" : "full"
            }
          )
        }
      )
    );
  }), filteredList.length === 0 && /* @__PURE__ */ React.createElement(
    ListItemText$1,
    {
      primary: t2("account.saved-addresses.item.no-result.primary"),
      secondary: t2("account.saved-addresses.item.no-result.secondary")
    }
  ));
});
function SavedAddressesDialog(props) {
  const { t: t2 } = useTranslation();
  const [editingAddress, setEditingAddress] = reactExports.useState(
    props.address ? { address: props.address, label: "" } : null
  );
  const { savedAddresses, add, remove: remove3 } = React.useContext(SavedAddressesContext);
  const openAddAddressDialog = () => {
    setEditingAddress({ address: "", label: "" });
  };
  const closeAddAddressDialog = () => {
    if (props.address) {
      props.onClose();
    }
    setEditingAddress(null);
  };
  const openAddressDetails = (address) => {
    const entry = savedAddresses[address];
    setEditingAddress({ address, label: (entry == null ? void 0 : entry.label) || "" });
  };
  const handleSaveAddress = (address, label) => {
    add(address, label);
    closeAddAddressDialog();
  };
  const handleRemoveAddress = (address) => {
    remove3(address);
    closeAddAddressDialog();
  };
  const [searchFieldValue, setSearchFieldValue] = React.useState("");
  const onSearchFieldChange = React.useCallback((event) => {
    setSearchFieldValue(event.target.value);
  }, []);
  const handleAddressClick = (address) => {
    if (props.onSelect) return props.onSelect(address);
    if (!props.readonly) return openAddressDetails(address);
  };
  return /* @__PURE__ */ React.createElement(DialogBody$1, { excessWidth: 12, top: /* @__PURE__ */ React.createElement(MainTitle, { onBack: props.onClose, title: t2("account.saved-addresses.title") }) }, /* @__PURE__ */ React.createElement(
    SearchField,
    {
      autoFocus: true,
      onChange: onSearchFieldChange,
      value: searchFieldValue,
      placeholder: t2("account.saved-addresses.search-field.placeholder")
    }
  ), /* @__PURE__ */ React.createElement(List$1, { style: { margin: "0 -8px" } }, !props.readonly && /* @__PURE__ */ React.createElement(ButtonListItem$1, { gutterBottom: true, onClick: openAddAddressDialog }, /* @__PURE__ */ React.createElement(AddIcon, null), "  ", t2("account.saved-addresses.button.add.label")), /* @__PURE__ */ React.createElement(SavedAddressesList, { addresses: savedAddresses, onClick: handleAddressClick, filterValue: searchFieldValue })), /* @__PURE__ */ React.createElement(
    Dialog$1,
    {
      fullScreen: true,
      open: !!editingAddress,
      onClose: closeAddAddressDialog,
      TransitionComponent: FullscreenDialogTransition
    },
    /* @__PURE__ */ React.createElement(React.Suspense, { fallback: /* @__PURE__ */ React.createElement(ViewLoading$1, null) }, /* @__PURE__ */ React.createElement(
      SavedAddressesDetailsDialog,
      {
        address: editingAddress == null ? void 0 : editingAddress.address,
        label: editingAddress == null ? void 0 : editingAddress.label,
        onSave: handleSaveAddress,
        onRemove: handleRemoveAddress,
        onClose: closeAddAddressDialog
      }
    ))
  ));
}
const SavedAddressesDialog$1 = React.memo(SavedAddressesDialog);
const initialValues = {
  isSavedAddressesOpened: false,
  openSavedAddresses: () => void 0
};
const DialogsContext = React.createContext(initialValues);
function DialogsProvider(props) {
  const [savedAddressesDialog, setSavedAddressesDialog] = React.useState(
    null
  );
  const closeSavedAddressesDialog = React.useCallback(() => {
    var _a;
    (_a = savedAddressesDialog == null ? void 0 : savedAddressesDialog.onClose) == null ? void 0 : _a.call(savedAddressesDialog);
    setSavedAddressesDialog(null);
  }, [savedAddressesDialog]);
  const context2 = {
    isSavedAddressesOpened: !!savedAddressesDialog,
    openSavedAddresses: setSavedAddressesDialog
  };
  return /* @__PURE__ */ React.createElement(DialogsContext.Provider, { value: context2 }, props.children, /* @__PURE__ */ React.createElement(React.Suspense, { fallback: null }, /* @__PURE__ */ React.createElement(
    Dialog$1,
    {
      open: !!savedAddressesDialog,
      fullScreen: true,
      onClose: closeSavedAddressesDialog,
      TransitionComponent: FullscreenDialogTransition
    },
    /* @__PURE__ */ React.createElement(React.Suspense, { fallback: /* @__PURE__ */ React.createElement(ViewLoading$1, null) }, /* @__PURE__ */ React.createElement(SavedAddressesDialog$1, { ...savedAddressesDialog || {}, onClose: closeSavedAddressesDialog }))
  )));
}
function ContextProviders(props) {
  return /* @__PURE__ */ React.createElement(StellarProvider, null, /* @__PURE__ */ React.createElement(AccountsProvider, null, /* @__PURE__ */ React.createElement(SavedAddressesProvider, null, /* @__PURE__ */ React.createElement(SettingsProvider, null, /* @__PURE__ */ React.createElement(TransactionRequestProvider, null, /* @__PURE__ */ React.createElement(CachingProviders, null, /* @__PURE__ */ React.createElement(NotificationsProvider, null, /* @__PURE__ */ React.createElement(DialogsProvider, null, /* @__PURE__ */ React.createElement(FeatureFlaggedProvider, null, props.children)))))))));
}
const Stage2 = React.lazy(() => __vitePreload(() => import("./app-stage2-CwdMAbKU.js").then((n) => n.ap), true ? __vite__mapDeps([0,1]) : void 0));
const Providers = (props) => /* @__PURE__ */ React.createElement(HashRouter, null, /* @__PURE__ */ React.createElement(ThemeProvider, { theme }, /* @__PURE__ */ React.createElement(ContextProviders, null, props.children)));
const App = () => /* @__PURE__ */ React.createElement(Providers, null, /* @__PURE__ */ React.createElement(React.Suspense, { fallback: /* @__PURE__ */ React.createElement(ViewLoading$1, null) }, /* @__PURE__ */ React.createElement(Stage2, null)));
clientExports.createRoot(document.getElementById("app")).render(React.createElement(App));
SmoothScroll.polyfill();
export {
  DialogActionsBox as $,
  duration as A,
  ButtonBase$1 as B,
  useTheme as C,
  getTransitionProps as D,
  Typography$1 as E,
  lighten as F,
  darken as G,
  ListItem$1 as H,
  I18nContext as I,
  createChainedFunction as J,
  Portal as K,
  ListContext as L,
  emphasize as M,
  Grow as N,
  useIsFocusVisible as O,
  Paper$1 as P,
  reflow as Q,
  React as R,
  requireInteropRequireDefault as S,
  Transition as T,
  requireReact as U,
  requireCreateSvgIcon as V,
  SvgIcon$2 as W,
  useLiveAccountData as X,
  makeStyles$2 as Y,
  useTranslation as Z,
  _objectWithoutProperties as _,
  getI18n as a,
  useDialogActions as a$,
  ActionButton as a0,
  useRouter as a1,
  ConfirmDialog as a2,
  AccountsContext as a3,
  CustomError as a4,
  libExports as a5,
  workers as a6,
  HorizontalLayout as a7,
  useIsMobile as a8,
  MainTitle as a9,
  trustlineLimitEqualsUnlimited as aA,
  SavedAddressesContext as aB,
  useIsSmallMobile as aC,
  useLiveAccountOffers as aD,
  offerAssetToAsset as aE,
  DialogsContext as aF,
  call as aG,
  Messages as aH,
  createPersistentCache as aI,
  useForceRerender as aJ,
  wellKnownAccountsCache as aK,
  trackError as aL,
  tickerAssetsCache as aM,
  Address as aN,
  Buffer as aO,
  warningColor as aP,
  useLiveAccountDataSet as aQ,
  useMediaQuery as aR,
  SigningKeyCacheContext as aS,
  useDeferredState as aT,
  ClickableAddress as aU,
  nanoid as aV,
  CloseIcon as aW,
  renderFormFieldError as aX,
  Dialog$1 as aY,
  FullscreenDialogTransition as aZ,
  CompactDialogTransition as a_,
  primaryBackgroundColor as aa,
  makeStyles as ab,
  TextField$1 as ac,
  InputAdornment$1 as ad,
  SettingsContext as ae,
  Box as af,
  HideOnError as ag,
  breakpoints as ah,
  __vitePreload as ai,
  ViewLoading$1 as aj,
  VerticalLayout as ak,
  CircularProgress$1 as al,
  Fade as am,
  grey as an,
  Big as ao,
  WrongPasswordError as ap,
  getAllSources as aq,
  isNotFoundError as ar,
  isMuxedAddress as as,
  stringifyAsset as at,
  balancelineToAsset as au,
  ReadOnlyTextfield as av,
  ListItemText$1 as aw,
  useAccountHomeDomainSafe as ax,
  stringifyAssetToReadableString as ay,
  CopyableAddress as az,
  getDefaults as b,
  ButtonListItem$1 as b$,
  DialogBody$1 as b0,
  t as b1,
  getErrorTranslation as b2,
  CloseButton as b3,
  useHorizon as b4,
  Translation as b5,
  isWrongPasswordError as b6,
  resolveMultiSignatureCoordinator as b7,
  useAssetMetadata as b8,
  brandColor as b9,
  setAsDefaultProtocolClient as bA,
  pkg as bB,
  theme as bC,
  NotificationsContext as bD,
  useOnlineStatus as bE,
  useNetWorker as bF,
  TransactionRequestContext as bG,
  isDifferentHandlerInstalled as bH,
  SignatureDelegationContext as bI,
  AddIcon as bJ,
  Button$1 as bK,
  getUpdater as bL,
  useHorizonURLs as bM,
  useSingleton as bN,
  useLiveAccountEffects as bO,
  MainErrorBoundary as bP,
  Switch as bQ,
  Route as bR,
  pick as bS,
  requireNaclFast as bT,
  DialogTitle$1 as bU,
  useAccountData as bV,
  parseAssetID as bW,
  BASE_RESERVE as bX,
  _inheritsLoose as bY,
  _assertThisInitialized as bZ,
  SearchField as b_,
  useFederationLookup as ba,
  useForm as bb,
  getSpendableBalance as bc,
  findMatchingBalanceLine as bd,
  getAccountMinimumBalance as be,
  isPublicKey as bf,
  isStellarAddress as bg,
  isStellarUri as bh,
  parseStellarUri as bi,
  StellarUriType as bj,
  QRReader as bk,
  Controller as bl,
  PriceInput as bm,
  MultisigTransactionStatus as bn,
  getAssetsFromBalances as bo,
  requirePropTypes as bp,
  useClipboard as bq,
  Section as br,
  InlineErrorBoundary as bs,
  PublicKey as bt,
  List$1 as bu,
  useStellarToml as bv,
  DialogContent$1 as bw,
  ErrorIcon as bx,
  Select$1 as by,
  isDefaultProtocolClient as bz,
  _defineProperty$1 as c,
  assetRecordToAsset as c0,
  useLiveOrderbook as c1,
  DialogActions$1 as c2,
  useLiveRecentTransactions as c3,
  useOlderTransactions as c4,
  friendbotTopup as c5,
  useLoadingState as c6,
  useOlderOffers as c7,
  requireUtil$2 as c8,
  TransactionStellarUri as c9,
  _arrayWithHoles as ca,
  _iterableToArray as cb,
  _unsupportedIterableToArray as cc,
  _nonIterableRest as cd,
  Menu$1 as ce,
  _objectWithoutPropertiesLoose as cf,
  process$1 as cg,
  commonjsGlobal as ch,
  useAccountHomeDomains as ci,
  mapSuspendables as cj,
  transferInfosCache as ck,
  requireBrowser$e as cl,
  useWebAuth as cm,
  stellarTomlCache as cn,
  warn as d,
  _typeof$2 as e,
  _extends$1 as f,
  getDefaultExportFromCjs$1 as g,
  defaultTheme$1 as h,
  withStyles as i,
  clsx as j,
  capitalize as k,
  deepmerge as l,
  _toConsumableArray as m,
  _slicedToArray as n,
  IconButton$1 as o,
  createSvgIcon$1 as p,
  fade as q,
  reactExports as r,
  styled as s,
  useForkRef as t,
  useFormControl as u,
  setRef as v,
  warnOnce as w,
  ReactDOM as x,
  useEventCallback as y,
  ownerDocument as z
};
//# sourceMappingURL=app-DBEXmgIl.js.map
