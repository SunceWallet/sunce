{"version":3,"file":"BalanceDetailsDialog-CzYuVvF6.js","sources":["../node_modules/memoize-one/dist/memoize-one.esm.js","../node_modules/react-window/dist/index.esm.js","../src/Generic/components/VirtualList.tsx","../src/Generic/lib/popularAssets.ts","../src/Assets/components/BalanceDetailsListItem.tsx","../src/Assets/components/CustomTrustline.tsx","../src/Assets/components/AddAssetDialog.tsx","../src/Assets/components/BalanceDetailsDialog.tsx"],"sourcesContent":["function areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsOverscanRowsColumnsCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _style;\n\n          itemStyleCache[key] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = getColumnOffset(_this.props, columnIndex, _this._instanceProps), _style.top = getRowOffset(_this.props, rowIndex, _this._instanceProps), _style.height = getRowHeight(_this.props, rowIndex, _this._instanceProps), _style.width = getColumnWidth(_this.props, columnIndex, _this._instanceProps), _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName$1 =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _style;\n\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          itemStyleCache[index] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = isHorizontal ? _offset : 0, _style.top = !isHorizontal ? _offset : 0, _style.height = !isHorizontal ? size : '100%', _style.width = isHorizontal ? size : '100%', _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n","import React from \"react\"\nimport * as Window from \"react-window\"\n\ninterface FixedSizeListProps {\n  children: React.FunctionComponent<Window.ListChildComponentProps>\n  container: HTMLElement | null\n  itemCount: number\n  itemSize: number\n}\n\nexport function FixedSizeList(props: FixedSizeListProps) {\n  if (!props.container) {\n    return null\n  }\n\n  const height = props.container.clientHeight\n  const width = props.container.clientWidth\n\n  return (\n    <Window.FixedSizeList height={height} itemCount={props.itemCount} itemSize={props.itemSize} width={width}>\n      {props.children}\n    </Window.FixedSizeList>\n  )\n}\n","import { Asset } from \"stellar-sdk\"\n\nexport const mainnet = [\n  new Asset(\"EURMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"MTLAP\", \"GCNVDZIHGX473FEI7IXCUAEXUJ4BGCKEMHF36VYP5EMS7PX2QBLAMTLA\"),\n  new Asset(\"MTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"MTLRECT\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"BTCMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"SATSMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"USDM\", \"GDHDC4GBNPMENZAOBB4NCQ25TGZPDRK6ZGWUGSI22TVFATOLRPSUUSDM\"),\n  new Asset(\"USDC\", \"GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN\")\n]\n\nexport const testnet = [\n  new Asset(\"USD\", \"GCKFBEIYV2U22IO2BJ4KVJOIP7XPWQGQFKKWXR6DOSJBV7STMAQSMTGG\"),\n  new Asset(\"SRT\", \"GCDNJUBQSX7AJWLJACMJ7I4BC3Z47BQUTMHEICZLE6MU4KQBRYG5JY6B\")\n]\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport Badge from \"@material-ui/core/Badge\"\nimport ListItem from \"@material-ui/core/ListItem\"\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\"\nimport ListItemText from \"@material-ui/core/ListItemText\"\nimport { makeStyles } from \"@material-ui/core/styles\"\nimport { useAssetMetadata } from \"~Generic/hooks/stellar\"\nimport { balancelineToAsset } from \"~Generic/lib/stellar\"\nimport { breakpoints } from \"~App/theme\"\nimport { SingleBalance } from \"~Account/components/AccountBalances\"\nimport { BalanceLine } from \"~Generic/lib/account\"\nimport { AccountName } from \"~Generic/components/Fetchers\"\nimport AssetLogo from \"./AssetLogo\"\n\nexport const actionsSize = 36\n\nconst useBalanceItemStyles = makeStyles({\n  clickable: {},\n  icon: {\n    [breakpoints.down(350)]: {\n      minWidth: 48\n    }\n  },\n  logo: {\n    [breakpoints.down(350)]: {\n      width: 36,\n      height: 36\n    }\n  },\n  logoHidden: {\n    visibility: \"hidden\"\n  },\n  badge: {\n    top: 4,\n    right: 4,\n    boxShadow: \"0 0 3px 1px black\"\n  },\n  mainListItemText: {\n    flex: \"1 1 auto\",\n    whiteSpace: \"nowrap\"\n  },\n  mainListItemTextPrimaryTypography: {\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\",\n\n    [breakpoints.down(400)]: {\n      fontSize: 15\n    },\n    [breakpoints.down(350)]: {\n      fontSize: 13\n    }\n  },\n  mainListItemTextSecondaryTypography: {\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\",\n\n    [breakpoints.down(400)]: {\n      fontSize: 14\n    },\n    [breakpoints.down(350)]: {\n      fontSize: 12\n    }\n  },\n  balanceListItemText: {\n    flex: \"1 0 auto\",\n    marginLeft: 8,\n    textAlign: \"right\"\n  },\n  balanceText: {\n    fontSize: \"140%\",\n\n    [breakpoints.down(350)]: {\n      fontSize: \"120%\"\n    }\n  },\n  actions: {\n    flex: \"0 0 auto\",\n    marginLeft: 4,\n    marginRight: -16,\n    width: 48\n  }\n})\n\ninterface BalanceListItemProps {\n  badgeCount?: number | string\n  balance: BalanceLine\n  className?: string\n  hideBalance?: boolean\n  hideLogo?: boolean\n  onClick?: () => void\n  spendableBalance?: boolean\n  style?: React.CSSProperties\n  testnet: boolean\n}\n\nfunction BalanceListItem(props: BalanceListItemProps) {\n  const classes = useBalanceItemStyles()\n  const className = `${props.className || \"\"} ${props.onClick ? classes.clickable : \"\"}`\n\n  const asset = React.useMemo(() => balancelineToAsset(props.balance), [props.balance])\n  const assetMetadata = useAssetMetadata(asset, props.testnet)\n  const { t } = useTranslation()\n\n  const balance = React.useMemo(\n    () => (props.hideBalance ? null : <SingleBalance assetCode={\"\"} balance={props.balance.balance} />),\n    [props.balance.balance, props.hideBalance]\n  )\n\n  if (props.balance.asset_type === \"native\") {\n    return (\n      <ListItem\n        button={Boolean(props.onClick) as any}\n        className={className}\n        onClick={props.onClick}\n        style={props.style}\n      >\n        <ListItemIcon className={classes.icon}>\n          <AssetLogo\n            asset={asset}\n            className={`${classes.logo} ${props.hideLogo ? classes.logoHidden : \"\"}`}\n            testnet={props.testnet}\n          />\n        </ListItemIcon>\n        <ListItemText\n          classes={{\n            root: classes.mainListItemText,\n            primary: classes.mainListItemTextPrimaryTypography,\n            secondary: classes.mainListItemTextSecondaryTypography\n          }}\n          primary={\n            props.spendableBalance\n              ? t(\"account.balance-details.item.spendable-balance.primary\")\n              : \"Stellar Lumens (XLM)\"\n          }\n          secondary={props.spendableBalance ? undefined : \"stellar.org\"}\n        />\n        <ListItemText\n          classes={{\n            root: classes.balanceListItemText,\n            primary: classes.balanceText\n          }}\n          primary={balance}\n        />\n      </ListItem>\n    )\n  }\n\n  const assetName = (assetMetadata && assetMetadata.name) || props.balance.asset_code\n  const title =\n    assetName !== props.balance.asset_code ? `${assetName} (${props.balance.asset_code})` : props.balance.asset_code\n\n  return (\n    <ListItem button={Boolean(props.onClick) as any} className={className} onClick={props.onClick} style={props.style}>\n      <ListItemIcon className={classes.icon}>\n        <Badge badgeContent={props.badgeCount} classes={{ badge: classes.badge }} color=\"primary\">\n          <AssetLogo\n            asset={asset}\n            className={`${classes.logo} ${props.hideLogo ? classes.logoHidden : \"\"}`}\n            dark\n            testnet={props.testnet}\n          />\n        </Badge>\n      </ListItemIcon>\n      <ListItemText\n        className={classes.mainListItemText}\n        classes={{\n          primary: classes.mainListItemTextPrimaryTypography,\n          secondary: classes.mainListItemTextSecondaryTypography\n        }}\n        primary={title}\n        secondary={<AccountName publicKey={props.balance.asset_issuer} testnet={props.testnet} />}\n      />\n      <ListItemText\n        className={classes.balanceListItemText}\n        primary={balance}\n        primaryTypographyProps={{ className: classes.balanceText }}\n      />\n    </ListItem>\n  )\n}\n\nexport default React.memo(BalanceListItem)\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, Server, Transaction } from \"stellar-sdk\"\nimport useMediaQuery from \"@material-ui/core/useMediaQuery\"\nimport TextField from \"@material-ui/core/TextField\"\nimport VerifiedUserIcon from \"@material-ui/icons/VerifiedUser\"\nimport { Account } from \"~App/contexts/accounts\"\nimport { AccountData } from \"~Generic/lib/account\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport { ActionButton, DialogActionsBox } from \"~Generic/components/DialogActions\"\nimport MainTitle from \"~Generic/components/MainTitle\"\n\ninterface Props {\n  account: Account\n  accountData: AccountData\n  createAddAssetTransaction: (asset: Asset, options: { limit?: string }) => any\n  horizon: Server\n  onClose: () => void\n  sendTransaction: (createTransactionToSend: () => Promise<Transaction>) => any\n  txCreationPending: boolean\n}\n\nfunction CustomTrustlineDialog(props: Props) {\n  const [code, setCode] = React.useState(\"\")\n  const [issuerPublicKey, setIssuerPublicKey] = React.useState(\"\")\n  const [limit, setLimit] = React.useState(\"\")\n  const isWidthMax450 = useMediaQuery(\"(max-width:450px)\")\n  const { t } = useTranslation()\n\n  const createTransaction = () =>\n    props.createAddAssetTransaction(new Asset(code, issuerPublicKey), { limit: limit || undefined })\n  const addCustomAsset = () => props.sendTransaction(createTransaction)\n\n  return (\n    <DialogBody\n      top={<MainTitle hideBackButton onBack={props.onClose} title={t(\"account-settings.custom-trustline.title\")} />}\n    >\n      <form noValidate style={{ display: \"block\", width: \"100%\" }}>\n        <TextField\n          label={t(\"account-settings.custom-trustline.textfield.code.label\")}\n          placeholder=\"EURT, USDT, BTC, ...\"\n          autoFocus={import.meta.env.VITE_PLATFORM !== \"ios\"}\n          margin=\"dense\"\n          name=\"asset-code\"\n          value={code}\n          onChange={event => setCode(event.target.value)}\n        />\n        <TextField\n          fullWidth\n          label={t(\"account-settings.custom-trustline.textfield.issuer.label\")}\n          placeholder={t(\"account-settings.custom-trustline.textfield.issuer.placeholder\")}\n          margin=\"dense\"\n          name=\"asset-issuer\"\n          value={issuerPublicKey}\n          onChange={event => setIssuerPublicKey(event.target.value)}\n        />\n        <TextField\n          inputProps={{\n            pattern: \"^[0-9]*(.[0-9]+)?$\",\n            inputMode: \"decimal\"\n          }}\n          fullWidth\n          label={t(\"account-settings.custom-trustline.textfield.limit.label\")}\n          placeholder={t(\"account-settings.custom-trustline.textfield.limit.placeholder\")}\n          margin=\"dense\"\n          name=\"trust-limit\"\n          value={limit}\n          type=\"number\"\n          onChange={event => setLimit(event.target.value)}\n        />\n        {/* Not in the DialogBody's `actions` prop as it's not a fullscreen dialog */}\n        <DialogActionsBox preventMobileActionsBox>\n          <ActionButton onClick={props.onClose}>{t(\"account-settings.custom-trustline.action.cancel\")}</ActionButton>\n          <ActionButton\n            icon={<VerifiedUserIcon />}\n            loading={props.txCreationPending}\n            onClick={addCustomAsset}\n            type=\"primary\"\n          >\n            {isWidthMax450\n              ? t(\"account-settings.custom-trustline.action.trust.short\")\n              : t(\"account-settings.custom-trustline.action.trust.long\")}\n          </ActionButton>\n        </DialogActionsBox>\n      </form>\n    </DialogBody>\n  )\n}\n\nexport default React.memo(CustomTrustlineDialog)\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, AssetType, Horizon, Operation, Server, Transaction } from \"stellar-sdk\"\nimport Dialog from \"@material-ui/core/Dialog\"\nimport List from \"@material-ui/core/List\"\nimport ListItem from \"@material-ui/core/ListItem\"\nimport ListItemText from \"@material-ui/core/ListItemText\"\nimport { makeStyles } from \"@material-ui/core/styles\"\nimport AddIcon from \"@material-ui/icons/Add\"\nimport { Account } from \"~App/contexts/accounts\"\nimport { trackError } from \"~App/contexts/notifications\"\nimport * as routes from \"~App/routes\"\nimport { CompactDialogTransition } from \"~App/theme\"\nimport ButtonListItem from \"~Generic/components/ButtonListItem\"\nimport { AccountName } from \"~Generic/components/Fetchers\"\nimport { SearchField } from \"~Generic/components/FormFields\"\nimport MainTitle from \"~Generic/components/MainTitle\"\nimport ViewLoading from \"~Generic/components/ViewLoading\"\nimport { FixedSizeList } from \"~Generic/components/VirtualList\"\nimport { useTickerAssets, useWellKnownAccounts } from \"~Generic/hooks/stellar-ecosystem\"\nimport { useRouter } from \"~Generic/hooks/userinterface\"\nimport { AccountData } from \"~Generic/lib/account\"\nimport * as popularAssets from \"~Generic/lib/popularAssets\"\nimport { assetRecordToAsset, stringifyAsset } from \"~Generic/lib/stellar\"\nimport { createTransaction } from \"~Generic/lib/transaction\"\nimport { VerticalLayout } from \"~Layout/components/Box\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport TransactionSender from \"~Transaction/components/TransactionSender\"\nimport BalanceDetailsListItem from \"./BalanceDetailsListItem\"\nimport CustomTrustlineDialog from \"./CustomTrustline\"\nimport { AssetRecord } from \"~Generic/lib/stellar-ticker\"\n\nfunction assetRecordMatches(assetRecord: AssetRecord, search: string) {\n  search = search.toLowerCase()\n  return assetRecord.code.toLowerCase().startsWith(search) || assetRecord.name.toLowerCase().startsWith(search)\n}\n\nfunction issuerMatches(issuerDetails: AssetRecord[\"issuer_detail\"], search: string) {\n  search = search.toLowerCase()\n  return issuerDetails.name.toLowerCase().startsWith(search)\n}\n\nfunction assetToBalance(asset: Asset): Horizon.BalanceLineAsset {\n  return {\n    asset_code: asset.getCode(),\n    asset_issuer: asset.getIssuer(),\n    asset_type: asset.getAssetType() as AssetType.credit4 | AssetType.credit12,\n    balance: \"0\",\n    is_authorized: true,\n    is_authorized_to_maintain_liabilities: true,\n    last_modified_ledger: 0,\n    limit: \"0\",\n    buying_liabilities: \"0\",\n    selling_liabilities: \"0\",\n    is_clawback_enabled: false\n  }\n}\n\nfunction groupAssets(values: AssetRecord[], createKey: (arg: AssetRecord) => string) {\n  const map: { [issuer: string]: AssetRecord[] } = {}\n\n  for (const value of values) {\n    const key = createKey(value)\n    const existingValues = map[key]\n    existingValues ? existingValues.push(value) : (map[key] = [value])\n  }\n\n  return map\n}\n\ninterface PopularAssetsProps {\n  assets: Asset[]\n  onOpenAssetDetails: (asset: Asset) => void\n  testnet: boolean\n}\n\nconst PopularAssets = React.memo(function PopularAssets(props: PopularAssetsProps) {\n  return (\n    <>\n      {props.assets.map(asset => (\n        <BalanceDetailsListItem\n          key={stringifyAsset(asset)}\n          balance={assetToBalance(asset)}\n          hideBalance\n          onClick={() => props.onOpenAssetDetails(asset)}\n          testnet={props.testnet}\n        />\n      ))}\n    </>\n  )\n})\n\nconst searchResultRowHeight = 73\n\nconst useSearchResultStyles = makeStyles({\n  assetItem: {\n    borderRadius: \"0 !important\",\n    height: searchResultRowHeight\n  },\n  issuerItem: {\n    background: \"white\",\n    borderRadius: 8,\n    height: searchResultRowHeight\n  },\n  noResultItem: {\n    background: \"white\",\n    borderRadius: 8,\n    height: searchResultRowHeight\n  }\n})\n\nfunction createSearchResultRow(\n  account: Account,\n  assetsByIssuer: Record<string, AssetRecord[]>,\n  openAssetDetails: (asset: Asset) => void\n) {\n  // tslint:disable-next-line interface-over-type-literal\n  type AssetItemRecord = { type: \"asset\"; issuer: string; record: AssetRecord }\n  // tslint:disable-next-line interface-over-type-literal\n  type IssuerItemRecord = { type: \"issuer\"; issuer: string }\n\n  const itemRenderMap: (AssetItemRecord | IssuerItemRecord)[] = []\n\n  for (const issuer of Object.keys(assetsByIssuer)) {\n    itemRenderMap.push({\n      type: \"issuer\",\n      issuer\n    })\n    itemRenderMap.push(\n      ...assetsByIssuer[issuer].map(\n        (assetRecord: AssetRecord): AssetItemRecord => ({\n          type: \"asset\",\n          issuer,\n          record: assetRecord\n        })\n      )\n    )\n  }\n\n  function SearchResultRow(props: { index: number; style: React.CSSProperties }) {\n    const classes = useSearchResultStyles()\n    const item = itemRenderMap[props.index]\n    const { t } = useTranslation()\n\n    return (\n      <div style={props.style}>\n        <React.Suspense fallback={<ViewLoading />}>\n          {item.type === \"issuer\" ? (\n            <ListItem key={item.issuer} className={classes.issuerItem}>\n              <ListItemText\n                primary={\n                  item.issuer === \"native\" ? (\n                    \"stellar.org\"\n                  ) : (\n                    <AccountName publicKey={item.issuer} testnet={account.testnet} />\n                  )\n                }\n                secondary={\n                  assetsByIssuer[item.issuer].length === 1\n                    ? t(\"account.add-asset.item.issuer.secondary.one-asset\")\n                    : t(\"account.add-asset.item.issuer.secondary.more-than-one-asset\", {\n                        amount: assetsByIssuer[item.issuer].length\n                      })\n                }\n                secondaryTypographyProps={{\n                  style: { overflow: \"hidden\", textOverflow: \"ellipsis\" }\n                }}\n              />\n            </ListItem>\n          ) : null}\n          {item.type === \"asset\" ? (\n            <BalanceDetailsListItem\n              balance={assetToBalance(assetRecordToAsset(item.record))}\n              className={classes.assetItem}\n              hideBalance\n              onClick={() => openAssetDetails(assetRecordToAsset(item.record))}\n              style={{ paddingLeft: 32 }}\n              testnet={account.testnet}\n            />\n          ) : null}\n        </React.Suspense>\n      </div>\n    )\n  }\n\n  function NoResultRow() {\n    const classes = useSearchResultStyles()\n    const { t } = useTranslation()\n\n    return (\n      <ListItem key={0} className={classes.noResultItem}>\n        <ListItemText\n          primary={t(\"account.add-asset.item.no-result.primary\")}\n          secondary={t(\"account.add-asset.item.no-result.secondary\")}\n        />\n      </ListItem>\n    )\n  }\n\n  if (itemRenderMap.length > 0) {\n    SearchResultRow.count = itemRenderMap.length\n    return SearchResultRow\n  } else {\n    NoResultRow.count = 1\n    return NoResultRow\n  }\n}\n\nconst useAddAssetStyles = makeStyles({\n  grow: {\n    flexGrow: 1\n  },\n  list: {\n    marginTop: 16,\n    padding: 0\n  },\n  searchField: {\n    background: \"white\",\n    flexShrink: 0,\n    flexGrow: 0,\n    marginBottom: 16\n  },\n  searchFieldInput: {\n    fontSize: 16,\n    paddingTop: 14,\n    paddingBottom: 14\n  }\n})\n\ninterface AddAssetDialogProps {\n  account: Account\n  accountData: AccountData\n  horizon: Server\n  hpadding: number\n  itemHPadding: number\n  onClose: () => void\n  sendTransaction: (transaction: Transaction, signatureRequest?: null) => void\n}\n\nconst AddAssetDialog = React.memo(function AddAssetDialog(props: AddAssetDialogProps) {\n  const assets = props.account.testnet ? popularAssets.testnet : popularAssets.mainnet\n  const classes = useAddAssetStyles()\n  const containerRef = React.useRef<HTMLUListElement | null>(null)\n  const allAssets = useTickerAssets(props.account.testnet)\n  const router = useRouter()\n  const { t } = useTranslation()\n  const wellKnownAccounts = useWellKnownAccounts(props.account.testnet)\n  const [customTrustlineDialogOpen, setCustomTrustlineDialogOpen] = React.useState(false)\n  const [searchFieldValue, setSearchFieldValue] = React.useState(\"\")\n  const [txCreationPending, setTxCreationPending] = React.useState(false)\n\n  const openAssetDetails = React.useCallback(\n    (asset: Asset) => router.history.push(routes.assetDetails(props.account.id, stringifyAsset(asset))),\n    [router.history, props.account.id]\n  )\n\n  const openCustomTrustlineDialog = () => setCustomTrustlineDialogOpen(true)\n  const closeCustomTrustlineDialog = () => setCustomTrustlineDialogOpen(false)\n\n  const createAddAssetTransaction = async (asset: Asset, options: { limit?: string } = {}) => {\n    const operations = [Operation.changeTrust({ asset, limit: options.limit, withMuxing: true })]\n    return createTransaction(operations, {\n      accountData: props.accountData,\n      horizon: props.horizon,\n      walletAccount: props.account\n    })\n  }\n\n  const sendTransaction = async (createTransactionToSend: () => Promise<Transaction>) => {\n    try {\n      setTxCreationPending(true)\n      const transaction = await createTransactionToSend()\n      setTxCreationPending(false)\n      await props.sendTransaction(transaction)\n    } catch (error) {\n      setTxCreationPending(false)\n      trackError(error)\n    }\n  }\n\n  const isAssetAlreadyAdded = (asset: Asset) => {\n    return props.accountData.balances.some(\n      (balance: any) => balance.asset_code === asset.code && balance.asset_issuer === asset.issuer\n    )\n  }\n\n  const wellknownAccountMatches = React.useCallback(\n    (accountID: string, search: string) => {\n      const lowerCasedSearch = search.toLowerCase()\n      const record = wellKnownAccounts.lookup(accountID)\n\n      if (!record) {\n        return false\n      }\n      return (\n        record.domain.toLowerCase().includes(lowerCasedSearch) || record.name.toLowerCase().includes(lowerCasedSearch)\n      )\n    },\n    [wellKnownAccounts]\n  )\n\n  const notYetAddedAssets = assets.filter(asset => !isAssetAlreadyAdded(asset))\n\n  const onSearchFieldChange = React.useCallback((event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    setSearchFieldValue(event.target.value)\n  }, [])\n\n  const assetsByIssuer = React.useMemo(() => {\n    const filteredAssets = allAssets.filter(\n      assetRecord =>\n        assetRecordMatches(assetRecord, searchFieldValue) ||\n        issuerMatches(assetRecord.issuer_detail, searchFieldValue) ||\n        wellknownAccountMatches(assetRecord.issuer, searchFieldValue)\n    )\n\n    return groupAssets(filteredAssets, assetRecord => assetRecord.issuer)\n  }, [allAssets, searchFieldValue, wellknownAccountMatches])\n\n  const SearchResultRow = React.useMemo(() => createSearchResultRow(props.account, assetsByIssuer, openAssetDetails), [\n    props.account,\n    assetsByIssuer,\n    openAssetDetails\n  ])\n\n  return (\n    <DialogBody excessWidth={24} top={<MainTitle onBack={props.onClose} title={t(\"account.add-asset.title\")} />}>\n      <VerticalLayout grow margin=\"16px 0 0\">\n        <SearchField\n          autoFocus\n          className={classes.searchField}\n          inputProps={{\n            className: classes.searchFieldInput\n          }}\n          onChange={onSearchFieldChange}\n          value={searchFieldValue}\n          placeholder={t(\"account.add-asset.search-field.placeholder\")}\n        />\n        <List className={classes.list}>\n          <ButtonListItem onClick={openCustomTrustlineDialog}>\n            <AddIcon />\n            &nbsp;&nbsp;{t(\"account.add-asset.button.add-custom-asset.label\")}\n          </ButtonListItem>\n        </List>\n        <React.Suspense fallback={<ViewLoading />}>\n          {searchFieldValue ? (\n            <ul className={`${classes.list} ${classes.grow}`} ref={containerRef}>\n              <FixedSizeList\n                container={containerRef.current}\n                itemCount={SearchResultRow.count}\n                itemSize={searchResultRowHeight}\n              >\n                {SearchResultRow}\n              </FixedSizeList>\n            </ul>\n          ) : (\n            <List className={`${classes.list} ${classes.grow}`}>\n              <PopularAssets\n                assets={notYetAddedAssets}\n                onOpenAssetDetails={openAssetDetails}\n                testnet={props.account.testnet}\n              />\n            </List>\n          )}\n        </React.Suspense>\n      </VerticalLayout>\n      <Dialog\n        open={customTrustlineDialogOpen}\n        onClose={closeCustomTrustlineDialog}\n        TransitionComponent={CompactDialogTransition}\n      >\n        <React.Suspense fallback={<ViewLoading />}>\n          <CustomTrustlineDialog\n            account={props.account}\n            accountData={props.accountData}\n            createAddAssetTransaction={createAddAssetTransaction}\n            horizon={props.horizon}\n            onClose={closeCustomTrustlineDialog}\n            sendTransaction={sendTransaction}\n            txCreationPending={txCreationPending}\n          />\n        </React.Suspense>\n      </Dialog>\n    </DialogBody>\n  )\n})\n\nfunction ConnectedAddAssetDialog(props: Omit<AddAssetDialogProps, \"horizon\" | \"sendTransaction\">) {\n  return (\n    <TransactionSender account={props.account} onSubmissionCompleted={props.onClose}>\n      {({ horizon, sendTransaction }) => (\n        <AddAssetDialog {...props} horizon={horizon} sendTransaction={sendTransaction} />\n      )}\n    </TransactionSender>\n  )\n}\n\nexport default React.memo(ConnectedAddAssetDialog)\n","import BigNumber from \"big.js\"\nimport React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, Horizon, ServerApi } from \"stellar-sdk\"\nimport Dialog from \"@material-ui/core/Dialog\"\nimport Divider from \"@material-ui/core/Divider\"\nimport List from \"@material-ui/core/List\"\nimport AddIcon from \"@material-ui/icons/Add\"\nimport { Account } from \"~App/contexts/accounts\"\nimport * as routes from \"~App/routes\"\nimport { FullscreenDialogTransition } from \"~App/theme\"\nimport ButtonListItem from \"~Generic/components/ButtonListItem\"\nimport MainTitle from \"~Generic/components/MainTitle\"\nimport ViewLoading from \"~Generic/components/ViewLoading\"\nimport { useLiveAccountData, useLiveAccountOffers } from \"~Generic/hooks/stellar-subscriptions\"\nimport { useIsMobile, useRouter } from \"~Generic/hooks/userinterface\"\nimport { AccountData, BalanceLine } from \"~Generic/lib/account\"\nimport { sortBalances } from \"~Generic/lib/balances\"\nimport { matchesRoute } from \"~Generic/lib/routes\"\nimport { getAccountMinimumBalance, getSpendableBalance, stringifyAsset } from \"~Generic/lib/stellar\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport AddAssetDialog from \"./AddAssetDialog\"\nimport BalanceDetailsListItem from \"./BalanceDetailsListItem\"\n\nfunction isAssetMatchingBalance(asset: Asset, balance: BalanceLine): boolean {\n  return balance.asset_type === \"native\"\n    ? asset.isNative()\n    : balance.asset_code === asset.getCode() && balance.asset_issuer === asset.getIssuer()\n}\n\ninterface TrustedAssetsProps {\n  account: Account\n  accountData: AccountData\n  assets: Asset[]\n  hmargin: string | number\n  hpadding: string | number\n  onOpenAssetDetails: (asset: Asset) => void\n  openOffers: ServerApi.OfferRecord[]\n  olderOffersAvailable?: boolean\n}\n\nconst TrustedAssets = React.memo(function TrustedAssets(props: TrustedAssetsProps) {\n  return (\n    <>\n      {props.assets.map(asset => {\n        const balance = props.accountData.balances.find(bal => isAssetMatchingBalance(asset, bal))\n        const openOffers = props.openOffers.filter(\n          offer =>\n            (offer.buying.asset_code === asset.code && offer.buying.asset_issuer === asset.issuer) ||\n            (offer.selling.asset_code === asset.code && offer.selling.asset_issuer === asset.issuer)\n        )\n        const badgeCount = props.olderOffersAvailable && openOffers.length >= 10 ? \"10+\" : openOffers.length\n        return (\n          <BalanceDetailsListItem\n            key={stringifyAsset(asset)}\n            badgeCount={badgeCount}\n            balance={balance!}\n            onClick={() => props.onOpenAssetDetails(asset)}\n            style={{\n              paddingLeft: props.hpadding,\n              paddingRight: props.hpadding,\n              marginLeft: props.hmargin,\n              marginRight: props.hmargin\n            }}\n            testnet={props.account.testnet}\n          />\n        )\n      })}\n    </>\n  )\n})\n\ninterface NativeBalanceItemsProps {\n  account: Account\n  accountData: AccountData\n  balance: Horizon.BalanceLineNative\n  hmargin: string | number\n  hpadding: string | number\n  onOpenAssetDetails: (asset: Asset) => void\n}\n\nconst NativeBalanceItems = React.memo(function NativeBalanceItems(props: NativeBalanceItemsProps) {\n  return (\n    <>\n      <BalanceDetailsListItem\n        key=\"XLM\"\n        balance={props.balance}\n        onClick={() => props.onOpenAssetDetails(Asset.native())}\n        style={{\n          paddingLeft: props.hpadding,\n          paddingRight: props.hpadding,\n          marginLeft: props.hmargin,\n          marginRight: props.hmargin\n        }}\n        testnet={props.account.testnet}\n      />\n      <BalanceDetailsListItem\n        key=\"XLM:spendable\"\n        balance={{\n          ...props.balance,\n          balance: BigNumber(props.balance.balance).eq(0)\n            ? \"0\"\n            : getSpendableBalance(getAccountMinimumBalance(props.accountData), props.balance).toString()\n        }}\n        hideLogo\n        onClick={() => props.onOpenAssetDetails(Asset.native())}\n        spendableBalance\n        style={{\n          marginTop: -8,\n          paddingLeft: props.hpadding,\n          paddingRight: props.hpadding,\n          marginLeft: props.hmargin,\n          marginRight: props.hmargin\n        }}\n        testnet={props.account.testnet}\n      />\n    </>\n  )\n})\n\ninterface BalanceDetailsProps {\n  account: Account\n  onClose: () => void\n}\n\nfunction BalanceDetailsDialog(props: BalanceDetailsProps) {\n  const accountData = useLiveAccountData(props.account.accountID, props.account.testnet)\n  const { offers: openOrders, olderOffersAvailable } = useLiveAccountOffers(\n    props.account.accountID,\n    props.account.testnet\n  )\n  const isSmallScreen = useIsMobile()\n  const router = useRouter()\n  const { t } = useTranslation()\n\n  const openAddAssetDialog = React.useCallback(\n    () => router.history.push(routes.manageAccountAssets(props.account.id)),\n    [props.account.id, router.history]\n  )\n  const closeAddAssetDialog = React.useCallback(() => router.history.push(routes.balanceDetails(props.account.id)), [\n    props.account.id,\n    router.history\n  ])\n\n  const addAssetDialogOpen = matchesRoute(router.location.pathname, routes.manageAccountAssets(props.account.id))\n  const assetDetailsDialogOpen =\n    matchesRoute(router.location.pathname, routes.assetDetails(\"*\", \"*\")) &&\n    !matchesRoute(router.location.pathname, routes.assetDetails(\"*\", \"manage\"))\n\n  const openAssetDetails = (asset: Asset) =>\n    router.history.push(routes.assetDetails(props.account.id, stringifyAsset(asset)))\n\n  const trustedAssets = sortBalances(accountData.balances)\n    .filter((balance): balance is Horizon.BalanceLineAsset => balance.asset_type !== \"native\")\n    .map(balance => new Asset(balance.asset_code, balance.asset_issuer))\n\n  const nativeBalance = accountData.balances.find(\n    (balance): balance is Horizon.BalanceLineNative => balance.asset_type === \"native\"\n  )\n\n  const hpadding = isSmallScreen ? 0 : 8\n  const itemHPadding = 16\n  const itemHMargin = 0\n\n  return (\n    <DialogBody excessWidth={12} top={<MainTitle onBack={props.onClose} title={props.account.name} />}>\n      <List style={{ paddingLeft: hpadding, paddingRight: hpadding, margin: \"0 -8px\" }}>\n        <ButtonListItem\n          gutterBottom\n          onClick={openAddAssetDialog}\n          style={{\n            padding: `0 ${itemHPadding}px`,\n            marginLeft: itemHMargin,\n            marginRight: itemHMargin\n          }}\n        >\n          <AddIcon />\n          &nbsp;&nbsp;{t(\"account.balance-details.button.add-asset.label\")}\n        </ButtonListItem>\n        <TrustedAssets\n          account={props.account}\n          accountData={accountData}\n          assets={trustedAssets}\n          hmargin={itemHMargin}\n          hpadding={itemHPadding}\n          onOpenAssetDetails={openAssetDetails}\n          openOffers={openOrders}\n          olderOffersAvailable={olderOffersAvailable}\n        />\n      </List>\n      <Divider style={{ margin: \"16px 0\" }} />\n      <List style={{ paddingLeft: hpadding, paddingRight: hpadding, margin: \"0 -8px 8px\" }}>\n        {nativeBalance ? (\n          <NativeBalanceItems\n            account={props.account}\n            accountData={accountData}\n            balance={nativeBalance}\n            hmargin={itemHMargin}\n            hpadding={itemHPadding}\n            onOpenAssetDetails={openAssetDetails}\n          />\n        ) : null}\n      </List>\n      <Dialog\n        fullScreen\n        open={addAssetDialogOpen || assetDetailsDialogOpen}\n        onClose={closeAddAssetDialog}\n        TransitionComponent={FullscreenDialogTransition}\n      >\n        <React.Suspense fallback={<ViewLoading />}>\n          <AddAssetDialog\n            account={props.account}\n            accountData={accountData}\n            hpadding={hpadding}\n            itemHPadding={itemHPadding}\n            onClose={closeAddAssetDialog}\n          />\n        </React.Suspense>\n      </Dialog>\n    </DialogBody>\n  )\n}\n\nexport default React.memo(BalanceDetailsDialog)\n"],"names":["defaultItemKey","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","validateProps","List","size","createElement","PureComponent","validateSharedProps","FixedSizeList","Window.FixedSizeList","Asset","createTransaction","PopularAssets","AddAssetDialog","popularAssets.testnet","popularAssets.mainnet","routes.assetDetails","Operation","CustomTrustlineDialog","TrustedAssets","NativeBalanceItems","BigNumber","routes.manageAccountAssets","routes.balanceDetails"],"mappings":"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","x_google_ignoreList":[0,1]}