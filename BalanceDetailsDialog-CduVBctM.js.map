{"version":3,"file":"BalanceDetailsDialog-CduVBctM.js","sources":["../node_modules/memoize-one/dist/memoize-one.esm.js","../node_modules/react-window/dist/index.esm.js","../src/Generic/components/VirtualList.tsx","../src/Generic/lib/popularAssets.ts","../src/Assets/components/BalanceDetailsListItem.tsx","../src/Assets/components/CustomTrustline.tsx","../src/Assets/components/AddAssetDialog.tsx","../src/Assets/components/BalanceDetailsDialog.tsx"],"sourcesContent":["var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var _this$props2 = this.props,\n          itemCount = _this$props2.itemCount,\n          layout = _this$props2.layout;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\n\n      var scrollbarSize = 0;\n\n      if (this._outerRef) {\n        var outerRef = this._outerRef;\n\n        if (layout === 'vertical') {\n          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n        } else {\n          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n        }\n      }\n\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          initialScrollOffset = _this$props3.initialScrollOffset,\n          layout = _this$props3.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props4 = this.props,\n          direction = _this$props4.direction,\n          layout = _this$props4.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          className = _this$props5.className,\n          direction = _this$props5.direction,\n          height = _this$props5.height,\n          innerRef = _this$props5.innerRef,\n          innerElementType = _this$props5.innerElementType,\n          innerTagName = _this$props5.innerTagName,\n          itemCount = _this$props5.itemCount,\n          itemData = _this$props5.itemData,\n          _this$props5$itemKey = _this$props5.itemKey,\n          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,\n          layout = _this$props5.layout,\n          outerElementType = _this$props5.outerElementType,\n          outerTagName = _this$props5.outerTagName,\n          style = _this$props5.style,\n          useIsScrolling = _this$props5.useIsScrolling,\n          width = _this$props5.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props6 = this.props,\n          itemCount = _this$props6.itemCount,\n          overscanCount = _this$props6.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n","import React from \"react\"\nimport * as Window from \"react-window\"\n\ninterface FixedSizeListProps {\n  children: React.FunctionComponent<Window.ListChildComponentProps>\n  container: HTMLElement | null\n  itemCount: number\n  itemSize: number\n}\n\nexport function FixedSizeList(props: FixedSizeListProps) {\n  if (!props.container) {\n    return null\n  }\n\n  const height = props.container.clientHeight\n  const width = props.container.clientWidth\n\n  return (\n    <Window.FixedSizeList height={height} itemCount={props.itemCount} itemSize={props.itemSize} width={width}>\n      {props.children}\n    </Window.FixedSizeList>\n  )\n}\n","import { Asset } from \"@stellar/stellar-sdk\"\n\nexport const mainnet = [\n  new Asset(\"EURMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"MTLAP\", \"GCNVDZIHGX473FEI7IXCUAEXUJ4BGCKEMHF36VYP5EMS7PX2QBLAMTLA\"),\n  new Asset(\"MTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"MTLRECT\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"BTCMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"SATSMTL\", \"GACKTN5DAZGWXRWB2WLM6OPBDHAMT6SJNGLJZPQMEZBUR4JUGBX2UK7V\"),\n  new Asset(\"USDM\", \"GDHDC4GBNPMENZAOBB4NCQ25TGZPDRK6ZGWUGSI22TVFATOLRPSUUSDM\"),\n  new Asset(\"USDC\", \"GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN\")\n]\n\nexport const testnet = [\n  new Asset(\"USD\", \"GCKFBEIYV2U22IO2BJ4KVJOIP7XPWQGQFKKWXR6DOSJBV7STMAQSMTGG\"),\n  new Asset(\"SRT\", \"GCDNJUBQSX7AJWLJACMJ7I4BC3Z47BQUTMHEICZLE6MU4KQBRYG5JY6B\")\n]\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport Badge from \"@material-ui/core/Badge\"\nimport ListItem from \"@material-ui/core/ListItem\"\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\"\nimport ListItemText from \"@material-ui/core/ListItemText\"\nimport { makeStyles } from \"@material-ui/core/styles\"\nimport { useAssetMetadata } from \"~Generic/hooks/stellar\"\nimport { balancelineToAsset } from \"~Generic/lib/stellar\"\nimport { breakpoints } from \"~App/theme\"\nimport { SingleBalance } from \"~Account/components/AccountBalances\"\nimport { BalanceLine } from \"~Generic/lib/account\"\nimport { AccountName } from \"~Generic/components/Fetchers\"\nimport AssetLogo from \"./AssetLogo\"\n\nexport const actionsSize = 36\n\nconst useBalanceItemStyles = makeStyles({\n  clickable: {},\n  icon: {\n    [breakpoints.down(350)]: {\n      minWidth: 48\n    }\n  },\n  logo: {\n    [breakpoints.down(350)]: {\n      width: 36,\n      height: 36\n    }\n  },\n  logoHidden: {\n    visibility: \"hidden\"\n  },\n  badge: {\n    top: 4,\n    right: 4,\n    boxShadow: \"0 0 3px 1px black\"\n  },\n  mainListItemText: {\n    flex: \"1 1 auto\",\n    whiteSpace: \"nowrap\"\n  },\n  mainListItemTextPrimaryTypography: {\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\",\n\n    [breakpoints.down(400)]: {\n      fontSize: 15\n    },\n    [breakpoints.down(350)]: {\n      fontSize: 13\n    }\n  },\n  mainListItemTextSecondaryTypography: {\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\",\n\n    [breakpoints.down(400)]: {\n      fontSize: 14\n    },\n    [breakpoints.down(350)]: {\n      fontSize: 12\n    }\n  },\n  balanceListItemText: {\n    flex: \"1 0 auto\",\n    marginLeft: 8,\n    textAlign: \"right\"\n  },\n  balanceText: {\n    fontSize: \"140%\",\n\n    [breakpoints.down(350)]: {\n      fontSize: \"120%\"\n    }\n  },\n  actions: {\n    flex: \"0 0 auto\",\n    marginLeft: 4,\n    marginRight: -16,\n    width: 48\n  }\n})\n\ninterface BalanceListItemProps {\n  badgeCount?: number | string\n  balance: BalanceLine\n  className?: string\n  hideBalance?: boolean\n  hideLogo?: boolean\n  onClick?: () => void\n  spendableBalance?: boolean\n  style?: React.CSSProperties\n  testnet: boolean\n  isOwnAsset?: boolean\n}\n\nfunction BalanceListItem(props: BalanceListItemProps) {\n  const classes = useBalanceItemStyles()\n  const className = `${props.className || \"\"} ${props.onClick ? classes.clickable : \"\"}`\n\n  const asset = React.useMemo(() => balancelineToAsset(props.balance), [props.balance])\n  const assetMetadata = useAssetMetadata(asset, props.testnet)\n  const { t } = useTranslation()\n\n  const balance = React.useMemo(() => {\n    if (props.hideBalance) return null\n    return <SingleBalance assetCode={\"\"} balance={props.balance.balance} showInfinity={props.isOwnAsset} />\n  }, [props.balance.balance, props.hideBalance])\n\n  if (props.balance.asset_type === \"native\") {\n    return (\n      <ListItem\n        button={Boolean(props.onClick) as any}\n        className={className}\n        onClick={props.onClick}\n        style={props.style}\n      >\n        <ListItemIcon className={classes.icon}>\n          <AssetLogo\n            asset={asset}\n            className={`${classes.logo} ${props.hideLogo ? classes.logoHidden : \"\"}`}\n            testnet={props.testnet}\n          />\n        </ListItemIcon>\n        <ListItemText\n          classes={{\n            root: classes.mainListItemText,\n            primary: classes.mainListItemTextPrimaryTypography,\n            secondary: classes.mainListItemTextSecondaryTypography\n          }}\n          primary={\n            props.spendableBalance\n              ? t(\"account.balance-details.item.spendable-balance.primary\")\n              : \"Stellar Lumens (XLM)\"\n          }\n          secondary={props.spendableBalance ? undefined : \"stellar.org\"}\n        />\n        <ListItemText\n          classes={{\n            root: classes.balanceListItemText,\n            primary: classes.balanceText\n          }}\n          primary={balance}\n        />\n      </ListItem>\n    )\n  }\n\n  const assetName = (assetMetadata && assetMetadata.name) || props.balance.asset_code\n  const title =\n    assetName !== props.balance.asset_code ? `${assetName} (${props.balance.asset_code})` : props.balance.asset_code\n\n  return (\n    <ListItem button={Boolean(props.onClick) as any} className={className} onClick={props.onClick} style={props.style}>\n      <ListItemIcon className={classes.icon}>\n        <Badge badgeContent={props.badgeCount} classes={{ badge: classes.badge }} color=\"primary\">\n          <AssetLogo\n            asset={asset}\n            className={`${classes.logo} ${props.hideLogo ? classes.logoHidden : \"\"}`}\n            dark\n            testnet={props.testnet}\n          />\n        </Badge>\n      </ListItemIcon>\n      <ListItemText\n        className={classes.mainListItemText}\n        classes={{\n          primary: classes.mainListItemTextPrimaryTypography,\n          secondary: classes.mainListItemTextSecondaryTypography\n        }}\n        primary={title}\n        secondary={<AccountName publicKey={props.balance.asset_issuer} testnet={props.testnet} />}\n      />\n      <ListItemText\n        className={classes.balanceListItemText}\n        primary={balance}\n        primaryTypographyProps={{ className: classes.balanceText }}\n      />\n    </ListItem>\n  )\n}\n\nexport default React.memo(BalanceListItem)\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, Horizon, Transaction } from \"@stellar/stellar-sdk\"\nimport useMediaQuery from \"@material-ui/core/useMediaQuery\"\nimport TextField from \"@material-ui/core/TextField\"\nimport VerifiedUserIcon from \"@material-ui/icons/VerifiedUser\"\nimport { Account } from \"~App/contexts/accounts\"\nimport { AccountData } from \"~Generic/lib/account\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport { ActionButton, DialogActionsBox } from \"~Generic/components/DialogActions\"\nimport MainTitle from \"~Generic/components/MainTitle\"\n\ninterface Props {\n  account: Account\n  accountData: AccountData\n  createAddAssetTransaction: (asset: Asset, options: { limit?: string }) => any\n  horizon: Horizon.Server\n  onClose: () => void\n  sendTransaction: (createTransactionToSend: () => Promise<Transaction>) => any\n  txCreationPending: boolean\n}\n\nfunction CustomTrustlineDialog(props: Props) {\n  const [code, setCode] = React.useState(\"\")\n  const [issuerPublicKey, setIssuerPublicKey] = React.useState(\"\")\n  const [limit, setLimit] = React.useState(\"\")\n  const isWidthMax450 = useMediaQuery(\"(max-width:450px)\")\n  const { t } = useTranslation()\n\n  const createTransaction = () =>\n    props.createAddAssetTransaction(new Asset(code, issuerPublicKey), { limit: limit || undefined })\n  const addCustomAsset = () => props.sendTransaction(createTransaction)\n\n  return (\n    <DialogBody\n      top={<MainTitle hideBackButton onBack={props.onClose} title={t(\"account-settings.custom-trustline.title\")} />}\n    >\n      <form noValidate style={{ display: \"block\", width: \"100%\" }}>\n        <TextField\n          label={t(\"account-settings.custom-trustline.textfield.code.label\")}\n          placeholder=\"EURT, USDT, BTC, ...\"\n          autoFocus={import.meta.env.VITE_PLATFORM !== \"ios\"}\n          margin=\"dense\"\n          name=\"asset-code\"\n          value={code}\n          onChange={event => setCode(event.target.value)}\n        />\n        <TextField\n          fullWidth\n          label={t(\"account-settings.custom-trustline.textfield.issuer.label\")}\n          placeholder={t(\"account-settings.custom-trustline.textfield.issuer.placeholder\")}\n          margin=\"dense\"\n          name=\"asset-issuer\"\n          value={issuerPublicKey}\n          onChange={event => setIssuerPublicKey(event.target.value)}\n        />\n        <TextField\n          inputProps={{\n            pattern: \"^[0-9]*(.[0-9]+)?$\",\n            inputMode: \"decimal\"\n          }}\n          fullWidth\n          label={t(\"account-settings.custom-trustline.textfield.limit.label\")}\n          placeholder={t(\"account-settings.custom-trustline.textfield.limit.placeholder\")}\n          margin=\"dense\"\n          name=\"trust-limit\"\n          value={limit}\n          type=\"number\"\n          onChange={event => setLimit(event.target.value)}\n        />\n        {/* Not in the DialogBody's `actions` prop as it's not a fullscreen dialog */}\n        <DialogActionsBox preventMobileActionsBox>\n          <ActionButton onClick={props.onClose}>{t(\"account-settings.custom-trustline.action.cancel\")}</ActionButton>\n          <ActionButton\n            icon={<VerifiedUserIcon />}\n            loading={props.txCreationPending}\n            onClick={addCustomAsset}\n            type=\"primary\"\n          >\n            {isWidthMax450\n              ? t(\"account-settings.custom-trustline.action.trust.short\")\n              : t(\"account-settings.custom-trustline.action.trust.long\")}\n          </ActionButton>\n        </DialogActionsBox>\n      </form>\n    </DialogBody>\n  )\n}\n\nexport default React.memo(CustomTrustlineDialog)\n","import React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, AssetType, Horizon, Operation, Transaction } from \"@stellar/stellar-sdk\"\nimport Dialog from \"@material-ui/core/Dialog\"\nimport List from \"@material-ui/core/List\"\nimport ListItem from \"@material-ui/core/ListItem\"\nimport ListItemText from \"@material-ui/core/ListItemText\"\nimport { makeStyles } from \"@material-ui/core/styles\"\nimport AddIcon from \"@material-ui/icons/Add\"\nimport { Account } from \"~App/contexts/accounts\"\nimport { trackError } from \"~App/contexts/notifications\"\nimport * as routes from \"~App/routes\"\nimport { CompactDialogTransition } from \"~App/theme\"\nimport ButtonListItem from \"~Generic/components/ButtonListItem\"\nimport { AccountName } from \"~Generic/components/Fetchers\"\nimport { SearchField } from \"~Generic/components/FormFields\"\nimport MainTitle from \"~Generic/components/MainTitle\"\nimport ViewLoading from \"~Generic/components/ViewLoading\"\nimport { FixedSizeList } from \"~Generic/components/VirtualList\"\nimport { useTickerAssets, useWellKnownAccounts } from \"~Generic/hooks/stellar-ecosystem\"\nimport { useRouter } from \"~Generic/hooks/userinterface\"\nimport { AccountData } from \"~Generic/lib/account\"\nimport * as popularAssets from \"~Generic/lib/popularAssets\"\nimport { assetRecordToAsset, stringifyAsset } from \"~Generic/lib/stellar\"\nimport { createTransaction } from \"~Generic/lib/transaction\"\nimport { VerticalLayout } from \"~Layout/components/Box\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport TransactionSender from \"~Transaction/components/TransactionSender\"\nimport BalanceDetailsListItem from \"./BalanceDetailsListItem\"\nimport CustomTrustlineDialog from \"./CustomTrustline\"\nimport { AssetRecord } from \"~Generic/lib/stellar-ticker\"\n\nfunction assetRecordMatches(assetRecord: AssetRecord, search: string) {\n  search = search.toLowerCase()\n  return assetRecord.code.toLowerCase().startsWith(search) || assetRecord.name.toLowerCase().startsWith(search)\n}\n\nfunction issuerMatches(issuerDetails: AssetRecord[\"issuer_detail\"], search: string) {\n  search = search.toLowerCase()\n  return issuerDetails.name.toLowerCase().startsWith(search)\n}\n\nfunction assetToBalance(asset: Asset): Horizon.BalanceLineAsset {\n  return {\n    asset_code: asset.getCode(),\n    asset_issuer: asset.getIssuer(),\n    asset_type: asset.getAssetType() as AssetType.credit4 | AssetType.credit12,\n    balance: \"0\",\n    is_authorized: true,\n    is_authorized_to_maintain_liabilities: true,\n    last_modified_ledger: 0,\n    limit: \"0\",\n    buying_liabilities: \"0\",\n    selling_liabilities: \"0\",\n    is_clawback_enabled: false\n  }\n}\n\nfunction groupAssets(values: AssetRecord[], createKey: (arg: AssetRecord) => string) {\n  const map: { [issuer: string]: AssetRecord[] } = {}\n\n  for (const value of values) {\n    const key = createKey(value)\n    const existingValues = map[key]\n    existingValues ? existingValues.push(value) : (map[key] = [value])\n  }\n\n  return map\n}\n\ninterface PopularAssetsProps {\n  assets: Asset[]\n  onOpenAssetDetails: (asset: Asset) => void\n  testnet: boolean\n}\n\nconst PopularAssets = React.memo(function PopularAssets(props: PopularAssetsProps) {\n  return (\n    <>\n      {props.assets.map(asset => (\n        <BalanceDetailsListItem\n          key={stringifyAsset(asset)}\n          balance={assetToBalance(asset)}\n          hideBalance\n          onClick={() => props.onOpenAssetDetails(asset)}\n          testnet={props.testnet}\n        />\n      ))}\n    </>\n  )\n})\n\nconst searchResultRowHeight = 73\n\nconst useSearchResultStyles = makeStyles({\n  assetItem: {\n    borderRadius: \"0 !important\",\n    height: searchResultRowHeight\n  },\n  issuerItem: {\n    background: \"white\",\n    borderRadius: 8,\n    height: searchResultRowHeight\n  },\n  noResultItem: {\n    background: \"white\",\n    borderRadius: 8,\n    height: searchResultRowHeight\n  }\n})\n\nfunction createSearchResultRow(\n  account: Account,\n  assetsByIssuer: Record<string, AssetRecord[]>,\n  openAssetDetails: (asset: Asset) => void\n) {\n  // tslint:disable-next-line interface-over-type-literal\n  type AssetItemRecord = { type: \"asset\"; issuer: string; record: AssetRecord }\n  // tslint:disable-next-line interface-over-type-literal\n  type IssuerItemRecord = { type: \"issuer\"; issuer: string }\n\n  const itemRenderMap: (AssetItemRecord | IssuerItemRecord)[] = []\n\n  for (const issuer of Object.keys(assetsByIssuer)) {\n    itemRenderMap.push({\n      type: \"issuer\",\n      issuer\n    })\n    itemRenderMap.push(\n      ...assetsByIssuer[issuer].map(\n        (assetRecord: AssetRecord): AssetItemRecord => ({\n          type: \"asset\",\n          issuer,\n          record: assetRecord\n        })\n      )\n    )\n  }\n\n  function SearchResultRow(props: { index: number; style: React.CSSProperties }) {\n    const classes = useSearchResultStyles()\n    const item = itemRenderMap[props.index]\n    const { t } = useTranslation()\n\n    return (\n      <div style={props.style}>\n        <React.Suspense fallback={<ViewLoading />}>\n          {item.type === \"issuer\" ? (\n            <ListItem key={item.issuer} className={classes.issuerItem}>\n              <ListItemText\n                primary={\n                  item.issuer === \"native\" ? (\n                    \"stellar.org\"\n                  ) : (\n                    <AccountName publicKey={item.issuer} testnet={account.testnet} />\n                  )\n                }\n                secondary={\n                  assetsByIssuer[item.issuer].length === 1\n                    ? t(\"account.add-asset.item.issuer.secondary.one-asset\")\n                    : t(\"account.add-asset.item.issuer.secondary.more-than-one-asset\", {\n                        amount: assetsByIssuer[item.issuer].length\n                      })\n                }\n                secondaryTypographyProps={{\n                  style: { overflow: \"hidden\", textOverflow: \"ellipsis\" }\n                }}\n              />\n            </ListItem>\n          ) : null}\n          {item.type === \"asset\" ? (\n            <BalanceDetailsListItem\n              balance={assetToBalance(assetRecordToAsset(item.record))}\n              className={classes.assetItem}\n              hideBalance\n              onClick={() => openAssetDetails(assetRecordToAsset(item.record))}\n              style={{ paddingLeft: 32 }}\n              testnet={account.testnet}\n            />\n          ) : null}\n        </React.Suspense>\n      </div>\n    )\n  }\n\n  function NoResultRow() {\n    const classes = useSearchResultStyles()\n    const { t } = useTranslation()\n\n    return (\n      <ListItem key={0} className={classes.noResultItem}>\n        <ListItemText\n          primary={t(\"account.add-asset.item.no-result.primary\")}\n          secondary={t(\"account.add-asset.item.no-result.secondary\")}\n        />\n      </ListItem>\n    )\n  }\n\n  if (itemRenderMap.length > 0) {\n    SearchResultRow.count = itemRenderMap.length\n    return SearchResultRow\n  } else {\n    NoResultRow.count = 1\n    return NoResultRow\n  }\n}\n\nconst useAddAssetStyles = makeStyles({\n  grow: {\n    flexGrow: 1\n  },\n  list: {\n    marginTop: 16,\n    padding: 0\n  },\n  searchField: {\n    background: \"white\",\n    flexShrink: 0,\n    flexGrow: 0,\n    marginBottom: 16\n  },\n  searchFieldInput: {\n    fontSize: 16,\n    paddingTop: 14,\n    paddingBottom: 14\n  }\n})\n\ninterface AddAssetDialogProps {\n  account: Account\n  accountData: AccountData\n  horizon: Horizon.Server\n  hpadding: number\n  itemHPadding: number\n  onClose: () => void\n  sendTransaction: (transaction: Transaction, signatureRequest?: null) => void\n}\n\nconst AddAssetDialog = React.memo(function AddAssetDialog(props: AddAssetDialogProps) {\n  const assets = props.account.testnet ? popularAssets.testnet : popularAssets.mainnet\n  const classes = useAddAssetStyles()\n  const containerRef = React.useRef<HTMLUListElement | null>(null)\n  const allAssets = useTickerAssets(props.account.testnet)\n  const router = useRouter()\n  const { t } = useTranslation()\n  const wellKnownAccounts = useWellKnownAccounts(props.account.testnet)\n  const [customTrustlineDialogOpen, setCustomTrustlineDialogOpen] = React.useState(false)\n  const [searchFieldValue, setSearchFieldValue] = React.useState(\"\")\n  const [txCreationPending, setTxCreationPending] = React.useState(false)\n\n  const openAssetDetails = React.useCallback(\n    (asset: Asset) => router.history.push(routes.assetDetails(props.account.id, stringifyAsset(asset))),\n    [router.history, props.account.id]\n  )\n\n  const openCustomTrustlineDialog = () => setCustomTrustlineDialogOpen(true)\n  const closeCustomTrustlineDialog = () => setCustomTrustlineDialogOpen(false)\n\n  const createAddAssetTransaction = async (asset: Asset, options: { limit?: string } = {}) => {\n    const operations = [Operation.changeTrust({ asset, limit: options.limit, withMuxing: true })]\n    return createTransaction(operations, {\n      accountData: props.accountData,\n      horizon: props.horizon,\n      walletAccount: props.account\n    })\n  }\n\n  const sendTransaction = async (createTransactionToSend: () => Promise<Transaction>) => {\n    try {\n      setTxCreationPending(true)\n      const transaction = await createTransactionToSend()\n      setTxCreationPending(false)\n      await props.sendTransaction(transaction)\n    } catch (error) {\n      setTxCreationPending(false)\n      trackError(error)\n    }\n  }\n\n  const isAssetAlreadyAdded = (asset: Asset) => {\n    return props.accountData.balances.some(\n      (balance: any) => balance.asset_code === asset.code && balance.asset_issuer === asset.issuer\n    )\n  }\n\n  const wellknownAccountMatches = React.useCallback(\n    (accountID: string, search: string) => {\n      const lowerCasedSearch = search.toLowerCase()\n      const record = wellKnownAccounts.lookup(accountID)\n\n      if (!record) {\n        return false\n      }\n      return (\n        record.domain.toLowerCase().includes(lowerCasedSearch) || record.name.toLowerCase().includes(lowerCasedSearch)\n      )\n    },\n    [wellKnownAccounts]\n  )\n\n  const notYetAddedAssets = assets.filter(asset => !isAssetAlreadyAdded(asset))\n\n  const onSearchFieldChange = React.useCallback((event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    setSearchFieldValue(event.target.value)\n  }, [])\n\n  const assetsByIssuer = React.useMemo(() => {\n    const filteredAssets = allAssets.filter(\n      assetRecord =>\n        assetRecordMatches(assetRecord, searchFieldValue) ||\n        issuerMatches(assetRecord.issuer_detail, searchFieldValue) ||\n        wellknownAccountMatches(assetRecord.issuer, searchFieldValue)\n    )\n\n    return groupAssets(filteredAssets, assetRecord => assetRecord.issuer)\n  }, [allAssets, searchFieldValue, wellknownAccountMatches])\n\n  const SearchResultRow = React.useMemo(() => createSearchResultRow(props.account, assetsByIssuer, openAssetDetails), [\n    props.account,\n    assetsByIssuer,\n    openAssetDetails\n  ])\n\n  return (\n    <DialogBody excessWidth={24} top={<MainTitle onBack={props.onClose} title={t(\"account.add-asset.title\")} />}>\n      <VerticalLayout grow margin=\"16px 0 0\">\n        <SearchField\n          autoFocus\n          className={classes.searchField}\n          inputProps={{\n            className: classes.searchFieldInput\n          }}\n          onChange={onSearchFieldChange}\n          value={searchFieldValue}\n          placeholder={t(\"account.add-asset.search-field.placeholder\")}\n        />\n        <List className={classes.list}>\n          <ButtonListItem onClick={openCustomTrustlineDialog}>\n            <AddIcon />\n            &nbsp;&nbsp;{t(\"account.add-asset.button.add-custom-asset.label\")}\n          </ButtonListItem>\n        </List>\n        <React.Suspense fallback={<ViewLoading />}>\n          {searchFieldValue ? (\n            <ul className={`${classes.list} ${classes.grow}`} ref={containerRef}>\n              <FixedSizeList\n                container={containerRef.current}\n                itemCount={SearchResultRow.count}\n                itemSize={searchResultRowHeight}\n              >\n                {SearchResultRow}\n              </FixedSizeList>\n            </ul>\n          ) : (\n            <List className={`${classes.list} ${classes.grow}`}>\n              <PopularAssets\n                assets={notYetAddedAssets}\n                onOpenAssetDetails={openAssetDetails}\n                testnet={props.account.testnet}\n              />\n            </List>\n          )}\n        </React.Suspense>\n      </VerticalLayout>\n      <Dialog\n        open={customTrustlineDialogOpen}\n        onClose={closeCustomTrustlineDialog}\n        TransitionComponent={CompactDialogTransition}\n      >\n        <React.Suspense fallback={<ViewLoading />}>\n          <CustomTrustlineDialog\n            account={props.account}\n            accountData={props.accountData}\n            createAddAssetTransaction={createAddAssetTransaction}\n            horizon={props.horizon}\n            onClose={closeCustomTrustlineDialog}\n            sendTransaction={sendTransaction}\n            txCreationPending={txCreationPending}\n          />\n        </React.Suspense>\n      </Dialog>\n    </DialogBody>\n  )\n})\n\nfunction ConnectedAddAssetDialog(props: Omit<AddAssetDialogProps, \"horizon\" | \"sendTransaction\">) {\n  return (\n    <TransactionSender account={props.account} onSubmissionCompleted={props.onClose}>\n      {({ horizon, sendTransaction }) => (\n        <AddAssetDialog {...props} horizon={horizon} sendTransaction={sendTransaction} />\n      )}\n    </TransactionSender>\n  )\n}\n\nexport default React.memo(ConnectedAddAssetDialog)\n","import BigNumber from \"big.js\"\nimport React from \"react\"\nimport { useTranslation } from \"react-i18next\"\nimport { Asset, Horizon } from \"@stellar/stellar-sdk\"\nimport Dialog from \"@material-ui/core/Dialog\"\nimport Divider from \"@material-ui/core/Divider\"\nimport List from \"@material-ui/core/List\"\nimport AddIcon from \"@material-ui/icons/Add\"\nimport { Account } from \"~App/contexts/accounts\"\nimport * as routes from \"~App/routes\"\nimport { FullscreenDialogTransition } from \"~App/theme\"\nimport ButtonListItem from \"~Generic/components/ButtonListItem\"\nimport MainTitle from \"~Generic/components/MainTitle\"\nimport ViewLoading from \"~Generic/components/ViewLoading\"\nimport { useLiveAccountData, useLiveAccountOffers } from \"~Generic/hooks/stellar-subscriptions\"\nimport { useIsMobile, useRouter } from \"~Generic/hooks/userinterface\"\nimport { AccountData, BalanceLine } from \"~Generic/lib/account\"\nimport { sortBalances } from \"~Generic/lib/balances\"\nimport { matchesRoute } from \"~Generic/lib/routes\"\nimport { getAccountMinimumBalance, getSpendableBalance, stringifyAsset } from \"~Generic/lib/stellar\"\nimport DialogBody from \"~Layout/components/DialogBody\"\nimport AddAssetDialog from \"./AddAssetDialog\"\nimport BalanceDetailsListItem from \"./BalanceDetailsListItem\"\n\nfunction isAssetMatchingBalance(asset: Asset, balance: BalanceLine): boolean {\n  return balance.asset_type === \"native\"\n    ? asset.isNative()\n    : balance.asset_code === asset.getCode() && balance.asset_issuer === asset.getIssuer()\n}\n\ninterface TrustedAssetsProps {\n  account: Account\n  accountData: AccountData\n  assets: Asset[]\n  hmargin: string | number\n  hpadding: string | number\n  onOpenAssetDetails: (asset: Asset) => void\n  openOffers: Horizon.ServerApi.OfferRecord[]\n  olderOffersAvailable?: boolean\n}\n\nconst TrustedAssets = React.memo(function TrustedAssets(props: TrustedAssetsProps) {\n  return (\n    <>\n      {props.assets.map(asset => {\n        const balance = props.accountData.balances.find(bal => isAssetMatchingBalance(asset, bal))\n        const openOffers = props.openOffers.filter(\n          offer =>\n            (offer.buying.asset_code === asset.code && offer.buying.asset_issuer === asset.issuer) ||\n            (offer.selling.asset_code === asset.code && offer.selling.asset_issuer === asset.issuer)\n        )\n        const badgeCount = props.olderOffersAvailable && openOffers.length >= 10 ? \"10+\" : openOffers.length\n        return (\n          <BalanceDetailsListItem\n            key={stringifyAsset(asset)}\n            badgeCount={badgeCount}\n            balance={balance!}\n            onClick={() => props.onOpenAssetDetails(asset)}\n            style={{\n              paddingLeft: props.hpadding,\n              paddingRight: props.hpadding,\n              marginLeft: props.hmargin,\n              marginRight: props.hmargin\n            }}\n            testnet={props.account.testnet}\n            isOwnAsset={props.account.accountID === asset.getIssuer()}\n          />\n        )\n      })}\n    </>\n  )\n})\n\ninterface NativeBalanceItemsProps {\n  account: Account\n  accountData: AccountData\n  balance: Horizon.HorizonApi.BalanceLineNative\n  hmargin: string | number\n  hpadding: string | number\n  onOpenAssetDetails: (asset: Asset) => void\n}\n\nconst NativeBalanceItems = React.memo(function NativeBalanceItems(props: NativeBalanceItemsProps) {\n  return (\n    <>\n      <BalanceDetailsListItem\n        key=\"XLM\"\n        balance={props.balance}\n        onClick={() => props.onOpenAssetDetails(Asset.native())}\n        style={{\n          paddingLeft: props.hpadding,\n          paddingRight: props.hpadding,\n          marginLeft: props.hmargin,\n          marginRight: props.hmargin\n        }}\n        testnet={props.account.testnet}\n      />\n      <BalanceDetailsListItem\n        key=\"XLM:spendable\"\n        balance={{\n          ...props.balance,\n          balance: BigNumber(props.balance.balance).eq(0)\n            ? \"0\"\n            : getSpendableBalance(getAccountMinimumBalance(props.accountData), props.balance).toString()\n        }}\n        hideLogo\n        onClick={() => props.onOpenAssetDetails(Asset.native())}\n        spendableBalance\n        style={{\n          marginTop: -8,\n          paddingLeft: props.hpadding,\n          paddingRight: props.hpadding,\n          marginLeft: props.hmargin,\n          marginRight: props.hmargin\n        }}\n        testnet={props.account.testnet}\n      />\n    </>\n  )\n})\n\ninterface BalanceDetailsProps {\n  account: Account\n  onClose: () => void\n}\n\nfunction BalanceDetailsDialog(props: BalanceDetailsProps) {\n  const accountData = useLiveAccountData(props.account.accountID, props.account.testnet)\n  const { offers: openOrders, olderOffersAvailable } = useLiveAccountOffers(\n    props.account.accountID,\n    props.account.testnet\n  )\n  const isSmallScreen = useIsMobile()\n  const router = useRouter()\n  const { t } = useTranslation()\n\n  const openAddAssetDialog = React.useCallback(\n    () => router.history.push(routes.manageAccountAssets(props.account.id)),\n    [props.account.id, router.history]\n  )\n  const closeAddAssetDialog = React.useCallback(() => router.history.push(routes.balanceDetails(props.account.id)), [\n    props.account.id,\n    router.history\n  ])\n\n  const addAssetDialogOpen = matchesRoute(router.location.pathname, routes.manageAccountAssets(props.account.id))\n  const assetDetailsDialogOpen =\n    matchesRoute(router.location.pathname, routes.assetDetails(\"*\", \"*\")) &&\n    !matchesRoute(router.location.pathname, routes.assetDetails(\"*\", \"manage\"))\n\n  const openAssetDetails = (asset: Asset) =>\n    router.history.push(routes.assetDetails(props.account.id, stringifyAsset(asset)))\n\n  const trustedAssets = sortBalances(accountData.balances)\n    .filter((balance): balance is Horizon.HorizonApi.BalanceLineAsset => balance.asset_type !== \"native\")\n    .map(balance => new Asset(balance.asset_code, balance.asset_issuer))\n\n  const nativeBalance = accountData.balances.find(\n    (balance): balance is Horizon.HorizonApi.BalanceLineNative => balance.asset_type === \"native\"\n  )\n\n  const hpadding = isSmallScreen ? 0 : 8\n  const itemHPadding = 16\n  const itemHMargin = 0\n\n  return (\n    <DialogBody excessWidth={12} top={<MainTitle onBack={props.onClose} title={props.account.name} />}>\n      <List style={{ paddingLeft: hpadding, paddingRight: hpadding, margin: \"0 -8px\" }}>\n        <ButtonListItem\n          gutterBottom\n          onClick={openAddAssetDialog}\n          style={{\n            padding: `0 ${itemHPadding}px`,\n            marginLeft: itemHMargin,\n            marginRight: itemHMargin\n          }}\n        >\n          <AddIcon />\n          &nbsp;&nbsp;{t(\"account.balance-details.button.add-asset.label\")}\n        </ButtonListItem>\n        <TrustedAssets\n          account={props.account}\n          accountData={accountData}\n          assets={trustedAssets}\n          hmargin={itemHMargin}\n          hpadding={itemHPadding}\n          onOpenAssetDetails={openAssetDetails}\n          openOffers={openOrders}\n          olderOffersAvailable={olderOffersAvailable}\n        />\n      </List>\n      <Divider style={{ margin: \"16px 0\" }} />\n      <List style={{ paddingLeft: hpadding, paddingRight: hpadding, margin: \"0 -8px 8px\" }}>\n        {nativeBalance ? (\n          <NativeBalanceItems\n            account={props.account}\n            accountData={accountData}\n            balance={nativeBalance}\n            hmargin={itemHMargin}\n            hpadding={itemHPadding}\n            onOpenAssetDetails={openAssetDetails}\n          />\n        ) : null}\n      </List>\n      <Dialog\n        fullScreen\n        open={addAssetDialogOpen || assetDetailsDialogOpen}\n        onClose={closeAddAssetDialog}\n        TransitionComponent={FullscreenDialogTransition}\n      >\n        <React.Suspense fallback={<ViewLoading />}>\n          <AddAssetDialog\n            account={props.account}\n            accountData={accountData}\n            hpadding={hpadding}\n            itemHPadding={itemHPadding}\n            onClose={closeAddAssetDialog}\n          />\n        </React.Suspense>\n      </Dialog>\n    </DialogBody>\n  )\n}\n\nexport default React.memo(BalanceDetailsDialog)\n"],"names":["safeIsNaN","value","isEqual","first","second","areInputsEqual","newInputs","lastInputs","i","memoizeOne","resultFn","lastThis","lastArgs","lastResult","calledOnce","memoized","newArgs","_i","hasNativePerformanceNow","now","cancelTimeout","timeoutID","requestTimeout","callback","delay","start","tick","size","getScrollbarSize","recalculate","div","style","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","innerDiv","innerStyle","IS_SCROLLING_DEBOUNCE_INTERVAL$1","defaultItemKey$1","index","data","createListComponent","_ref","_class","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","_inheritsLoose","List","props","_this","_assertThisInitialized","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","scrollDirection","scrollOffset","scrollUpdateWasRequested","_this$props","direction","itemSize","layout","itemStyleCache","_offset","isHorizontal","isRtl","offsetHorizontal","_","__","___","event","_event$currentTarget","clientWidth","scrollLeft","scrollWidth","prevState","_event$currentTarget2","clientHeight","scrollHeight","scrollTop","ref","outerRef","nextProps","validateSharedProps$1","_proto","align","_this$props2","itemCount","scrollbarSize","_this$props3","initialScrollOffset","_this$props4","_this$state","_this$props5","children","className","height","innerRef","innerElementType","innerTagName","itemData","_this$props5$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","width","isScrolling","onScroll","_this$_getRangeToRend","startIndex","stopIndex","items","_index","createElement","estimatedTotalSize","_extends","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_this$state2","_scrollDirection","_scrollOffset","_scrollUpdateWasRequested","_this$props6","overscanCount","_this$state3","overscanBackward","overscanForward","PureComponent","_ref2","_ref3","FixedSizeList","_ref4","instanceProps","lastItemOffset","maxOffset","minOffset","middleOffset","_ref5","offset","_ref6","numVisibleItems","_ref7","React","Window.FixedSizeList","mainnet","Asset","testnet","useBalanceItemStyles","makeStyles","breakpoints","BalanceListItem","classes","asset","balancelineToAsset","assetMetadata","useAssetMetadata","t","useTranslation","balance","SingleBalance","ListItem","ListItemIcon","AssetLogo","ListItemText","assetName","title","Badge","AccountName","BalanceDetailsListItem","CustomTrustlineDialog","code","setCode","issuerPublicKey","setIssuerPublicKey","limit","setLimit","isWidthMax450","useMediaQuery","createTransaction","addCustomAsset","DialogBody","MainTitle","TextField","DialogActionsBox","ActionButton","VerifiedUserIcon","CustomTrustlineDialog$1","assetRecordMatches","assetRecord","search","issuerMatches","issuerDetails","assetToBalance","groupAssets","values","createKey","map","key","existingValues","PopularAssets","stringifyAsset","searchResultRowHeight","useSearchResultStyles","createSearchResultRow","account","assetsByIssuer","openAssetDetails","itemRenderMap","issuer","SearchResultRow","item","ViewLoading","assetRecordToAsset","NoResultRow","useAddAssetStyles","AddAssetDialog","assets","popularAssets.testnet","popularAssets.mainnet","containerRef","allAssets","useTickerAssets","router","useRouter","wellKnownAccounts","useWellKnownAccounts","customTrustlineDialogOpen","setCustomTrustlineDialogOpen","searchFieldValue","setSearchFieldValue","txCreationPending","setTxCreationPending","routes.assetDetails","openCustomTrustlineDialog","closeCustomTrustlineDialog","createAddAssetTransaction","options","operations","Operation","sendTransaction","createTransactionToSend","transaction","error","trackError","isAssetAlreadyAdded","wellknownAccountMatches","accountID","lowerCasedSearch","record","notYetAddedAssets","onSearchFieldChange","filteredAssets","VerticalLayout","SearchField","ButtonListItem","AddIcon","Dialog","CompactDialogTransition","ConnectedAddAssetDialog","TransactionSender","horizon","AddAssetDialog$1","isAssetMatchingBalance","TrustedAssets","bal","openOffers","offer","badgeCount","NativeBalanceItems","BigNumber","getSpendableBalance","getAccountMinimumBalance","BalanceDetailsDialog","accountData","useLiveAccountData","openOrders","olderOffersAvailable","useLiveAccountOffers","isSmallScreen","useIsMobile","openAddAssetDialog","routes.manageAccountAssets","closeAddAssetDialog","routes.balanceDetails","addAssetDialogOpen","matchesRoute","assetDetailsDialogOpen","trustedAssets","sortBalances","nativeBalance","hpadding","itemHPadding","itemHMargin","Divider","FullscreenDialogTransition","BalanceDetailsDialog$1"],"mappings":"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","x_google_ignoreList":[0,1]}